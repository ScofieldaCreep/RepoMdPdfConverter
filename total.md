# [0001. 两数之和](https://leetcode.cn/problems/two-sum/)

- 标签：数组、哈希表
- 难度：简单

## 题目链接

- [0001. 两数之和 - 力扣](https://leetcode.cn/problems/two-sum/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数目标值 $target$。

**要求**：在该数组中找出和为 $target$ 的两个整数，并输出这两个整数的下标。可以按任意顺序返回答案。

**说明**：

- $2 \le nums.length \le 10^4$。
- $-10^9 \le nums[i] \le 10^9$。
- $-10^9 \le target \le 10^9$。
- 只会存在一个有效答案。

**示例**：

- 示例 1：

```python
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

- 示例 2：

```python
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

## 解题思路

### 思路 1：枚举算法

1. 使用两重循环枚举数组中每一个数 $nums[i]$、$nums[j]$，判断所有的 $nums[i] + nums[j]$ 是否等于 $target$。
2. 如果出现 $nums[i] + nums[j] == target$，则说明数组中存在和为 $target$ 的两个整数，将两个整数的下标 $i$、$j$ 输出即可。

### 思路 1：代码

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if i != j and nums[i] + nums[j] == target:
                    return [i, j]
        return []
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 是数组 $nums$ 的元素数量。
- **空间复杂度**：$O(1)$。

### 思路 2：哈希表

哈希表中键值对信息为 $target-nums[i] ：i，其中 $i$ 为下标。

1. 遍历数组，对于每一个数 $nums[i]$：
   1. 先查找字典中是否存在 $target - nums[i]$，存在则输出 $target - nums[i]$ 对应的下标和当前数组的下标 $i$。
   2. 不存在则在字典中存入 $target - nums[i]$ 的下标 $i$。

### 思路 2：代码

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    numDict = dict()
    for i in range(len(nums)):
        if target-nums[i] in numDict:
            return numDict[target-nums[i]], i
        numDict[nums[i]] = i
    return [0]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 $nums$ 的元素数量。
- **空间复杂度**：$O(n)$。# [0002. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

- 标签：递归、链表、数学
- 难度：中等

## 题目链接

- [0002. 两数相加 - 力扣](https://leetcode.cn/problems/add-two-numbers/)

## 题目大意

**描述**：给定两个非空的链表 `l1` 和 `l2`。分别用来表示两个非负整数，每位数字都是按照逆序的方式存储的，每个节点存储一位数字。

**要求**：计算两个非负整数的和，并逆序返回表示和的链表。

**说明**：

- 每个链表中的节点数在范围 $[1, 100]$ 内。
- $0 \le Node.val \le 9$。
- 题目数据保证列表表示的数字不含前导零。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```python
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

- 示例 2：

```python
输入：l1 = [0], l2 = [0]
输出：[0]
```

## 解题思路

### 思路 1：模拟

模拟大数加法，按位相加，将结果添加到新链表上。需要注意进位和对 $10$ 取余。

### 思路 1：代码

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = curr = ListNode(0)
        carry = 0
        while l1 or l2 or carry:
            if l1:
                num1 = l1.val
                l1 = l1.next
            else:
                num1 = 0
            if l2:
                num2 = l2.val
                l2 = l2.next
            else:
                num2 = 0

            sum = num1 + num2 + carry
            carry = sum // 10

            curr.next = ListNode(sum % 10)
            curr = curr.next

        return head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(max(m, n))$。其中，$m$ 和 $n$ 分别是链表 `l1` 和 `l2` 的长度。
- **空间复杂度**：$O(1)$。# [0003. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0003. 无重复字符的最长子串 - 力扣](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：找出其中不含有重复字符的最长子串的长度。

**说明**：

- $0 \le s.length \le 5 * 10^4$。
- $s$ 由英文字母、数字、符号和空格组成。

**示例**：

- 示例 1：

```python
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

- 示例 2：

```python
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

## 解题思路

### 思路 1：滑动窗口（不定长度）

用滑动窗口 $window$ 来记录不重复的字符个数，$window$ 为哈希表类型。

1. 设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口中没有重复字符。
2. 一开始，$left$、$right$ 都指向 $0$。
3. 向右移动 $right$，将最右侧字符 $s[right]$ 加入当前窗口 $window$ 中，记录该字符个数。
4. 如果该窗口中该字符的个数多于 $1$ 个，即 $window[s[right]] > 1$，则不断右移 $left$，缩小滑动窗口长度，并更新窗口中对应字符的个数，直到 $window[s[right]] \le 1$。
5. 维护更新无重复字符的最长子串长度。然后继续右移 $right$，直到 $right \ge len(nums)$ 结束。
6. 输出无重复字符的最长子串长度。

### 思路 1：代码

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        right = 0
        window = dict()
        ans = 0

        while right < len(s):
            if s[right] not in window:
                window[s[right]] = 1
            else:
                window[s[right]] += 1

            while window[s[right]] > 1:
                window[s[left]] -= 1
                left += 1

            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(| \sum |)$。其中 $\sum$ 表示字符集，$| \sum |$ 表示字符集的大小。
# [0004. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

- 标签：数组、二分查找、分治
- 难度：困难

## 题目链接

- [0004. 寻找两个正序数组的中位数 - 力扣](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

## 题目大意

**描述**：给定两个正序（从小到大排序）数组 $nums1$、$nums2$。

**要求**：找出并返回这两个正序数组的中位数。

**说明**：

- 算法的时间复杂度应该为 $O(\log (m + n))$ 。
- $nums1.length == m$。
- $nums2.length == n$。
- $0 \le m \le 1000$。
- $0 \le n \le 1000$。
- $1 \le m + n \le 2000$。
- $-10^6 \le nums1[i], nums2[i] \le 10^6$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

- 示例 2：

```python
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

## 解题思路

### 思路 1：二分查找

单个有序数组的中位数是中间元素位置的元素。如果中间元素位置有两个元素，则为两个元素的平均数。如果是两个有序数组，则可以使用归并排序的方式将两个数组拼接为一个大的有序数组。合并后有序数组中间位置的元素，即为中位数。

当然不合并的话，我们只需找到中位数的位置即可。我们用 $n1$、$n2$ 来表示数组 $nums1$、$nums2$ 的长度，则合并后的大的有序数组长度为 $(n1 + n2)$。

我们可以发现：**中位数把数组分割成了左右两部分，并且左右两部分元素个数相等。**

- 如果 $(n1 + n2)$ 是奇数时，中位数是大的有序数组中第 $\lfloor \frac{(n1 + n2)}{2} \rfloor + 1$  的元素，单侧元素个数为 $\lfloor \frac{(n1 + n2)}{2} \rfloor + 1$ 个（包含中位数）。
- 如果 $(n1 + n2)$ 是偶数时，中位数是第 $\lfloor \frac{(n1 + n2)}{2} \rfloor$ 的元素和第 $\lfloor \frac{(n1 + n2)}{2} \rfloor + 1$ 的元素的平均值，单侧元素个数为 $\lfloor \frac{(n1 + n2)}{2} \rfloor$ 个。

因为是向下取整，上面两种情况综合可以写为：单侧元素个数为：$\lfloor \frac{(n1 + n2 + 1)}{2} \rfloor$ 个。

我们用 $k$ 来表示 $\lfloor \frac{(n1 + n2 + 1)}{2} \rfloor$ 。现在的问题就变为了：**如何在两个有序数组中找到前 k 小的元素位置？**

如果我们从 $nums1$ 数组中取出前 $m1(m1 \le k)$ 个元素，那么从 $nums2$ 就需要取出前 $m2  = k - m1$ 个元素。

并且如果我们在 $nums1$ 数组中找到了合适的 $m1$ 位置，则 $m2$ 的位置也就确定了。

问题就可以进一步转换为：**如何从 $nums1$ 数组中取出前 $m1$ 个元素，使得 $nums1$ 第 $m1$ 个元素或者 $nums2$ 第 $m2 = k - m1$ 个元素为中位线位置**。

我们可以通过「二分查找」的方法，在数组 $nums1$ 中找到合适的 $m1$ 位置，具体做法如下：

1. 让 $left$ 指向 $nums1$ 的头部位置 $0$，$right$ 指向 $nums1$ 的尾部位置 $n1$。
2. 每次取中间位置作为 $m1$，则 $m2 = k - m1$。然后判断 $nums1$ 第 $m1$ 位置上元素和 $nums2$ 第 $m2 - 1$ 位置上元素之间的关系，即 $nums1[m1]$ 和 $nums2[m2 - 1]$ 的关系。
   1. 如果 $nums1[m1] < nums2[m2 - 1]$，则 $nums1$ 的前 $m1$ 个元素都不可能是第 $k$ 个元素。说明 $m1$ 取值有点小了，应该将 $m1$ 进行右移操作，即 $left = m1 + 1$。
   2. 如果 $nums1[m1] \ge nums2[m2 - 1]$，则说明 $m1$ 取值可能有点大了，应该将 $m1$ 进行左移。根据二分查找排除法的思路（排除一定不存在的区间，在剩下区间中继续查找），这里应取 $right = m1$。
3. 找到 $m1$ 的位置之后，还要根据两个数组长度和 $(n1 + n2)$ 的奇偶性，以及边界条件来计算对应的中位数。

---

上面之所以要判断 $nums1[m1]$ 和 $nums2[m2 - 1]$ 的关系是因为：

> 如果 $nums1[m1] < nums2[m2 - 1]$，则说明：
>
> - 最多有 $m1 + m2 - 1 = k - 1$  个元素比 $nums1[m1]$ 小，所以 $nums1[m1]$ 左侧的 $m1$ 个元素都不可能是第 $k$ 个元素。可以将 $m1$ 左侧的元素全部排除，然后将 $m1$ 进行右移。

推理过程：

如果 $nums1[m1] < nums2[m2 - 1]$，则：

1. $nums1[m1]$ 左侧比 $nums1[m1]$ 小的一共有 $m1$ 个元素（$nums1[0] ... nums1[m1 -  1]$ 共 $m1$ 个）。
2. $nums2$ 数组最多有 $m2 - 1$ 个元素比 $nums1[m1]$ 小（即便是 $nums2[m2 - 1]$ 左侧所有元素都比 $nums1[m1]$ 小，也只有 $m2 - 1$ 个）。
3. 综上所述，$nums1$、$nums2$ 数组中最多有 $m1 + m2 - 1 = k - 1$ 个元素比 $nums1[m1]$ 小。
4. 所以 $nums1[m1]$ 左侧的 $m1$ 个元素（$nums1[0] ... nums1[m1 -  1]$）都不可能是第 $k$ 个元素。可以将 $m1$ 左侧的元素全部排除，然后将 $m1$ 进行右移。

### 思路 1：代码

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n1 = len(nums1)
        n2 = len(nums2)
        if n1 > n2:
            return self.findMedianSortedArrays(nums2, nums1)

        k = (n1 + n2 + 1) // 2
        left = 0
        right = n1
        while left < right:
            m1 = left + (right - left) // 2    # 在 nums1 中取前 m1 个元素
            m2 = k - m1                        # 在 nums2 中取前 m2 个元素
            if nums1[m1] < nums2[m2 - 1]:      # 说明 nums1 中所元素不够多，
                left = m1 + 1
            else:
                right = m1

        m1 = left
        m2 = k - m1
        
        c1 = max(float('-inf') if m1 <= 0 else nums1[m1 - 1], float('-inf') if m2 <= 0 else nums2[m2 - 1])
        if (n1 + n2) % 2 == 1:
            return c1

        c2 = min(float('inf') if m1 >= n1 else nums1[m1], float('inf') if m2 >= n2 else nums2[m2])

        return (c1 + c2) / 2
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log  (m + n))$ 。
- **空间复杂度**：$O(1)$。# [0005. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0005. 最长回文子串 - 力扣](https://leetcode.cn/problems/longest-palindromic-substring/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：找到 $s$ 中最长的回文子串。

**说明**：

- **回文串**：如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
- $1 \le s.length \le 1000$。
- $s$ 仅由数字和英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

- 示例 2：

```python
输入：s = "cbbd"
输出："bb"
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：字符串 $s$ 在区间 $[i, j]$ 范围内是否是一个回文串。

###### 3. 状态转移方程

- 当子串只有 $1$ 位或 $2$ 位的时候，如果 $s[i] == s[j]$，该子串为回文子串，即：`dp[i][j] = (s[i] == s[j])`。
- 如果子串大于 $2$ 位，则如果 $s[i + 1...j - 1]$ 是回文串，且 $s[i] == s[j]$，则 $s[i...j]$ 也是回文串，即：`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]`。

###### 4. 初始条件

- 初始状态下，默认字符串 $s$ 的所有子串都不是回文串。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：字符串 $s$ 在区间 $[i, j]$ 范围内是否是一个回文串。当判断完 $s[i: j]$ 是否为回文串时，同时判断并更新最长回文子串的起始位置 $max\underline{\hspace{0.5em}}start$ 和最大长度 $max\underline{\hspace{0.5em}}len$。则最终结果为 $s[max\underline{\hspace{0.5em}}start, max\underline{\hspace{0.5em}}start + max\underline{\hspace{0.5em}}len]$。

### 思路 1：代码

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s

        dp = [[False for _ in range(n)] for _ in range(n)]
        max_start = 0
        max_len = 1

        for j in range(1, n):
            for i in range(j):
                if s[i] == s[j]:
                    if j - i <= 2:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j] and (j - i + 1) > max_len:
                    max_len = j - i + 1
                    max_start = i
        return s[max_start: max_start + max_len]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 是字符串的长度。
- **空间复杂度**：$O(n^2)$。

# [0007. 整数反转](https://leetcode.cn/problems/reverse-integer/)

- 标签：数学
- 难度：中等

## 题目链接

- [0007. 整数反转 - 力扣](https://leetcode.cn/problems/reverse-integer/)

## 题目大意

给定一个 32 位有符号整数 x，将 x 进行反转。

## 解题思路

x 的范围为 $[-2^{31}, 2^{31}-1]$，即 $[-2147483648 ,2147483647]$。

反转的步骤就是让 x 不断对 10 取余，再除以 10，得到每一位的数字，同时累积结果。

注意累积结果的时候需要判断是否溢出。

当 ans * 10 + pop > INT_MAX  ，或者 ans * 10 + pop < INT_MIN 时就会溢出。

按题设要求，无法在溢出之后对其判断。那么如何在进行累积操作之前判断溢出呢？

ans * 10 + pop > INT_MAX 有两种情况：

1. ans > INT_MAX / 10，这种情况下，无论是否考虑 pop 进位都会溢出；
2. ans == INT_MAX / 10，这种情况下，考虑进位，如果 pop 大于 IN_MAX 的个位数，就会导致溢出。

同理   ans * 10 + pop < INT_MIN 也有两种情况：

1. ans < INT_MIN / 10
2. ans == INT_MIN / 10 且 pop < INT_MIN 的个位数，就会导致溢出

## 代码

```python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MAX_10 = (1<<31)//10
        INT_MIN_10 = int((-1<<31)/10)
        INT_MAX_LAST = (1<<31) % 10
        INT_MIN_LAST = (-1<<31) % -10
        ans = 0
        while x:
            pop = x % 10 if x > 0 else x % -10
            x = x // 10 if x > 0 else int(x / 10)
            if ans > INT_MAX_10 or (ans == INT_MAX_10 and pop > INT_MAX_LAST):
                return 0
            if ans < INT_MIN_10 or (ans == INT_MIN_10 and pop < INT_MIN_LAST):
                return 0
            ans = ans*10+pop
        return ans
```

# [0008. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)

- 标签：字符串
- 难度：中等

## 题目链接

- [0008. 字符串转换整数 (atoi) - 力扣](https://leetcode.cn/problems/string-to-integer-atoi/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：实现一个 `myAtoi(s)` 函数。使其能换成一个 32 位有符号整数（类似 C / C++ 中的 `atoi` 函数）。需要检测有效性，无法读取返回 $0$。

**说明**：

- 函数 `myAtoi(s)` 的算法如下：
  1. 读入字符串并丢弃无用的前导空格。
  2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
  3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
  4. 将前面步骤读入的这些数字转换为整数（即，`"123"` -> `123`， `"0032"` -> `32`）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
  5. 如果整数数超过 32 位有符号整数范围 $[−2^{31}, 2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $−2^{31}$ 的整数应该被固定为 $−2^{31}$ ，大于 $2^{31} − 1$ 的整数应该被固定为 $2^{31} − 1$。
  6. 返回整数作为最终结果。
- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。
- $0 \le s.length \le 200$。
- `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成

**示例**：

- 示例 1：

```python
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```

- 示例 2：

```python
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```

## 解题思路

### 思路 1：模拟

1. 先去除前后空格。
2. 检测正负号。
3. 读入数字，并用字符串存储数字结果。
4. 将数字字符串转为整数，并根据正负号转换整数结果。
5. 判断整数范围，并返回最终结果。

### 思路 1：代码

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        num_str = ""
        positive = True
        start = 0

        s = s.lstrip()
        if not s:
            return 0

        if s[0] == '-':
            positive = False
            start = 1
        elif s[0] == '+':
            positive = True
            start = 1
        elif not s[0].isdigit():
            return 0

        for i in range(start, len(s)):
            if s[i].isdigit():
                num_str += s[i]
            else:
                break
        if not num_str:
            return 0
        num = int(num_str)
        if not positive:
            num = -num
            return max(num, -2 ** 31)
        else:
            return min(num, 2 ** 31 - 1)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是字符串 `s` 的长度。
- **空间复杂度**：$O(1)$。

# [0009. 回文数](https://leetcode.cn/problems/palindrome-number/)

- 标签：数学
- 难度：简单

## 题目链接

- [0009. 回文数 - 力扣](https://leetcode.cn/problems/palindrome-number/)

## 题目大意

给定整数 x，判断 x 是否是回文数。要求不能用整数转为字符串的方式来解决这个问题。

回文数指的是正序（从左向右）和倒序（从右向左）读都是一样的整数。比如 12321。

## 解题思路

- 首先，负数，10 的倍数都不是回文数，可以直接排除。
- 然后将原数进行按位取余，并按位反转，若与原数完全相等，则原数为回文数。
- 其实，第二步在反转到一半的时候，就可以进行判断了。因为原数是回文数，那么在反转到中间的时候，留下的前半部分，应该与转换好的后半部分倒转过来相等。比如：1221，转换到一半，原数变为 12，转换好的数变为 12，则说明原数就是回文数。如果原数为奇数，比如：12321，转换到一半，原数变为 12，转换好的数变为 123，则应该将原数与 转换好的数对 10 取余的部分进行比较。

## 代码

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        res = 0
        while x > res:
            res = res * 10 + x % 10
            x = x // 10
        return x == res or x == res // 10
```

# [0010. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

- 标签：递归、字符串、动态规划
- 难度：困难

## 题目链接

- [0010. 正则表达式匹配 - 力扣](https://leetcode.cn/problems/regular-expression-matching/)

## 题目大意

**描述**：给定一个字符串 `s` 和一个字符模式串 `p`。

**要求**：实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。两个字符串完全匹配才算匹配成功。如果匹配成功，则返回 `True`，否则返回 `False`。

- `'.'` 匹配任意单个字符。
- `'*'` 匹配零个或多个前面的那一个元素。

**说明**：

- $1 \le s.length \le 20$。
- $1 \le p.length \le 30$。
- `s` 只包含从 `a` ~ `z` 的小写字母。
- `p` 只包含从 `a` ~ `z` 的小写字母，以及字符 `.` 和 `*`。
- 保证每次出现字符 `*` 时，前面都匹配到有效的字符。

**示例**：

- 示例 1：

```python
输入：s = "aa", p = "a*"
输出：True
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

- 示例 2：

```python
输入：s = "aa", p = "a"
输出：False
解释："a" 无法匹配 "aa" 整个字符串。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照两个字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配。

###### 3. 状态转移方程

- 如果 `s[i - 1] == p[j - 1]`，则字符串 `s` 的第 `i` 个字符与字符串 `p` 的第 `j` 个字符是匹配的。此时「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i - 1` 个字符与字符串 `p` 的前 `j - 1` 个字符是否匹配」。即 `dp[i][j] = dp[i - 1][j - 1] `。
- 如果 `p[j - 1] == '.'`，则字符串 `s` 的第 `i` 个字符与字符串 `p` 的第 `j` 个字符是匹配的（同上）。此时 `dp[i][j] = dp[i - 1][j - 1] `。
- 如果 `p[j - 1] == '*'`，则我们可以对字符 `p[j - 2]` 进行 `0` ~ 若干次数的匹配。
  - 如果 `s[i - 1] != p[j - 2]` 并且 `p[j - 2] != '.'`，则说明当前星号匹配不上，只能匹配 `0` 次（即匹配空字符串），则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j - 2` 个字符是否匹配」，即 `dp[i][j] = dp[i][j - 2] `。
  - 如果 `s[i - 1] == p[j - 2]` 或者 `p[j - 2] == '.'`，则说明当前星号前面的字符 `p[j - 2]` 可以匹配 `s[i - 1]`。
    - 如果匹配 `0` 个，则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j - 2` 个字符是否匹配」。即 `dp[i][j] = dp[i][j - 2]`。
    - 如果匹配 `1` 个，则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j - 1` 个字符是否匹配」。即 `dp[i][j] = dp[i][j - 1] `。
    - 如果匹配多个，则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i - 1` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」。即 `dp[i][j] = dp[i - 1][j]`。

###### 4. 初始条件

- 默认状态下，两个空字符串是匹配的，即 `dp[0][0] = True`。
- 当字符串 `s` 为空，字符串 `p` 右端有 `*` 时，想要匹配，则如果「空字符串」与「去掉字符串 `p` 右端的 `*` 和 `*` 之前的字符之后的字符串」匹配的话，则空字符串与字符串 `p` 匹配。也就是说如果 `p[j - 1] == '*'`，则 `dp[0][j] = dp[0][j - 2]`。

###### 5. 最终结果

根据我们之前定义的状态， `dp[i][j]` 表示为：字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配。则最终结果为 `dp[size_s][size_p]`，其实 `size_s` 是字符串 `s` 的长度，`size_p` 是字符串 `p` 的长度。

### 思路 1：动态规划代码

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        size_s, size_p = len(s), len(p)
        dp = [[False for _ in range(size_p + 1)] for _ in range(size_s + 1)]
        
        dp[0][0] = True
        for j in range(1, size_p + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]

        for i in range(1, size_s + 1):
            for j in range(1, size_p + 1):
                if s[i - 1] == p[j - 1] or p[j - 1] == '.':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    if s[i - 1] != p[j - 2] and p[j - 2] != '.':
                        dp[i][j] = dp[i][j - 2]
                    else:
                        dp[i][j] = dp[i][j - 1] or dp[i][j - 2] or dp[i - 1][j]

        return dp[size_s][size_p]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m n)$，其中 $m$ 是字符串 `s` 的长度，$n$ 是字符串 `p` 的长度。使用了两重循环，外层循环遍历的时间复杂度是 $O(m)$，内层循环遍历的时间复杂度是 $O(n)$，所以总体的时间复杂度为 $O(m n)$。
- **空间复杂度**：$O(m n)$，其中 $m$ 是字符串 `s` 的长度，$n$ 是字符串 `p` 的长度。使用了二维数组保存状态，且第一维的空间复杂度为 $O(m)$，第二位的空间复杂度为 $O(n)$，所以总体的空间复杂度为 $O(m n)$。
# [0011. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

- 标签：贪心、数组、双指针
- 难度：中等

## 题目链接

- [0011. 盛最多水的容器 - 力扣](https://leetcode.cn/problems/container-with-most-water/)

## 题目大意

**描述**：给定 $n$ 个非负整数 $a_1,a_2, ...,a_n$，每个数代表坐标中的一个点 $(i, a_i)$。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$。

**要求**：找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。

**说明**：

- $n == height.length$。
- $2 \le n \le 10^5$。
- $0 \le height[i] \le 10^4$。

**示例**：

- 示例 1：

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```python
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

## 解题思路

### 思路 1：对撞指针

从示例中可以看出，如果确定好左右两端的直线，容纳的水量是由 `左右两端直线中较低直线的高度 * 两端直线之间的距离 ` 所决定的。所以我们应该使得 **较低直线的高度尽可能的高**，这样才能使盛水面积尽可能的大。

可以使用对撞指针求解。移动较低直线所在的指针位置，从而得到不同的高度和面积，最终获取其中最大的面积。具体做法如下：

1. 使用两个指针 `left`，`right`。`left` 指向数组开始位置，`right` 指向数组结束位置。
2. 计算 `left` 和 `right` 所构成的面积值，同时维护更新最大面积值。
3. 判断 `left` 和 `right` 的高度值大小。
   1. 如果 `left` 指向的直线高度比较低，则将 `left` 指针右移。
   2. 如果 `right` 指向的直线高度比较低，则将 `right` 指针左移。
4. 如果遇到 `left == right`，跳出循环，最后返回最大的面积。

### 思路 1：代码

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        ans = 0
        while left < right:
            area = min(height[left], height[right]) * (right-left)
            ans = max(ans, area)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0012. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

- 标签：哈希表、数学、字符串
- 难度：中等

## 题目链接

- [0012. 整数转罗马数字 - 力扣](https://leetcode.cn/problems/integer-to-roman/)

## 题目大意

给定一个整数，将其转换为罗马数字。

罗马数字规则：

- I 代表数值 1，V 代表数值 5，X 代表数值 10，L 代表数值 50，C 代表数值 100，D 代表数值 500，M 代表数值 1000；
- 一般罗马数字较大数字在左边，较小数字在右边，此时值为两者之和，比如 XI = X + I = 10 + 1 = 11。
- 例外情况下，较小数字在左边，较大数字在右边，此时值为后者减前者之差，比如 IX = X - I = 10 - 1 = 9。

## 解题思路

根据规则，可以得出：

- I 代表数值 1，V 代表数值 5，X 代表数值 10，L 代表数值 50，C 代表数值 100，D 代表数值 500，M 代表数值 1000；
- CM 代表 900，CD 代表 400，XC 代表 90，XL 代表 40，IX 代表 9，IV 代表 4。

依次排序可得：

- 1000 : M、900 : CM、D : 500、400 : CD、100 : C、90 : XC、50 : L、40 : XL、10 : X、9 : IX、5 : V、4 : IV、1 : I。

使用贪心算法。每次尽量用最大的数对应的罗马字符来表示。先选择 1000，再选择 900，然后 500，等等。 

## 代码

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        roman_dict = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}
        res = ""
        for key in roman_dict:
            if num // key != 0:
                res += roman_dict[key] * (num // key)
                num %= key
        return res
```

# [0013. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

- 标签：哈希表、数学、字符串
- 难度：简单

## 题目链接

- [0013. 罗马数字转整数 - 力扣](https://leetcode.cn/problems/roman-to-integer/)

## 题目大意

给定一个罗马数字对应的字符串，将其转换为整数。

罗马数字规则：

- I 代表数值 1，V 代表数值 5，X 代表数值 10，L 代表数值 50，C 代表数值 100，D 代表数值 500，M 代表数值 1000；
- 一般罗马数字较大数字在左边，较小数字在右边，此时值为两者之和，比如 XI = X + I = 10 + 1 = 11。
- 例外情况下，较小数字在左边，较大数字在右边，此时值为后者减前者之差，比如 IX = X - I = 10 - 1 = 9。

## 解题思路

用一个哈希表存储罗马数字与对应数值关系。遍历罗马数字对应的字符串，判断相邻两个数大小关系，并计算对应结果。

## 代码

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        nunbers = {
            "I" : 1,
            "V" : 5,
            "X" : 10,
            "L" : 50,
            "C" : 100,
            "D" : 500,
            "M" : 1000
        }
        sum = 0
        pre_num = nunbers[s[0]]
        for i in range(1, len(s)):
            cur_num = nunbers[s[i]]
            if pre_num < cur_num:
                sum -= pre_num
            else:
                sum += pre_num
            pre_num = cur_num
        sum += pre_num
        return sum
```

# [0014. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

- 标签：字典树、字符串
- 难度：简单

## 题目链接

- [0014. 最长公共前缀 - 力扣](https://leetcode.cn/problems/longest-common-prefix/)

## 题目大意

**描述**：给定一个字符串数组 `strs`。

**要求**：返回字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

**说明**：

- $1 \le strs.length \le 200$。
- $0 \le strs[i].length \le 200$。
- `strs[i]` 仅由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：strs = ["flower","flow","flight"]
输出："fl"
```

- 示例 2：

```python
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

## 解题思路

### 思路 1：纵向遍历

1. 依次遍历所有字符串的每一列，比较相同位置上的字符是否相同。
   1. 如果相同，则继续对下一列进行比较。
   2. 如果不相同，则当前列字母不再属于公共前缀，直接返回当前列之前的部分。
2. 如果遍历结束，说明字符串数组中的所有字符串都相等，则可将字符串数组中的第一个字符串作为公共前缀进行返回。

### 思路 1：代码

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""

        length = len(strs[0])
        count = len(strs)
        for i in range(length):
            c = strs[0][i]
            for j in range(1, count):
                if len(strs[j]) == i or strs[j][i] != c:
                    return strs[0][:i]
        return strs[0]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$ 是字符串数组中的字符串的平均长度，$n$ 是字符串的数量。
- **空间复杂度**：$O(1)$。# [0015. 三数之和](https://leetcode.cn/problems/3sum/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [0015. 三数之和 - 力扣](https://leetcode.cn/problems/3sum/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：判断 $nums$ 中是否存在三个元素 $a$、$b$、$c$，满足 $a + b + c == 0$。要求找出所有满足要求的不重复的三元组。

**说明**：

- $3 \le nums.length \le 3000$。
- $-10^5 \le nums[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

- 示例 2：

```python
输入：nums = [0,1,1]
输出：[]
```

## 解题思路

### 思路 1：对撞指针

直接三重遍历查找 $a$、$b$、$c$ 的时间复杂度是：$O(n^3)$。我们可以通过一些操作来降低复杂度。

先将数组进行排序，以保证按顺序查找 $a$、$b$、$c$ 时，元素值为升序，从而保证所找到的三个元素是不重复的。同时也方便下一步使用双指针减少一重遍历。时间复杂度为：$O(n \times \log n)$。

第一重循环遍历 $a$，对于每个 $a$ 元素，从 $a$ 元素的下一个位置开始，使用对撞指针 $left$，$right$。$left$ 指向 $a$ 元素的下一个位置，$right$ 指向末尾位置。先将 $left$ 右移、$right$ 左移去除重复元素，再进行下边的判断。

1. 如果 $nums[a] + nums[left] + nums[right] == 0$，则得到一个解，将其加入答案数组中，并继续将 $left$ 右移，$right$ 左移；
2. 如果 $nums[a] + nums[left] + nums[right] > 0$，说明 $nums[right]$ 值太大，将 $right$ 向左移；
3. 如果 $nums[a] + nums[left] + nums[right] < 0$，说明 $nums[left]$ 值太小，将 $left$ 右移。

### 思路 1：代码

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = []

        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left = i + 1
            right = n - 1
            while left < right:
                while left < right and left > i + 1 and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and right < n - 1 and nums[right + 1] == nums[right]:
                    right -= 1
                if left < right and nums[i] + nums[left] + nums[right] == 0:
                    ans.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                else:
                    left += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n)$。

# [0016. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [0016. 最接近的三数之和 - 力扣](https://leetcode.cn/problems/3sum-closest/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和 一个目标值 $target$。

**要求**：从 $nums$ 中选出三个整数，使它们的和与 $target$ 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。

**说明**：

- $3 \le nums.length \le 1000$。
- $-1000 \le nums[i] \le 1000$。
- $-10^4 \le target \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。
```

- 示例 2：

```python
输入：nums = [0,0,0], target = 1
输出：0
```

## 解题思路

### 思路 1：对撞指针

直接暴力枚举三个数的时间复杂度是 $O(n^3)$。很明显的容易超时。考虑使用双指针减少循环内的时间复杂度。具体做法如下：

- 先对数组进行从小到大排序，使用 $ans$ 记录最接近的三数之和。
- 遍历数组，对于数组元素 $nums[i]$，使用两个指针 $left$、$right$。$left$ 指向第 $0$ 个元素位置，$right$ 指向第 $i - 1$ 个元素位置。
- 计算 $nums[i]$、$nums[left]$、$nums[right]$ 的和与 $target$ 的差值，将其与 $ans$ 与 $target$ 的差值作比较。如果差值小，则更新 $ans$。
  - 如果 $nums[i] + nums[left] + nums[right] < target$，则说明 $left$ 小了，应该将 $left$ 右移，继续查找。
  - 如果 $nums[i] + nums[left] + nums[right] \ge target$，则说明 $right$ 太大了，应该将 $right$ 左移，然后继续判断。
- 当 $left == right$ 时，区间搜索完毕，继续遍历 $nums[i + 1]$。
- 最后输出 $ans$。

这种思路使用了两重循环，其中内层循环当 $left == right$ 时循环结束，时间复杂度为 $O(n)$，外层循环时间复杂度也是 $O(n)$。所以算法的整体时间复杂度为 $O(n^2)$。

### 思路 1：代码

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        res = float('inf')
        size = len(nums)
        for i in range(2, size):
            left = 0
            right = i - 1
            while left < right:
                total = nums[left] + nums[right] + nums[i]
                if abs(total - target) < abs(res - target):
                    res = total
                if total < target:
                    left += 1
                else:
                    right -= 1

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组中元素的个数。
- **空间复杂度**：$O(\log n)$，排序需要 $\log n$ 的栈空间。

# [0017. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

- 标签：哈希表、字符串、回溯
- 难度：中等

## 题目链接

- [0017. 电话号码的字母组合 - 力扣](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

## 题目大意

**描述**：给定一个只包含数字 2~9 的字符串 `digits`。给出数字到字母的映射如下（与电话按键相同）。注意 $1$ 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**要求**：返回字符串 `digits` 在九宫格键盘上所能表示的所有字母组合。答案可以按 「任意顺序」返回。

**说明**：

- $0 \le digits.length \le 4$。
- `digits[i]` 是范围 $2 \sim 9$ 的一个数字。

**示例**：

- 示例 1：

```python
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

- 示例 2：

```python
输入：digits = "2"
输出：["a","b","c"]
```

## 解题思路

### 思路 1：回溯算法 + 哈希表

用哈希表保存每个数字键位对应的所有可能的字母，然后进行回溯操作。

回溯过程中，维护一个字符串 combination，表示当前的字母排列组合。初始字符串为空，每次取电话号码的一位数字，从哈希表中取出该数字所对应的所有字母，并将其中一个插入到 combination 后面，然后继续处理下一个数字，知道处理完所有数字，得到一个完整的字母排列。开始进行回退操作，遍历其余的字母排列。

### 思路 1：代码

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []

        phone_dict = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz"
        }

        def backtrack(combination, index):
            if index == len(digits):
                combinations.append(combination)
            else:
                digit = digits[index]
                for letter in phone_dict[digit]:
                    backtrack(combination + letter, index + 1)

        combinations = list()
        backtrack('', 0)
        return combinations
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(3^m \times 4^n)$，其中 $m$ 是 `digits` 中对应 $3$ 个字母的数字个数，$m$ 是  `digits` 中对应 $4$ 个字母的数字个数。
- **空间复杂度**：$O(m + n)$。

# [0018. 四数之和](https://leetcode.cn/problems/4sum/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [0018. 四数之和 - 力扣](https://leetcode.cn/problems/4sum/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个目标值 $target$。

**要求**：找出所有满足以下条件切不重复的四元组。

1. $0 \le a, b, c, d < n$。
2. $a$、$b$、$c$ 和 $d$ 互不相同。
3. $nums[a] + nums[b] + nums[c] + nums[d] == target$。

**说明**：

- $1 \le nums.length \le 200$。
- $-10^9 \le nums[i] \le 10^9$。
- $-10^9 \le target \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

- 示例 2：

```python
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

## 解题思路

### 思路 1：排序 + 双指针

和 [0015. 三数之和](https://leetcode.cn/problems/3sum/) 解法类似。

直接三重遍历查找 $a$、$b$、$c$、$d$ 的时间复杂度是：$O(n^4)$。我们可以通过一些操作来降低复杂度。

1. 先将数组进行排序，以保证按顺序查找 $a$、$b$、$c$、$d$ 时，元素值为升序，从而保证所找到的四个元素是不重复的。同时也方便下一步使用双指针减少一重遍历。这一步的时间复杂度为：$O(n \times \log n)$。
2. 两重循环遍历元素 $a$、$b$，对于每个 $a$ 元素，从 $a$ 元素的下一个位置开始遍历元素 $b$。对于元素 $a$、$b$，使用双指针 $left$，$right$ 来查找 $c$、$d$。$left$ 指向 $b$ 元素的下一个位置，$right$ 指向末尾位置。先将 $left$ 右移、$right$ 左移去除重复元素，再进行下边的判断。
   1. 如果 $nums[a] + nums[b] + nums[left] + nums[right] == target$，则得到一个解，将其加入答案数组中，并继续将 $left$ 右移，$right$ 左移；
   2. 如果 $nums[a] + nums[b] + nums[left] + nums[right] > target$，说明 $nums[right]$ 值太大，将 $right$ 向左移；
   3. 如果 $nums[a] + nums[b] + nums[left] + nums[right] < target$，说明 $nums[left]$ 值太小，将 $left$ 右移。

### 思路 1：代码

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = []

        for i in range(n):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            for j in range(i+1, n):
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                left = j + 1
                right = n - 1
                while left < right:
                    while left < right and left > j + 1 and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and right < n - 1 and nums[right + 1] == nums[right]:
                        right -= 1
                    if left < right and nums[i] + nums[j] + nums[left] + nums[right] == target:
                        ans.append([nums[i], nums[j], nums[left], nums[right]])
                        left += 1
                        right -= 1
                    elif nums[i] + nums[j] + nums[left] + nums[right] > target:
                        right -= 1
                    else:
                        left += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为数组中元素个数。
- **空间复杂度**：$O(\log n)$，排序额外使用空间为 $\log n$。

# [0019. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

- 标签：链表、双指针
- 难度：中等

## 题目链接

- [0019. 删除链表的倒数第 N 个结点 - 力扣](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：删除链表的倒数第 `n` 个节点，并且返回链表的头节点。

**说明**：

- 要求使用一次遍历实现。
- 链表中结点的数目为 `sz`。
- $1 \le sz \le 30$。
- $0 \le Node.val \le 100$。
- $1 \le n \le sz$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```python
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

- 示例 2：

```python
输入：head = [1], n = 1
输出：[]
```

## 解题思路

### 思路 1：快慢指针

常规思路是遍历一遍链表，求出链表长度，再遍历一遍到对应位置，删除该位置上的节点。

如果用一次遍历实现的话，可以使用快慢指针。让快指针先走 `n` 步，然后快慢指针、慢指针再同时走，每次一步，这样等快指针遍历到链表尾部的时候，慢指针就刚好遍历到了倒数第 `n` 个节点位置。将该位置上的节点删除即可。

需要注意的是要删除的节点可能包含了头节点。我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则删除原头节点即可。返回结果的时候，可以直接返回新建头节点的下一位节点。

### 思路 1：代码

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        newHead = ListNode(0, head)
        fast = head
        slow = newHead
        while n:
            fast = fast.next
            n -= 1
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return newHead.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0020. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

- 标签：栈、字符串
- 难度：简单

## 题目链接

- [0020. 有效的括号 - 力扣](https://leetcode.cn/problems/valid-parentheses/)

## 题目大意

**描述**：给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` 。

**要求**：判断字符串 `s` 是否有效（即括号是否匹配）。

**说明**：

- 有效字符串需满足：
  1. 左括号必须用相同类型的右括号闭合。
  2. 左括号必须以正确的顺序闭合。

**示例**：

- 示例 1：

```python
输入：s = "()"
输出：True
```

- 示例 2：

```python
输入：s = "()[]{}"
输出：True
```

## 解题思路

### 思路 1：栈

括号匹配是「栈」的经典应用。我们可以用栈来解决这道题。具体做法如下：

1. 先判断一下字符串的长度是否为偶数。因为括号是成对出现的，所以字符串的长度应为偶数，可以直接判断长度为奇数的字符串不匹配。如果字符串长度为奇数，则说明字符串 `s` 中的括号不匹配，直接返回 `False`。
2. 使用栈 `stack` 来保存未匹配的左括号。然后依次遍历字符串 `s` 中的每一个字符。
   1. 如果遍历到左括号时，将其入栈。
   2. 如果遍历到右括号时，先看栈顶元素是否是与当前右括号相同类型的左括号。
      1. 如果是与当前右括号相同类型的左括号，则令其出栈，继续向前遍历。
      2. 如果不是与当前右括号相同类型的左括号，则说明字符串 `s` 中的括号不匹配，直接返回 `False`。
3. 遍历完，还要再判断一下栈是否为空。
   1. 如果栈为空，则说明字符串 `s` 中的括号匹配，返回 `True`。
   2. 如果栈不为空，则说明字符串 `s` 中的括号不匹配，返回 `False`。

### 思路 1：代码

```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2 == 1:
            return False
        stack = list()
        for ch in s:
            if ch == '(' or ch == '[' or ch == '{':
                stack.append(ch)
            elif ch == ')':
                if len(stack) !=0 and stack[-1] == '(':
                    stack.pop()
                else:
                    return False
            elif ch == ']':
                if len(stack) !=0 and stack[-1] == '[':
                    stack.pop()
                else:
                    return False
            elif ch == '}':
                if len(stack) !=0 and stack[-1] == '{':
                    stack.pop()
                else:
                    return False
        if len(stack) == 0:
            return True
        else:
            return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0021. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [0021. 合并两个有序链表 - 力扣](https://leetcode.cn/problems/merge-two-sorted-lists/)

## 题目大意

**描述**：给定两个升序链表的头节点 `list1` 和 `list2`。

**要求**：将其合并为一个升序链表。

**说明**：

- 两个链表的节点数目范围是 $[0, 50]$。
- $-100 \le Node.val \le 100$。
- `list1` 和 `list2` 均按 **非递减顺序** 排列

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```python
输入：list1 = [1,2,4], list2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

- 示例 2：

```python
输入：list1 = [], list2 = []
输出：[]
```

## 解题思路

### 思路 1：归并排序

利用归并排序的思想，具体步骤如下：

1. 使用哑节点 `dummy_head` 构造一个头节点，并使用 `curr` 指向 `dummy_head` 用于遍历。
2. 然后判断 `list1` 和 `list2` 头节点的值，将较小的头节点加入到合并后的链表中。并向后移动该链表的头节点指针。
3. 然后重复上一步操作，直到两个链表中出现链表为空的情况。
4. 将剩余链表链接到合并后的链表中。
5. 将哑节点 `dummy_dead` 的下一个链节点 `dummy_head.next` 作为合并后有序链表的头节点返回。

### 思路 1：代码

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head = ListNode(-1)

        curr = dummy_head
        while list1 and list2:
            if list1.val <= list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next

        curr.next = list1 if list1 is not None else list2

        return dummy_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0022. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

- 标签：字符串、回溯算法
- 难度：中等

## 题目链接

- [0022. 括号生成 - 力扣](https://leetcode.cn/problems/generate-parentheses/)

## 题目大意

**描述**：给定一个整数 $n$，代表生成括号的对数。

**要求**：生成所有有可能且有效的括号组合。

**说明**：

- $1 \le n \le 8$。

**示例**：

- 示例 1：

```python
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

- 示例 2：

```python
输入：n = 1
输出：["()"]
```

## 解题思路

### 思路 1：回溯算法

为了生成的括号组合是有效的，回溯的时候，使用一个标记变量 `symbol` 来表示是否当前组合是否成对匹配。

如果在当前组合中增加一个 `(`，则令 `symbol` 加 `1`，如果增加一个 `)`，则令 `symbol` 减 `1`。

显然只有在 `symbol < n` 的时候，才能增加 `(`，在 `symbol > 0` 的时候，才能增加 `)`。

如果最终生成 $2 \times n$ 的括号组合，并且 `symbol == 0`，则说明当前组合是有效的，将其加入到最终答案数组中。

下面我们根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：$2 \times n$ 的括号组合中的每个位置，都可以从 `(` 或者 `)` 中选出。并且，只有在 `symbol < n` 的时候，才能选择 `(`，在 `symbol > 0` 的时候，才能选择 `)`。

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - `backtracking(symbol, index):` 函数的传入参数是 `symbol`（用于表示是否当前组合是否成对匹配），`index`（当前元素下标），全局变量是 `parentheses`（用于保存所有有效的括号组合），`parenthesis`（当前括号组合），。
      - `backtracking(symbol, index)` 函数代表的含义是：递归根据 `symbol`，在 `(` 和 `)` 中选择第 `index` 个元素。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑元素，到第 $2 \times n$ 个元素为止，枚举出所有可选的元素。对于每一个可选元素：
        - 约束条件：`symbol < n` 或者 `symbol > 0`。
        - 选择元素：将其添加到当前括号组合 `parenthesis` 中。
        - 递归搜索：在选择该元素的情况下，继续递归选择剩下元素。
        - 撤销选择：将该元素从当前括号组合 `parenthesis` 中移除。

    ```python
   if symbol < n:
       parenthesis.append('(')
       backtrack(symbol + 1, index + 1)
       parenthesis.pop()
   if symbol > 0:
       parenthesis.append(')')
       backtrack(symbol - 1, index + 1)
       parenthesis.pop()
    ```
   
   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是当 `index == 2 * n` 时，递归停止。
      - 并且在 `symbol == 0` 时，当前组合才是有效的，此时将其加入到最终答案数组中。

### 思路 1：代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        parentheses = []            # 存放所有括号组合
        parenthesis = []            # 存放当前括号组合
        def backtrack(symbol, index):
            if n * 2 == index:
                if symbol == 0:
                    parentheses.append("".join(parenthesis))
            else:
                if symbol < n:
                    parenthesis.append('(')
                    backtrack(symbol + 1, index + 1)
                    parenthesis.pop()
                if symbol > 0:
                    parenthesis.append(')')
                    backtrack(symbol - 1, index + 1)
                    parenthesis.pop()
        backtrack(0, 0)
        return parentheses
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\frac{2^{2 \times n}}{\sqrt{n}})$，其中 $n$ 为生成括号的对数。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[22. 括号生成 - 力扣（Leetcode）](https://leetcode.cn/problems/generate-parentheses/solutions/192912/gua-hao-sheng-cheng-by-leetcode-solution/)# [0023. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

- 标签：链表、分治、堆（优先队列）、归并排序
- 难度：困难

## 题目链接

- [0023. 合并 K 个升序链表 - 力扣](https://leetcode.cn/problems/merge-k-sorted-lists/)

## 题目大意

**描述**：给定一个链表数组，每个链表都已经按照升序排列。

**要求**：将所有链表合并到一个升序链表中，返回合并后的链表。

**说明**：

- $k == lists.length$。
- $0 \le k \le 10^4$。
- $0 \le lists[i].length \le 500$。
- $-10^4 \le lists[i][j] \le 10^4$。
- $lists[i]$ 按升序排列。
- $lists[i].length$ 的总和不超过 $10^4$。

**示例**：

- 示例 1：

```python
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

- 示例 2：

```python
输入：lists = []
输出：[]
```

## 解题思路

### 思路 1：分治算法

分而治之的思想。将链表数组不断二分，转为规模为二分之一的子问题，然后再进行归并排序。

### 思路 1：代码

```python
class Solution:
    def merge_sort(self, lists: List[ListNode], left: int, right: int) -> ListNode:
        if left == right:
            return lists[left]
        mid = left + (right - left) // 2
        node_left = self.merge_sort(lists, left, mid)
        node_right = self.merge_sort(lists, mid + 1, right)
        return self.merge(node_left, node_right)

    def merge(self, a: ListNode, b: ListNode) -> ListNode:
        root = ListNode(-1)
        cur = root
        while a and b:
            if a.val < b.val:
                cur.next = a
                a = a.next
            else:
                cur.next = b
                b = b.next
            cur = cur.next
        if a:
            cur.next = a
        if b:
            cur.next = b
        return root.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        size = len(lists)
        return self.merge_sort(lists, 0, size - 1)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(k \times n \times \log_2k)$。
- **空间复杂度**：$O(\log_2k)$。

# [0024. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

- 标签：递归、链表
- 难度：中等

## 题目链接

- [0024. 两两交换链表中的节点 - 力扣](https://leetcode.cn/problems/swap-nodes-in-pairs/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：按顺序将链表中每两个节点交换一下，并返回交换后的链表。

**说明**：

- 需要实际进行节点交换，而不是纸改变节点内部的值。
- 链表中节点的数目在范围 $[0, 100]$ 内。
- $0 \le Node.val \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```python
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

- 示例 2：

```python
输入：head = []
输出：[]
```

## 解题思路

### 思路 1：迭代

1. 创建一个哑节点 `new_head`，令 `new_head.next = head`。
2. 遍历链表，并判断当前链表后两位节点是否为空。如果后两个节点不为空，则使用三个指针：`curr` 指向当前节点，`node1` 指向下一个节点，`node2` 指向下面第二个节点。
3. 将 `curr` 指向 `node2`，`node1` 指向 `node2` 后边的节点，`node2` 指向 `node1`。则节点关系由 `curr → node1 → node2` 变为了 `curr → node2 → node1`。
4. 依次类推，最终返回哑节点连接的后一个节点。

### 思路 1：代码

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        new_head = ListNode(0)
        new_head.next = head
        curr = new_head
        while curr.next and curr.next.next:
            node1 = curr.next
            node2 = curr.next.next
            curr.next = node2
            node1.next = node2.next
            node2.next = node1
            curr = node1
        return new_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为链表的节点数量。
- **空间复杂度**：$O(n)$。# [0025. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

- 标签：递归、链表
- 难度：困难

## 题目链接

- [0025. K 个一组翻转链表 - 力扣](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

## 题目大意

**描述**：给你链表的头节点 `head` ，再给定一个正整数 `k`，`k` 的值小于或等于链表的长度。

**要求**：每 `k` 个节点一组进行翻转，并返回修改后的链表。如果链表节点总数不是 `k` 的整数倍，则将最后剩余的节点保持原有顺序。

**说明**：

- 不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
- 假设链表中的节点数目为 `n`。
- $1 \le k \le n \le 5000$。
- $0 \le Node.val \le 1000$。
- 要求设计一个只用 `O(1)` 额外内存空间的算法解决此问题。

**示例**：

- 示例 1：

```python
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

## 解题思路

### 思路 1：迭代

在「[0206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)」中我们可以通过迭代、递归两种方法将整个链表反转。而这道题要求以 `k` 为单位，对链表的区间进行反转。而区间反转其实就是「[0092. 反转链表 II ](https://leetcode.cn/problems/reverse-linked-list-ii/)」这道题的题目要求。

本题中，我们可以以 `k` 为单位对链表进行切分，然后分别对每个区间部分进行反转。最后再返回头节点即可。

但是需要注意一点，如果需要反转的区间包含了链表的第一个节点，那么我们可以事先创建一个哑节点作为链表初始位置开始遍历，这样就能避免找不到需要反转的链表区间的前一个节点。

这道题的具体解题步骤如下：

1. 先使用哑节点 `dummy_head` 构造一个指向 `head` 的指针，避免找不到需要反转的链表区间的前一个节点。使用变量 `index` 记录当前元素的序号。
2. 使用两个指针 `cur`、`tail` 分别表示链表中待反转区间的首尾节点。初始 `cur` 赋值为 `dummy_head`，`tail` 赋值为 `dummy_head.next`，也就是 `head`。
3. 将 `tail` 向右移动，每移动一步，就领 `index` 加 `1`。
   1. 当 `index % k != 0` 时，直接将 `tail` 向右移动，直到移动到当前待反转区间的结尾位置。
   2. 当 `index % k == 0` 时，说明 `tail` 已经移动到了当前待反转区间的结尾位置，此时调用 `cur = self.reverse(cur, tail.next)` ，将待反转区间进行反转，并返回反转后区间的起始节点赋值给当前反转区间的首节点 `cur`。然后将 `tail` 移动到 `cur` 的下一个节点。
4. 最后返回新的头节点 `dummy_head.next`。

关于 `def reverse(self, head, tail):` 方法这里也说下具体步骤：

1. `head` 代表当前待反转区间的第一个节点的前一个节点，`tail`  代表当前待反转区间的最后一个节点的后一个节点。
2. 先用 `first` 保存一下待反转区间的第一个节点（反转之后为区间的尾节点），方便反转之后进行连接。
3. 我们使用两个指针 `cur` 和 `pre` 进行迭代。`pre` 指向 `cur` 前一个节点位置，即 `pre` 指向需要反转节点的前一个节点，`cur` 指向需要反转的节点。初始时，`pre` 指向待反转区间的第一个节点的前一个节点 `head`，`cur` 指向待反转区间的第一个节点，即 `pre.next`。
4. 当当前节点 `cur` 不等于 `tail` 时，将 `pre` 和 `cur` 的前后指针进行交换，指针更替顺序为：
   1. 使用 `next` 指针保存当前节点 `cur` 的后一个节点，即 `next = cur.next`；
   2. 断开当前节点 `cur` 的后一节点链接，将 `cur` 的 `next` 指针指向前一节点 `pre`，即 `cur.next = pre`；
   3. `pre` 向前移动一步，移动到 `cur` 位置，即 `pre = cur`；
   4. `cur` 向前移动一步，移动到之前 `next` 指针保存的位置，即 `cur = next`。
5. 继续执行第 `4` 步中的 `1`、`2`、`3`、`4`步。
6. 最后等到 `cur` 遍历到链表末尾（即 `cur == tail`）时，令「当前待反转区间的第一个节点的前一个节点」指向「反转区间后的头节点」 ，即 `head.next = pre`。令「待反转区间的第一个节点（反转之后为区间的尾节点）」指向「待反转分区间的最后一个节点的后一个节点」，即 `first.next = tail`。
7. 最后返回新的头节点 `dummy_head.next`。

### 思路 1：代码

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverse(self, head, tail):
        pre = head
        cur = pre.next
        first = cur
        while cur != tail:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        head.next = pre
        first.next = tail
        return first

    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy_head = ListNode(0)
        dummy_head.next = head
        cur = dummy_head
        tail = dummy_head.next
        index = 0
        while tail:
            index += 1
            if index % k == 0:
                cur = self.reverse(cur, tail.next)
                tail = cur.next
            else:
                tail = tail.next
        return dummy_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为链表的总长度。
- **空间复杂度**：$O(1)$。
# [0026. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

- 标签：数组、双指针
- 难度：简单

## 题目链接

- [0026. 删除有序数组中的重复项 - 力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

## 题目大意

**描述**：给定一个有序数组 `nums`。

**要求**：删除数组 `nums` 中的重复元素，使每个元素只出现一次。并输出去除重复元素之后数组的长度。

**说明**：

- 不能使用额外的数组空间，在原地修改数组，并在使用 $O(1)$ 额外空间的条件下完成。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

- 示例 2：

```python
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

## 解题思路

### 思路 1：快慢指针

因为数组是有序的，那么重复的元素一定会相邻。

删除重复元素，实际上就是将不重复的元素移到数组左侧。考虑使用双指针。具体算法如下：

1. 定义两个快慢指针 `slow`，`fast`。其中 `slow` 指向去除重复元素后的数组的末尾位置。`fast` 指向当前元素。
2. 令 `slow` 在后， `fast` 在前。令 `slow = 0`，`fast = 1`。
3. 比较 `slow` 位置上元素值和 `fast` 位置上元素值是否相等。
   - 如果不相等，则将 `slow` 后移一位，将 `fast` 指向位置的元素复制到 `slow` 位置上。
4. 将 `fast` 右移 `1` 位。
5. 重复上述 3 ~ 4 步，直到 `fast` 等于数组长度。
6. 返回 `slow + 1` 即为新数组长度。

### 思路 1：代码

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        
        slow, fast = 0, 1

        while (fast < len(nums)):
            if nums[slow] != nums[fast]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
            
        return slow + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0027. 移除元素](https://leetcode.cn/problems/remove-element/)

- 标签：数组、双指针
- 难度：简单

## 题目链接

- [0027. 移除元素 - 力扣](https://leetcode.cn/problems/remove-element/)

## 题目大意

**描述**：给定一个数组 $nums$，和一个值 $val$。

**要求**：不使用额外数组空间，将数组中所有数值等于 $val$ 值的元素移除掉，并且返回新数组的长度。

**说明**：

- $0 \le nums.length \le 100$。
- $0 \le nums[i] \le 50$。
- $0 \le val \le 100$。

**示例**：

- 示例 1：

```python
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

- 示例 2：

```python
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

## 解题思路

### 思路 1：快慢指针

1. 使用两个指针 $slow$，$fast$。$slow$ 指向处理好的非 $val$ 值元素数组的尾部，$fast$ 指针指向当前待处理元素。
2. 不断向右移动 $fast$ 指针，每次移动到非 $val$ 值的元素，则将左右指针对应的数交换，交换同时将 $slow$ 右移。
3. 这样就将非 $val$ 值的元素进行前移，$slow$ 指针左边均为处理好的非 $val$ 值元素，而从 $slow$ 指针指向的位置开始， $fast$ 指针左边都为 $val $值。
4. 遍历结束之后，则所有 $val$ 值元素都移动到了右侧，且保持了非零数的相对位置。此时 $slow$ 就是新数组的长度。

### 思路 1：代码

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = 0
        fast = 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
            fast += 1
        return slow
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0028. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

- 标签：双指针、字符串、字符串匹配
- 难度：中等

## 题目链接

- [0028. 找出字符串中第一个匹配项的下标 - 力扣](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

## 题目大意

**描述**：给定两个字符串 `haystack` 和 `needle`。 

**要求**：在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（从 `0` 开始）。如果不存在，则返回 `-1`。

**说明**：

- 当 `needle` 为空字符串时，返回 `0`。
- $1 \le haystack.length, needle.length \le 10^4$。
- `haystack` 和 `needle` 仅由小写英文字符组成。

**示例**：

- 示例 1：

```python
输入：haystack = "hello", needle = "ll"
输出：2
解释："sad" 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。
```

- 示例 2：

```python
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

## 解题思路

字符串匹配的经典题目。常见的字符串匹配算法有：BF（Brute Force）算法、RK（Robin-Karp）算法、KMP（Knuth Morris Pratt）算法、BM（Boyer Moore）算法、Horspool 算法、Sunday 算法等。

### 思路 1：BF（Brute Force）算法

**BF 算法思想**：对于给定文本串 `T` 与模式串 `p`，从文本串的第一个字符开始与模式串 `p` 的第一个字符进行比较，如果相等，则继续逐个比较后续字符，否则从文本串 `T` 的第二个字符起重新和模式串 `p` 进行比较。依次类推，直到模式串 `p` 中每个字符依次与文本串 `T` 的一个连续子串相等，则模式匹配成功。否则模式匹配失败。

BF 算法具体步骤如下：

1. 对于给定的文本串 `T` 与模式串 `p`，求出文本串 `T` 的长度为 `n`，模式串 `p` 的长度为 `m`。
2. 同时遍历文本串 `T` 和模式串 `p`，先将 `T[0]` 与 `p[0]` 进行比较。
   1. 如果相等，则继续比较 `T[1]` 和 `p[1]`。以此类推，一直到模式串 `p` 的末尾 `p[m - 1]` 为止。
   2. 如果不相等，则将文本串 `T` 移动到上次匹配开始位置的下一个字符位置，模式串 `p` 则回退到开始位置，再依次进行比较。
3. 当遍历完文本串 `T` 或者模式串 `p` 的时候停止搜索。

### 思路 1：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        i = 0
        j = 0
        len1 = len(haystack)
        len2 = len(needle)

        while i < len1 and j < len2:
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            else:
                i = i - (j - 1)
                j = 0

        if j == len2:
            return i - j
        else:
            return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：平均时间复杂度为 $O(n + m)$，最坏时间复杂度为 $O(m \times n)$。其中文本串 $T$ 的长度为 $n$，模式串 $p$ 的长度为 $m$。
- **空间复杂度**：$O(1)$。

### 思路 2：RK（Robin Karp）算法

**RK 算法思想**：对于给定文本串 `T` 与模式串 `p`，通过滚动哈希算快速筛选出与模式串 `p` 不匹配的文本位置，然后在其余位置继续检查匹配项。

RK 算法具体步骤如下：

1. 对于给定的文本串 `T` 与模式串 `p`，求出文本串 `T` 的长度为 `n`，模式串 `p` 的长度为 `m`。
2. 通过滚动哈希算法求出模式串 `p` 的哈希值 `hash_p`。
3. 再通过滚动哈希算法对文本串 `T` 中 `n - m + 1` 个子串分别求哈希值 `hash_t`。
4. 然后逐个与模式串的哈希值比较大小。
   1. 如果当前子串的哈希值 `hash_t` 与模式串的哈希值 `hash_p` 不同，则说明两者不匹配，则继续向后匹配。
   2. 如果当前子串的哈希值 `hash_t` 与模式串的哈希值 `hash_p` 相等，则验证当前子串和模式串的每个字符是否真的相等（避免哈希冲突）。
      1. 如果当前子串和模式串的每个字符相等，则说明当前子串和模式串匹配。
      2. 如果当前子串和模式串的每个字符不相等，则说明两者不匹配，继续向后匹配。
5. 比较到末尾，如果仍未成功匹配，则说明文本串 `T` 中不包含模式串 `p`，方法返回 `-1`。

### 思路 2：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def rabinKarp(T: str, p: str) -> int:
            len1, len2 = len(T), len(p)
            
            hash_p = hash(p)
            for i in range(len1 - len2 + 1):
                hash_T = hash(T[i: i + len2])
                if hash_p != hash_T:
                    continue
                k = 0
                for j in range(len2):
                    if T[i + j] != p[j]:
                        break
                    k += 1
                if k == len2:
                    return i
            return -1
        return rabinKarp(haystack, needle)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中文本串 $T$ 的长度为 $n$，模式串 $p$ 的长度为 $m$。
- **空间复杂度**：$O(m)$。

### 思路 3：KMP（Knuth Morris Pratt）算法

**KMP 算法思想**：对于给定文本串 `T` 与模式串 `p`，当发现文本串 `T` 的某个字符与模式串 `p` 不匹配的时候，可以利用匹配失败后的信息，尽量减少模式串与文本串的匹配次数，避免文本串位置的回退，以达到快速匹配的目的。

KMP 算法具体步骤如下：

1. 根据 `next` 数组的构造步骤生成「前缀表」`next`。
2. 使用两个指针 `i`、`j`，其中 `i` 指向文本串中当前匹配的位置，`j` 指向模式串中当前匹配的位置。初始时，`i = 0`，`j = 0`。
3. 循环判断模式串前缀是否匹配成功，如果模式串前缀匹配不成功，将模式串进行回退，即 `j = next[j - 1]`，直到 `j == 0` 时或前缀匹配成功时停止回退。
4. 如果当前模式串前缀匹配成功，则令模式串向右移动 `1` 位，即 `j += 1`。
5. 如果当前模式串 **完全** 匹配成功，则返回模式串 `p` 在文本串 `T` 中的开始位置，即 `i - j + 1`。
6. 如果还未完全匹配成功，则令文本串向右移动 `1` 位，即 `i += 1`，然后继续匹配。
7. 如果直到文本串遍历完也未完全匹配成功，则说明匹配失败，返回 `-1`。

### 思路 3：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        # KMP 匹配算法，T 为文本串，p 为模式串
        def kmp(T: str, p: str) -> int:
            n, m = len(T), len(p)

            next = generateNext(p)  # 生成 next 数组

            i, j = 0, 0
            while i < n and j < m:
                if j == -1 or T[i] == p[j]:
                    i += 1
                    j += 1
                else:
                    j = next[j]
            if j == m:
                return i - j

            return -1

        # 生成 next 数组
        # next[i] 表示坏字符在模式串中最后一次出现的位置
        def generateNext(p: str):
            m = len(p)

            next = [-1 for _ in range(m)]  # 初始化数组元素全部为 -1
            i, k = 0, -1
            while i < m - 1:  # 生成下一个 next 元素
                if k == -1 or p[i] == p[k]:
                    i += 1
                    k += 1
                    if p[i] == p[k]:
                        next[i] = next[k]  # 设置 next 元素
                    else:
                        next[i] = k  # 退到更短相同前缀
                else:
                    k = next[k]
            return next

        return kmp(haystack, needle)
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n + m)$，其中文本串 $T$ 的长度为 $n$，模式串 $p$ 的长度为 $m$。
- **空间复杂度**：$O(m)$。

### 思路 4：BM（Boyer Moore）算法

**BM 算法思想**：对于给定文本串 `T` 与模式串 `p`，先对模式串 `p` 进行预处理。然后在匹配的过程中，当发现文本串 `T` 的某个字符与模式串 `p` 不匹配的时候，根据启发策略，能够直接尽可能地跳过一些无法匹配的情况，将模式串多向后滑动几位。

BM 算法具体步骤如下：

1. 计算出文本串 `T` 的长度为 `n`，模式串 `p` 的长度为 `m`。
2. 先对模式串 `p` 进行预处理，生成坏字符位置表 `bc_table` 和好后缀规则后移位数表 `gs_talbe`。
3. 将模式串 `p` 的头部与文本串 `T` 对齐，将 `i` 指向文本串开始位置，即 `i = 0`。`j` 指向模式串末尾位置，即 `j = m - 1`，然后从模式串末尾位置开始进行逐位比较。
   1. 如果文本串对应位置 `T[i + j]` 上的字符与 `p[j]` 相同，则继续比较前一位字符。
      1. 如果模式串全部匹配完毕，则返回模式串 `p` 在文本串中的开始位置 `i`。
   2. 如果文本串对应位置 `T[i + j]` 上的字符与 `p[j]` 不相同，则：
      1. 根据坏字符位置表计算出在「坏字符规则」下的移动距离 `bad_move`。
      2. 根据好后缀规则后移位数表计算出在「好后缀规则」下的移动距离 `good_mode`。
      3. 取两种移动距离的最大值，然后对模式串进行移动，即 `i += max(bad_move, good_move)`。
4. 如果移动到末尾也没有找到匹配情况，则返回 `-1`。

### 思路 4：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def boyerMoore(T: str, p: str) -> int:
            n, m = len(T), len(p)
            
            bc_table = generateBadCharTable(p)      # 生成坏字符位置表
            gs_list = generageGoodSuffixList(p)     # 生成好后缀规则后移位数表
            
            i = 0
            while i <= n - m:
                j = m - 1
                while j > -1 and T[i + j] == p[j]:
                    j -= 1
                if j < 0:
                    return i
                bad_move = j - bc_table.get(T[i + j], -1)
                good_move = gs_list[j]
                i += max(bad_move, good_move)
            return -1
            
        # 生成坏字符位置表
        def generateBadCharTable(p: str):
            bc_table = dict()
            
            for i in range(len(p)):
                bc_table[p[i]] = i          # 坏字符在模式串中最后一次出现的位置
            return bc_table

        # 生成好后缀规则后移位数表
        def generageGoodSuffixList(p: str):
            m = len(p)
            gs_list = [m for _ in range(m)]
            suffix = generageSuffixArray(p)
            j = 0
            for i in range(m - 1, -1, -1):
                if suffix[i] == i + 1:
                    while j < m - 1 - i:
                        if gs_list[j] == m:
                            gs_list[j] = m - 1 - i
                        j += 1
                
            for i in range(m - 1):
                gs_list[m - 1 - suffix[i]] = m - 1 - i
            
            return gs_list

        def generageSuffixArray(p: str):
            m = len(p)
            suffix = [m for _ in range(m)]
            for i in range(m - 2, -1, -1):
                start = i
                while start >= 0 and p[start] == p[m - 1 - i + start]:
                    start -= 1
                suffix[i] = i - start
            return suffix

        return boyerMoore(haystack, needle)
```

### 思路 4：复杂度分析

- **时间复杂度**：$O(n + \sigma)$，其中文本串 $T$ 的长度为 $n$，字符集的大小是 $\sigma$。
- **空间复杂度**：$O(m)$。其中模式串 $p$ 的长度为 $m$。

### 思路 5：Horspool 算法

**Horspool 算法思想**：对于给定文本串 `T` 与模式串 `p`，先对模式串 `p` 进行预处理。然后在匹配的过程中，当发现文本串 `T` 的某个字符与模式串 `p` 不匹配的时候，根据启发策略，能够尽可能的跳过一些无法匹配的情况，将模式串多向后滑动几位。

Horspool 算法具体步骤如下：

1. 计算出文本串 `T` 的长度为 `n`，模式串 `p` 的长度为 `m`。
2. 先对模式串 `p` 进行预处理，生成后移位数表 `bc_table`。
3. 将模式串 `p` 的头部与文本串 `T` 对齐，将 `i` 指向文本串开始位置，即 `i = 0`。`j` 指向模式串末尾位置，即 `j = m - 1`，然后从模式串末尾位置开始比较。
   1. 如果文本串对应位置的字符 `T[i + j]` 与模式串对应字符 `p[j]` 相同，则继续比较前一位字符。
      1. 如果模式串全部匹配完毕，则返回模式串 `p` 在文本串中的开始位置 `i`。
   2. 如果文本串对应位置的字符 `T[i + j]` 与模式串对应字符 `p[j]` 不同，则：
      1. 根据后移位数表 `bc_table` 和模式串末尾位置对应的文本串上的字符 `T[i + m - 1]` ，计算出可移动距离 `bc_table[T[i + m - 1]]`，然后将模式串进行后移。
4. 如果移动到末尾也没有找到匹配情况，则返回 `-1`。

### 思路 5：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def horspool(T: str, p: str) -> int:
            n, m = len(T), len(p)
            
            bc_table = generateBadCharTable(p)
            
            i = 0
            while i <= n - m:
                j = m - 1
                while j > -1 and T[i + j] == p[j]:
                    j -= 1
                if j < 0:
                    return i
                i += bc_table.get(T[i + m - 1], m)
            return -1

        # 生成后移位置表
        # bc_table[bad_char] 表示坏字符在模式串中最后一次出现的位置
        def generateBadCharTable(p: str):
            m = len(p)
            bc_table = dict()
            
            for i in range(m - 1):
                bc_table[p[i]] = m - i - 1    # 更新坏字符在模式串中最后一次出现的位置
            return bc_table

        return horspool(haystack, needle)
```

### 思路 5：复杂度分析

- **时间复杂度**：$O(n)$。其中文本串 $T$ 的长度为 $n$。
- **空间复杂度**：$O(m)$。其中模式串 $p$ 的长度为 $m$。

### 思路 6：Sunday 算法

**Sunday 算法思想**：对于给定文本串 `T` 与模式串 `p`，先对模式串 `p` 进行预处理。然后在匹配的过程中，当发现文本串 `T` 的某个字符与模式串 `p` 不匹配的时候，根据启发策略，能够尽可能的跳过一些无法匹配的情况，将模式串多向后滑动几位。

Sunday 算法具体步骤如下：

1. 计算出文本串 `T` 的长度为 `n`，模式串 `p` 的长度为 `m`。
2. 先对模式串 `p` 进行预处理，生成后移位数表 `bc_table`。
3. 将模式串 `p` 的头部与文本串 `T` 对齐，将 `i` 指向文本串开始位置，即 `i = 0`。`j` 指向模式串末尾位置，即 `j = m - 1`，然后从模式串末尾位置开始比较。
   1. 如果文本串对应位置的字符 `T[i + j]` 与模式串对应字符 `p[j]` 相同，则继续比较前一位字符。
      1. 如果模式串全部匹配完毕，则返回模式串 `p` 在文本串中的开始位置 `i`。
   2. 如果文本串对应位置的字符 `T[i + j]` 与模式串对应字符 `p[j]` 不同，则：
      1. 根据后移位数表 `bc_table` 和模式串末尾位置对应的文本串上的字符 `T[i + m - 1]` ，计算出可移动距离 `bc_table[T[i + m - 1]]`，然后将模式串进行后移。
4. 如果移动到末尾也没有找到匹配情况，则返回 `-1`。

### 思路 6：代码

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        # sunday 算法，T 为文本串，p 为模式串
        def sunday(T: str, p: str) -> int:
            n, m = len(T), len(p)
            if m == 0:
                return 0
            
            bc_table = generateBadCharTable(p)          # 生成后移位数表
            
            i = 0
            while i <= n - m:
                if T[i: i + m] == p:
                    return i                            # 匹配完成，返回模式串 p 在文本串 T 中的位置
                if i + m >= n:
                    return -1
                i += bc_table.get(T[i + m], m + 1)      # 通过后移位数表，向右进行进行快速移动
            return -1                                   # 匹配失败

        # 生成后移位数表
        # bc_table[bad_char] 表示遇到坏字符可以向右移动的距离
        def generateBadCharTable(p: str):
            m = len(p)
            bc_table = dict()
            
            for i in range(m):
                bc_table[p[i]] = m - i              # 更新遇到坏字符可向右移动的距离
            return bc_table

        return sunday(haystack, needle)
```

### 思路 6：复杂度分析

- **时间复杂度**：$O(n)$。其中文本串 $T$ 的长度为 $n$。
- **空间复杂度**：$O(m)$。其中模式串 $p$ 的长度为 $m$。# [0029. 两数相除](https://leetcode.cn/problems/divide-two-integers/)

- 标签：位运算、数学
- 难度：中等

## 题目链接

- [0029. 两数相除 - 力扣](https://leetcode.cn/problems/divide-two-integers/)

## 题目大意

给定两个整数，被除数 dividend 和除数 divisor。要求返回两数相除的商，并且不能使用乘法，除法和取余运算。取值范围在 $[-2^{31}, 2^{31}-1]$。如果结果溢出，则返回 $2^{31} - 1$。

## 解题思路

题目要求不能使用乘法，除法和取余运算。

可以把被除数和除数当做二进制，这样进行运算的时候，就可以通过移位运算来实现二进制的乘除。

- 先将除数不断左移，移位到位数大于或等于被除数。记录其移位次数 count。

- 然后再将除数右移 count 次，模拟二进制除法运算。
  - 如果当前被除数大于等于除数，则将 1 左移 count 位，即为当前位的商，并将其累加答案上。再用除数减去被除数，进行下一次运算。



## 代码

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        MIN_INT, MAX_INT = -2147483648, 2147483647
        # 标记被除数和除数是否异号
        symbol = True if (dividend ^ divisor) < 0 else False
        # 将被除数和除数转换为正数处理
        if dividend < 0:
            dividend = -dividend
        if divisor < 0:
            divisor = -divisor

        # 除数不断左移，移位到位数大于或等于被除数
        count = 0
        while dividend >= divisor:
            count += 1
            divisor <<= 1

        # 向右移位，不断模拟二进制除法运算
        res = 0
        while count > 0:
            count -= 1
            divisor >>= 1
            if dividend >= divisor:
                res += (1 << count)
                dividend -= divisor
        if symbol:
            res = -res
        if MIN_INT <= res <= MAX_INT:
            return res
        else:
            return MAX_INT
```

# [0032. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

- 标签：栈、字符串、动态规划
- 难度：困难

## 题目链接

- [0032. 最长有效括号 - 力扣](https://leetcode.cn/problems/longest-valid-parentheses/)

## 题目大意

**描述**：给定一个只包含 `'('` 和 `')'` 的字符串。

**要求**：找出最长有效（格式正确且连续）括号子串的长度。

**说明**：

- $0 \le s.length \le 3 * 10^4$。
- `s[i]` 为 `'('` 或 `')'`。

**示例**：

- 示例 1：

```python
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

- 示例 2：

```python
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照最长有效括号子串的结束位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：以字符 `s[i]` 为结尾的最长有效括号的长度。

###### 3. 状态转移方程

- 如果 `s[i] == '('`，此时以 `s[i]` 结尾的子串不可能构成有效括号对，则 `dp[i] = 0`。
- 如果 `s[i] == ')'`，我们需要考虑 `s[i - 1]` 来判断是否能够构成有效括号对。
  - 如果 `s[i - 1] == '('`，字符串形如 `......()`，此时 `s[i - 1]` 与 `s[i]` 为 `()`，则：
    - `dp[i]` 取决于「以字符 `s[i - 2]` 为结尾的最长有效括号长度」 + 「`s[i - 1]` 与 `s[i]` 构成的有效括号对长度（`2`）」，即 `dp[i] = dp[i - 2] + 2`。
    - 特别地，如果 `s[i - 2]` 不存在，即 `i - 2 < 0`，则 `dp[i]` 直接取决于 「`s[i - 1]` 与 `s[i]` 构成的有效括号对长度（`2`）」，即 `dp[i] = 2`。
  - 如果 `s[i - 1] == ')'`，字符串形如 `......))`，此时 `s[i - 1]` 与 `s[i]` 为 `))`。那么以 `s[i - 1]` 为结尾的最长有效长度为 `dp[i - 1]`，则我们需要看 `i - 1 - dp[i - 1]` 位置上的字符 `s[i - 1 - dp[i - 1]]`是否与 `s[i]` 匹配。
    - 如果 `s[i - 1 - dp[i - 1]] == '('`，则说明 `s[i - 1 - dp[i - 1]]`与 `s[i]` 相匹配，此时我们需要看以 `s[i - 1 - dp[i - 1]]` 的前一个字符 `s[i - 1 - dp[i - 2]]` 为结尾的最长括号长度是多少，将其加上 ``s[i - 1 - dp[i - 1]]`与 `s[i]`，从而构成更长的有效括号对：
      - `dp[i]` 取决于「以字符 `s[i - 1]` 为结尾的最长括号长度」 + 「以字符 `s[i - 1 - dp[i - 2]]` 为结尾的最长括号长度」+ 「`s[i - 1 - dp[i - 1]]` 与 `s[i]` 的长度（`2`）」，即 `dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2`。
      - 特别地，如果 `s[i - dp[i - 1] - 2]` 不存在，即 `i - dp[i - 1] - 2 < 0`，则 `dp[i]` 直接取决于「以字符 `s[i - 1]` 为结尾的最长括号长度」+「`s[i - 1 - dp[i - 1]]` 与 `s[i]` 的长度（`2`）」，即 `dp[i] = dp[i - 1] + 2`。

###### 4. 初始条件

- 默认所有以字符 `s[i]` 为结尾的最长有效括号的长度为 `0`，即 `dp[i] = 0`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：以字符 `s[i]` 为结尾的最长有效括号的长度。则最终结果为 `max(dp[i])`。

### 思路 1：代码

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0 for _ in range(len(s))]
        ans = 0
        for i in range(1, len(s)):
            if s[i] == '(':
                continue
            if s[i - 1] == '(':
                if i >= 2:
                    dp[i] = dp[i - 2] + 2
                else:
                    dp[i] = 2
            elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                if i - dp[i - 1] >= 2:
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
                else:
                    dp[i] = dp[i - 1] + 2
            ans = max(ans, dp[i])

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串长度。
- **空间复杂度**：$O(n)$。

### 思路 2：栈

1. 定义一个变量 `ans` 用于维护最长有效括号的长度，初始时，`ans = 0`。
2. 定义一个栈用于判定括号对是否匹配（栈中存储的是括号的下标），栈底元素始终保持「最长有效括号子串的开始元素的前一个元素下标」。
3. 初始时，我们在栈中存储 `-1` 作为哨兵节点，表示「最长有效括号子串的开始元素的前一个元素下标为 `-1`」，即 `stack = [-1]`，
4. 然后从左至右遍历字符串。
   1. 如果遇到左括号，即 `s[i] == '('`，则将其下标 `i` 压入栈，用于后续匹配右括号。
   2. 如果遇到右括号，即 `s[i] == ')'`，则将其与最近的左括号进行匹配（即栈顶元素），弹出栈顶元素，与当前右括号进行匹配。弹出之后：
      1. 如果栈为空，则说明：
         1. 之前弹出的栈顶元素实际上是「最长有效括号子串的开始元素的前一个元素下标」，而不是左括号`(`，此时无法完成合法匹配。
         2. 将当前右括号的坐标 `i` 压入栈中，充当「下一个有效括号子串的开始元素前一个下标」。
      2. 如果栈不为空，则说明：
         1. 之前弹出的栈顶元素为左括号 `(`，此时可完成合法匹配。
         2. 当前合法匹配的长度为「当前右括号的下标 `i`」 - 「最长有效括号子串的开始元素的前一个元素下标」。即 `i - stack[-1]`。
         3. 更新最长匹配长度 `ans` 为 `max(ans, i - stack[-1])`。
5. 遍历完输出答案 `ans`。

### 思路 2：代码

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        ans = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if stack:
                    ans = max(ans, i - stack[-1])
                else:
                    stack.append(i)
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串长度。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[动态规划思路详解（C++）——32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/solutions/206995/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/)
- 【题解】[32. 最长有效括号 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/)
- 【题解】[【Nick~Hot一百题系列】超简单思路栈！](https://leetcode.cn/problems/longest-valid-parentheses/solutions/1258643/nickhotyi-bai-ti-xi-lie-chao-jian-dan-si-ggi4/)# [0033. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0033. 搜索旋转排序数组 - 力扣](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

## 题目大意

**描述**：给定一个整数数组 $nums$，数组中值互不相同。给定的 $nums$ 是经过升序排列后的又进行了「旋转」操作的。再给定一个整数 $target$。

**要求**：从 $nums$ 中找到 $target$ 所在位置，如果找到，则返回对应下标，找不到则返回 $-1$。

**说明**：

- 旋转操作：升序排列的数组 nums 在预先未知的第 k 个位置进行了右移操作，变成了 $[nums[k]], nums[k+1], ... , nums[n-1], ... , nums[0], nums[1], ... , nums[k-1]$。

**示例**：

- 示例 1：

```python
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

- 示例 2：

```python
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

## 解题思路

### 思路 1：二分查找

原本为升序排列的数组 $nums$ 经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。

```python
          *
        *
      *
    *
  *
*
```

```python
    *
  *
*
          *
        *
      *
```

最直接的办法就是遍历一遍，找到目标值 $target$。但是还可以有更好的方法。考虑用二分查找来降低算法的时间复杂度。

我们将旋转后的数组看成左右两个升序部分：左半部分和右半部分。

有人会说第一种情况不是只有一个部分吗？其实我们可以把第一种情况中的整个数组看做是左半部分，然后右半部分为空数组。

然后创建两个指针 $left$、$right$，分别指向数组首尾。让后计算出两个指针中间值 $mid$。将 $mid$ 与两个指针做比较，并考虑与 $target$ 的关系。

- 如果 $nums[mid] == target$，说明找到了 $target$，直接返回下标。
- 如果 $nums[mid] \ge nums[left]$，则 $mid$ 在左半部分（因为右半部分值都比 $nums[left]$ 小）。
  - 如果 $nums[mid] \ge target$，并且 $target \ge nums[left]$，则 $target$ 在左半部分，并且在 $mid$ 左侧，此时应将 $right$ 左移到 $mid - 1$ 位置。
  - 否则如果 $nums[mid] \le target$，则 $target$ 在左半部分，并且在 $mid$ 右侧，此时应将 $left$ 右移到 $mid + 1$ 位置。
  - 否则如果 $nums[left] > target$，则 $target$ 在右半部分，应将 $left$ 移动到 $mid + 1$ 位置。

- 如果 $nums[mid] < nums[left]$，则 $mid$ 在右半部分（因为右半部分值都比 $nums[left]$ 小）。
  - 如果 $nums[mid] < target$，并且 $target \le nums[right]$，则 $target$ 在右半部分，并且在 $mid$ 右侧，此时应将 $left$ 右移到 $mid + 1$ 位置。
  - 否则如果 $nums[mid] \ge target$，则 $target$ 在右半部分，并且在 $mid$ 左侧，此时应将 $right$ 左移到 $mid - 1$ 位置。
  - 否则如果 $nums[right] < target$，则 $target$ 在左半部分，应将 $right$ 左移到 $mid - 1$ 位置。

### 思路 1：代码

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid

            if nums[mid] >= nums[left]:
                if nums[mid] > target and target >= nums[left]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [0034. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0034. 在排序数组中查找元素的第一个和最后一个位置 - 力扣](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

## 题目大意

**描述**：给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。

**要求**：找出给定目标值在数组中的开始位置和结束位置。

**说明**：

- 要求使用时间复杂度为 $O(\log n)$ 的算法解决问题。

**示例**：

- 示例 1：

```python
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

- 示例 2：

```python
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

## 解题思路

### 思路 1：二分查找

要求使用时间复杂度为 $O(\log n)$ 的算法解决问题，那么就需要使用「二分查找算法」了。

- 进行两次二分查找，第一次尽量向左搜索。第二次尽量向右搜索。

### 思路 1：代码

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        ans = [-1, -1]
        n = len(nums)
        if n == 0:
            return ans

        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid

        if nums[left] != target:
            return ans

        ans[0] = left

        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left + 1) // 2
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid

        if nums[left] == target:
            ans[1] = left

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log_2 n)$。
- **空间复杂度**：$O(1)$。# [0035. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [0035. 搜索插入位置 - 力扣](https://leetcode.cn/problems/search-insert-position/)

## 题目大意

**描述**：给定一个排好序的数组 $nums$，以及一个目标值 $target$。

**要求**：在数组中找到目标值，并返回下标。如果找不到，则返回目标值按顺序插入数组的位置。

**说明**：

- $1 \le nums.length \le 10^4$。
- $-10^4 \le nums[i] \le 10^4$。
- $nums$ 为无重复元素的升序排列数组。
- $-10^4 \le target \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,5,6], target = 5
输出：2
```

## 解题思路

### 思路 1：二分查找

设定左右节点为数组两端，即 `left = 0`，`right = len(nums) - 1`，代表待查找区间为 $[left, right]$（左闭右闭）。

取两个节点中心位置 $mid$，先比较中心位置值 $nums[mid]$ 与目标值 $target$ 的大小。

- 如果 $target == nums[mid]$，则当前中心位置为待插入数组的位置。
- 如果 $target > nums[mid]$，则将左节点设置为 $mid + 1$，然后继续在右区间 $[mid + 1, right]$ 搜索。
- 如果 $target < nums[mid]$，则将右节点设置为 $mid - 1$，然后继续在左区间 $[left, mid - 1]$ 搜索。

直到查找到目标值返回待插入数组的位置，或者等到 $left > right$ 时停止查找，此时 $left$ 所在位置就是待插入数组的位置。

### 思路 1：二分查找代码

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        size = len(nums)
        left, right = 0, size - 1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [0036. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

- 标签：数组、哈希表、矩阵
- 难度：中等

## 题目链接

- [0036. 有效的数独 - 力扣](https://leetcode.cn/problems/valid-sudoku/)

## 题目大意

**描述**：给定一个数独，用 `9 * 9` 的二维字符数组 `board` 来表示，其中，未填入的空白用 "." 代替。

**要求**：判断该数独是否是一个有效的数独。

**说明**：

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

一个有效的数独需满足：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3 * 3` 宫内只能出现一次。（请参考示例图）

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```python
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：True
```

## 解题思路

### 思路 1：哈希表

判断数独有效，需要分别看每一行、每一列、每一个 `3 * 3` 的小方格是否出现了重复数字，如果都没有出现重复数字就是一个有效的数独，如果出现了重复数字则不是有效的数独。

- 用 `3` 个 `9 * 9` 的数组分别来表示该数字是否在所在的行，所在的列，所在的方格出现过。其中方格角标的计算用 `box[(i / 3) * 3 + (j / 3)][n]` 来表示。
- 双重循环遍历数独矩阵。如果对应位置上的数字如果已经在在所在的行 / 列 / 方格出现过，则返回 `False`。
- 遍历完没有重复出现，则返回 `Ture`。

### 思路 1：代码

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows_map = [dict() for _ in range(9)]
        cols_map = [dict() for _ in range(9)]
        boxes_map = [dict() for _ in range(9)]

        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    continue
                num = int(board[i][j])
                box_index = (i // 3) * 3 + j // 3
                row_num = rows_map[i].get(num, 0)
                col_num = cols_map[j].get(num, 0)
                box_num = boxes_map[box_index].get(num, 0)
                if row_num > 0 or col_num > 0 or box_num > 0:
                    return False
                rows_map[i][num] = 1
                cols_map[j][num] = 1
                boxes_map[box_index][num] = 1
        
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。数独总共 81 个单元格，对每个单元格遍历一次，可以看做是常数级的时间复杂度。
- **空间复杂度**：$O(1)$。使用 81 个单位空间，可以看做是常数级的空间复杂度。
# [0037. 解数独](https://leetcode.cn/problems/sudoku-solver/)

- 标签：数组、哈希表、回溯、矩阵
- 难度：困难

## 题目链接

- [0037. 解数独 - 力扣](https://leetcode.cn/problems/sudoku-solver/)

## 题目大意

**描述**：给定一个二维的字符数组 $board$ 用来表示数独，其中数字 $1 \sim 9$ 表示该位置已经填入了数字，`.` 表示该位置还没有填入数字。

**要求**：现在编写一个程序，通过填充空格的方式来解决数独问题，最终不用返回答案，将题目给定 $board$ 修改为可行的方案即可。

**说明**：

- 数独解法需遵循如下规则：

  - 数字 $1 \sim 9$ 在每一行只能出现一次。
  - 数字 $1 \sim 9$ 在每一列只能出现一次。
  - 数字 $1 \sim 9$ 在每一个以粗直线分隔的 $3 \times 3$ 宫格内只能出现一次。
- $board.length == 9$。
- $board[i].length == 9$。
- $board[i][j]$ 是一位数字或者 `.`。
- 题目数据保证输入数独仅有一个解。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```python
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

## 解题思路

### 思路 1：回溯算法

对于每一行、每一列、每一个数字，都需要一重 `for` 循环来遍历，这样就是三重 `for` 循环。

对于第 $i$ 行、第 $j$ 列的元素来说，如果当前位置为空位，则尝试将第 $k$ 个数字置于此处，并检验数独的有效性。如果有效，则继续遍历下一个空位，直到遍历完所有空位，得到可行方案或者遍历失败时结束。

遍历完下一个空位之后再将此位置进行回退，置为 `.`。

### 思路 1：代码

```python
class Solution:
    def backtrack(self, board: List[List[str]]):
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] != '.':
                    continue
                for k in range(1, 10):
                    if self.isValid(i, j, k, board):
                        board[i][j] = str(k)
                        if self.backtrack(board):
                            return True
                        board[i][j] = '.'
                return False
        return True

    def isValid(self, row: int, col: int, val: int, board: List[List[str]]) -> bool:
        for i in range(0, 9):
            if board[row][i] == str(val):
                return False

        for j in range(0, 9):
            if board[j][col] == str(val):
                return False

        start_row = (row // 3) * 3
        start_col = (col // 3) * 3

        for i in range(start_row, start_row + 3):
            for j in range(start_col, start_col + 3):
                if board[i][j] == str(val):
                    return False
        return True

    def solveSudoku(self, board: List[List[str]]) -> None:
        self.backtrack(board)
        """
        Do not return anything, modify board in-place instead.
        """
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(9^m)$，$m$ 为棋盘中 `.` 的数量。
- **空间复杂度**：$O(9^2)$。

# [0038. 外观数列](https://leetcode.cn/problems/count-and-say/)

- 标签：字符串
- 难度：中等

## 题目链接

- [0038. 外观数列 - 力扣](https://leetcode.cn/problems/count-and-say/)

## 题目大意

给定一个正整数 n，$(1 \le n \le 30)$，要求输出外观数列的第 n 项。

外观数列：整数序列，数字由 1 开始，每一项都是对前一项的描述

例如：

| 1.  |    1 | 由 1 开始           |
| --- | ---: | ------------------- |
| 2.  |   11 | 表示 1 个 1         |
| 3.  |   21 | 表示 2 个 1         |
| 4.  | 1211 | 表示 1 个 1，1 个 2 |



## 解题思路

模拟题目遍历求解。

将 ans 设为 "1"，每次遍历判断相邻且相同的数字有多少个，再将 ans 拼接上「数字个数 + 数字」。

## 代码

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        ans = "1"

        for _ in range(1, n):
            s = ""
            start = 0
            for i in range(len(ans)):
                if ans[i] != ans[start]:
                    s += str(i-start) + ans[start]
                    start = i
            s += str(len(ans)-start) + ans[start]
            ans = s
        return ans
```

# [0039. 组合总和](https://leetcode.cn/problems/combination-sum/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [0039. 组合总和 - 力扣](https://leetcode.cn/problems/combination-sum/)

## 题目大意

**描述**：给定一个无重复元素的正整数数组 `candidates` 和一个正整数 `target`。

**要求**：找出 `candidates` 中所有可以使数字和为目标数 `target` 的所有不同组合，并以列表形式返回。可以按照任意顺序返回这些组合。

**说明**：

- 数组 `candidates` 中的数字可以无限重复选取。
- 如果至少一个数字的被选数量不同，则两种组合是不同的。 
- $1 \le candidates.length \le 30$。
- $2 \le candidates[i] \le 40$。
- `candidates` 的所有元素互不相同。
- $1 \le target \le 40$。

**示例**：

- 示例 1：

```python
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

- 示例 2：

```python
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

## 解题思路

### 思路 1：回溯算法

定义回溯方法，start_index = 1 开始进行回溯。

- 如果 `sum > target`，则直接返回。
- 如果 `sum == target`，则将 path 中的元素加入到 res 数组中。
- 然后对 `[start_index, n]` 范围内的数进行遍历取值。
  - 如果 `sum + candidates[i] > target`，可以直接跳出循环。
  - 将和累积，即 `sum += candidates[i]`，然后将当前元素 i 加入 path 数组。
  - 递归遍历 `[start_index, n]` 上的数。
  - 加之前的和回退，即 `sum -= candidates[i]`，然后将遍历的 i 元素进行回退。
- 最终返回 res 数组。

根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：一个组合每个位置上的元素都可以从剩余可选元素中选出。

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - `backtrack(total, start_index):` 函数的传入参数是 `total`（当前和）、`start_index`（剩余可选元素开始位置），全局变量是 `res`（存放所有符合条件结果的集合数组）和 `path`（存放当前符合条件的结果）。
        - `backtrack(total, start_index):` 函数代表的含义是：当前组合和为 `total`，递归从 `candidates` 的 `start_index` 位置开始，选择剩下的元素。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑元素，到数组结束为止，枚举出所有可选的元素。对于每一个可选元素：
        - 约束条件：之前已经选择的元素不再重复选用，只能从剩余元素中选择。
        - 选择元素：将其添加到当前数组 `path` 中。
        - 递归搜索：在选择该元素的情况下，继续递归选择剩下元素。
        - 撤销选择：将该元素从当前结果数组 `path` 中移除。

    ```python
   for i in range(start_index, len(candidates)):
       if total + candidates[i] > target:
           break
   
       total += candidates[i]
       path.append(candidates[i])
       backtrack(total, i)
       total -= candidates[i]
       path.pop()
    ```
   
   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当不可能再出现解（`total > target`），或者遍历到决策树的叶子节点时（`total == target`）时，就终止了。
      - 当遍历到决策树的叶子节点时（`total == target`）时，将当前结果的数组 `path` 放入答案数组 `res` 中，递归停止。

### 思路 1：代码

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(total, start_index):
            if total > target:
                return
            
            if total == target:
                res.append(path[:])
                return
            
            for i in range(start_index, len(candidates)):
                if total + candidates[i] > target:
                    break
                
                total += candidates[i]
                path.append(candidates[i])
                backtrack(total, i)
                total -= candidates[i]
                path.pop()
        candidates.sort()
        backtrack(0, 0)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n \times n)$，其中 $n$ 是数组 `candidates` 的元素个数，$2^n$ 指的是所有状态数。
- **空间复杂度**：$O(target)$，递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $O(target)$，所以空间复杂度为 $O(target)$。

# [0040. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [0040. 组合总和 II - 力扣](https://leetcode.cn/problems/combination-sum-ii/)

## 题目大意

**描述**：给定一个数组 `candidates` 和一个目标数 `target`。

**要求**：找出 `candidates` 中所有可以使数字和为目标数 `target` 的组合。

**说明**：

- 数组 `candidates` 中的数字在每个组合中只能使用一次。
- $1 \le candidates.length \le 100$。
- $1 \le candidates[i] \le 50$。

**示例**：

- 示例 1：

```python
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

- 示例 2：

```python
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

## 解题思路

### 思路 1：回溯算法

跟「[0039. 组合总和](https://leetcode.cn/problems/combination-sum/)」不一样的地方在于本题不能有重复组合，所以关键步骤在于去重。

在回溯遍历的时候，下一层递归的 `start_index` 要从当前节点的后一位开始遍历，即 `i + 1` 位开始。而且统一递归层不能使用相同的元素，即需要增加一句判断 `if i > start_index and candidates[i] == candidates[i - 1]: continue`。

### 思路 1：代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, candidates: List[int], target: int, sum: int, start_index: int):
        if sum > target:
            return
        if sum == target:
            self.res.append(self.path[:])
            return

        for i in range(start_index, len(candidates)):
            if sum + candidates[i] > target:
                break
            if i > start_index and candidates[i] == candidates[i - 1]:
                continue
            sum += candidates[i]
            self.path.append(candidates[i])
            self.backtrack(candidates, target, sum, i + 1)
            sum -= candidates[i]
            self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        candidates.sort()
        self.backtrack(candidates, target, 0, 0)
        return self.res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n \times n)$，其中 $n$ 是数组 `candidates` 的元素个数，$2^n$ 指的是所有状态数。
- **空间复杂度**：$O(target)$，递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $O(target)$，所以空间复杂度为 $O(target)$。

# [0041. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

- 标签：数组、哈希表
- 难度：困难

## 题目链接

- [0041. 缺失的第一个正数 - 力扣](https://leetcode.cn/problems/first-missing-positive/)

## 题目大意

**描述**：给定一个未排序的整数数组 `nums`。

**要求**：找出其中没有出现的最小的正整数。

**说明**：

- $1 \le nums.length \le 5 * 10^5$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- 要求实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,0]
输出：3
```

- 示例 2：

```python
输入：nums = [3,4,-1,1]
输出：2
```

## 解题思路

### 思路 1：哈希表、原地哈希

如果使用普通的哈希表，我们只需要遍历一遍数组，将对应整数存入到哈希表中，再从 `1` 开始，依次判断对应正数是否在哈希表中即可。但是这种做法的空间复杂度为 $O(n)$，不满足常数级别的额外空间要求。

我们可以将当前数组视为哈希表。一个长度为 `n` 的数组，对应存储的元素值应该为 `[1, n + 1]` 之间，其中还包含一个缺失的元素。

1. 我们可以遍历一遍数组，将当前元素放到其对应位置上（比如元素值为 `1` 的元素放到数组第 `0` 个位置上、元素值为 `2` 的元素放到数组第 `1` 个位置上，等等）。
2. 然后再次遍历一遍数组。遇到第一个元素值不等于下标 + 1 的元素，就是答案要求的缺失的第一个正数。
3. 如果遍历完没有在数组中找到缺失的第一个正数，则缺失的第一个正数是 `n + 1`。
4. 最后返回我们找到的缺失的第一个正数。

### 思路 1：代码

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        size = len(nums)

        for i in range(size):
            while 1 <= nums[i] <= size and nums[i] != nums[nums[i] - 1]:
                index1 = i
                index2 = nums[i] - 1
                nums[index1], nums[index2] = nums[index2], nums[index1]

        for i in range(size):
            if nums[i] != i + 1:
                return i + 1
        return size + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 `nums` 的元素个数。
- **空间复杂度**：$O(1)$。
# [0042. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

- 标签：栈、数组、双指针、动态规划、单调栈
- 难度：困难

## 题目链接

- [0042. 接雨水 - 力扣](https://leetcode.cn/problems/trapping-rain-water/)

## 题目大意

**描述**：给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，用数组 `height` 表示，其中 `height[i]` 表示第 `i` 根柱子的高度。

**要求**：计算按此排列的柱子，下雨之后能接多少雨水。

**说明**：

- $n == height.length$。
- $1 \le n \le 2 * 10^4$。
- $0 \le height[i] \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```python
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

- 示例 2：

```python
输入：height = [4,2,0,3,2,5]
输出：9
```

## 解题思路

### 思路 1：单调栈

1. 遍历高度数组 `height`。
2. 如果当前柱体高度较小，小于等于栈顶柱体的高度，则将当前柱子高度入栈。
3. 如果当前柱体高度较大，大于栈顶柱体的高度，则一直出栈，直到当前柱体小于等于栈顶柱体的高度。
4. 假设当前柱体为 `C`，出栈柱体为 `B`，出栈之后新的栈顶柱体为 `A`。则说明：
   1. 当前柱体 `C` 是出栈柱体 `B` 向右找到的第一个大于当前柱体高度的柱体，那么以出栈柱体 `B`  为中心，可以向右将宽度扩展到当前柱体 `C`。
   2. 新的栈顶柱体 `A` 是出栈柱体 `B` 向左找到的第一个大于当前柱体高度的柱体，那么以出栈柱体 `B` 为中心，可以向左将宽度扩展到当前柱体 `A`。
5. 出栈后，以新的栈顶柱体 `A` 为左边界，以当前柱体 `C` 为右边界，以左右边界与出栈柱体 `B` 的高度差为深度，计算可以接到雨水的面积。然后记录并更新累积面积。

### 思路 1：代码

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = []
        size = len(height)
        for i in range(size):
            while stack and height[i] > height[stack[-1]]:
                cur = stack.pop(-1)
                if stack:
                    left = stack[-1] + 1
                    right = i - 1
                    high = min(height[i], height[stack[-1]]) - height[cur]
                    ans += high * (right - left + 1)
                else:
                    break
            stack.append(i)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `height` 的长度。
- **空间复杂度**：$O(n)$。# [0043. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

- 标签：数学、字符串、模拟
- 难度：中等

## 题目链接

- [0043. 字符串相乘 - 力扣](https://leetcode.cn/problems/multiply-strings/)

## 题目大意

**描述**：给定两个以字符串形式表示的非负整数 `num1` 和 `num2`。

**要求**：返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**说明**：

- 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。
- $1 \le num1.length, num2.length \le 200$。
- `num1` 和 `num2` 只能由数字组成。
- `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。

**示例**：

- 示例 1：

```python
输入: num1 = "2", num2 = "3"
输出: "6"
```

- 示例 2：

```python
输入: num1 = "123", num2 = "456"
输出: "56088"
```

## 解题思路

### 思路 1：模拟

我们可以使用数组来模拟大数乘法。长度为 `len(num1)` 的整数 `num1` 与长度为 `len(num2)` 的整数 `num2` 相乘的结果长度为 `len(num1) + len(num2) - 1` 或 `len(num1) + len(num2)`。所以我们可以使用长度为 `len(num1) + len(num2)` 的整数数组 `nums` 来存储两个整数相乘之后的结果。

整个计算流程的步骤如下：

1. 从个位数字由低位到高位开始遍历 `num1`，取得每一位数字 `digit1`。从个位数字由低位到高位开始遍历 `num2`，取得每一位数字 `digit2`。
2. 将 `digit1 * digit2` 的结果累积存储到 `nums` 对应位置 `i + j + 1` 上。
3. 计算完毕之后从 `len(num1) + len(num2) - 1` 的位置由低位到高位遍历数组 `nums`。将每个数位上大于等于 `10` 的数字进行进位操作，然后对该位置上的数字进行取余操作。
4. 最后判断首位是否有进位。如果首位为 `0`，则从第 `1` 个位置开始将答案数组拼接成字符串。如果首位不为 `0`，则从第 `0` 个位置开始将答案数组拼接成字符串。并返回答案字符串。

### 思路 1：代码

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"

        len1, len2 = len(num1), len(num2)
        nums = [0 for _ in range(len1 + len2)]

        for i in range(len1 - 1, -1, -1):
            digit1 = int(num1[i])
            for j in range(len2 - 1, -1, -1):
                digit2 = int(num2[j])
                nums[i + j + 1] += digit1 * digit2

        for i in range(len1 + len2 - 1, 0, -1):
            nums[i - 1] += nums[i] // 10
            nums[i] %= 10

        if nums[0] == 0:
            ans = "".join(str(digit) for digit in nums[1:])
        else:
            ans = "".join(str(digit) for digit in nums[:])
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$ 和 $n$ 分别为 `nums1` 和 `nums2` 的长度。
- **空间复杂度**：$O(m + n)$。

# [0044. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

- 标签：贪心、递归、字符串、动态规划
- 难度：困难

## 题目链接

- [0044. 通配符匹配 - 力扣](https://leetcode.cn/problems/wildcard-matching/)

## 题目大意

**描述**：给定一个字符串 `s` 和一个字符模式串 `p`。

**要求**：实现一个支持 `'?'` 和 `'*'` 的通配符匹配。两个字符串完全匹配才算匹配成功。如果匹配成功，则返回 `True`，否则返回 `False`。

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符串（包括空字符串）。

**说明**：

- `s` 可能为空，且只包含从 `a` ~ `z` 的小写字母。
- `p` 可能为空，且只包含从 `a` ~ `z` 的小写字母，以及字符 `'?'` 和 `'*'`。

**示例**：

- 示例 1：

```python
输入：s = "aa"  p = "a"
输出：False
解释："a" 无法匹配 "aa" 整个字符串。
```

- 示例 2：

```python
输入：s = "aa"  p = "*"
输出：True
解释：'*' 可以匹配任意字符串。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照两个字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配。

###### 3. 状态转移方程

- 如果 `s[i - 1] == p[j - 1]`，或者 `p[j - 1] == '?'`，则表示字符串 `s` 的第 `i` 个字符与字符串 `p` 的第 `j` 个字符是匹配的。此时「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i - 1` 个字符与字符串 `p` 的前 `j - 1` 个字符是否匹配」。即 `dp[i][j] = dp[i - 1][j - 1] `。
- 如果 `p[j - 1] == '*'`，则字符串 `p` 的第 `j` 个字符可以对应字符串 `s` 中 `0` ~ 若干个字符。则：
  - 如果当前星号没有匹配当前第 `i` 个字符，则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i - 1` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」，即 `dp[i][j] = dp[i - 1][j]`。
  - 如果当前星号匹配了当前第 `i` 个字符，则「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配」取决于「字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j - 1` 个字符是否匹配」，即 `dp[i][j] = dp[i][j - 1]`。
  - 这两种情况只需匹配一种，就视为匹配，所以 `dp[i][j] = dp[i - 1][j] or dp[i][j - 1] `。

则动态转移方程为：

$dp[i][j] = \begin{cases} dp[i - 1][j - 1] & s[i - 1] == p[j - 1] \or p[j - 1] == '?' \cr dp[i - 1][j] or dp[i][j - 1] & p[j - 1] == '*' \end{cases}$

###### 4. 初始条件

- 默认状态下，两个空字符串是匹配的，即 `dp[0][0] = True`。
- 当字符串 `s` 为空，字符串 `p` 开始字符为若干个 `*` 时，两个字符串是匹配的，即 `p[j - 1] == '*'` 时，`dp[0][j] = True`。

###### 5. 最终结果

根据我们之前定义的状态， `dp[i][j]` 表示为：字符串 `s` 的前 `i` 个字符与字符串 `p` 的前 `j` 个字符是否匹配。则最终结果为 `dp[size_s][size_p]`，其实 `size_s` 是字符串 `s` 的长度，`size_p` 是字符串 `p` 的长度。

### 思路 1：动态规划代码

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        size_s, size_p = len(s), len(p)
        dp = [[False for _ in range(size_p + 1)] for _ in range(size_s + 1)]
        dp[0][0] = True

        for j in range(1, size_p + 1):
            if p[j - 1] != '*':
                break
            dp[0][j] = True

        for i in range(1, size_s + 1):
            for j in range(1, size_p + 1):
                if s[i - 1] == p[j - 1] or p[j - 1] == '?':
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]

        return dp[size_s][size_p]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m n)$，其中 $m$ 是字符串 `s` 的长度，$n$ 是字符串 `p` 的长度。使用了两重循环，外层循环遍历的时间复杂度是 $O(m)$，内层循环遍历的时间复杂度是 $O(n)$，所以总体的时间复杂度为 $O(m n)$。
- **空间复杂度**：$O(m n)$，其中 $m$ 是字符串 `s` 的长度，$n$ 是字符串 `p` 的长度。使用了二维数组保存状态，且第一维的空间复杂度为 $O(m)$，第二位的空间复杂度为 $O(n)$，所以总体的空间复杂度为 $O(m n)$。
# [0045. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [0045. 跳跃游戏 II - 力扣](https://leetcode.cn/problems/jump-game-ii/)

## 题目大意

**描述**：给定一个非负整数数组 `nums`，数组中每个元素代表在该位置可以跳跃的最大长度。开始位置为数组的第一个下标处。

**要求**：计算出到达最后一个下标处的最少的跳跃次数。假设你总能到达数组的最后一个下标处。

**说明**：

- $1 \le nums.length \le 10^4$。
- $0 \le nums[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [2,3,1,1,4]
输出：2
解释：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

## 解题思路

### 思路 1：动态规划（超时）

###### 1. 划分阶段

按照位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：跳到下标 `i` 所需要的最小跳跃次数。

###### 3. 状态转移方程

对于当前位置 `i`，如果之前的位置 `j`（$o \le j < i$） 能够跳到位置 `i` 需要满足：位置 `j`（$o \le j < i$）加上位置 `j` 所能跳到的最远长度要大于等于 `i`，即 `j + nums[j] >= i` 。

而跳到下标 `i` 所需要的最小跳跃次数则等于满足上述要求的位置 `j` 中最小跳跃次数加 `1`，即 `dp[i] = min(dp[i], dp[j] + 1)`。

###### 4. 初始条件

初始状态下，跳到下标 `0`  需要的最小跳跃次数为 `0`，即 `dp[0] = 0`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：跳到下标 `i` 所需要的最小跳跃次数。则最终结果为 `dp[size - 1]`。

### 思路 1：动态规划（超时）代码

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [float("inf") for _ in range(size)]
        dp[0] = 0

        for i in range(1, size):
            for j in range(i):
                if j + nums[j] >= i:
                    dp[i] = min(dp[i], dp[j] + 1)

        return dp[size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，所以总体时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

### 思路 2：动态规划 + 贪心

因为本题的数据规模为 $10^4$，而思路 1 的时间复杂度是 $O(n^2)$，所以就超时了。那么我们有什么方法可以优化一下，减少一下时间复杂度吗？

上文提到，在满足 `j + nums[j] >= i` 的情况下，`dp[i] = min(dp[i], dp[j] + 1)`。

通过观察可以发现，`dp[i]` 是单调递增的，也就是说 `dp[i - 1] <= dp[i] <= dp[i + 1]`。

举个例子，比如跳到下标 `i` 最少需要 `5` 步，即 `dp[i] = 5`，那么必然不可能出现少于 `5` 步就能跳到下标 `i + 1` 的情况，跳到下标 `i + 1` 至少需要 `5` 步或者更多步。

既然 `dp[i]` 是单调递增的，那么在更新 `dp[i]` 时，我们找到最早可以跳到 `i` 的点 `j`，从该点更新 `dp[i]`。即找到满足 `j + nums[j] >= i` 的第一个 `j`，使得 `dp[i] = dp[j] + 1`。

而查找第一个 `j` 的过程可以通过使用一个指针变量 `j` 从前向后迭代查找。

最后，将最终结果 `dp[size - 1]` 返回即可。

### 思路 2：动态规划 + 贪心代码

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [float("inf") for _ in range(size)]
        dp[0] = 0

        j = 0
        for i in range(1, size):
            while j + nums[j] < i:
                j += 1
            dp[i] = dp[j] + 1

        return dp[size - 1]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。最外层循环遍历的时间复杂度是 $O(n)$，看似和内层循环结合遍历的时间复杂度是 $O(n^2)$，实际上内层循环只遍历了一遍，与外层循环遍历次数是相加关系，两者的时间复杂度和是 $O(2n)$，$O(2n) = O(n)$，所以总体时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

### 思路 2：贪心算法

如果第 `i` 个位置所能跳到的位置为  `[i + 1, i + nums[i]]`，则：

- 第 `0` 个位置所能跳到的位置就是 `[0 + 1, 0 + nums[0]]`，即 `[1, nums[0]]`。
- 第 `1` 个位置所能跳到的位置就是 `[1 + 1, 1 + nums[1]]`，即 `[2, 1 + nums[1]]`。
- ……

对于每一个位置 `i` 来说，所能跳到的所有位置都可以作为下一个起跳点，为了尽可能使用最少的跳跃次数，所以我们应该使得下一次起跳所能达到的位置尽可能的远。简单来说，就是每次在「可跳范围」内选择可以使下一次跳的更远的位置。这样才能获得最少跳跃次数。具体做法如下：

1. 维护几个变量：当前所能达到的最远位置 `end`，下一步所能跳到的最远位置 `max_pos`，最少跳跃次数 `setps`。
2. 遍历数组 `nums` 的前 `len(nums) - 1` 个元素：
  1. 每次更新第 `i` 位置下一步所能跳到的最远位置 `max_pos`。
  2. 如果索引 `i` 到达了 `end` 边界，则：更新 `end` 为新的当前位置 `max_pos`，并令步数 `setps` 加 `1`。
3. 最终返回跳跃次数 `steps`。

### 思路 2：贪心算法代码

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        end, max_pos = 0, 0
        steps = 0
        for i in range(len(nums) - 1):
            max_pos = max(max_pos, nums[i] + i)
            if i == end:
                end = max_pos
                steps += 1
        return steps
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n)$。
- **空间复杂度**：$O(1)$。只用到了常数项的变量，所以总体空间复杂度为 $O(1)$。

## 参考资料

- 【题解】[【宫水三叶の相信科学系列】详解「DP + 贪心 + 双指针」解法，以及该如何猜 DP 的状态定义 - 跳跃游戏 II - 力扣](https://leetcode.cn/problems/jump-game-ii/solution/xiang-jie-dp-tan-xin-shuang-zhi-zhen-jie-roh4/)
- 【题解】[动态规划+贪心，易懂。 - 跳跃游戏 II - 力扣](https://leetcode.cn/problems/jump-game-ii/solution/dong-tai-gui-hua-tan-xin-yi-dong-by-optimjie/)
# [0046. 全排列](https://leetcode.cn/problems/permutations/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [0046. 全排列 - 力扣](https://leetcode.cn/problems/permutations/)

## 题目大意

**描述**：给定一个不含重复数字的数组 `nums`。

**要求**：返回其有可能的全排列。

**说明**：

- $1 \le nums.length \le 6$
- $-10 \le nums[i] \le 10$。
- `nums` 中的所有整数互不相同。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

- 示例 2：

```python
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

## 解题思路

### 思路 1：回溯算法

根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：全排列中每个位置上的元素都可以从剩余可选元素中选出，对此画出决策树，如下图所示。

   - ![](https://qcdn.itcharge.cn/images/20220425102048.png)

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - `backtracking(nums):` 函数的传入参数是 `nums`（可选数组列表），全局变量是 `res`（存放所有符合条件结果的集合数组）和 `path`（存放当前符合条件的结果）。
      - `backtracking(nums):` 函数代表的含义是：递归在 `nums` 中选择剩下的元素。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑元素，到数组结束为止，枚举出所有可选的元素。对于每一个可选元素：
        - 约束条件：之前已经选择的元素不再重复选用，只能从剩余元素中选择。
        - 选择元素：将其添加到当前子集数组 `path` 中。
        - 递归搜索：在选择该元素的情况下，继续递归选择剩下元素。
        - 撤销选择：将该元素从当前结果数组 `path` 中移除。

    ```python
   for i in range(len(nums)):          # 枚举可选元素列表
       if nums[i] not in path:         # 从当前路径中没有出现的数字中选择
           path.append(nums[i])        # 选择元素
           backtracking(nums)          # 递归搜索
           path.pop()                  # 撤销选择
    ```

   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是存放当前结果的数组 `path` 的长度等于给定数组 `nums` 的长度（即 `len(path) == len(nums)`）时，递归停止。

### 思路 1：代码

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []    # 存放所有符合条件结果的集合
        path = []   # 存放当前符合条件的结果
        def backtracking(nums):             # nums 为选择元素列表
            if len(path) == len(nums):      # 说明找到了一组符合条件的结果
                res.append(path[:])         # 将当前符合条件的结果放入集合中
                return

            for i in range(len(nums)):      # 枚举可选元素列表
                if nums[i] not in path:     # 从当前路径中没有出现的数字中选择
                    path.append(nums[i])    # 选择元素
                    backtracking(nums)      # 递归搜索
                    path.pop()              # 撤销选择

        backtracking(nums)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times n!)$，其中 $n$ 为数组 `nums` 的元素个数。
- **空间复杂度**：$O(n)$。
# [0047. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [0047. 全排列 II - 力扣](https://leetcode.cn/problems/permutations-ii/)

## 题目大意

**描述**：给定一个可包含重复数字的序列 `nums`。

**要求**：按任意顺序返回所有不重复的全排列。

**说明**：

- $1 \le nums.length \le 8$。
- $-10 \le nums[i] \le 10$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,2]
输出：[[1,1,2],[1,2,1],[2,1,1]]
```

- 示例 2：

```python
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

## 解题思路

### 思路 1：回溯算法

这道题跟「[0046. 全排列](https://leetcode.cn/problems/permutations/)」不一样的地方在于增加了序列中的元素可重复这一条件。这就涉及到了如何去重。

我们可以先对数组 `nums` 进行排序，然后使用一个数组 `visited` 标记该元素在当前排列中是否被访问过。

如果未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。

然后再递归遍历下一层元素之前，增加一句语句进行判重：`if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue`。

然后再进行回溯遍历。

### 思路 1：代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, nums: List[int], visited: List[bool]):
        if len(self.path) == len(nums):
            self.res.append(self.path[:])
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:
                continue

            if not visited[i]:
                visited[i] = True
                self.path.append(nums[i])
                self.backtrack(nums, visited)
                self.path.pop()
                visited[i] = False

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        nums.sort()
        visited = [False for _ in range(len(nums))]
        self.backtrack(nums, visited)
        return self.res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times n!)$，其中 $n$ 为数组 `nums` 的元素个数。
- **空间复杂度**：$O(n)$。

# [0048. 旋转图像](https://leetcode.cn/problems/rotate-image/)

- 标签：数组、数学、矩阵
- 难度：中等

## 题目链接

- [0048. 旋转图像 - 力扣](https://leetcode.cn/problems/rotate-image/)

## 题目大意

**描述**：给定一个 $n \times n$ 大小的二维矩阵（代表图像）$matrix$。

**要求**：将二维矩阵 $matrix$ 顺时针旋转 90°。

**说明**：

- 不能使用额外的数组空间。
- $n == matrix.length == matrix[i].length$。
- $1 \le n \le 20$。
- $-1000 \le matrix[i][j] \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```python
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```python
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

## 解题思路

### 思路 1：原地旋转

如果使用额外数组空间的话，将对应元素存放到对应位置即可。如果不使用额外的数组空间，则需要观察每一个位置上的点最初位置和最终位置有什么规律。

对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i$ 列的第 $j$ 个位置。即 $matrixnew[j][n − i − 1] = matrix[i][j]$。

而  $matrixnew[j][n - i - 1]$  的点经过旋转移动到了 $matrix[n − i − 1][n − j − 1]$ 的位置。

$matrix[n − i − 1][n − j − 1]$ 位置上的点经过旋转移动到了 $matrix[n − j − 1][i]$  的位置。

$matrix[n− j − 1][i]$  位置上的点经过旋转移动到了最初的 $matrix[i][j]$ 的位置。

这样就形成了一个循环，我们只需要通过一个临时变量 $temp$ 就可以将循环中的元素逐一进行交换。Python 中则可以直接使用语法直接交换。

### 思路 1：代码

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)

        for i in range(n // 2):
            for j in range((n + 1) // 2):
                matrix[i][j], matrix[n - j - 1][i], matrix[n - i - 1][n - j - 1], matrix[j][n - i - 1] = matrix[n - j - 1][i], matrix[n - i - 1][n - j - 1], matrix[j][n - i - 1], matrix[i][j]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：原地翻转

通过观察可以得出：原矩阵可以通过一次「水平翻转」+「主对角线翻转」得到旋转后的二维矩阵。

### 思路 2：代码

```python
def rotate(self, matrix: List[List[int]]) -> None:
    n = len(matrix)
    
    for i in range(n // 2):
        for j in range(n):
            matrix[i][j], matrix[n - i - 1][j] = matrix[n - i - 1][j], matrix[i][j]
    
    for i in range(n):
        for j in range(i):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

# [0049. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

- 标签：数组、哈希表、字符串、排序
- 难度：中等

## 题目链接

- [0049. 字母异位词分组 - 力扣](https://leetcode.cn/problems/group-anagrams/)

## 题目大意

给定一个字符串数组，将包含字母相同的字符串组合在一起，不需要考虑输出顺序。

## 解题思路

使用哈希表记录字母相同的字符串。对每一个字符串进行排序，按照 排序字符串：字母相同的字符串数组 的键值顺序进行存储。

最终将哈希表的值转换为对应数组返回结果。

## 代码

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        str_dict = dict()
        res = []
        for s in strs:
            sort_s = str(sorted(s))
            if sort_s in str_dict:
                str_dict[sort_s] += [s]
            else:
                str_dict[sort_s] = [s]

        for sort_s in str_dict:
            res += [str_dict[sort_s]]
        return res
```

# [0050. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

- 标签：递归、数学
- 难度：中等

## 题目链接

- [0050. Pow(x, n) - 力扣](https://leetcode.cn/problems/powx-n/)

## 题目大意

**描述**：给定浮点数 $x$ 和整数 $n$。

**要求**：计算 $x$ 的 $n$ 次方（即 $x^n$）。

**说明**：

- $-100.0 < x < 100.0$。
- $-2^{31} \le n \le 2^{31} - 1$。
- $n$ 是一个整数。
- $-10^4 \le x^n \le 10^4$。

**示例**：

- 示例 1：

```python
输入：x = 2.00000, n = 10
输出：1024.00000
```

- 示例 2：

```python
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

## 解题思路

### 思路 1：分治算法

常规方法是直接将 $x$ 累乘 $n$ 次得出结果，时间复杂度为 $O(n)$。

我们可以利用分治算法来减少时间复杂度。

根据 $n$ 的奇偶性，我们可以得到以下结论：

1. 如果 $n$ 为偶数，$x^n = x^{n / 2} \times x^{n / 2}$。
2. 如果 $n$ 为奇数，$x^n = x \times x^{(n - 1) / 2} \times x^{(n - 1) / 2}$。

$x^{(n / 2)}$ 或 $x^{(n - 1) / 2}$ 又可以继续向下递归划分。

则我们可以利用低纬度的幂计算结果，来得到高纬度的幂计算结果。

这样递归求解，时间复杂度为 $O(\log n)$，并且递归也可以转为递推来做。

需要注意如果 $n$ 为负数，可以转换为 $\frac{1}{x} ^{(-n)}$。

### 思路 1：代码

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0.0:
            return 0.0
        res = 1
        if n < 0:
            x = 1/x
            n = -n
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0051. N 皇后](https://leetcode.cn/problems/n-queens/)

- 标签：数组、回溯
- 难度：困难

## 题目链接

- [0051. N 皇后 - 力扣](https://leetcode.cn/problems/n-queens/)

## 题目大意

**描述**：给定一个整数 `n`。

**要求**：返回所有不同的「`n` 皇后问题」的解决方案。每一种解法包含一个不同的「`n` 皇后问题」的棋子放置方案，该方案中的 `Q` 和 `.` 分别代表了皇后和空位。

**说明**：

- **n 皇后问题**：将 `n` 个皇后放置在 `n * n` 的棋盘上，并且使得皇后彼此之间不能攻击。
- **皇后彼此不能相互攻击**：指的是任何两个皇后都不能处于同一条横线、纵线或者斜线上。
- $1 \le n \le 9$。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如下图所示，4 皇后问题存在 2 个不同的解法。
```

![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

## 解题思路

### 思路 1：回溯算法

这道题是经典的回溯问题。我们可以按照行序来放置皇后，也就是先放第一行，再放第二行 …… 一直放到最后一行。

对于 `n * n` 的棋盘来说，每一行有 `n`  列，也就有 `n` 种放法可供选择。我们可以尝试选择其中一列，查看是否与之前放置的皇后有冲突，如果没有冲突，则继续在下一行放置皇后。依次类推，直到放置完所有皇后，并且都不发生冲突时，就得到了一个合理的解。

并且在放置完之后，通过回溯的方式尝试其他可能的分支。

下面我们根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：根据棋盘中当前行的所有列位置上是否选择放置皇后，画出决策树，如下图所示。

   - ![](https://qcdn.itcharge.cn/images/20220426095225.png)

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。也就是在最后一行放置完皇后时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - 首先我们先使用一个 `n * n` 大小的二维矩阵 `chessboard` 来表示当前棋盘，`chessboard` 中的字符 `Q` 代表皇后，`.` 代表空位，初始都为 `.`。
      - 然后定义回溯函数 `backtrack(chessboard, row): ` 函数的传入参数是 `chessboard`（棋盘数组）和 `row`（代表当前正在考虑放置第 `row` 行皇后），全局变量是 `res`（存放所有符合条件结果的集合数组）。
      - `backtrack(chessboard, row):` 函数代表的含义是：在放置好第 `row` 行皇后的情况下，递归放置剩下行的皇后。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 枚举出当前行所有的列。对于每一列位置：
        - 约束条件：定义一个判断方法，先判断一下当前位置是否与之前棋盘上放置的皇后发生冲突，如果不发生冲突则继续放置，否则则继续向后遍历判断。
        - 选择元素：选择 `row, col` 位置放置皇后，将其棋盘对应位置设置为 `Q`。
        - 递归搜索：在该位置放置皇后的情况下，继续递归考虑下一行。
        - 撤销选择：将棋盘上 `row, col` 位置设置为 `.`。

   ```python
   # 判断当前位置 row, col 是否与之前放置的皇后发生冲突
   def isValid(self, n: int, row: int, col: int, chessboard: List[List[str]]):
       for i in range(row):
           if chessboard[i][col] == 'Q':
               return False
   
       i, j = row - 1, col - 1
       while i >= 0 and j >= 0:
           if chessboard[i][j] == 'Q':
               return False
           i -= 1
           j -= 1
       i, j = row - 1, col + 1
       while i >= 0 and j < n:
           if chessboard[i][j] == 'Q':
               return False
           i -= 1
           j += 1
   
       return True
   ```

    ```python
   for col in range(n):                            # 枚举可放置皇后的列
       if self.isValid(n, row, col, chessboard):   # 如果该位置与之前放置的皇后不发生冲突
           chessboard[row][col] = 'Q'              # 选择 row, col 位置放置皇后
           backtrack(row + 1, chessboard)          # 递归放置 row + 1 行之后的皇后
           chessboard[row][col] = '.'              # 撤销选择 row, col 位置
    ```

   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是在最后一行放置完皇后（即 `row == n`）时，递归停止。
      - 递归停止时，将当前符合条件的棋盘转换为答案需要的形式，然后将其存入答案数组 `res` 中即可。

### 思路 1：代码

```python
class Solution:
    res = []
    def backtrack(self, n: int, row: int, chessboard: List[List[str]]):
        if row == n:
            temp_res = []
            for temp in chessboard:
                temp_str = ''.join(temp)
                temp_res.append(temp_str)
            self.res.append(temp_res)
            return
        for col in range(n):
            if self.isValid(n, row, col, chessboard):
                chessboard[row][col] = 'Q'
                self.backtrack(n, row + 1, chessboard)
                chessboard[row][col] = '.'

    def isValid(self, n: int, row: int, col: int, chessboard: List[List[str]]):
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False

        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j += 1

        return True

    def solveNQueens(self, n: int) -> List[List[str]]:
        self.res.clear()
        chessboard = [['.' for _ in range(n)] for _ in range(n)]
        self.backtrack(n, 0, chessboard)
        return self.res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n!)$，其中 $n$ 是皇后数量。
- **空间复杂度**：$O(n^2)$，其中 $n$ 是皇后数量。递归调用层数不会超过 $n$，每个棋盘的空间复杂度为 $O(n^2)$，所以空间复杂度为 $O(n^2)$。
# [0052. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

- 标签：回溯
- 难度：困难

## 题目链接

- [0052. N 皇后 II - 力扣](https://leetcode.cn/problems/n-queens-ii/)

## 题目大意

**描述**：给定一个整数 `n`。

**要求**：返回「`n` 皇后问题」不同解决方案的数量。

**说明**：

- **n 皇后问题**：将 `n` 个皇后放置在 `n * n` 的棋盘上，并且使得皇后彼此之间不能攻击。
- **皇后彼此不能相互攻击**：指的是任何两个皇后都不能处于同一条横线、纵线或者斜线上。
- $1 \le n \le 9$。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：2
解释：如下图所示，4 皇后问题存在两个不同的解法。
```

![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

## 解题思路

### 思路 1：回溯算法

和「[51. N 皇后 - 力扣](https://leetcode.cn/problems/n-queens/)」做法一致。区别在于「[51. N 皇后 - 力扣](https://leetcode.cn/problems/n-queens/)」需要返回所有解决方案，而这道题只需要得到所有解决方案的数量即可。下面来说一下这道题的解题思路。

我们可以按照行序来放置皇后，也就是先放第一行，再放第二行 …… 一直放到最后一行。

对于 `n * n` 的棋盘来说，每一行有 `n`  列，也就有 `n` 种放法可供选择。我们可以尝试选择其中一列，查看是否与之前放置的皇后有冲突，如果没有冲突，则继续在下一行放置皇后。依次类推，直到放置完所有皇后，并且都不发生冲突时，就得到了一个合理的解。

并且在放置完之后，通过回溯的方式尝试其他可能的分支。

下面我们根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：根据棋盘中当前行的所有列位置上是否选择放置皇后，画出决策树，如下图所示。

   - ![](https://qcdn.itcharge.cn/images/20220426095225.png)

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。也就是在最后一行放置完皇后时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - 首先我们先使用一个 `n * n` 大小的二维矩阵 `chessboard` 来表示当前棋盘，`chessboard` 中的字符 `Q` 代表皇后，`.` 代表空位，初始都为 `.`。
      - 然后定义回溯函数 `backtrack(chessboard, row): ` 函数的传入参数是 `chessboard`（棋盘数组）和 `row`（代表当前正在考虑放置第 `row` 行皇后），全局变量是 `ans`（所有可行方案的数量）。
      - `backtrack(chessboard, row):` 函数代表的含义是：在放置好第 `row` 行皇后的情况下，递归放置剩下行的皇后。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 枚举出当前行所有的列。对于每一列位置：
        - 约束条件：定义一个判断方法，先判断一下当前位置是否与之前棋盘上放置的皇后发生冲突，如果不发生冲突则继续放置，否则则继续向后遍历判断。
        - 选择元素：选择 `row, col` 位置放置皇后，将其棋盘对应位置设置为 `Q`。
        - 递归搜索：在该位置放置皇后的情况下，继续递归考虑下一行。
        - 撤销选择：将棋盘上 `row, col` 位置设置为 `.`。

### 思路 1：代码

```python
class Solution:
    # 判断当前位置 row, col 是否与之前放置的皇后发生冲突
    def isValid(self, n: int, row: int, col: int, chessboard: List[List[str]]):
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False

        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j += 1

        return True

    def totalNQueens(self, n: int) -> int:
        chessboard = [['.' for _ in range(n)] for _ in range(n)]    # 棋盘初始化
        
        ans = 0
        def backtrack(chessboard: List[List[str]], row: int):                     # 正在考虑放置第 row 行的皇后
            if row == n:                                    # 遇到终止条件
                nonlocal ans
                ans += 1
                return

            for col in range(n):                            # 枚举可放置皇后的列
                if self.isValid(n, row, col, chessboard):   # 如果该位置与之前放置的皇后不发生冲突
                    chessboard[row][col] = 'Q'              # 选择 row, col 位置放置皇后
                    backtrack(chessboard, row + 1)          # 递归放置 row + 1 行之后的皇后
                    chessboard[row][col] = '.'              # 撤销选择 row, col 位置

        backtrack(chessboard, 0)

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n!)$，其中 $n$ 是皇后数量。
- **空间复杂度**：$O(n^2)$，其中 $n$ 是皇后数量。递归调用层数不会超过 $n$，每个棋盘的空间复杂度为 $O(n^2)$，所以空间复杂度为 $O(n^2)$。
# [0053. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

- 标签：数组、分治、动态规划
- 难度：中等

## 题目链接

- [0053. 最大子数组和 - 力扣](https://leetcode.cn/problems/maximum-subarray/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**说明**：

- **子数组**：指的是数组中的一个连续部分。
- $1 \le nums.length \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

- 示例 2：

```python
输入：nums = [1]
输出：1
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照连续子数组的结束位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。

###### 3. 状态转移方程

状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则我们可以从「第 $i - 1$ 个数结尾的连续子数组的最大和」，以及「第 $i$ 个数的值」来讨论 $dp[i]$。

- 如果 $dp[i - 1] < 0$，则「第 $i - 1$ 个数结尾的连续子数组的最大和」+「第 $i$  个数的值」<「第 $i$ 个数的值」，即：$dp[i - 1] + nums[i] < nums[i]$。所以，此时 $dp[i]$ 应取「第 $i$ 个数的值」，即 $dp[i] = nums[i]$。
- 如果 $dp[i - 1] \ge 0$，则「第 $i - 1$ 个数结尾的连续子数组的最大和」 +「第 $i$  个数的值」 >= 第 $i$ 个数的值，即：$dp[i - 1] + nums[i] \ge nums[i]$。所以，此时 $dp[i]$  应取「第 $i - 1$ 个数结尾的连续子数组的最大和」+「 第 $i$  个数的值」，即 $dp[i] = dp[i - 1] + nums[i]$。

归纳一下，状态转移方程为：

$dp[i] = \begin{cases} nums[i], &  dp[i - 1] < 0 \cr dp[i - 1] + nums[i] & dp[i - 1] \ge 0 \end{cases}$

###### 4. 初始条件

- 第 $0$ 个数结尾的连续子数组的最大和为 $nums[0]$，即 $dp[0] = nums[0]$。

###### 5. 最终结果

根据状态定义，$dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则最终结果应为所有 $dp[i]$ 的最大值，即 $max(dp)$。

### 思路 1：代码

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [0 for _ in range(size)]

        dp[0] = nums[0]
        for i in range(1, size):
            if dp[i - 1] < 0:
                dp[i] = nums[i]
            else:
                dp[i] = dp[i - 1] + nums[i]
        return max(dp)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。
- **空间复杂度**：$O(n)$。

### 思路 2：动态规划 + 滚动优化

因为 $dp[i]$ 只和 $dp[i - 1]$ 和当前元素 $nums[i]$ 相关，我们也可以使用一个变量 $subMax$ 来表示以第 $i$ 个数结尾的连续子数组的最大和。然后使用 $ansMax$ 来保存全局中最大值。

### 思路 2：代码

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        subMax = nums[0]
        ansMax = nums[0]

        for i in range(1, size):
            if subMax < 0:
                subMax = nums[i]
            else:
                subMax += nums[i]
            ansMax = max(ansMax, subMax)
        return ansMax
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。
- **空间复杂度**：$O(1)$。

### 思路 3：分治算法

我们将数组 $nums$ 根据中心位置分为左右两个子数组。则具有最大和的连续子数组可能存在以下 $3$ 种情况：

1. 具有最大和的连续子数组在左子数组中。
2. 具有最大和的连续子数组在右子数组中。
3. 具有最大和的连续子数组跨过中心位置，一部分在左子数组中，另一部分在右子树组中。

那么我们要求出具有最大和的连续子数组的最大和，则分别对上面 $3$ 种情况求解即可。具体步骤如下：

1. 将数组 $nums$ 根据中心位置递归分为左右两个子数组，直到所有子数组长度为 $1$。
2. 长度为 $1$ 的子数组最大和肯定是数组中唯一的数，将其返回即可。
3. 求出左子数组的最大和 $leftMax$。
4. 求出右子树组的最大和 $rightMax$。
5. 求出跨过中心位置，一部分在左子数组中，另一部分在右子树组的子数组最大和 $leftTotal + rightTotal$。
6. 求出 $3$、$4$、$5$ 中的最大值，即为当前数组的最大和，将其返回即可。

### 思路 3：代码

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def max_sub_array(low, high):
            if low == high:
                return nums[low]

            mid = low + (high - low) // 2
            leftMax = max_sub_array(low, mid)
            rightMax = max_sub_array(mid + 1, high)

            total = 0
            leftTotal = -inf
            for i in range(mid, low - 1, -1):
                total += nums[i]
                leftTotal = max(leftTotal, total)
            
            total = 0
            rightTotal = -inf
            for i in range(mid + 1, high + 1):
                total += nums[i]
                rightTotal = max(rightTotal, total)
            
            return max(leftMax, rightMax, leftTotal + rightTotal)
        
        return max_sub_array(0, len(nums) - 1)
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(\log n)$。# [0054. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

- 标签：数组、矩阵、模拟
- 难度：中等

## 题目链接

- [0054. 螺旋矩阵 - 力扣](https://leetcode.cn/problems/spiral-matrix/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的二维矩阵 $matrix$。

**要求**：按照顺时针旋转的顺序，返回矩阵中的所有元素。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 10$。
- $-100 \le matrix[i][j] \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```python
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```python
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

## 解题思路

### 思路 1：模拟

1. 使用数组 $ans$ 存储答案。然后定义一下上、下、左、右的边界。
2. 然后按照逆时针的顺序从边界上依次访问元素。
3. 当访问完当前边界之后，要更新一下边界位置，缩小范围，方便下一轮进行访问。
4. 最后返回答案数组 $ans$。

### 思路 1：代码

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        up, down, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1
        ans = []
        while True:
            for i in range(left, right + 1):
                ans.append(matrix[up][i])
            up += 1
            if up > down:
                break
            for i in range(up, down + 1):
                ans.append(matrix[i][right])
            right -= 1
            if right < left:
                break
            for i in range(right, left - 1, -1):
                ans.append(matrix[down][i])
            down -= 1
            if down < up:
                break
            for i in range(down, up - 1, -1):
                ans.append(matrix[i][left])
            left += 1
            if left > right:
                break
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$、$n$ 分别为二维矩阵的行数和列数。
- **空间复杂度**：$O(m \times n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(m \times n)$。不算上则空间复杂度为 $O(1)$。

# [0055. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [0055. 跳跃游戏 - 力扣](https://leetcode.cn/problems/jump-game/)

## 题目大意

**描述**：给定一个非负整数数组 `nums`，数组中每个元素代表在该位置可以跳跃的最大长度。开始位置位于数组的第一个下标处。

**要求**：判断是否能够到达最后一个下标。

**说明**：

- $1 \le nums.length \le 3 \times 10^4$。
- $0 \le nums[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

- 示例 2：

```python
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

## 解题思路

### 思路 1：贪心算法

如果我们能通过前面的某个位置 $j$，到达后面的某个位置 $i$，则我们一定能到达区间 $[j, i]$ 中所有的点（$j \le i$）。

而前面的位置 $j$ 肯定也是通过 $j$ 前面的点到达的。所以我们可以通过贪心算法来计算出所能到达的最远位置。具体步骤如下：

1. 初始化能到达的最远位置 $max_i$ 为 $0$。
2. 遍历数组 `nums`。
3. 如果能到达当前位置，即 $max_i \le i$，并且当前位置 + 当前位置最大跳跃长度 > 能到达的最远位置，即 $i + nums[i] > max_i$，则更新能到达的最远位置 $max_i$。
4. 遍历完数组，最后比较能到达的最远位置 $max_i$ 和数组最远距离 `size -  1` 的关系。如果 $max_i >= len(nums)$，则返回 `True`，否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        size = len(nums)
        max_i = 0
        for i in range(size):
            if max_i >= i and i + nums[i] > max_i:
                max_i = i + nums[i]
            
        return max_i >= size - 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `nums` 的长度。
- **空间复杂度**：

### 思路 2：动态规划

###### 1. 划分阶段

按照位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：从位置 $0$ 出发，经过 $j \le i$，可以跳出的最远距离。

###### 3. 状态转移方程

- 如果能通过 $0 \sim i - 1$ 个位置到达 $i$，即 $dp[i-1] \le i$，则 $dp[i] = max(dp[i-1], i + nums[i])$。
- 如果不能通过 $0 \sim i - 1$ 个位置到达 $i$，即 $dp[i - 1] < i$，则 $dp[i] = dp[i - 1]$。

###### 4. 初始条件

初始状态下，从 $0$ 出发，经过 $0$，可以跳出的最远距离为 `nums[0]`，即 `dp[0] = nums[0]`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：从位置 $0$ 出发，经过 $j \le i$，可以跳出的最远距离。则我们需要判断 `dp[size - 1]` 与数组最远距离 `size -  1` 的关系。

### 思路 2：代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        size = len(nums)
        dp = [0 for _ in range(size)]
        dp[0] = nums[0]
        for i in range(1, size):
            if i <= dp[i - 1]:
                dp[i] = max(dp[i - 1], i + nums[i])
            else:
                dp[i] = dp[i - 1]
        return dp[size - 1] >= size - 1
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `nums` 的长度。
- **空间复杂度**：$O(n)$。

# [0056. 合并区间](https://leetcode.cn/problems/merge-intervals/)

- 标签：数组、排序
- 难度：中等

## 题目链接

- [0056. 合并区间 - 力扣](https://leetcode.cn/problems/merge-intervals/)

## 题目大意

**描述**：给定数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。

**要求**：合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**说明**：

- $1 \le intervals.length \le 10^4$。
- $intervals[i].length == 2$。
- $0 \le starti \le endi \le 10^4$。

**示例**：

- 示例 1：

```python
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

- 示例 2：

```python
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

## 解题思路

### 思路 1：排序

1. 设定一个数组 `ans` 用于表示最终不重叠的区间数组，然后对原始区间先按照区间左端点大小从小到大进行排序。
2. 遍历所有区间。
3. 先将第一个区间加入 `ans` 数组中。
4. 然后依次考虑后边的区间：
   1. 如果第 `i` 个区间左端点在前一个区间右端点右侧，则这两个区间不会重合，直接将该区间加入 `ans` 数组中。
   2. 否则的话，这两个区间重合，判断一下两个区间的右区间值，更新前一个区间的右区间值为较大值，然后继续考虑下一个区间，以此类推。
5. 最后返回数组 `ans`。

### 思路 1：代码

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])

        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log_2 n)$。其中 $n$ 为区间数量。
- **空间复杂度**：$O(n)$。

# [0058. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)

- 标签：字符串
- 难度：简单

## 题目链接

- [0058. 最后一个单词的长度 - 力扣](https://leetcode.cn/problems/length-of-last-word/)

## 题目大意

给定一个字符串 s，返回字符串中最后一个单词长度。

- 「单词」：指仅由字母组成、不包含任何空格字符的最大子字符串。

## 解题思路

从字符串末尾开始逆序遍历，先过滤掉末尾空白字符，然后统计字符数量，直到遇到空格或到达字符串开始位置。

## 代码

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        ans = 0
        for i in range(len(s)-1, -1, -1):
            if s[i] == " ":
                if ans == 0:
                    continue
                else:
                    return ans
            else:
                ans += 1
        return ans
```

# [0059. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

- 标签：数组、矩阵、模拟
- 难度：中等

## 题目链接

- [0059. 螺旋矩阵 II - 力扣](https://leetcode.cn/problems/spiral-matrix-ii/)

## 题目大意

给你一个正整数 $n$。

要求：生成一个包含 $1 \sim n^2$ 的所有元素，且元素按顺时针顺序螺旋排列的 $n \times n$ 正方形矩阵 $matrix$。

## 解题思路

### 思路 1：模拟

这道题跟「[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)」思路是一样的。

1. 构建一个 $n \times n$ 大小的数组 $matrix$ 存储答案。然后定义一下上、下、左、右的边界。
2. 然后按照逆时针的顺序从边界上依次给数组 $matrix$ 相应位置赋值。
3. 当访问完当前边界之后，要更新一下边界位置，缩小范围，方便下一轮进行访问。
4. 最后返回 $matrix$。

### 思路 1：代码

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        up, down, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1
        index = 1
        while True:
            for i in range(left, right + 1):
                matrix[up][i] = index
                index += 1
            up += 1
            if up > down:
                break
            for i in range(up, down + 1):
                matrix[i][right] = index
                index += 1
            right -= 1
            if right < left:
                break
            for i in range(right, left - 1, -1):
                matrix[down][i] = index
                index += 1
            down -= 1
            if down < up:
                break
            for i in range(down, up - 1, -1):
                matrix[i][left] = index
                index += 1
            left += 1
            if left > right:
                break
        return matrix
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n^2)$。

# [0061. 旋转链表](https://leetcode.cn/problems/rotate-list/)

- 标签：链表、双指针
- 难度：中等

## 题目链接

- [0061. 旋转链表 - 力扣](https://leetcode.cn/problems/rotate-list/)

## 题目大意

给定一个链表和整数 k，将链表每个节点向右移动 k 个位置。

## 解题思路

我们可以将链表先连成环，然后将链表在指定位置断开。

先遍历一遍，求出链表节点个数 n。注意到 k 可能很大，我们只需将链表右移 k % n 个位置即可。

第二次遍历到 n - k % n 的位置，记录下断开后新链表头节点位置，再将其断开并返回新的头节点。

## 代码

```python
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if k == 0 or not head or not head.next:
            return head
        curr = head
        count = 1
        while curr.next:
            count += 1
            curr = curr.next
        cut = count - k % count
        curr.next = head
        while cut:
            curr = curr.next
            cut -= 1
        newHead = curr.next
        curr.next = None
        return newHead
```

# [0062. 不同路径](https://leetcode.cn/problems/unique-paths/)

- 标签：数学、动态规划、组合数学
- 难度：中等

## 题目链接

- [0062. 不同路径 - 力扣](https://leetcode.cn/problems/unique-paths/)

## 题目大意

**描述**：给定两个整数 $m$ 和 $n$，代表大小为 $m \times n$ 的棋盘， 一个机器人位于棋盘左上角的位置，机器人每次只能向右、或者向下移动一步。

**要求**：计算出机器人从棋盘左上角到达棋盘右下角一共有多少条不同的路径。

**说明**：

- $1 \le m, n \le 100$。
- 题目数据保证答案小于等于 $2 \times 10^9$。

**示例**：

- 示例 1：

```python
输入：m = 3, n = 7
输出：28
```

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

- 示例 2：

```python
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 为：从左上角到达位置 $(i, j)$ 的路径数量。

###### 3. 状态转移方程

因为我们每次只能向右、或者向下移动一步，因此想要走到 $(i, j)$，只能从 $(i - 1, j)$ 向下走一步走过来；或者从 $(i, j - 1)$ 向右走一步走过来。所以可以写出状态转移方程为：$dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$，此时 $i > 0, j > 0$。

###### 4. 初始条件

- 从左上角走到 $(0, 0)$ 只有一种方法，即 $dp[0][0] = 1$。
- 第一行元素只有一条路径（即只能通过前一个元素向右走得到），所以 $dp[0][j] = 1$。
- 同理，第一列元素只有一条路径（即只能通过前一个元素向下走得到），所以 $dp[i][0] = 1$。

###### 5. 最终结果

根据状态定义，最终结果为 $dp[m - 1][n - 1]$，即从左上角到达右下角 $(m - 1, n - 1)$ 位置的路径数量为 $dp[m - 1][n - 1]$。

### 思路 1：动态规划代码

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for _ in range(n)] for _ in range(m)]
        
        for j in range(n):
            dp[0][j] = 1
        for i in range(m):
            dp[i][0] = 1

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        return dp[m - 1][n - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。初始条件赋值的时间复杂度为 $O(m + n)$，两重循环遍历的时间复杂度为 $O(m \times n)$，所以总体时间复杂度为 $O(m \times n)$。
- **空间复杂度**：$O(m \times n)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(m \times n)$。因为 $dp[i][j]$ 的状态只依赖于上方值 $dp[i - 1][j]$ 和左侧值 $dp[i][j - 1]$，而我们在进行遍历时的顺序刚好是从上至下、从左到右。所以我们可以使用长度为 $n$ 的一维数组来保存状态，从而将空间复杂度优化到 $O(n)$。# [0063. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

- 标签：数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [0063. 不同路径 II - 力扣](https://leetcode.cn/problems/unique-paths-ii/)

## 题目大意

**描述**：一个机器人位于一个 $m \times n$ 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。但是网格中有障碍物，不能通过。

现在给定一个二维数组表示网格，$1$ 代表障碍物，$0$ 表示空位。

**要求**：计算出从左上角到右下角会有多少条不同的路径。

**说明**：

- $m == obstacleGrid.length$。
- $n == obstacleGrid[i].length$。
- $1 \le m, n \le 100$。
- $obstacleGrid[i][j]$ 为 $0$ 或 $1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```python
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

```python
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

## 解题思路

###  思路 1：动态规划

###### 1. 划分阶段

按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：从 $(0, 0)$ 到 $(i, j)$ 的不同路径数。

###### 3. 状态转移方程

因为我们每次只能向右、或者向下移动一步，因此想要走到 $(i, j)$，只能从 $(i - 1, j)$ 向下走一步走过来；或者从 $(i, j - 1)$ 向右走一步走过来。则状态转移方程为：$dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$，其中 $obstacleGrid[i][j] == 0$。

###### 4. 初始条件

- 对于第一行、第一列，因为只能超一个方向走，所以 $dp[i][0] = 1$，$dp[0][j] = 1$。如果在第一行、第一列遇到障碍，则终止赋值，跳出循环。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：从 $(0, 0)$ 到 $(i, j)$ 的不同路径数。所以最终结果为 $dp[m - 1][n - 1]$。

### 思路 1：代码

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]

        for i in range(m):
            if obstacleGrid[i][0] == 1:
                break
            dp[i][0] = 1

        for j in range(n):
            if obstacleGrid[0][j] == 1:
                break
            dp[0][j] = 1

        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    continue
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[m - 1][n - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。
- **空间复杂度**：$O(m \times n)$。

# [0064. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

- 标签：数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [0064. 最小路径和 - 力扣](https://leetcode.cn/problems/minimum-path-sum/)

## 题目大意

**描述**：给定一个包含非负整数的 $m \times n$  大小的网格 $grid$。

**要求**：找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明**：

- 每次只能向下或者向右移动一步。
- $m == grid.length$。
- $n == grid[i].length$。
- $1 \le m, n \le 200$。
- $0 \le grid[i][j] \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```python
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

- 示例 2：

```python
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 为：从左上角到达 $(i, j)$ 位置的最小路径和。

###### 3. 状态转移方程

当前位置 $(i, j)$ 只能从左侧位置 $(i, j - 1)$ 或者上方位置 $(i - 1, j)$ 到达。为了使得从左上角到达 $(i, j)$ 位置的最小路径和最小，应从 $(i, j - 1)$ 位置和 $(i - 1, j)$ 位置选择路径和最小的位置达到 $(i, j)$。

即状态转移方程为：$dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]$。

###### 4. 初始条件

- 当左侧和上方是矩阵边界时（即 $i = 0, j = 0$），$dp[i][j] = grid[i][j]$。
- 当只有左侧是矩阵边界时（即 $i \ne 0, j = 0$），只能从上方到达，$dp[i][j] = dp[i - 1][j] + grid[i][j]$。
- 当只有上方是矩阵边界时（即 $i = 0, j \ne 0$），只能从左侧到达，$dp[i][j] = dp[i][j - 1] + grid[i][j]$。

###### 5. 最终结果

根据状态定义，最后输出 $dp[rows - 1][cols - 1]$（即从左上角到达 $(rows - 1, cols - 1)$ 位置的最小路径和）即可。其中 $rows$、$cols$ 分别为 $grid$ 的行数、列数。

### 思路 1：代码

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        dp = [[0 for _ in range(cols)] for _ in range(rows)]

        dp[0][0] = grid[0][0]
        
        for i in range(1, rows):
            dp[i][0] = dp[i - 1][0] + grid[i][0]
        
        for j in range(1, cols):
            dp[0][j] = dp[0][j - 1] + grid[0][j]

        for i in range(1, rows):
            for j in range(1, cols):
                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]
            
        return dp[rows - 1][cols - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m * n)$，其中 $m$、$n$ 分别为 $grid$ 的行数和列数。
- **空间复杂度**：$O(m * n)$。
# [0066. 加一](https://leetcode.cn/problems/plus-one/)

- 标签：数组、数学
- 难度：简单

## 题目链接

- [0066. 加一 - 力扣](https://leetcode.cn/problems/plus-one/)

## 题目大意

**描述**：给定一个非负整数数组，数组每一位对应整数的一位数字。

**要求**：计算整数加 $1$ 后的结果。

**说明**：

- $1 \le digits.length \le 100$。
- $0 \le digits[i] \le 9$。

**示例**：

- 示例 1：

```python
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123，加 1 之后为 124。
```

- 示例 2：

```python
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

## 解题思路

### 思路 1：模拟

这道题把整个数组看成了一个整数，然后个位数加 $1$。问题的实质是利用数组模拟加法运算。

如果个位数不为 $9$ 的话，直接把个位数加 $1$ 就好。如果个位数为 $9$ 的话，还要考虑进位。

具体步骤：

1. 数组前补 $0$ 位。
2. 将个位数字进行加 $1$ 计算。
3. 遍历数组
   1. 如果该位数字大于等于 $10$，则向下一位进 $1$，继续下一位判断进位。
   2. 如果该位数字小于 $10$，则跳出循环。

### 思路 1：代码

```python
def plusOne(self, digits: List[int]) -> List[int]:
    digits = [0] + digits
    digits[len(digits) - 1] += 1
    for i in range(len(digits)-1, 0, -1):
        if digits[i] != 10:
            break
        else:
            digits[i] = 0
            digits[i - 1] += 1
        
    if digits[0] == 0:
        return digits[1:] 
    else:
        return digits
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$ 。
- **空间复杂度**：$O(1)$。# [0067. 二进制求和](https://leetcode.cn/problems/add-binary/)

- 标签：位运算、数学、字符串、模拟
- 难度：简单

## 题目链接

- [0067. 二进制求和 - 力扣](https://leetcode.cn/problems/add-binary/)

## 题目大意

给定两个二进制数的字符串 a、b。计算 a 和 b 的和，返回结果也用二进制表示。

## 解题思路

这道题可以直接将 a、b 转换为十进制数，相加后再转换为二进制数。

也可以利用位运算的一些知识，直接求和。

因为 a、b 为二进制的字符串，先将其转换为二进制数。

本题用到的位运算知识：

- 异或运算 x ^ y ：可以获得 x + y 无进位的加法结果。
- 与运算 x & y：对应位置为 1，说明 x、y 该位置上原来都为 1，则需要进位。
- 座椅运算 x << 1：将 a 对应二进制数左移 1 位。

这样，通过 x ^ y 运算，我们可以得到相加后无进位结果，再根据 (x & y) << 1，计算进位后结果。

进行 x ^ y 和 (x & y) << 1操作之后判断进位是否为 0，若不为 0，则继续上一步操作，直到进位为 0。

最后将其结果转为 2 进制返回。

## 代码

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        x = int(a, 2)
        y = int(b, 2)
        ans = 0
        while y:
            carry = ((x & y) << 1)
            x ^= y
            y = carry
        return bin(x)[2:]
```

# [0069. x 的平方根](https://leetcode.cn/problems/sqrtx/)

- 标签：数学、二分查找
- 难度：简单

## 题目链接

- [0069. x 的平方根 - 力扣](https://leetcode.cn/problems/sqrtx/)

## 题目大意

**要求**：实现 `int sqrt(int x)` 函数。计算并返回 $x$ 的平方根（只保留整数部分），其中 $x$ 是非负整数。

**说明**：

- $0 \le x \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：x = 4
输出：2
```

- 示例 2：

```python
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

## 解题思路

### 思路 1：二分查找

因为求解的是 $x$ 开方的整数部分。所以我们可以从 $0 \sim x$ 的范围进行遍历，找到 $k^2 \le x$ 的最大结果。

为了减少算法的时间复杂度，我们使用二分查找的方法来搜索答案。

### 思路 1：代码

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        left = 0
        right = x
        ans = -1
        while left <= right:
            mid = (left + right) // 2
            if mid * mid <= x:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [0070. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

- 标签：记忆化搜索、数学、动态规划
- 难度：简单

## 题目链接

- [0070. 爬楼梯 - 力扣](https://leetcode.cn/problems/climbing-stairs/)

## 题目大意

**描述**：假设你正在爬楼梯。需要 $n$ 阶你才能到达楼顶。每次你可以爬 $1$ 或 $2$ 个台阶。现在给定一个整数 $n$。

**要求**：计算出有多少种不同的方法可以爬到楼顶。

**说明**：

- $1 \le n \le 45$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

- 示例 2：

```python
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

## 解题思路

### 思路 1：递归（超时）

根据我们的递推三步走策略，写出对应的递归代码。

1. 写出递推公式：$f(n) = f(n - 1) + f(n - 2)$。
2. 明确终止条件：$f(0) = 0, f(1) = 1$。
3. 翻译为递归代码：
   1. 定义递归函数：`climbStairs(self, n)` 表示输入参数为问题的规模 $n$，返回结果为爬 $n$ 阶台阶到达楼顶的方案数。
   2. 书写递归主体：`return self.climbStairs(n - 1) + self.climbStairs(n - 2)`。
   3. 明确递归终止条件：
      1. `if n == 0: return 0`
      2. `if n == 1: return 1`

### 思路 1：代码

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O((\frac{1 + \sqrt{5}}{2})^n)$。
- **空间复杂度**：$O(n)$。每次递归的空间复杂度是 $O(1)$， 调用栈的深度为 $n$，所以总的空间复杂度就是 $O(n)$。

### 思路 2：动态规划

###### 1. 划分阶段

按照台阶的层数进行划分为 $0 \sim n$。

###### 2. 定义状态

定义状态 $dp[i]$ 为：爬到第 $i$ 阶台阶的方案数。

###### 3. 状态转移方程

根据题目大意，每次只能爬 $1$ 或 $2$ 个台阶。则第 $i$ 阶楼梯只能从第 $i - 1$ 阶向上爬 $1$ 阶上来，或者从第 $i - 2$ 阶向上爬 $2$ 阶上来。所以可以推出状态转移方程为 $dp[i] = dp[i - 1] + dp[i - 2]$。

###### 4. 初始条件

- 第 $0$ 层台阶方案数：可以看做 $1$ 种方法（从 $0$ 阶向上爬 $0$ 阶），即 $dp[0] = 1$。
- 第 $1$ 层台阶方案数：$1$ 种方法（从 $0$ 阶向上爬 $1$ 阶），即 $dp[1] = 1$。
- 第 $2$ 层台阶方案数：$2$ 种方法（从 $0$ 阶向上爬 $2$ 阶，或者从 $1$ 阶向上爬 $1$ 阶）。

###### 5. 最终结果

根据状态定义，最终结果为 $dp[n]$，即爬到第 $n$ 阶台阶（即楼顶）的方案数为 $dp[n]$。

### 思路 2：代码

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。因为 $dp[i]$ 的状态只依赖于 $dp[i - 1]$ 和 $dp[i - 2]$，所以可以使用 $3$ 个变量来分别表示 $dp[i]$、$dp[i - 1]$、$dp[i - 2]$，从而将空间复杂度优化到 $O(1)$。

# [0072. 编辑距离](https://leetcode.cn/problems/edit-distance/)

- 标签：字符串、动态规划
- 难度：困难

## 题目链接

- [0072. 编辑距离 - 力扣](https://leetcode.cn/problems/edit-distance/)

## 题目大意

**描述**：给定两个单词 $word1$、$word2$。

对一个单词可以进行以下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**要求**：计算出将 $word1$ 转换为 $word2$ 所使用的最少操作数。

**说明**：

- $0 \le word1.length, word2.length \le 500$。
- $word1$ 和 $word2$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

- 示例 2：

```python
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照两个字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，所需要的最少操作次数。

###### 3. 状态转移方程

1. 如果当前字符相同（$word1[i - 1] = word2[j - 1]$），无需插入、删除、替换。$dp[i][j] = dp[i - 1][j - 1]$。
2. 如果当前字符不同（$word1[i - 1] \ne word2[j - 1]$），$dp[i][j]$ 取源于以下三种情况中的最小情况：
   1. 替换（$word1[i - 1]$ 替换为 $word2[j - 1]$）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上替换的操作数 $1$，即：$dp[i][j] = dp[i - 1][j - 1] + 1$。
   2. 插入（$word1$ 在第 $i - 1$ 位置上插入元素）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」 变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，再加上插入需要的操作数 $1$，即：$dp[i][j] = dp[i - 1][j] + 1$。
   3. 删除（$word1$ 删除第 $i - 1$ 位置元素）：最少操作次数依赖于「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上删除需要的操作数 $1$，即：$dp[i][j] = dp[i][j - 1] + 1$。

综合上述情况，状态转移方程为：

$dp[i][j] = \begin{cases} dp[i - 1][j - 1] & word1[i - 1] = word2[j - 1] \cr min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 & word1[i - 1] \ne word2[j - 1] \end{cases}$

###### 4. 初始条件

- 当 $i = 0$，「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」为空字符串，「$str1$」变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」时，至少需要插入 $j$ 次，即：$dp[0][j] = j$。
- 当 $j = 0$，「以 $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」为空字符串，「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「$str2$」时，至少需要删除 $i$ 次，即：$dp[i][0] = i$。

###### 5. 最终结果

根据状态定义，最后输出 $dp[sise1][size2]$（即 $word1$ 变为 $word2$ 所使用的最少操作数）即可。其中 $size1$、$size2$ 分别为 $word1$、$word2$ 的字符串长度。

### 思路 1：代码

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        size1 = len(word1)
        size2 = len(word2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]

        for i in range(size1 + 1):
            dp[i][0] = i
        for j in range(size2 + 1):
            dp[0][j] = j
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
        return dp[size1][size2]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $word1$、$word2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。
- **空间复杂度**：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。
# [0073. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

- 标签：数组、哈希表、矩阵
- 难度：中等

## 题目链接

- [0073. 矩阵置零 - 力扣](https://leetcode.cn/problems/set-matrix-zeroes/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的矩阵 $matrix$。

**要求**：如果一个元素为 $0$，则将其所在行和列所有元素都置为 $0$。

**说明**：

- 请使用「原地」算法。
- $m == matrix.length$。
- $n == matrix[0].length$。
- $1 \le m, n \le 200$。
- $-2^{31} \le matrix[i][j] \le 2^{31} - 1$。
- **进阶**：
  - 一个直观的解决方案是使用  $O(m \times n)$ 的额外空间，但这并不是一个好的解决方案。
  - 一个简单的改进方案是使用 $O(m + n)$ 的额外空间，但这仍然不是最好的解决方案。
  - 你能想出一个仅使用常量空间的解决方案吗？


**示例**：

- 示例 1：
- ![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```python
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

## 解题思路

### 思路 1：使用标记变量

直观上可以使用两个数组来标记行和列出现 $0$ 的情况，但这样空间复杂度就是 $O(m+n)$ 了，不符合题意。

考虑使用数组原本的元素进行记录出现 $0$ 的情况。

1. 设定两个变量 $flag\underline{\hspace{0.5em}}row0$、$flag\underline{\hspace{0.5em}}col0$ 来标记第一行、第一列是否出现了 $0$。
2. 接下来我们使用数组第一行、第一列来标记 $0$ 的情况。
3. 对数组除第一行、第一列之外的每个元素进行遍历，如果某个元素出现 $0$ 了，则使用数组的第一行、第一列对应位置来存储 $0$ 的标记。
4. 再对数组除第一行、第一列之外的每个元素进行遍历，通过对第一行、第一列的标记 $0$ 情况，进行置为 $0$ 的操作。
5. 最后再根据 $flag\underline{\hspace{0.5em}}row0$、$flag\underline{\hspace{0.5em}}col0$ 的标记情况，对第一行、第一列进行置为 $0$ 的操作。

### 思路 1：代码

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        m = len(matrix)
        n = len(matrix[0])
        flag_col0 = False
        flag_row0 = False
        for i in range(m):
            if matrix[i][0] == 0:
                flag_col0 = True
                break

        for j in range(n):
            if matrix[0][j] == 0:
                flag_row0 = True
                break

        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0

        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

        if flag_col0:
            for i in range(m):
                matrix[i][0] = 0

        if flag_row0:
            for j in range(n):
                matrix[0][j] = 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。
- **空间复杂度**：$O(1)$。

# [0074. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

- 标签：数组、二分查找、矩阵
- 难度：中等

## 题目链接

- [0074. 搜索二维矩阵 - 力扣](https://leetcode.cn/problems/search-a-2d-matrix/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的有序二维矩阵 $matrix$。矩阵中每行元素从左到右升序排列，每列元素从上到下升序排列。再给定一个目标值 $target$。

**要求**：判断矩阵中是否存在目标值 $target$。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 100$。
- $-10^4 \le matrix[i][j], target \le 10^4$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```python
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：True
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```python
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：False
```

## 解题思路

### 思路 1：二分查找

二维矩阵是有序的，可以考虑使用二分搜索来进行查找。

1. 首先二分查找遍历对角线元素，假设对角线元素的坐标为 $(row, col)$。把数组元素按对角线分为右上角部分和左下角部分。
2. 然后对于当前对角线元素右侧第 $row$ 行、对角线元素下侧第 $col$ 列进行二分查找。
   1. 如果找到目标，直接返回 `True`。
   2. 如果找不到目标，则缩小范围，继续查找。
   3. 直到所有对角线元素都遍历完，依旧没找到，则返回 `False`。

### 思路 1：代码

```python
class Solution:
    # 二分查找对角线元素
    def diagonalBinarySearch(self, matrix, diagonal, target):
        left = 0
        right = diagonal
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
    
    def rowBinarySearch(self, matrix, begin, cols, target):
        left = begin
        right = cols
        while left < right:
            mid = left + (right - left) // 2
            if matrix[begin][mid] < target:
                left = mid + 1
            elif matrix[begin][mid] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= cols and matrix[begin][left] == target

    def colBinarySearch(self, matrix, begin, rows, target):
        left = begin + 1
        right = rows
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][begin] < target:
                left = mid + 1
            elif matrix[mid][begin] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= rows and matrix[left][begin] == target

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows = len(matrix)
        if rows == 0:
            return False
        cols = len(matrix[0])
        if cols == 0:
            return False

        min_val = min(rows, cols)
        index = self.diagonalBinarySearch(matrix, min_val - 1, target)
        if matrix[index][index] == target:
            return True
        for i in range(index + 1):
            row_search = self.rowBinarySearch(matrix, i, cols - 1, target)
            col_search = self.colBinarySearch(matrix, i, rows - 1, target)
            if row_search or col_search:
                return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log m + \log n)$，其中 $m$、$n$ 分别是矩阵的行数和列数。
- **空间复杂度**：$O(1)$。
# [0075. 颜色分类](https://leetcode.cn/problems/sort-colors/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [0075. 颜色分类 - 力扣](https://leetcode.cn/problems/sort-colors/)

## 题目大意

**描述**：给定一个数组 $nums$，元素值只有 $0$、$1$、$2$，分别代表红色、白色、蓝色。

**要求**：将数组进行排序，使得红色在前，白色在中间，蓝色在最后。

**说明**：

- 要求不使用标准库函数，同时仅用常数空间，一趟扫描解决。
- $n == nums.length$。
- $1 \le n \le 300$。
- $nums[i]$ 为 $0$、$1$ 或 $2$。

**示例**：

- 示例 1：

```python
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

- 示例 2：

```python
输入：nums = [2,0,1]
输出：[0,1,2]
```

## 解题思路

### 思路 1：双指针 + 快速排序思想

快速排序算法中的 $partition$ 过程，利用双指针，将序列中比基准数 $pivot$ 大的元素移动到了基准数右侧，将比基准数 $pivot$ 小的元素移动到了基准数左侧。从而将序列分为了三部分：比基准数小的部分、基准数、比基准数大的部分。

这道题我们也可以借鉴快速排序算法中的 $partition$ 过程，将 $1$ 作为基准数 $pivot$，然后将序列分为三部分：$0$（即比 $1$ 小的部分）、等于 $1$ 的部分、$2$（即比 $1$ 大的部分）。具体步骤如下：

1. 使用两个指针 $left$、$right$，分别指向数组的头尾。$left$ 表示当前处理好红色元素的尾部，$right$ 表示当前处理好蓝色的头部。
2. 再使用一个下标 $index$ 遍历数组，如果遇到 $nums[index] == 0$，就交换 $nums[index]$ 和 $nums[left]$，同时将 $left$ 右移。如果遇到 $nums[index] == 2$，就交换 $nums[index]$ 和 $nums[right]$，同时将 $right$ 左移。
3. 直到 $index$ 移动到 $right$ 位置之后，停止遍历。遍历结束之后，此时 $left$ 左侧都是红色，$right$ 右侧都是蓝色。

注意：移动的时候需要判断 $index$ 和 $left$ 的位置，因为 $left$ 左侧是已经处理好的数组，所以需要判断 $index$ 的位置是否小于 $left$，小于的话，需要更新 $index$ 位置。

### 思路 1：代码

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        left = 0
        right = len(nums) - 1
        index = 0
        while index <= right:
            if index < left:
                index += 1
            elif nums[index] == 0:
                nums[index], nums[left] = nums[left], nums[index]
                left += 1
            elif nums[index] == 2:
                nums[index], nums[right] = nums[right], nums[index]
                right -= 1
            else:
                index += 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0076. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

- 标签：哈希表、字符串、滑动窗口
- 难度：困难

## 题目链接

- [0076. 最小覆盖子串 - 力扣](https://leetcode.cn/problems/minimum-window-substring/)

## 题目大意

**描述**：给定一个字符串 `s`、一个字符串 `t`。

**要求**：返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。

**说明**：

- $1 \le s.length, t.length \le 10^5$。
- `s` 和 `t` 由英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

- 示例 2：

```python
输入：s = "a", t = "a"
输出："a"
```

## 解题思路

### 思路 1：滑动窗口

1. `left`、`right` 表示窗口的边界，一开始都位于下标 `0` 处。`need` 用于记录短字符串需要的字符数。`window` 记录当前窗口内的字符数。
2. 将 `right` 右移，直到出现了 `t` 中全部字符，开始右移 `left`，减少滑动窗口的大小，并记录下最小覆盖子串的长度和起始位置。
3. 最后输出结果。

### 思路 1：代码

```python
import collections

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = collections.defaultdict(int)
        window = collections.defaultdict(int)
        for ch in t:
            need[ch] += 1

        left, right = 0, 0
        valid = 0
        start = 0
        size = len(s) + 1

        while right < len(s):
            insert_ch = s[right]
            right += 1

            if insert_ch in need:
                window[insert_ch] += 1
                if window[insert_ch] == need[insert_ch]:
                    valid += 1

            while valid == len(need):
                if right - left < size:
                    start = left
                    size = right - left
                remove_ch = s[left]
                left += 1
                if remove_ch in need:
                    if window[remove_ch] == need[remove_ch]:
                        valid -= 1
                    window[remove_ch] -= 1
        if size == len(s) + 1:
            return ''
        return s[start:start+size]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是字符串 $s$ 的长度。
- **空间复杂度**：$O(| \sum |)$。$| \sum |$  是 $s$ 和 $t$ 的字符集大小。# [0077. 组合](https://leetcode.cn/problems/combinations/)

- 标签：回溯
- 难度：中等

## 题目链接

- [0077. 组合 - 力扣](https://leetcode.cn/problems/combinations/)

## 题目大意

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。可以按任何顺序返回答案。

## 解题思路

组合问题通常可以用回溯算法来解决。定义两个数组 res、path。res 用来存放最终答案，path 用来存放当前符合条件的一个结果。再使用一个变量 start_index 来表示从哪一个数开始遍历。

定义回溯方法，start_index = 1 开始进行回溯。

- 如果 path 数组的长度等于 k，则将 path 中的元素加入到 res 数组中。
- 然后对 `[start_index, n]` 范围内的数进行遍历取值。
  - 将当前元素 i 加入 path 数组。
  - 递归遍历 `[start_index, n]` 上的数。
  - 将遍历的 i 元素进行回退。
- 最终返回 res 数组。

## 代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, n: int, k: int, start_index: int):
        if len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start_index, n - (k - len(self.path)) + 2):
            self.path.append(i)
            self.backtrack(n, k, i + 1)
            self.path.pop()

    def combine(self, n: int, k: int) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        self.backtrack(n, k, 1)
        return self.res
```

# [0078. 子集](https://leetcode.cn/problems/subsets/)

- 标签：位运算、数组、回溯
- 难度：中等

## 题目链接

- [0078. 子集 - 力扣](https://leetcode.cn/problems/subsets/)

## 题目大意

**描述**：给定一个整数数组 `nums`，数组中的元素互不相同。

**要求**：返回该数组所有可能的不重复子集。可以按任意顺序返回解集。

**说明**：

- $1 \le nums.length \le 10$。
- $-10 \le nums[i] \le 10$。
- `nums` 中的所有元素互不相同。

**示例**：

- 示例 1：

```python
输入 nums = [1,2,3]
输出 [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

- 示例 2：

```python
输入：nums = [0]
输出：[[],[0]]
```

## 解题思路

### 思路 1：回溯算法

数组的每个元素都有两个选择：选与不选。

我们可以通过向当前子集数组中添加可选元素来表示选择该元素。也可以在当前递归结束之后，将之前添加的元素从当前子集数组中移除（也就是回溯）来表示不选择该元素。

下面我们根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：根据数组中每个位置上的元素选与不选两种选择，画出决策树，如下图所示。

  - ![](https://qcdn.itcharge.cn/images/20220425210640.png)

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**
   1. 定义回溯函数：

      - `backtracking(nums, index):` 函数的传入参数是 `nums`（可选数组列表）和 `index`（代表当前正在考虑元素是 `nums[i]` ），全局变量是 `res`（存放所有符合条件结果的集合数组）和 `path`（存放当前符合条件的结果）。
      - `backtracking(nums, index):` 函数代表的含义是：在选择 `nums[index]` 的情况下，递归选择剩下的元素。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑元素，到数组结束为止，枚举出所有可选的元素。对于每一个可选元素：
        - 约束条件：之前选过的元素不再重复选用。每次从 `index` 位置开始遍历而不是从 `0` 位置开始遍历就是为了避免重复。集合跟全排列不一样，子集中 `{1, 2}` 和 `{2, 1}` 是等价的。为了避免重复，我们之前考虑过的元素，就不再重复考虑了。
        - 选择元素：将其添加到当前子集数组 `path` 中。
        - 递归搜索：在选择该元素的情况下，继续递归考虑下一个位置上的元素。
        - 撤销选择：将该元素从当前子集数组 `path` 中移除。
    ```python
    for i in range(index, len(nums)):   # 枚举可选元素列表
        path.append(nums[i])            # 选择元素
        backtracking(nums, i + 1)       # 递归搜索
        path.pop()                      # 撤销选择
    ```
   
   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是当正在考虑的元素位置到达数组末尾（即 `start >= len(nums)`）时，递归停止。
      - 从决策树中也可以看出，子集需要存储的答案集合应该包含决策树上所有的节点，应该需要保存递归搜索的所有状态。所以无论是否达到终止条件，我们都应该将当前符合条件的结果放入到集合中。

### 思路 1：代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  # 存放所有符合条件结果的集合
        path = []  # 存放当前符合条件的结果
        def backtracking(nums, index):          # 正在考虑可选元素列表中第 index 个元素
            res.append(path[:])                 # 将当前符合条件的结果放入集合中
            if index >= len(nums):              # 遇到终止条件（本题）
                return

            for i in range(index, len(nums)):   # 枚举可选元素列表
                path.append(nums[i])            # 选择元素
                backtracking(nums, i + 1)       # 递归搜索
                path.pop()                      # 撤销选择

        backtracking(nums, 0)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。

### 思路 2：二进制枚举

对于一个元素个数为 `n` 的集合 `nums`  来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 `1` 来表示选取该元素，用数字 `0` 来表示不选取该元素。

那么我们就可以用一个长度为 `n` 的二进制数来表示集合 `nums` 或者表示 `nums` 的子集。其中二进制的每一位数都对应了集合中某一个元素的选取状态。对于集合中第 `i` 个元素（`i` 从 `0` 开始编号）来说，二进制对应位置上的 `1` 代表该元素被选取，`0` 代表该元素未被选取。

举个例子来说明一下，比如长度为 `5` 的集合 `nums = {5, 4, 3, 2, 1}`，我们可以用一个长度为 `5` 的二进制数来表示该集合。 

比如二进制数 `11111` 就表示选取集合的第 `0` 位、第 `1` 位、第 `2` 位、第 `3` 位、第 `4` 位元素，也就是集合 `{5, 4, 3, 2, 1}` ，即集合 `nums`  本身。如下表所示：

| 集合 nums 对应位置（下标） |  4   |  3   |  2   |  1   |  0   |
| :------------------------- | :--: | :--: | :--: | :--: | :--: |
| 二进制数对应位数           |  1   |  1   |  1   |  1   |  1   |
| 对应选取状态               | 选取 | 选取 | 选取 | 选取 | 选取 |

再比如二进制数 `10101` 就表示选取集合的第 `0` 位、第 `2` 位、第 `5` 位元素，也就是集合 `{5, 3, 1}`。如下表所示：

| 集合 nums 对应位置（下标） |  4   |   3    |  2   |   1    |  0   |
| :------------------------- | :--: | :----: | :--: | :----: | :--: |
| 二进制数对应位数           |  1   |   0    |  1   |   0    |  1   |
| 对应选取状态               | 选取 | 未选取 | 选取 | 未选取 | 选取 |

再比如二进制数 `01001` 就表示选取集合的第 `0` 位、第 `3` 位元素，也就是集合 `{5, 2}`。如下标所示：

| 集合 nums 对应位置（下标） |   4    |  3   |   2    |   1    |  0   |
| :------------------------- | :----: | :--: | :----: | :----: | :--: |
| 二进制数对应位数           |   0    |  1   |   0    |   0    |  1   |
| 对应选取状态               | 未选取 | 选取 | 未选取 | 未选取 | 选取 |

通过上面的例子我们可以得到启发：对于长度为 `5` 的集合 `nums` 来说，我们只需要从 `00000` ~ `11111` 枚举一次（对应十进制为 $0 \sim 2^4 - 1$）即可得到长度为 `5` 的集合 `S` 的所有子集。

我们将上面的例子拓展到长度为 `n` 的集合 `nums`。可以总结为：

- 对于长度为 `5` 的集合 `nums` 来说，只需要枚举 $0 \sim 2^n - 1$（共 $2^n$ 种情况），即可得到所有的子集。

### 思路 2：代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)                       # n 为集合 nums 的元素个数
        sub_sets = []                       # sub_sets 用于保存所有子集
        for i in range(1 << n):             # 枚举 0 ~ 2^n - 1
            sub_set = []                    # sub_set 用于保存当前子集
            for j in range(n):              # 枚举第 i 位元素
                if i >> j & 1:              # 如果第 i 为元素对应二进制位为 1，则表示选取该元素
                    sub_set.append(nums[j]) # 将选取的元素加入到子集 sub_set 中
            sub_sets.append(sub_set)        # 将子集 sub_set 加入到所有子集数组 sub_sets 中
        return sub_sets                     # 返回所有子集
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。

# [0079. 单词搜索](https://leetcode.cn/problems/word-search/)

- 标签：数组、回溯、矩阵
- 难度：中等

## 题目链接

- [0079. 单词搜索 - 力扣](https://leetcode.cn/problems/word-search/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的二维字符矩阵 $board$ 和一个字符串单词 $word$。

**要求**：如果 $word$ 存在于网格中，返回 `True`，否则返回 `False`。

**说明**：

- 单词必须按照字母顺序通过上下左右相邻的单元格字母构成。且同一个单元格内的字母不允许被重复使用。
- $m == board.length$。
- $n == board[i].length$。
- $1 \le m, n \le 6$。
- $1 \le word.length \le 15$。
- $board$ 和 $word$ 仅由大小写英文字母组成。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```python
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```python
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

## 解题思路

### 思路 1：回溯算法

使用回溯算法在二维矩阵 $board$ 中按照上下左右四个方向递归搜索。

设函数 `backtrack(i, j, index)` 表示从 $board[i][j]$ 出发，能否搜索到单词字母 $word[index]$，以及 $index$ 位置之后的后缀子串。如果能搜索到，则返回 `True`，否则返回 `False`。

`backtrack(i, j, index)` 执行步骤如下：

1. 如果 $board[i][j] = word[index]$，而且 index 已经到达 word 字符串末尾，则返回 True。
2. 如果 $board[i][j] = word[index]$，而且 index 未到达 word 字符串末尾，则遍历当前位置的所有相邻位置。如果从某个相邻位置能搜索到后缀子串，则返回 True，否则返回 False。
3. 如果 $board[i][j] \ne word[index]$，则当前字符不匹配，返回 False。

### 思路 1：代码

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        rows = len(board)
        if rows == 0:
            return False
        cols = len(board[0])
        visited = [[False for _ in range(cols)] for _ in range(rows)]

        def backtrack(i, j, index):
            if index == len(word) - 1:
                return board[i][j] == word[index]

            if board[i][j] == word[index]:
                visited[i][j] = True
                for direct in directs:
                    new_i = i + direct[0]
                    new_j = j + direct[1]
                    if 0 <= new_i < rows and 0 <= new_j < cols and visited[new_i][new_j] == False:
                        if backtrack(new_i, new_j, index + 1):
                            return True
                visited[i][j] = False
            return False

        for i in range(rows):
            for j in range(cols):
                if backtrack(i, j, 0):
                    return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n \times 2^l)$，其中 $m$、$n$ 为二维矩阵 $board$的行数和列数。$l$ 为字符串 $word$ 的长度。
- **空间复杂度**：$O(m \times n)$。

# [0080. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

- 标签：数组、双指针
- 难度：中等

## 题目链接

- [0080. 删除有序数组中的重复项 II - 力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

## 题目大意

**描述**：给定一个有序数组 $nums$。

**要求**：在原数组空间基础上删除重复出现 $2$ 次以上的元素，并返回删除后数组的新长度。

**说明**：

- $1 \le nums.length \le 3 * 10^4$。
- $-10^4 \le nums[i] \le 10^4$。
- $nums$ 已按升序排列。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```

- 示例 2：

```python
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

## 解题思路

### 思路 1：快慢指针

因为数组是有序的，所以重复元素必定是连续的。可以使用快慢指针来解决。具体做法如下：

1. 使用两个指针 $slow$，$fast$。$slow$ 指针指向即将放置元素的位置，$fast$ 指针指向当前待处理元素。
2. 本题要求相同元素最多出现 $2$ 次，并且 $slow - 2$ 是上上次放置了元素的位置。则应该检查 $nums[slow - 2]$ 和当前待处理元素 $nums[fast]$ 是否相同。
   1. 如果 $nums[slow - 2] == nums[fast]$ 时，此时必有 $nums[slow - 2] == nums[slow - 1] == nums[fast]$，则当前 $nums[fast]$ 不保留，直接向右移动快指针 $fast$。
   2. 如果 $nums[slow - 2] \ne nums[fast]$ 时，则保留 $nums[fast]$。将 $nums[fast]$ 赋值给 $nums[slow]$ ，同时将 $slow$ 右移。然后再向右移动快指针 $fast$。
3. 这样 $slow$ 指针左边均为处理好的数组元素，而从 $slow$ 指针指向的位置开始， $fast$ 指针左边都为舍弃的重复元素。
4. 遍历结束之后，此时 $slow$ 就是新数组的长度。

### 思路 1：代码

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        size = len(nums)
        if size <= 2:
            return size
        slow, fast = 2, 2
        while (fast < size):
            if nums[slow - 2] != nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。# [0081. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0081. 搜索旋转排序数组 II - 力扣](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

## 题目大意

**描述**：一个按照升序排列的整数数组 $nums$，在位置的某个下标 $k$ 处进行了旋转操作。（例如：$[0, 1, 2, 5, 6, 8]$ 可能变为 $[5, 6, 8, 0, 1, 2]$）。

现在给定旋转后的数组 $nums$ 和一个整数 $target$。

**要求**：编写一个函数来判断给定的 $target$ 是否存在与数组中。如果存在则返回 `True`，否则返回 `False`。

**说明**：

- $1 \le nums.length \le 5000$。
- $-10^4 \le nums[i] \le 10^4$。
- 题目数据保证 $nums$ 在预先未知的某个下标上进行了旋转。
- $-10^4 \le target \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

- 示例 2：

```python
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

## 解题思路

### 思路 1：二分查找

这道题算是「[0033. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)」的变形，只不过输出变为了判断。

原本为升序排列的数组 nums 经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。

```
          *
        *
      *
    *
  *
*
```

```
    *
  *
*
          *
        *
      *
```

最直接的办法就是遍历一遍，找到目标值 target。但是还可以有更好的方法。考虑用二分查找来降低算法的时间复杂度。

我们将旋转后的数组看成左右两个升序部分：左半部分和右半部分。

有人会说第一种情况不是只有一个部分吗？其实我们可以把第一种情况中的整个数组看做是左半部分，然后右半部分为空数组。

然后创建两个指针 $left$、$right$，分别指向数组首尾。让后计算出两个指针中间值 $mid$。将 $mid$ 与两个指针做比较，并考虑与 $target$ 的关系。

- 如果 $nums[mid] > nums[left]$，则 $mid$ 在左半部分（因为右半部分值都比 $nums[left]$ 小）。
  - 如果 $nums[mid] \ge target$，并且 $target \ge nums[left]$，则 $target$ 在左半部分，并且在 $mid$ 左侧，此时应将 $right$ 左移到 $mid - 1$ 位置。
  - 否则如果 $nums[mid] < target$，则 $target$ 在左半部分，并且在 $mid$ 右侧，此时应将 $left$ 右移到 $mid + 1$。
  - 否则如果 $nums[left] > target$，则 $target$ 在右半部分，应将 $left$ 移动到 $mid + 1$ 位置。

- 如果 $nums[mid] < nums[left]$，则 $mid$ 在右半部分（因为右半部分值都比 $nums[left]$ 小）。
  - 如果 $nums[mid] < target$，并且 $target \le nums[right]$，则 $target$ 在右半部分，并且在 $mid$ 右侧，此时应将 $left$ 右移到 $mid + 1$ 位置。
  - 否则如果 $nums[mid] \ge target$，则 $target$ 在右半部分，并且在 $mid$ 左侧，此时应将 $right$ 左移到 $mid - 1$ 位置。
  - 否则如果 $nums[right] < target$，则 $target$ 在左半部分，应将 $right$ 左移到 $mid - 1$ 位置。
- 最终判断 $nums[left]$ 是否等于 $target$，如果等于，则返回 `True`，否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        n = len(nums)
        if n == 0:
            return False

        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2

            if nums[mid] > nums[left]:
                if nums[left] <= target and target <= nums[mid]:
                    right = mid
                else:
                    left = mid + 1
            elif nums[mid] < nums[left]:
                if nums[mid] < target and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid
            else:
                if nums[mid] == target:
                    return True
                else:
                    left = left + 1

        return nums[left] == target
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 $nums$ 的长度。最坏情况下数组元素均相等且不为 $target$，我们需要访问所有位置才能得出结果。
- **空间复杂度**：$O(1)$。

# [0082. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

- 标签：链表、双指针
- 难度：中等

## 题目链接

- [0082. 删除排序链表中的重复元素 II - 力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

## 题目大意

**描述**：给定一个已排序的链表的头 $head$。

**要求**：删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。

**说明**：

- 链表中节点数目在范围 $[0, 300]$ 内。
- $-100 \le Node.val \le 100$。
- 题目数据保证链表已经按升序排列。

**示例**：

- 示例 1：

```python
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

## 解题思路

### 思路 1：遍历

这道题的题意是需要保留所有不同数字，而重复出现的所有数字都要删除。因为给定的链表是升序排列的，所以我们要删除的重复元素在链表中的位置是连续的。所以我们可以对链表进行一次遍历，然后将连续的重复元素从链表中删除即可。具体步骤如下：

- 先使用哑节点 $dummy\underline{\hspace{0.5em}}head$ 构造一个指向 $head$ 的指针，使得可以防止从 $head$ 开始就是重复元素。
- 然后使用指针 $cur$ 表示链表中当前元素，从 $head$ 开始遍历。
- 当指针 $cur$ 的下一个元素和下下一个元素存在时：
  - 如果下一个元素值和下下一个元素值相同，则我们使用指针 $temp$ 保存下一个元素，并使用 $temp$ 向后遍历，跳过所有重复元素，然后令 $cur$ 的下一个元素指向 $temp$ 的下一个元素，继续向后遍历。
  - 如果下一个元素值和下下一个元素值不同，则令 $cur$ 向右移动一位，继续向后遍历。
- 当指针 $cur$ 的下一个元素或者下下一个元素不存在时，说明已经遍历完，则返回哑节点 $dummy\underline{\hspace{0.5em}}head$ 的下一个节点作为头节点。

### 思路 1：代码

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy_head = ListNode(-1)
        dummy_head.next = head

        cur = dummy_head
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                temp = cur.next
                while temp and temp.next and temp.val == temp.next.val:
                    temp = temp.next
                cur.next = temp.next
            else:
                cur = cur.next
        return dummy_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为链表长度。
- **空间复杂度**：$O(1)$。# [0083. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

- 标签：链表
- 难度：简单

## 题目链接

- [0083. 删除排序链表中的重复元素 - 力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

## 题目大意

**描述**：给定一个已排序的链表的头 $head$。

**要求**：删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。

**说明**：

- 链表中节点数目在范围 $[0, 300]$ 内。
- $-100 \le Node.val \le 100$。
- 题目数据保证链表已经按升序排列。

**示例**：

- 示例 1：

```python
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

## 解题思路

### 思路 1：遍历

- 使用指针 $curr$ 遍历链表，先将 $head$ 保存到 $curr$ 指针。
- 判断当前元素的值和当前元素下一个节点元素值是否相等。
- 如果相等，则让当前指针指向当前指针下两个节点。
- 否则，让 $curr$ 继续向后遍历。
- 遍历完之后返回头节点 $head$。

### 思路 1：遍历代码

```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if head == None:
            return head

        curr = head
        while curr.next:
            if curr.val == curr.next.val:
                curr.next = curr.next.next
            else:
                curr = curr.next
        return head
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为链表长度。
- **空间复杂度**：$O(1)$。# [0084. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

- 标签：栈、数组、单调栈
- 难度：困难

## 题目链接

- [0084. 柱状图中最大的矩形 - 力扣](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

## 题目大意

给定一个非负整数数组 `heights` ，`heights[i]` 用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

要求：计算出在该柱状图中，能够勾勒出来的矩形的最大面积。

## 解题思路

思路一：枚举「宽度」。一重循环枚举所有柱子，第二重循环遍历柱子右侧的柱子，所得的宽度就是两根柱子形成区间的宽度，高度就是这段区间中的最小高度。然后计算出对应面积，记录并更新最大面积。这样下来，时间复杂度为 $O(n^2)$。

思路二：枚举「高度」。一重循环枚举所有柱子，以柱子高度为当前矩形高度，然后向两侧延伸，遇到小于当前矩形高度的情况就停止。然后计算当前矩形面积，记录并更新最大面积。这样下来，时间复杂度也是 $O(n^2)$。

思路三：利用「单调栈」减少两侧延伸的复杂度。

- 枚举所有柱子。
- 如果当前柱子高度较大，大于等于栈顶柱体的高度，则直接将当前柱体入栈。
- 如果当前柱体高度较小，小于栈顶柱体的高度，则一直出栈，直到当前柱体大于等于栈顶柱体高度。
  - 出栈后，说明当前柱体是出栈柱体向右找到的第一个小于当前柱体高度的柱体，那么就可以向右将宽度扩展到当前柱体。
  - 出栈后，说明新的栈顶柱体是出栈柱体向左找到的第一个小于新的栈顶柱体高度的柱体，那么就可以向左将宽度扩展到新的栈顶柱体。
  - 以新的栈顶柱体为左边界，当前柱体为右边界，以出栈柱体为高度。计算矩形面积，然后记录并更新最大面积。

## 代码

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        ans = 0
        stack = []
        for i in range(len(heights)):
            while stack and heights[stack[-1]] >= heights[i]:
                cur = stack.pop(-1)
                left = stack[-1] + 1 if stack else 0
                right = i - 1
                ans = max(ans, (right - left + 1) * heights[cur])
            stack.append(i)

        return ans
```

# [0088. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

- 标签：数组、双指针、排序
- 难度：简单

## 题目链接

- [0088. 合并两个有序数组 - 力扣](https://leetcode.cn/problems/merge-sorted-array/)

## 题目大意

**描述**：给定两个有序数组 $nums1$、$nums2$。

**要求**：将 $nums2$ 合并到 $nums1$ 中，使 $nums1$ 成为一个有序数组。

**说明**：

- 给定数组 $nums1$ 空间大小为$ m + n$ 个，其中前 $m$ 个为 $nums1$ 的元素。$nums2$ 空间大小为 $n$。这样可以用 $nums1$ 的空间来存储最终的有序数组。
- $nums1.length == m + n$。
- $nums2.length == n$。
- $0 \le m, n \le 200$。
- $1 \le m + n \le 200$。
- $-10^9 \le nums1[i], nums2[j] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

- 示例 2：

```python
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

## 解题思路

### 思路 1：快慢指针

1. 将两个指针 $index1$、$index2$ 分别指向 $nums1$、$nums2$ 数组的尾部，再用一个指针 $index$ 指向数组 $nums1$ 的尾部。
2. 从后向前判断当前指针下 $nums1[index1]$ 和 $nums[index2]$ 的值大小，将较大值存入 $num1[index]$ 中，然后继续向前遍历。
3. 最后再将 $nums2$ 中剩余元素赋值到 $num1$ 前面对应位置上。

### 思路 1：代码

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        index1 = m - 1
        index2 = n - 1
        index = m + n - 1
        while index1 >= 0 and index2 >= 0:
            if nums1[index1] < nums2[index2]:
                nums1[index] = nums2[index2]
                index2 -= 1
            else:
                nums1[index] = nums1[index1]
                index1 -= 1
            index -= 1

        nums1[:index2+1] = nums2[:index2+1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$。
- **空间复杂度**：$O(m + n)$。
# [0089. 格雷编码](https://leetcode.cn/problems/gray-code/)

- 标签：位运算、数学、回溯
- 难度：中等

## 题目链接

- [0089. 格雷编码 - 力扣](https://leetcode.cn/problems/gray-code/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回任一有效的 $n$ 位格雷码序列。

**说明**：

- **n 位格雷码序列**：是一个由 $2^n$ 个整数组成的序列，其中：
  - 每个整数都在范围 $[0, 2^n - 1]$ 内（含 $0$ 和 $2^n - 1$）。
  - 第一个整数是 $0$。
  - 一个整数在序列中出现不超过一次。
  - 每对相邻整数的二进制表示恰好一位不同 ，且第一个和最后一个整数的二进制表示恰好一位不同。

- $1 \le n \le 16$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

- 示例 2：

```python
输入：n = 1
输出：[0,1]
```

## 解题思路

### 思路 1：位运算 + 公式法

- 格雷编码生成规则：以二进制值为 $0$ 的格雷编码作为第 $0$ 项，第一次改变最右边的数位，第二次改变从右边数第一个为 $1$ 的数位左边的数位，第三次跟第一次一样，改变最右边的数位，第四次跟第二次一样，改变从右边数第一个为 $1$ 的数位左边的数位。此后，第五、六次，第七、八次 ... 都跟第一二次一样反复进行，直到生成 $2^n$​ 个格雷编码。

- 也可以直接利用二进制转换为格雷编码公式：

  ![image.png](https://pic.leetcode-cn.com/1013850d7f6c8cf1d99dc0ac3292264b74f6a52d84e0215f540c80952e184f41-image.png)

### 思路 1：代码

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        gray = []
        binary = 0
        while binary < (1 << n):
            gray.append(binary ^ binary >> 1)
            binary += 1
        return gray
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n)$。
- **空间复杂度**：$O(1)$。
# [0090. 子集 II](https://leetcode.cn/problems/subsets-ii/)

- 标签：位运算、数组、回溯
- 难度：中等

## 题目链接

- [0090. 子集 II - 力扣](https://leetcode.cn/problems/subsets-ii/)

## 题目大意

**描述**：给定一个整数数组 `nums`，其中可能包含重复元素。

**要求**：返回该数组所有可能的子集（幂集）。

**说明**：

- 解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。
- $1 \le nums.length \le 10$。
- $-10 \le nums[i] \le 10$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

## 解题思路

### 思路 1：回溯算法

数组的每个元素都有两个选择：选与不选。

我们可以通过向当前子集数组中添加可选元素来表示选择该元素。也可以在当前递归结束之后，将之前添加的元素从当前子集数组中移除（也就是回溯）来表示不选择该元素。

因为数组中可能包含重复元素，所以我们可以先将数组排序，然后在回溯时，判断当前元素是否和上一个元素相同，如果相同，则直接跳过，从而去除重复元素。

回溯算法解决这道题的步骤如下：

- 先对数组 `nums` 进行排序。
- 从第 `0` 个位置开始，调用 `backtrack` 方法进行深度优先搜索。
- 将当前子集数组 `sub_set` 添加到答案数组 `sub_sets` 中。
- 然后从当前位置开始，到数组结束为止，枚举出所有可选的元素。对于每一个可选元素：
  - 如果当前元素与上一个元素相同，则跳过当前生成的子集。
  - 将可选元素添加到当前子集数组 `sub_set` 中。
  - 在选择该元素的情况下，继续递归考虑下一个元素。
  - 进行回溯，撤销选择该元素。即从当前子集数组 `sub_set` 中移除之前添加的元素。

### 思路 1：代码

```python
class Solution:
    def backtrack(self, nums, index, res, path):
        res.append(path[:])

        for i in range(index, len(nums)):
            if i > index and nums[i] == nums[i - 1]:
                continue
            path.append(nums[i])
            self.backtrack(nums, i + 1, res, path)
            path.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res, path = [], []
        self.backtrack(nums, 0, res, path)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。

### 思路 2：二进制枚举

对于一个元素个数为 `n` 的集合 `nums`  来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 `1` 来表示选取该元素，用数字 `0` 来表示不选取该元素。

那么我们就可以用一个长度为 `n` 的二进制数来表示集合 `nums` 或者表示 `nums` 的子集。其中二进制的每一位数都对应了集合中某一个元素的选取状态。对于集合中第 `i` 个元素（`i` 从 `0` 开始编号）来说，二进制对应位置上的 `1` 代表该元素被选取，`0` 代表该元素未被选取。

举个例子来说明一下，比如长度为 `5` 的集合 `nums = {5, 4, 3, 2, 1}`，我们可以用一个长度为 `5` 的二进制数来表示该集合。 

比如二进制数 `11111` 就表示选取集合的第 `0` 位、第 `1` 位、第 `2` 位、第 `3` 位、第 `4` 位元素，也就是集合 `{5, 4, 3, 2, 1}` ，即集合 `nums`  本身。如下表所示：

| 集合 nums 对应位置（下标） |  4   |  3   |  2   |  1   |  0   |
| :------------------------- | :--: | :--: | :--: | :--: | :--: |
| 二进制数对应位数           |  1   |  1   |  1   |  1   |  1   |
| 对应选取状态               | 选取 | 选取 | 选取 | 选取 | 选取 |

再比如二进制数 `10101` 就表示选取集合的第 `0` 位、第 `2` 位、第 `5` 位元素，也就是集合 `{5, 3, 1}`。如下表所示：

| 集合 nums 对应位置（下标） |  4   |   3    |  2   |   1    |  0   |
| :------------------------- | :--: | :----: | :--: | :----: | :--: |
| 二进制数对应位数           |  1   |   0    |  1   |   0    |  1   |
| 对应选取状态               | 选取 | 未选取 | 选取 | 未选取 | 选取 |

再比如二进制数 `01001` 就表示选取集合的第 `0` 位、第 `3` 位元素，也就是集合 `{5, 2}`。如下标所示：

| 集合 nums 对应位置（下标） |   4    |  3   |   2    |   1    |  0   |
| :------------------------- | :----: | :--: | :----: | :----: | :--: |
| 二进制数对应位数           |   0    |  1   |   0    |   0    |  1   |
| 对应选取状态               | 未选取 | 选取 | 未选取 | 未选取 | 选取 |

通过上面的例子我们可以得到启发：对于长度为 `5` 的集合 `nums` 来说，我们只需要从 `00000` ~ `11111` 枚举一次（对应十进制为 $0 \sim 2^4 - 1$）即可得到长度为 `5` 的集合 `S` 的所有子集。

我们将上面的例子拓展到长度为 `n` 的集合 `nums`。可以总结为：

- 对于长度为 `5` 的集合 `nums` 来说，只需要枚举 $0 \sim 2^n - 1$（共 $2^n$ 种情况），即可得到所有的子集。

因为数组中可能包含重复元素，所以我们可以先对数组进行排序。然后在枚举过程中，如果发现当前元素和上一个元素相同，则直接跳过当前生层的子集，从而去除重复元素。

### 思路 2：代码

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)                       # n 为集合 nums 的元素个数
        sub_sets = []                       # sub_sets 用于保存所有子集
        for i in range(1 << n):             # 枚举 0 ~ 2^n - 1
            sub_set = []                    # sub_set 用于保存当前子集
            flag = True                     # flag 用于判断重复元素
            for j in range(n):  # 枚举第 i 位元素
                if i >> j & 1:  # 如果第 i 为元素对应二进制位为 1，则表示选取该元素
                    if j > 0 and (i >> (j - 1) & 1) == 0 and nums[j] == nums[j - 1]:
                        flag = False        # 如果出现重复元素，则跳过当前生成的子集
                        break
                    sub_set.append(nums[j]) # 将选取的元素加入到子集 sub_set 中
            if flag:
                sub_sets.append(sub_set)    # 将子集 sub_set 加入到所有子集数组 sub_sets 中
        return sub_sets                     # 返回所有子集
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。
# [0091. 解码方法](https://leetcode.cn/problems/decode-ways/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0091. 解码方法 - 力扣](https://leetcode.cn/problems/decode-ways/)

## 题目大意

**描述**：给定一个数字字符串 $s$。该字符串已经按照下面的映射关系进行了编码：

- `A` 映射为 $1$。
- `B` 映射为 $2$。
- ...
- `Z` 映射为 $26$。

基于上述映射的方法，现在对字符串 $s$ 进行「解码」。即从数字到字母进行反向映射。比如 `"11106"` 可以映射为：

- `"AAJF"`，将消息分组为 $(1 1 10 6)$。
- `"KJF"`，将消息分组为 $(11 10 6)$。

**要求**：计算出共有多少种可能的解码方案。

**说明**：

- $1 \le s.length \le 100$。
- $s$ 只包含数字，并且可能包含前导零。
- 题目数据保证答案肯定是一个 $32$ 位的整数。

**示例**：

- 示例 1：

```python
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：字符串 $s$ 前 $i$ 个字符构成的字符串可能构成的翻译方案数。

###### 3. 状态转移方程

$dp[i]$ 的来源有两种情况：

1. 使用了一个字符，对 $s[i]$ 进行翻译。只要 $s[i] != 0$，就可以被翻译为 `A` ~ `I` 的某个字母，此时方案数为 $dp[i] = dp[i - 1]$。
2. 使用了两个字符，对 $s[i - 1]$ 和 $s[i]$ 进行翻译，只有 $s[i - 1] != 0$，且 $s[i - 1]$ 和 $s[i]$ 组成的整数必须小于等于 $26$ 才能翻译，可以翻译为 `J` ~ `Z` 中的某字母，此时方案数为 $dp[i] = dp[i - 2]$。

这两种情况有可能是同时存在的，也有可能都不存在。在进行转移的时候，将符合要求的方案数累加起来即可。

状态转移方程可以写为：

$dp[i] += \begin{cases} dp[i-1] & \quad s[i] \ne 0 \cr dp[i-2] & \quad s[i-1] \ne 0, s[i-1:i] \le 26 \end{cases}$

###### 4. 初始条件

- 字符串为空时，只有一个翻译方案，翻译为空字符串，即 $dp[0] = 1$。
- 字符串只有一个字符时，需要考虑该字符是否为 $0$，不为 $0$ 的话，$dp[1] = 1$，为 $0$ 的话，$dp[0] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：字符串 $s$ 前 $i$ 个字符构成的字符串可能构成的翻译方案数。则最终结果为 $dp[size]$，$size$ 为字符串长度。


### 思路 1：动态规划代码

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        size = len(s)
        dp = [0 for _ in range(size + 1)]
        dp[0] = 1
        for i in range(1, size + 1):
            if s[i - 1] != '0':
                dp[i] += dp[i - 1]
            if i > 1 and s[i - 2] != '0' and int(s[i - 2: i]) <= 26:
                dp[i] += dp[i - 2]
        return dp[size]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度是 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。
# [0092. 反转链表 II ](https://leetcode.cn/problems/reverse-linked-list-ii/)

- 标签：链表
- 难度：中等

## 题目链接

- [0092. 反转链表 II  - 力扣](https://leetcode.cn/problems/reverse-linked-list-ii/)

## 题目大意

**描述**：给定单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right`。

**要求**：反转从位置 `left` 到位置 `right` 的链表节点，返回反转后的链表 。

**说明**：

- 链表中节点数目为 `n`。
- $1 \le n \le 500$。
- $-500 \le Node.val \le 500$。
- $1 \le left \le right \le n$。

**示例**：

- 示例 1：

```python
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

## 解题思路

在「[0206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)」中我们可以通过迭代、递归两种方法将整个链表反转。这道题而这道题要求对链表的部分区间进行反转。我们同样可以通过迭代、递归两种方法将链表的部分区间进行反转。

### 思路 1：迭代

我们可以先遍历到需要反转的链表区间的前一个节点，然后对需要反转的链表区间进行迭代反转。最后再返回头节点即可。

但是需要注意一点，如果需要反转的区间包含了链表的第一个节点，那么我们可以事先创建一个哑节点作为链表初始位置开始遍历，这样就能避免找不到需要反转的链表区间的前一个节点。

这道题的具体解题步骤如下：

1. 先使用哑节点 `dummy_head` 构造一个指向 `head` 的指针，使得可以从 `head` 开始遍历。使用 `index` 记录当前元素的序号。
2. 我们使用一个指针 `reverse_start`，初始赋值为 `dummy_head`。然后向右逐步移动到需要反转的区间的前一个节点。
3. 然后再使用两个指针 `cur` 和 `pre` 进行迭代。`pre` 指向 `cur` 前一个节点位置，即 `pre` 指向需要反转节点的前一个节点，`cur` 指向需要反转的节点。初始时，`pre` 指向 `reverse_start`，`cur` 指向 `pre.next`。
4. 当当前节点 `cur` 不为空，且 `index` 在反转区间内时，将 `pre` 和 `cur` 的前后指针进行交换，指针更替顺序为：
   1. 使用 `next` 指针保存当前节点 `cur` 的后一个节点，即 `next = cur.next`；
   2. 断开当前节点 `cur` 的后一节点链接，将 `cur` 的 `next` 指针指向前一节点 `pre`，即 `cur.next = pre`；
   3. `pre` 向前移动一步，移动到 `cur` 位置，即 `pre = cur`；
   4. `cur` 向前移动一步，移动到之前 `next` 指针保存的位置，即 `cur = next`。
   5. 然后令 `index` 加 `1`。
5. 继续执行第 `4` 步中的 `1`、`2`、`3`、`4`、`5` 步。
6. 最后等到 `cur` 遍历到链表末尾（即 `cur == None`）或者遍历到需要反转区间的末尾时（即 `index > right`） 时，将反转区间的头尾节点分别与之前保存的需要反转的区间的前一个节点 `reverse_start` 相连，即 `reverse_start.next.next = cur`，`reverse_start.next = pre`。
7. 最后返回新的头节点 `dummy_head.next`。

### 思路 1：代码

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        index = 1
        dummy_head = ListNode(0)
        dummy_head.next = head
        pre = dummy_head

        reverse_start = dummy_head
        while reverse_start.next and index < left:
            reverse_start = reverse_start.next
            index += 1

        pre = reverse_start
        cur = pre.next
        while cur and index <= right:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
            index += 1

        reverse_start.next.next = cur
        reverse_start.next = pre
        
        return dummy_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是链表节点个数。
- **空间复杂度**：$O(1)$。

### 思路 2：递归算法

#### 1. 翻转链表前 n 个节点

1. 当 `left == 1`  时，无论 `right` 等于多少，实际上都是将当前链表到 `right` 部分进行翻转，也就是将前 `right` 个节点进行翻转。

2. 我们可以先定义一个递归函数 `reverseN(self, head, n)`，含义为：将链表前第 $n$ 个节点位置进行翻转。
   1. 然后从 `head.next` 的位置开始调用递归函数，即将 `head.next` 为头节点的链表的的前 $n - 1$ 个位置进行反转，并返回该链表的新头节点 `new_head`。
   2. 然后改变 `head`（原先头节点）和 `new_head`（新头节点）之间的指向关系，即将 `head` 指向的节点作为 `head` 下一个节点的下一个节点。
   3. 先保存 `head.next` 的 `next` 指针，也就是新链表前 $n$ 个节点的尾指针，即 `last = head.next.next`。
   4. 将 `head.next` 的`next` 指针先指向当前节点 `head`，即 `head.next.next = head `。
   5. 然后让当前节点 `head` 的 `next` 指针指向 `last`，则完成了前 $n - 1$ 个位置的翻转。

3. 递归终止条件：当 `n == 1` 时，相当于翻转第一个节点，直接返回 `head` 即可。

4. #### 翻转链表 `[left, right]` 上的节点。

接下来我们来翻转区间上的节点。

1. 定义递归函数 `reverseBetween(self, head, left, right)` 为
2. 

### 思路 2：代码

```python
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if left == 1:
            return self.reverseN(head, right)
        
        head.next = self.reverseBetween(head.next, left - 1, right - 1)
        return head
    
    def reverseN(self, head, n):
        if n == 1:
            return head
        last = self.reverseN(head.next, n - 1)
        next = head.next.next
        head.next.next = head
        head.next = next
        return last
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。最多需要 $n$ 层栈空间。

## 参考资料

- 【题解】[动画图解：翻转链表的指定区间 - 反转链表 II - 力扣](https://leetcode.cn/problems/reverse-linked-list-ii/solution/dong-hua-tu-jie-fan-zhuan-lian-biao-de-z-n4px/)
- 【题解】[【宫水三叶】一个能应用所有「链表」题里的「哨兵」技巧 - 反转链表 II - 力扣](https://leetcode.cn/problems/reverse-linked-list-ii/solution/yi-ge-neng-ying-yong-suo-you-lian-biao-t-vjx6/)

# [0093. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

- 标签：字符串、回溯
- 难度：中等

## 题目链接

- [0093. 复原 IP 地址 - 力扣](https://leetcode.cn/problems/restore-ip-addresses/)

## 题目大意

**描述**：给定一个只包含数字的字符串 `s`，用来表示一个 IP 地址

**要求**：返回所有由 `s` 构成的有效 IP 地址，这些地址可以通过在 `s` 中插入 `'.'` 来形成。不能重新排序或删除 `s` 中的任何数字。可以按任何顺序返回答案。

**说明**：

- **有效 IP 地址**：正好由四个整数（每个整数由 $0 \sim 255$ 的数构成，且不能含有前导 0），整数之间用 `.` 分割。
- $1 \le s.length \le 20$。
- `s` 仅由数字组成。

**示例**：

- 示例 1：

```python
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

- 示例 2：

```python
输入：s = "0000"
输出：["0.0.0.0"]
```

## 解题思路

### 思路 1：回溯算法

一个有效 IP 地址由四个整数构成，中间用 $3$ 个点隔开。现在给定的是无分隔的整数字符串，我们可以通过在整数字符串中间的不同位置插入 $3$ 个点来生成不同的 IP 地址。这个过程可以通过回溯算法来生成。

根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：全排列中每个位置上的元素都可以从剩余可选元素中选出，对此画出决策树，如下图所示。

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**

   1. 定义回溯函数：

      - `backtracking(index):` 函数的传入参数是 `index`（剩余字符开始位置），全局变量是 `res`（存放所有符合条件结果的集合数组）和 `path`（存放当前符合条件的结果）。
      - `backtracking(index):` 函数代表的含义是：递归从 `index` 位置开始，从剩下字符中，选择当前子段的值。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑的字符，到字符串结束为止，枚举出所有可作为当前子段值的字符。对于每一个子段值：
        - 约束条件：只能从 `index` 位置开始选择，并且要符合规则要求。
        - 选择元素：将其添加到当前子集数组 `path` 中。
        - 递归搜索：在选择该子段值的情况下，继续递归从剩下字符中，选择下一个子段值。
        - 撤销选择：将该子段值从当前结果数组 `path` 中移除。

    ```python
   for i in range(index, len(s)):    # 枚举可选元素列表
       sub = s[index: i + 1]
       # 如果当前值不在 0 ~ 255 之间，直接跳过
       if int(sub) > 255:
           continue
       # 如果当前值为 0，但不是单个 0（"00..."），直接跳过
       if int(sub) == 0 and i != index:
           continue
       # 如果当前值大于 0，但是以 0 开头（"0XX..."），直接跳过
       if int(sub) > 0 and s[index] == '0':
           continue
                   
       path.append(sub)              # 选择元素
       backtracking(i + 1)           # 递归搜索
       path.pop()                    # 撤销选择
    ```

   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是存放当前结果的数组 `path` 的长度等于 $4$，并且剩余字符开始位置为字符串结束位置（即 `len(path) == 4 and index == len(s)`）时，递归停止。
      - 如果回溯过程中，切割次数大于 4（即 `len(path) > 4`），递归停止，直接返回。

### 思路 1：代码

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        path = []
        def backtracking(index):
            # 如果切割次数大于 4，直接返回
            if len(path) > 4:            
                return

            # 切割完成，将当前结果加入答案结果数组中
            if len(path) == 4 and index == len(s):
                res.append('.'.join(path))
                return
            
            for i in range(index, len(s)):
                sub = s[index: i + 1]
                # 如果当前值不在 0 ~ 255 之间，直接跳过
                if int(sub) > 255:
                    continue
                # 如果当前值为 0，但不是单个 0（"00..."），直接跳过
                if int(sub) == 0 and i != index:
                    continue
                # 如果当前值大于 0，但是以 0 开头（"0XX..."），直接跳过
                if int(sub) > 0 and s[index] == '0':
                    continue
                
                path.append(sub)
                backtracking(i + 1)
                path.pop()

            
        backtracking(0)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(3^4 \times |s|)$，其中 $|s|$ 是字符串 `s` 的长度。由于 IP 地址的每一子段位数不会超过 $3$，因此在递归时，我们最多只会深入到下一层中的 $3$ 种情况。而 IP 地址由 $4$ 个子段构成，所以递归的最大层数为 $4$ 层，则递归的时间复杂度为 $O(3^4)$。而每次将有效的 IP 地址添加到答案数组的时间复杂度为 $|s|$，所以总的时间复杂度为 $3^4 \times |s|$。
- **空间复杂度**：$O(|s|)$，只记录除了用来存储答案数组之外的空间复杂度。

# [0094. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

- 标签：栈、树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0094. 二叉树的中序遍历 - 力扣](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：返回该二叉树的中序遍历结果。

**说明**：

- 树中节点数目在范围 $[0, 100]$ 内。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```python
输入：root = [1,null,2,3]
输出：[1,3,2]
```

- 示例 2：

```python
输入：root = []
输出：[]
```

## 解题思路

### 思路 1：递归遍历

二叉树的前序遍历递归实现步骤为：

1. 判断二叉树是否为空，为空则直接返回。
2. 先访问根节点。
3. 然后递归遍历左子树。
4. 最后递归遍历右子树。

### 思路 1：代码

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)

        inorder(root)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。

### 思路 2：模拟栈迭代遍历

二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用一个显式栈 `stack` 来模拟递归的过程。

前序遍历的顺序为：根节点 - 左子树 - 右子树，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终遍历顺序为前序遍历顺序。 

二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
   1. 弹出栈顶元素 `node`，并访问该元素。
   2. 如果 `node` 的右子树不为空，则将 `node` 的右子树入栈。
   3. 如果 `node` 的左子树不为空，则将 `node` 的左子树入栈。

### 思路 2：代码

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:                # 二叉树为空直接返回
            return []
        
        res = []
        stack = []

        while root or stack:        # 根节点或栈不为空
            while root:
                stack.append(root)  # 将当前树的根节点入栈
                root = root.left    # 找到最左侧节点
            
            node = stack.pop()      # 遍历到最左侧，当前节点无左子树时，将最左侧节点弹出
            res.append(node.val)    # 访问该节点
            root = node.right       # 尝试访问该节点的右子树
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。# [0095. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

- 标签：树、二叉搜索树、动态规划、回溯、二叉树
- 难度：中等

## 题目链接

- [0095. 不同的二叉搜索树 II - 力扣](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：请生成返回以 $1$ 到 $n$ 为节点构成的「二叉搜索树」，可以按任意顺序返回答案。

**说明**：

- $1 \le n \le 8$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```python
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

- 示例 2：

```python
输入：n = 1
输出：[[1]]
```

## 解题思路

### 思路 1：递归遍历

如果根节点为 $i$，则左子树的节点为 $(1, 2, ..., i - 1)$，右子树的节点为 $(i + 1, i + 2, ..., n)$。可以递归的构建二叉树。

定义递归函数 `generateTrees(start, end)`，表示生成 $[left, ..., right]$ 构成的所有可能的二叉搜索树。

- 如果 $start > end$，返回 `[None]`。
- 初始化存放所有可能二叉搜索树的数组。
- 遍历 $[left, ..., right]$ 的每一个节点 $i$，将其作为根节点。
  - 递归构建左右子树。
  - 将所有符合要求的左右子树组合起来，将其加入到存放二叉搜索树的数组中。
- 返回存放二叉搜索树的数组。

### 思路 1：代码

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n == 0:
            return []

        def generateTrees(start, end):
            if start > end:
                return [None]
            trees = []
            for i in range(start, end+1):
                left_trees = generateTrees(start, i - 1)
                right_trees = generateTrees(i + 1, end)
                for left_tree in left_trees:
                    for right_tree in right_trees:
                        curr_tree = TreeNode(i)
                        curr_tree.left = left_tree
                        curr_tree.right = right_tree
                        trees.append(curr_tree)
            return trees
        return generateTrees(1, n)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(C_n)$，其中 $C_n$ 是第 $n$ 个卡特兰数。
- **空间复杂度**：$O(C_n)$，其中 $C_n$ 是第 $n$ 个卡特兰数。

# [0096. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

- 标签：树、二叉搜索树、数学、动态规划、二叉树
- 难度：中等

## 题目链接

- [0096. 不同的二叉搜索树 - 力扣](https://leetcode.cn/problems/unique-binary-search-trees/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：求以 $1$ 到 $n$ 为节点构成的「二叉搜索树」有多少种？

**说明**：

- $1 \le n \le 19$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```python
输入：n = 3
输出：5
```

- 示例 2：

```python
输入：n = 1
输出：1
```

## 解题思路

### 思路 1：动态规划

一棵搜索二叉树的左、右子树，要么也是搜索二叉树，要么就是空树。

如果定义 $f[i]$ 表示以 $i$ 为根的二叉搜索树个数，定义 $g(i)$ 表示 $i$ 个节点可以构成的二叉搜索树个数，则有：

- $g(i) = f(1) + f(2) + f(3) + … + f(i)$。

其中当 $i$ 为根节点时，则用 $(1, 2, …, i - 1)$ 共 $i - 1$ 个节点去递归构建左子搜索二叉树，用 $(i + 1, i + 2, …, n)$ 共 $n - i$ 个节点去递归构建右子搜索树。则有：

- $f(i) = g(i - 1) \times g(n - i)$。

综合上面两个式子 $\begin{cases} g(i) = f(1) + f(2) + f(3) + … + f(i) \cr f(i) = g(i - 1) \times g(n - i) \end{cases}$ 可得出：

- $g(n) = g(0) \times g(n - 1) + g(1) \times g(n - 2) + … + g(n - 1) \times g(0)$。

将 $n$ 换为 $i$，可变为：

- $g(i) = g(0) \times g(i - 1) + g(1) \times g(i - 2) + … + g(i - 1) \times g(0)$。

再转换一下，可变为：

- $g(i) = \sum_{1 \le j \le i} \lbrace g(j - 1) \times g(i - j) \rbrace$。

则我们可以通过动态规划的方法，递推求解 $g(i)$，并求解出 $g(n)$。具体步骤如下：

###### 1. 划分阶段

按照根节点的编号进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为： $i$ 个节点可以构成的二叉搜索树个数。

###### 3. 状态转移方程

$dp[i] = \sum_{1 \le j \le i} \lbrace dp[j - 1] \times dp[i - j] \rbrace$

###### 4. 初始条件

- $0$ 个节点可以构成的二叉搜索树个数为 $1$（空树），即 $dp[0] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为： $i$ 个节点可以构成的二叉搜索树个数。。 所以最终结果为 $dp[n]$。

### 思路 1：代码

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        dp[0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[画解算法：96. 不同的二叉搜索树 - 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/)

# [0098. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0098. 验证二叉搜索树 - 力扣](https://leetcode.cn/problems/validate-binary-search-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：判断其是否是一个有效的二叉搜索树。

**说明**：

- **二叉搜索树特征**：
  - 节点的左子树只包含小于当前节点的数。
  - 节点的右子树只包含大于当前节点的数。
  - 所有左子树和右子树自身必须也是二叉搜索树。
- 树中节点数目范围在$[1, 10^4]$ 内。
- $-2^{31} \le Node.val \le 2^{31} - 1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```python
输入：root = [2,1,3]
输出：true
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```python
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

## 解题思路

### 思路 1：递归遍历

根据题意进行递归遍历即可。前序、中序、后序遍历都可以。

1. 以前序遍历为例，递归函数为：`preorderTraversal(root, min_v, max_v)`。
2. 前序遍历时，先判断根节点的值是否在 `(min_v, max_v)` 之间。
   1. 如果不在则直接返回 `False`。
   2. 如果在区间内，则继续递归检测左右子树是否满足，都满足才是一棵二叉搜索树。
3. 当递归遍历左子树的时候，要将上界 `max_v` 改为左子树的根节点值，因为左子树上所有节点的值均小于根节点的值。
4. 当递归遍历右子树的时候，要将下界 `min_v` 改为右子树的根节点值，因为右子树上所有节点的值均大于根节点。

### 思路 1：代码

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def preorderTraversal(root, min_v, max_v):
            if root == None:
                return True
            if root.val >= max_v or root.val <= min_v:
                return False
            return preorderTraversal(root.left, min_v, root.val) and preorderTraversal(root.right, root.val, max_v)

        return preorderTraversal(root, float('-inf'), float('inf'))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。# [0100. 相同的树](https://leetcode.cn/problems/same-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0100. 相同的树 - 力扣](https://leetcode.cn/problems/same-tree/)

## 题目大意

**描述**：给定两个二叉树的根节点 $p$ 和 $q$。

**要求**：判断这两棵树是否相同。

**说明**：

- **两棵树相同的定义**：结构上相同；节点具有相同的值。
- 两棵树上的节点数目都在范围 $[0, 100]$ 内。
- $-10^4 \le Node.val \le 10^4$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```python
输入：p = [1,2,3], q = [1,2,3]
输出：True
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```python
输入：p = [1,2], q = [1,null,2]
输出：False
```

## 解题思路

### 思路 1：递归

1. 先判断两棵树的根节点是否相同。
2. 然后再递归地判断左右子树是否相同。

### 思路 1：代码

```python
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        if not p or not q:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(min(m, n))$，其中 $m$、$n$ 分别为两棵树中的节点数量。
- **空间复杂度**：$O(min(m, n))$。
# [0101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0101. 对称二叉树 - 力扣](https://leetcode.cn/problems/symmetric-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：判断该二叉树是否是左右对称的。

**说明**：

- 树中节点数目在范围 $[1, 1000]$ 内。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```python
输入：root = [1,2,2,3,4,4,3]
输出：true
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```python
输入：root = [1,2,2,null,3,null,3]
输出：false
```

## 解题思路

### 思路 1：递归遍历

如果一棵二叉树是对称的，那么其左子树和右子树的外侧节点的节点值应当是相等的，并且其左子树和右子树的内侧节点的节点值也应当是相等的。

那么我们可以通过递归方式，检查其左子树与右子树外侧节点和内测节点是否相等。即递归检查左子树的左子节点值与右子树的右子节点值是否相等（外侧节点值是否相等），递归检查左子树的右子节点值与右子树的左子节点值是否相等（内测节点值是否相等）。

具体步骤如下：

1. 如果当前根节点为 `None`，则直接返回 `True`。
2. 如果当前根节点不为 `None`，则调用 `check(left, right)` 方法递归检查其左右子树是否对称。
   1. 如果左子树节点为 `None`，并且右子树节点也为 `None`，则直接返回 `True`。
   2. 如果左子树节点为 `None`，并且右子树节点不为 `None`，则直接返回 `False`。
   3. 如果左子树节点不为 `None`，并且右子树节点为 `None`，则直接返回 `False`。
   4. 如果左子树节点值不等于右子树节点值，则直接返回 `False`。
   5. 如果左子树节点不为 `None`，并且右子树节点不为 `None`，并且左子树节点值等于右子树节点值，则：
      1. 递归检测左右子树的外侧节点是否相等。
      2. 递归检测左右子树的内测节点是否相等。
      3. 如果左右子树的外侧节点、内测节点值相等，则返回 `True`。

### 思路 1：代码

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if root == None:
            return True
        return self.check(root.left, root.right)

    def check(self, left: TreeNode, right: TreeNode):
        if left == None and right == None:
            return True
        elif left == None and right != None:
            return False
        elif left != None and right == None:
            return False
        elif left.val != right.val:
            return False

        return self.check(left.left, right.right) and self.check(left.right, right.left)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0102. 二叉树的层序遍历 - 力扣](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：返回该二叉树按照「层序遍历」得到的节点值。

**说明**：

- 返回结果为二维数组，每一层都要存为数组返回。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```python
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

- 示例 2：

```python
输入：root = [1]
输出：[[1]
```

## 解题思路

### 思路 1：广度优先搜索

广度优先搜索，需要增加一些变化。普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 $i$ 层上所有元素。

具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 $s_i$。
4. 依次从队列中取出这 $s_i$ 个元素，并对这 $s_i$ 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

### 思路 1：代码

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            level = []
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                level.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if level:
                order.append(level)
        return order
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。# [0103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0103. 二叉树的锯齿形层序遍历 - 力扣](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：返回其节点值的锯齿形层序遍历结果。

**说明**：

- **锯齿形层序遍历**：从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```python
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

- 示例 2：

```python
输入：root = [1]
输出：[[1]]
```

## 解题思路

### 思路 1：广度优先搜索

在二叉树的层序遍历的基础上需要增加一些变化。

普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 `i` 层上所有元素。

新增一个变量 `odd`，用于判断当前层数是奇数层，还是偶数层。从而判断元素遍历方向。

存储每层元素的 `level` 列表改用双端队列，如果是奇数层，则从末尾添加元素。如果是偶数层，则从头部添加元素。

具体步骤如下：

1. 使用列表 `order` 存放锯齿形层序遍历结果，使用整数 `odd` 变量用于判断奇偶层，使用双端队列 `level` 存放每层元素，使用列表 `queue` 用于进行广度优先搜索。
2. 将根节点放入入队列中，即 `queue = [root]`。
3. 当队列 `queue` 不为空时，求出当前队列长度 $s_i$，并判断当前层数的奇偶性。
4. 依次从队列中取出这 $s_i$ 个元素。
   1. 如果当前层为奇数层，如果是奇数层，则从 `level` 末尾添加元素。
   2. 如果当前层是偶数层，则从 `level` 头部添加元素。
   3. 然后将当前元素的左右子节点加入队列 `queue` 中，然后继续迭代。
5. 将存储当前层元素的 `level` 存入答案列表 `order` 中。
6. 当队列为空时，结束。返回锯齿形层序遍历结果 `order`。

### 思路 1：代码

```python
import collections
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        order = []
        odd = True
        while queue:
            level = collections.deque()
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                if odd:
                    level.append(curr.val)
                else:
                    level.appendleft(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if level:
                order.append(list(level))
            odd = not odd
        return order
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。

# [0104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0104. 二叉树的最大深度 - 力扣](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：找出该二叉树的最大深度。

**说明**：

- **二叉树的深度**：根节点到最远叶子节点的最长路径上的节点数。
- **叶子节点**：没有子节点的节点。

**示例**：

- 示例 1：

```python
输入：[3,9,20,null,null,15,7]
对应二叉树
            3
           / \
          9  20
            /  \
           15   7
输出：3
解释：该二叉树的最大深度为 3
```

## 解题思路

### 思路 1： 递归算法

根据递归三步走策略，写出对应的递归代码。

1. 写出递推公式：`当前二叉树的最大深度 = max(当前二叉树左子树的最大深度, 当前二叉树右子树的最大深度) + 1`。
   - 即：先得到左右子树的高度，在计算当前节点的高度。
2. 明确终止条件：当前二叉树为空。
3. 翻译为递归代码：
   1. 定义递归函数：`maxDepth(self, root)` 表示输入参数为二叉树的根节点 `root`，返回结果为该二叉树的最大深度。
   2. 书写递归主体：`return max(self.maxDepth(root.left) + self.maxDepth(root.right))`。
   3. 明确递归终止条件：`if not root: return 0`

### 思路 1：代码

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。# [0105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

- 标签：树、数组、哈希表、分治、二叉树
- 难度：中等

## 题目链接

- [0105. 从前序与中序遍历序列构造二叉树 - 力扣](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## 题目大意

**描述**：给定一棵二叉树的前序遍历结果 `preorder` 和中序遍历结果 `inorder`。

**要求**：构造出该二叉树并返回其根节点。

**说明**：

- $1 \le preorder.length \le 3000$。
- $inorder.length == preorder.length$。
- $-3000 \le preorder[i], inorder[i] \le 3000$。
- `preorder` 和 `inorder` 均无重复元素。
- `inorder` 均出现在 `preorder`。
- `preorder` 保证为二叉树的前序遍历序列。
- `inorder` 保证为二叉树的中序遍历序列。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```python
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

- 示例 2：

```python
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

## 解题思路

### 思路 1：递归遍历

前序遍历的顺序是：根 -> 左 -> 右。中序遍历的顺序是：左 -> 根 -> 右。根据前序遍历的顺序，可以找到根节点位置。然后在中序遍历的结果中可以找到对应的根节点位置，就可以从根节点位置将二叉树分割成左子树、右子树。同时能得到左右子树的节点个数。此时构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历进行上述步骤，直到节点为空，具体操作步骤如下：

1. 从前序遍历顺序中当前根节点的位置在 `postorder[0]`。
2. 通过在中序遍历中查找上一步根节点对应的位置 `inorder[k]`，从而将二叉树的左右子树分隔开，并得到左右子树节点的个数。
3. 从上一步得到的左右子树个数将前序遍历结果中的左右子树分开。
4. 构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历并执行上述三步，直到节点为空。

### 思路 1：代码

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def createTree(preorder, inorder, n):
            if n == 0:
                return None
            k = 0
            while preorder[0] != inorder[k]:
                k += 1
            node = TreeNode(inorder[k])
            node.left = createTree(preorder[1: k+1], inorder[0: k], k)
            node.right = createTree(preorder[k+1:], inorder[k+1:], n-k-1)
            return node
        return createTree(preorder, inorder, len(inorder))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。# [0106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

- 标签：树、数组、哈希表、分治、二叉树
- 难度：中等

## 题目链接

- [0106. 从中序与后序遍历序列构造二叉树 - 力扣](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## 题目大意

**描述**：给定一棵二叉树的中序遍历结果 `inorder` 和后序遍历结果 `postorder`。

**要求**：构造出该二叉树并返回其根节点。

**说明**：

- $1 \le inorder.length \le 3000$。
- $postorder.length == inorder.length$。
- $-3000 \le inorder[i], postorder[i] \le 3000$。
- `inorder` 和 `postorder` 都由不同的值组成。
- `postorder` 中每一个值都在 `inorder` 中。
- `inorder` 保证是二叉树的中序遍历序列。
- `postorder` 保证是二叉树的后序遍历序列。
- `inorder` 保证为二叉树的中序遍历序列。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```python
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

- 示例 2：

```python
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

## 解题思路

### 思路 1：递归

中序遍历的顺序是：左 -> 根 -> 右。后序遍历的顺序是：左 -> 右 -> 根。根据后序遍历的顺序，可以找到根节点位置。然后在中序遍历的结果中可以找到对应的根节点位置，就可以从根节点位置将二叉树分割成左子树、右子树。同时能得到左右子树的节点个数。此时构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历进行上述步骤，直到节点为空，具体操作步骤如下：

1. 从后序遍历顺序中当前根节点的位置在 `postorder[n - 1]`。
2. 通过在中序遍历中查找上一步根节点对应的位置 `inorder[k]`，从而将二叉树的左右子树分隔开，并得到左右子树节点的个数。
3. 从上一步得到的左右子树个数将后序遍历结果中的左右子树分开。
4. 构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历并执行上述三步，直到节点为空。

### 思路 1：代码

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        def createTree(inorder, postorder, n):
            if n == 0:
                return None
            k = 0
            while postorder[n-1] != inorder[k]:
                k += 1
            node = TreeNode(inorder[k])
            node.right = createTree(inorder[k+1: n], postorder[k: n-1], n-k-1)
            node.left = createTree(inorder[0: k], postorder[0: k], k)
            return node
        return createTree(inorder, postorder, len(postorder))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0107. 二叉树的层序遍历 II - 力扣](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

## 题目大意

**描述**：给定一个二叉树的根节点 $root$。

**要求**：返回其节点值按照「自底向上」的「层序遍历」（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。

**说明**：

- 树中节点数目在范围 $[0, 2000]$ 内。
- $-1000 \le Node.val \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```python
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

- 示例 2：

```python
输入：root = [1]
输出：[[1]]
```

## 解题思路

### 思路 1：二叉树的层次遍历

先得到层次遍历的节点顺序，再将其进行反转返回即可。

其中层次遍历用到了广度优先搜索，不过需要增加一些变化。普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 i 层上所有元素。

具体步骤如下：

1. 根节点入队。
2. 当队列不为空时，求出当前队列长度 $s_i$。
3. 依次从队列中取出这 $s_i$ 个元素，将其左右子节点入队，然后继续迭代。
4. 当队列为空时，结束。

### 思路 1：代码

```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            level = []
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                level.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if level:
                order.append(level)
        return order[::-1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中节点个数。
- **空间复杂度**：$O(n)$。

# [0108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

- 标签：树、二叉搜索树、数组、分治、二叉树
- 难度：简单

## 题目链接

- [0108. 将有序数组转换为二叉搜索树 - 力扣](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

## 题目大意

**描述**：给定一个升序的有序数组 `nums`。

**要求**：将其转换为一棵高度平衡的二叉搜索树。

**说明**：

- $1 \le nums.length \le 10^4$。
- $-10^4 \le nums[i] \le 10^4$。
- `nums` 按严格递增顺序排列。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```python
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案
```

- 示例 2：

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```python
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

## 解题思路

### 思路 1：递归遍历

直观上，如果把数组的中间元素当做根，那么数组左侧元素都小于根节点，右侧元素都大于根节点，且左右两侧元素个数相同，或最多相差 $1$ 个。那么构建的树高度差也不会超过 $1$。

所以猜想出：如果左右子树越平均，树就越平衡。这样我们就可以每次取中间元素作为当前的根节点，两侧的元素作为左右子树递归建树，左侧区间 $[L, mid - 1]$ 作为左子树，右侧区间 $[mid + 1, R]$ 作为右子树。

### 思路 1：代码

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def build(left, right):
            if left > right:
                return 
            mid = left + (right - left) // 2
            root = TreeNode(nums[mid])
            root.left = build(left, mid - 1)
            root.right = build(mid + 1, right)
            return root
        return build(0, len(nums) - 1)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是数组的长度。
- **空间复杂度**：$O(n)$。# [0110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

- 标签：树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0110. 平衡二叉树 - 力扣](https://leetcode.cn/problems/balanced-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：判断该二叉树是否是高度平衡的二叉树。

**说明**：

- **高度平衡二叉树**：二叉树中每个节点的左右两个子树的高度差的绝对值不超过 $1$。
- 树中的节点数在范围 $[0, 5000]$ 内。
- $-10^4 \le Node.val \le 10^4$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```python
输入：root = [3,9,20,null,null,15,7]
输出：True
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```python
输入：root = [1,2,2,3,3,null,null,4,4]
输出：False
```

## 解题思路

### 思路 1：递归遍历

1. 先递归遍历左右子树，判断左右子树是否平衡，再判断以当前节点为根节点的左右子树是否平衡。
2. 如果遍历的子树是平衡的，则返回它的高度，否则返回 -1。
3. 只要出现不平衡的子树，则该二叉树一定不是平衡二叉树。

### 思路 1：代码

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if root == None:
                return False
            leftHeight = height(root.left)
            rightHeight = height(root.right)
            if leftHeight == -1 or rightHeight == -1 or abs(leftHeight-rightHeight) > 1:
                return -1
            else:
                return max(leftHeight, rightHeight)+1
        return height(root) >= 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索
- 难度：简单

## 题目链接

- [0111. 二叉树的最小深度 - 力扣](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 $root$。

**要求**：找出该二叉树的最小深度。

**说明**：

- **最小深度**：从根节点到最近叶子节点的最短路径上的节点数量。
- **叶子节点**：指没有子节点的节点。
- 树中节点数的范围在 $[0, 10^5]$ 内。
- $-1000 \le Node.val \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```python
输入：root = [3,9,20,null,null,15,7]
输出：2
```

- 示例 2：

```python
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

## 解题思路

### 思路 1：深度优先搜索

深度优先搜索递归遍历左右子树，记录最小深度。

对于每一个非叶子节点，计算其左右子树的最小叶子节点深度，将较小的深度+1 即为当前节点的最小叶子节点深度。

### 思路 1：代码

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 遍历到空节点，直接返回 0
        if root == None:
            return 0

        # 左右子树为空，说明为叶子节点 返回 1
        if root.left == None and root.right == None:
            return 1

        leftHeight = self.minDepth(root.left)
        rightHeight = self.minDepth(root.right)

        # 当前节点的左右子树的最小叶子节点深度
        min_depth = 0xffffff
        if root.left:
            min_depth = min(leftHeight, min_depth)
        if root.right:
            min_depth = min(rightHeight, min_depth)

        # 当前节点的最小叶子节点深度
        return min_depth + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是树中的节点数量。
- **空间复杂度**：$O(n)$。

# [0112. 路径总和](https://leetcode.cn/problems/path-sum/)

- 标签：树、深度优先搜索
- 难度：简单

## 题目链接

- [0112. 路径总和 - 力扣](https://leetcode.cn/problems/path-sum/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root` 和一个值 `targetSum`。

**要求**：判断该树中是否存在从根节点到叶子节点的路径，使得这条路径上所有节点值相加等于 `targetSum`。如果存在，返回 `True`；否则，返回 `False`。

**说明**：

- 树中节点的数目在范围 $[0, 5000]$ 内。
- $-1000 \le Node.val \le 1000$。
- $-1000 \le targetSum \le 1000$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```python
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```python
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

## 解题思路

### 思路 1：递归遍历

1. 定义一个递归函数，递归函数传入当前根节点 `root`，目标节点和 `targetSum`，以及新增变量 `currSum`（表示为从根节点到当前节点的路径上所有节点值之和）。
2. 递归遍历左右子树，同时更新维护 `currSum` 值。
3. 如果当前节点为叶子节点时，判断 `currSum` 是否与 `targetSum` 相等。
   1. 如果 `currSum` 与 `targetSum` 相等，则返回 `True`。
   2. 如果 `currSum` 不与 `targetSum` 相等，则返回 `False`。
4. 如果当前节点不为叶子节点，则继续递归遍历左右子树。

### 思路 1：代码

```python
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        return self.sum(root, targetSum, 0)

    def sum(self, root: TreeNode, targetSum: int, curSum:int) -> bool:
        if root == None:
            return False
        curSum += root.val
        if root.left == None and root.right == None:
            return curSum == targetSum
        else:
            return self.sum(root.left, targetSum, curSum) or self.sum(root.right, targetSum, curSum)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。# [0113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

- 标签：树、深度优先搜索、回溯、二叉树
- 难度：中等

## 题目链接

- [0113. 路径总和 II - 力扣](https://leetcode.cn/problems/path-sum-ii/)

## 题目大意

**描述**：给定一棵二叉树的根节点 `root` 和一个整数目标 `targetSum`。

**要求**：找出「所有从根节点到叶子节点路径总和」等于给定目标和 `targetSum` 的路径。

**说明**：

- **叶子节点**：指没有子节点的节点。
- 树中节点总数在范围 $[0, 5000]$ 内。
- $-1000 \le Node.val \le 1000$。
- $-1000 \le targetSum \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```python
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```python
输入：root = [1,2,3], targetSum = 5
输出：[]
```

## 解题思路

### 思路 1：回溯

在回溯的同时，记录下当前路径。同时维护 `targetSum`，每遍历到一个节点，就减去该节点值。如果遇到叶子节点，并且 `targetSum == 0` 时，将当前路径加入答案数组中。然后递归遍历左右子树，并回退当前节点，继续遍历。

具体步骤如下：

1. 使用列表 `res` 存储所有路径，使用列表 `path` 存储当前路径。
2. 如果根节点为空，则直接返回。
3. 将当前节点值添加到当前路径 `path` 中。
4. `targetSum` 减去当前节点值。
5. 如果遇到叶子节点，并且 `targetSum == 0` 时，将当前路径加入答案数组中。
6. 递归遍历左子树。
7. 递归遍历右子树。
8. 回退当前节点，继续递归遍历。

### 思路 1：代码

```python
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        res = []
        path = []

        def dfs(root: TreeNode, targetSum: int):
            if not root:
                return
            path.append(root.val)
            targetSum -= root.val
            if not root.left and not root.right and targetSum == 0:
                res.append(path[:])
            dfs(root.left, targetSum)
            dfs(root.right, targetSum)
            path.pop()

        dfs(root, targetSum)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

- 标签：字符串、动态规划
- 难度：困难

## 题目链接

- [0115. 不同的子序列 - 力扣](https://leetcode.cn/problems/distinct-subsequences/)

## 题目大意

**描述**：给定两个字符串 `s` 和 `t`。

**要求**：计算在 `s` 的子序列中 `t` 出现的个数。

**说明**：

- **字符串的子序列**：通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）。
- $0 \le s.length, t.length \le 1000$。
- `s` 和 `t` 由英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
```

$\underline{rabb}b\underline{it}$
$\underline{ra}b\underline{bbit}$
$\underline{rab}b\underline{bit}$

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照子序列的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：以第 `i - 1` 个字符为结尾的 `s` 子序列中出现以第 `j - 1` 个字符为结尾的 `t` 的个数。

###### 3. 状态转移方程

双重循环遍历字符串 `s` 和 `t`，则状态转移方程为：

- 如果 `s[i - 1] == t[j - 1]`，则：`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`。即 `dp[i][j]` 来源于两部分：
  - 使用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于以 `i - 2` 为结尾的 `s` 子序列中出现以 `j - 2` 为结尾的 `t` 的个数，即 `dp[i - 1][j - 1]`。
  - 不使用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于以 `i - 2` 为结尾的 `s` 子序列中出现以 `j - 1` 为结尾的 `t` 的个数，即 `dp[i - 1][j]`。
- 如果 `s[i - 1] != t[j - 1]`，那么肯定不能用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于 `dp[i - 1][j]`。

###### 4. 初始条件

- `dp[i][0]` 表示以 `i - 1` 为结尾的 `s` 子序列中出现空字符串的个数。把 `s` 中的元素全删除，出现空字符串的个数就是 `1`，则 `dp[i][0] = 1`。
- `dp[0][j]` 表示空字符串中出现以 `j - 1` 结尾的 `t` 的个数，空字符串无论怎么变都不会变成 `t`，则 `dp[0][j] = 0`
- `dp[0][0]` 表示空字符串中出现空字符串的个数，这个应该是 `1`，即 `dp[0][0] = 1`。

##### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：以第 `i - 1` 个字符为结尾的 `s` 子序列中出现以第 `j - 1` 个字符为结尾的 `t` 的个数。则最终结果为 `dp[size_s][size_t]`，将其返回即可。

### 思路 1：动态规划代码

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        size_s = len(s)
        size_t = len(t)
        dp = [[0 for _ in range(size_t + 1)] for _ in range(size_s + 1)]
        for i in range(size_s):
            dp[i][0] = 1
        for i in range(1, size_s + 1):
            for j in range(1, size_t + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[size_s][size_t]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，所以总的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。
# [0116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

- 标签：树、深度优先搜索、广度优先搜索、链表、二叉树
- 难度：中等

## 题目链接

- [0116. 填充每个节点的下一个右侧节点指针 - 力扣](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

## 题目大意

**描述**：给定一个完美二叉树，所有叶子节点都在同一层，每个父节点都有两个子节点。完美二叉树结构如下：

```python
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

**要求**：填充每个 `next` 指针，使得这个指针指向下一个右侧节点。如果找不到下一个右侧节点，则将 `next` 置为 `None`。

**说明**：

- 初始状态下，所有 next 指针都被设置为 `None`。
- 树中节点的数量在 $[0, 2^{12} - 1]$ 范围内。
- $-1000 \le node.val \le 1000$。
- 进阶：
  - 只能使用常量级额外空间。
  - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。


**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```python
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

- 示例 2：

```python
输入：root = []
输出：[]
```

## 解题思路

### 思路 1：层次遍历

在层次遍历的过程中，依次取出每一层的节点，并进行连接。然后再扩展下一层节点。

### 思路 1：代码

```python
import collections

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        queue = collections.deque()
        queue.append(root)
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                if i < size - 1:
                    node.next = queue[0]

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中的节点数量。
- **空间复杂度**：$O(1)$。

# [0117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

- 标签：树、深度优先搜索、广度优先搜索、链表、二叉树
- 难度：中等

## 题目链接

- [0117. 填充每个节点的下一个右侧节点指针 II - 力扣](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

## 题目大意

**描述**：给定一个二叉树。二叉树结构如下：

```python
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

**要求**：填充每个 `next` 指针，使得这个指针指向下一个右侧节点。如果找不到下一个右侧节点，则将 `next` 置为 `None`。

**说明**：

- 初始状态下，所有 next 指针都被设置为 `None`。
- 树中节点的数量在 $[0, 6000]$ 范围内。
- $-100 \le Node.val \le 100$。
- 进阶：
  - 只能使用常量级额外空间。
  - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

```python
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

- 示例 2：

```python
输入：root = []
输出：[]
```

## 解题思路

### 思路 1：层次遍历

在层次遍历的过程中，依次取出每一层的节点，并进行连接。然后再扩展下一层节点。

### 思路 1：代码

```python
import collections

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        queue = collections.deque()
        queue.append(root)
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                if i < size - 1:
                    node.next = queue[0]

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中的节点数量。
- **空间复杂度**：$O(1)$。

# [0118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

- 标签：数组、动态规划
- 难度：简单

## 题目链接

- [0118. 杨辉三角 - 力扣](https://leetcode.cn/problems/pascals-triangle/)

## 题目大意

**描述**：给定一个整数 $numRows$。

**要求**：生成前 $numRows$ 行的杨辉三角。

**说明**：

- $1 \le numRows \le 30$。

**示例**：

- 示例 1：

```python
输入：numRows = 5
输出：[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
即
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

- 示例 2：

```python
输入: numRows = 1
输出: [[1]]
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照行数进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 为：杨辉三角第 $i$ 行、第 $j$ 列位置上的值。

###### 3. 状态转移方程

根据观察，很容易得出状态转移方程为：$dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]$，此时 $i > 0$，$j > 0$。

###### 4. 初始条件

- 每一行第一列都为 $1$，即 $dp[i][0] = 1$。
- 每一行最后一列都为 $1$，即 $dp[i][i] = 1$。

###### 5. 最终结果

根据题意和状态定义，我们将每行结果存入答案数组中，将其返回。

### 思路 1：动态规划代码

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        dp = [[0] * i for i in range(1, numRows + 1)]
        
        for i in range(numRows):
            dp[i][0] = 1
            dp[i][i] = 1

        res = []
        for i in range(numRows):
            for j in range(i):
                if i != 0 and j != 0:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            res.append(dp[i])

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。初始条件赋值的时间复杂度为 $O(n)$，两重循环遍历的时间复杂度为 $O(n^2)$，所以总的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。

### 思路 2：动态规划 + 滚动数组优化

因为 $dp[i][j]$ 仅依赖于上一行（第 $i - 1$ 行）的 $dp[i - 1][j - 1]$ 和 $dp[i - 1][j]$，所以我们没必要保存所有阶段的状态，只需要保存上一阶段的所有状态和当前阶段的所有状态就可以了，这样使用两个一维数组分别保存相邻两个阶段的所有状态就可以实现了。

其实我们还可以进一步进行优化，即我们只需要使用一个一维数组保存上一阶段的所有状态。

定义 $dp[j]$ 为杨辉三角第 $i$ 行第 $j$ 列位置上的值。则第 $i + 1$ 行、第 $j$ 列的值可以通过 $dp[j]$ + $dp[j - 1]$ 所得到。

这样我们就可以对这个一维数组保存的「上一阶段的所有状态值」进行逐一计算，从而获取「当前阶段的所有状态值」。

需要注意：本题在计算的时候需要从右向左依次遍历每个元素位置，这是因为如果从左向右遍历，如果当前元素 $dp[j]$ 已经更新为当前阶段第 $j$ 列位置的状态值之后，右侧 $dp[j + 1]$ 想要更新的话，需要的是上一阶段的状态值 $dp[j]$，而此时 $dp[j]$ 已经更新了，会破坏当前阶段的状态值。而如果用从右向左的顺序，则不会出现该问题。

### 思路 2：动态规划 + 滚动数组优化代码

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        dp = [1 for _ in range(numRows + 1)]
        
        res = []
        
        for i in range(numRows):
            for j in range(i - 1, -1, -1):
                if i != 0 and j != 0:
                    dp[j] = dp[j - 1] + dp[j]
            res.append(dp[:i + 1])

        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n)$。不考虑最终返回值的空间占用，则总的空间复杂度为 $O(n)$。
# [0119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/)

- 标签：数组、动态规划
- 难度：简单

## 题目链接

- [0119. 杨辉三角 II - 力扣](https://leetcode.cn/problems/pascals-triangle-ii/)

## 题目大意

**描述**：给定一个非负整数 $rowIndex$。

**要求**：返回杨辉三角的第 $rowIndex$ 行。

**说明**：

- $0 \le rowIndex \le 33$。
- 要求使用 $O(k)$ 的空间复杂度。

**示例**：

- 示例 1：

```python
输入：rowIndex = 3
输出：[1,3,3,1]
```

## 解题思路

### 思路 1：动态规划

因为这道题是从 $0$ 行开始计算，则可以先将 $rowIndex$ 加 $1$，计算出总共的行数，即 $numRows = rowIndex + 1$。

###### 1. 划分阶段

按照行数进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 为：杨辉三角第 $i$ 行、第 $j$ 列位置上的值。

###### 3. 状态转移方程

根据观察，很容易得出状态转移方程为：$dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]$，此时 $i > 0$，$j > 0$。

###### 4. 初始条件

- 每一行第一列都为 $1$，即 $dp[i][0] = 1$。
- 每一行最后一列都为 $1$，即 $dp[i][i] = 1$。

###### 5. 最终结果

根据题意和状态定义，将 $dp$ 最后一行返回。

### 思路 1：代码

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        # 本题从 0 行开始计算
        numRows = rowIndex + 1

        dp = [[0] * i for i in range(1, numRows + 1)]
        
        for i in range(numRows):
            dp[i][0] = 1
            dp[i][i] = 1

        for i in range(numRows):
            for j in range(i):
                if i != 0 and j != 0:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]

        return dp[-1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。初始条件赋值的时间复杂度为 $O(n)$，两重循环遍历的时间复杂度为 $O(n^2)$，所以总的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。

### 思路 2：动态规划 + 滚动数组优化

因为 $dp[i][j]$ 仅依赖于上一行（第 $i - 1$ 行）的 $dp[i - 1][j - 1]$ 和 $dp[i - 1][j]$，所以我们没必要保存所有阶段的状态，只需要保存上一阶段的所有状态和当前阶段的所有状态就可以了，这样使用两个一维数组分别保存相邻两个阶段的所有状态就可以实现了。

其实我们还可以进一步进行优化，即我们只需要使用一个一维数组保存上一阶段的所有状态。

定义 $dp[j]$ 为杨辉三角第 $i$ 行第 $j$ 列位置上的值。则第 $i + 1$ 行、第 $j$ 列的值可以通过 $dp[j]$ + $dp[j - 1]$ 所得到。

这样我们就可以对这个一维数组保存的「上一阶段的所有状态值」进行逐一计算，从而获取「当前阶段的所有状态值」。

需要注意：本题在计算的时候需要从右向左依次遍历每个元素位置，这是因为如果从左向右遍历，如果当前元素 $dp[j]$ 已经更新为当前阶段第 $j$ 列位置的状态值之后，右侧 $dp[j + 1]$ 想要更新的话，需要的是上一阶段的状态值 $dp[j]$，而此时 $dp[j]$ 已经更新了，会破坏当前阶段的状态值。而是用从左向左的顺序，则不会出现该问题。

### 思路 2：动态规划 + 滚动数组优化代码

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        # 本题从 0 行开始计算
        numRows = rowIndex + 1

        dp = [1 for _ in range(numRows)]
        
        for i in range(numRows):
            for j in range(i - 1, -1, -1):
                if i != 0 and j != 0:
                    dp[j] = dp[j - 1] + dp[j]

        return dp
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n)$。不考虑最终返回值的空间占用，则总的空间复杂度为 $O(n)$。

# [0120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0120. 三角形最小路径和 - 力扣](https://leetcode.cn/problems/triangle/)

## 题目大意

**描述**：给定一个代表三角形的二维数组 $triangle$，$triangle$ 共有 $n$ 行，其中第 $i$ 行（从 $0$ 开始编号）包含了 $i + 1$ 个数。

我们每一步只能从当前位置移动到下一行中相邻的节点上。也就是说，如果正位于第 $i$ 行第 $j$ 列的节点，那么下一步可以移动到第 $i + 1$ 行第 $j$ 列的位置上，或者第 $i + 1$ 行，第 $j + 1$ 列的位置上。

**要求**：找出自顶向下的最小路径和。

**说明**：

- $1 \le triangle.length \le 200$。
- $triangle[0].length == 1$。
- $triangle[i].length == triangle[i - 1].length + 1$。
- $-10^4 \le triangle[i][j] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

- 示例 2：

```python
输入：triangle = [[-10]]
输出：-10
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照行数进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：从顶部走到第 $i$ 行（从 $0$ 开始编号）、第 $j$ 列的位置时的最小路径和。

###### 3. 状态转移方程

由于每一步只能从当前位置移动到下一行中相邻的节点上，想要移动到第 $i$ 行、第 $j$ 列的位置，那么上一步只能在第 $i - 1$ 行、第 $j - 1$ 列的位置上，或者在第 $i - 1$ 行、第 $j$ 列的位置上。则状态转移方程为：

$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]$。其中 $triangle[i][j]$ 表示第 $i$ 行、第 $j$ 列位置上的元素值。

###### 4. 初始条件

 在第 $0$ 行、第 $j$ 列时，最小路径和为 $triangle[0][0]$，即 $dp[0][0] = triangle[0][0]$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：从顶部走到第 $i$ 行（从 $0$ 开始编号）、第 $j$ 列的位置时的最小路径和。为了计算出最小路径和，则需要再遍历一遍 $dp[size - 1]$ 行的每一列，求出最小值即为最终结果。

### 思路 1：动态规划代码

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        size = len(triangle)
        dp = [[0 for _ in range(size)] for _ in range(size)]
        dp[0][0] = triangle[0][0]

        for i in range(1, size):
            dp[i][0] = dp[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]
            dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]

        return min(dp[size - 1])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，最后求最小值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。
# [0121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

- 标签：数组、动态规划
- 难度：简单

## 题目链接

- [0121. 买卖股票的最佳时机 - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

## 题目大意

**描述**：给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。

**要求**：计算出能获取的最大利润。如果你不能获取任何利润，返回 $0$。

**说明**：

- $1 \le prices.length \le 10^5$。
- $0 \le prices[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

- 示例 2：

```python
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

## 解题思路

最简单的思路当然是两重循环暴力枚举，寻找不同天数下的最大利润。但更好的做法是进行一次遍历，递推求解。

### 思路 1：递推


1. 设置两个变量 `minprice`（用来记录买入的最小值）、`maxprofit`（用来记录可获取的最大利润）。
2. 从左到右进行遍历数组 `prices`。
3. 如果遇到当前价格比 `minprice` 还要小的，就更新 `minprice`。
4. 如果遇到当前价格大于或者等于 `minprice`，则判断一下以当前价格卖出的话能卖多少，如果比 `maxprofit` 还要大，就更新 `maxprofit`。
5. 最后输出 `maxprofit`。

### 思路 1：代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minprice = 10010
        maxprofit = 0
        for price in prices:
            if price < minprice:
                minprice = price
            elif price - minprice > maxprofit:
                maxprofit = price - minprice
        return maxprofit
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `prices` 的元素个数。
- **空间复杂度**：$O(1)$。

# [0122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [0122. 买卖股票的最佳时机 II - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

## 题目大意

**描述**：给定一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买 / 出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。

**要求**：计算出能获取的最大利润。

**说明**：

- $1 \le prices.length \le 3 * 10^4$。
- $0 \le prices[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7。
```

- 示例 2：

```python
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

## 解题思路

### 思路 1：贪心算法

股票买卖获取利润主要是看差价，必然是低点买入，高点卖出才会赚钱。而要想获取最大利润，就要在跌入谷底的时候买入，在涨到波峰的时候卖出利益才会最大化。所以我们购买股票的策略变为了：

1. 连续跌的时候不买。
2. 跌到最低点买入。
3. 涨到最高点卖出。

在这种策略下，只要计算波峰和谷底的差值即可。而波峰和谷底的差值可以通过两两相减所得的差值来累加计算。

### 思路 1：代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            ans += max(0, prices[i]-prices[i-1])
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `prices` 的元素个数。
- **空间复杂度**：$O(1)$。

# [0123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [0123. 买卖股票的最佳时机 III - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

## 题目大意

给定一个数组 `prices` 代表一只股票，其中 `prices[i]` 代表这只股票第 `i` 天的价格。最多可完成两笔交易，且不同同时参与躲避交易（必须在再次购买前出售掉之前的股票）。

现在要求：计算所能获取的最大利润。

## 解题思路

动态规划求解。

最多可完成两笔交易意味着总共有三种情况：买卖一次，买卖两次，不买卖。

具体到每一天结束总共有 5 种状态：

0. 未进行买卖状态；
1. 第一次买入状态；
2. 第一次卖出状态；
3. 第二次买入状态；
4. 第二次卖出状态。

所以我们可以定义状态 `dp[i][j]` ，表示为：第 `i` 天第 `j` 种情况（`0 <= j <= 4`）下，所获取的最大利润。

注意：这里第第 `j` 种情况，并不一定是这一天一定要买入或卖出，而是这一天所处于的买入卖出状态。比如说前一天是第一次买入，第二天没有操作，则第二天就沿用前一天的第一次买入状态。

接下来确定状态转移公式：

- 第 `0` 种状态下显然利润为 `0`，可以直接赋值为昨天获取的最大利润，即 `dp[i][0] = dp[i - 1][0]`。
- 第 `1` 种状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天买入状态所得的最大利润：`dp[i][1] = dp[i - 1][1]`。
  - 第一次买入：`dp[i][1] = dp[i - 1][0] - prices[i]`。
- 第 `2` 种状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][2] = dp[i - 1][2]`。
  - 第一次卖出：`dp[i][2] = dp[i - 1][1] + prices[i]`。
- 第 `3` 种状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天买入状态所得的最大利润：`dp[i][3] = dp[i - 1][3]`。
  - 第二次买入：`dp[i][3] = dp[i - 1][2] - prices[i]`。
- 第 `4` 种状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][4] = dp[i - 1][4]`。
  - 第二次卖出：`dp[i][4] = dp[i - 1][3] + prices[i]`。

下面确定初始化的边界值：

可以很明显看出第一天不做任何操作就是 `dp[0][0] = 0`，第一次买入就是 `dp[0][1] = -prices[i]`。

第一次卖出的话，可以视作为没有盈利（当天买卖，价格没有变化），即 `dp[0][2] = 0`。第二次买入的话，就是 `dp[0][3] = -prices[i]`。同理第二次卖出就是 `dp[0][4] = 0`。

在递推结束后，最大利润肯定是无操作、第一次卖出、第二次卖出这三种情况里边，且为最大值。我们在维护的时候维护的是最大值，则第一次卖出、第二次卖出所获得的利润肯定大于等于 0。而且，如果最优情况为一笔交易，那么在转移状态时，我们允许在一天内进行两次交易，则一笔交易的状态可以转移至两笔交易。所以最终答案为 `dp[size - 1][4]`。`size` 为股票天数。

## 代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 0:
            return 0
        dp = [[0 for _ in range(5)] for _ in range(size)]

        dp[0][1] = -prices[0]
        dp[0][3] = -prices[0]

        for i in range(1, size):
            dp[i][0] = dp[i - 1][0]
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])
        return dp[size - 1][4]
```

# [0124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

- 标签：树、深度优先搜索、动态规划、二叉树
- 难度：困难

## 题目链接

- [0124. 二叉树中的最大路径和 - 力扣](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

## 题目大意

**描述**：给定一个二叉树的根节点 $root$。

**要求**：返回其最大路径和。

**说明**：

- **路径**：被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。
- **路径和**：路径中各节点值的总和。
- 树中节点数目范围是 $[1, 3 * 10^4]$。
- $-1000 \le Node.val \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```python
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```python
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

根据最大路径和中对应路径是否穿过根节点，我们可以将二叉树分为两种：

1. 最大路径和中对应路径穿过根节点。
2. 最大路径和中对应路径不穿过根节点。

如果最大路径和中对应路径穿过根节点，则：**该二叉树的最大路径和 = 左子树中最大贡献值 + 右子树中最大贡献值 + 当前节点值**。

而如果最大路径和中对应路径不穿过根节点，则：**该二叉树的最大路径和 = 所有子树中最大路径和**。

即：**该二叉树的最大路径和 = max(左子树中最大贡献值 + 右子树中最大贡献值 + 当前节点值，所有子树中最大路径和)**。

对此我们可以使用深度优先搜索递归遍历二叉树，并在递归遍历的同时，维护一个最大路径和变量 $ans$。

然后定义函数 ` def dfs(self, node):` 计算二叉树中以该节点为根节点，并且经过该节点的最大贡献值。

计算的结果可能的情况有 $2$ 种：

1. 经过空节点的最大贡献值等于 $0$。
2. 经过非空节点的最大贡献值等于 **当前节点值 + 左右子节点提供的最大贡献值中较大的一个**。如果该贡献值为负数，可以考虑舍弃，即最大贡献值为 $0$。

在递归时，我们先计算左右子节点的最大贡献值，再更新维护当前最大路径和变量。最终 $ans$ 即为答案。具体步骤如下：

1. 如果根节点 $root$ 为空，则返回 $0$。
2. 递归计算左子树的最大贡献值为 $left\underline{\hspace{0.5em}}max$。
3. 递归计算右子树的最大贡献值为 $right\underline{\hspace{0.5em}}max$。
4. 更新维护最大路径和变量，即 $self.ans = max \lbrace self.ans, \quad left\underline{\hspace{0.5em}}max + right\underline{\hspace{0.5em}}max + node.val \rbrace$。
5. 返回以当前节点为根节点，并且经过该节点的最大贡献值。即返回 **当前节点值 + 左右子节点提供的最大贡献值中较大的一个**。
6. 最终 $self.ans$ 即为答案。

### 思路 1：代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.ans = float('-inf')
        
    def dfs(self, node):
        if not node:
            return 0
        left_max = max(self.dfs(node.left), 0)     # 左子树提供的最大贡献值
        right_max = max(self.dfs(node.right), 0)   # 右子树提供的最大贡献值

        cur_max = left_max + right_max + node.val  # 包含当前节点和左右子树的最大路径和
        self.ans = max(self.ans, cur_max)          # 更新所有路径中的最大路径和

        return max(left_max, right_max) + node.val # 返回包含当前节点的子树的最大贡献值

    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.dfs(root)
        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [0125. 验证回文串 - 力扣](https://leetcode.cn/problems/valid-palindrome/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：判断是否为回文串（只考虑字符串中的字母和数字字符，并且忽略字母的大小写）。

**说明**：

- 回文串：正着读和反着读都一样的字符串。
- $1 \le s.length \le 2 * 10^5$。
- `s` 仅由可打印的 ASCII 字符组成。

**示例**：

- 示例 1：

```python
输入: "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

- 示例 2：

```python
输入："race a car"
输出：false
解释："raceacar" 不是回文串。
```

## 解题思路

### 思路 1：对撞指针

1. 使用两个指针 `left`，`right`。`left` 指向字符串开始位置，`right` 指向字符串结束位置。
2. 判断两个指针对应字符是否是字母或数字。 通过 `left` 右移、`right` 左移的方式过滤掉字母和数字以外的字符。
3. 然后判断 `s[left]` 是否和 `s[right]` 相等（注意大小写）。
   1. 如果相等，则将 `left` 右移、`right` 左移，继续进行下一次过滤和判断。
   2. 如果不相等，则说明不是回文串，直接返回 `False`。
4. 如果遇到 `left == right`，跳出循环，则说明该字符串是回文串，返回 `True`。

### 思路 1：代码

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        
        while left < right:
            if not s[left].isalnum():
                left += 1
                continue
            if not s[right].isalnum():
                right -= 1
                continue
            
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(len(s))$。
- **空间复杂度**：$O(len(s))$。
# [0127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

- 标签：广度优先搜索、哈希表、字符串
- 难度：困难

## 题目链接

- [0127. 单词接龙 - 力扣](https://leetcode.cn/problems/word-ladder/)

## 题目大意

给定两个单词 `beginWord` 和 `endWord`，以及一个字典 `wordList`。找到从 `beginWord` 到 `endWord` 的最短转换序列中的单词数目。如果不存在这样的转换序列，则返回 0。

转换需要遵守的规则如下：

- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须为字典中的单词。

## 解题思路

广度优先搜索。使用队列存储将要遍历的单词和单词数目。

从 `beginWord` 开始变换，把单词的每个字母都用 `a ~ z` 变换一次，变换后的单词是否是 `endWord`，如果是则直接返回。

否则查找变换后的词是否在 `wordList` 中。如果在 `wordList` 中找到就加入队列，找不到就输出 `0`。然后按照广度优先搜索的算法急需要遍历队列中的节点，直到所有单词都出队时结束。

## 代码

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if not wordList or endWord not in wordList:
            return 0
        word_set = set(wordList)
        if beginWord in word_set:
            word_set.remove(beginWord)

        queue = collections.deque()
        queue.append((beginWord, 1))
        while queue:
            word, level = queue.popleft()
            if word == endWord:
                return level

            for i in range(len(word)):
                for j in range(26):
                    new_word = word[:i] + chr(ord('a') + j) + word[i + 1:]
                    if new_word in word_set:
                        word_set.remove(new_word)
                        queue.append((new_word, level + 1))

        return 0
```

# [0128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

- 标签：并查集、数组、哈希表
- 难度：中等

## 题目链接

- [0128. 最长连续序列 - 力扣](https://leetcode.cn/problems/longest-consecutive-sequence/)

## 题目大意

**描述**：给定一个未排序的整数数组 `nums`。

**要求**：找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。并且要用时间复杂度为 $O(n)$ 的算法解决此问题。

**说明**：

- $0 \le nums.length \le 10^5$。
- $-10^9 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

- 示例 2：

```python
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

## 解题思路

暴力做法有两种思路。

- 第 1 种思路是先排序再依次判断，这种做法时间复杂度最少是 $O(n \log_2 n)$。
- 第 2 种思路是枚举数组中的每个数 `num`，考虑以其为起点，不断尝试匹配 `num + 1`、`num + 2`、`...` 是否存在，最长匹配次数为 `len(nums)`。这样下来时间复杂度为 $O(n^2)$。

我们可以使用哈希表优化这个过程。

### 思路 1：哈希表

1. 先将数组存储到集合中进行去重，然后使用 `curr_streak` 维护当前连续序列长度，使用 `ans` 维护最长连续序列长度。
2. 遍历集合中的元素，对每个元素进行判断，如果该元素不是序列的开始（即 `num - 1` 在集合中），则跳过。
3. 如果 `num - 1` 不在集合中，说明 `num` 是序列的开始，判断 `num + 1` 、`nums + 2`、`...` 是否在哈希表中，并不断更新当前连续序列长度 `curr_streak`。并在遍历结束之后更新最长序列的长度。
4. 最后输出最长序列长度。

### 思路 1：代码

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        ans = 0
        nums_set = set(nums)
        for num in nums_set:
            if num - 1 not in nums_set:
                curr_num = num
                curr_streak = 1
                
                while curr_num + 1 in nums_set:
                    curr_num += 1
                    curr_streak += 1
                ans = max(ans, curr_streak)

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。将数组存储到集合中进行去重的操作的时间复杂度是 $O(n)$。查询每个数是否在集合中的时间复杂度是 $O(1)$ ，并且跳过了所有不是起点的元素。更新当前连续序列长度 `curr_streak` 的时间复杂度是 $O(n)$，所以最终的时间复杂度是 $O(n)$。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[128. 最长连续序列 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/1176496/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/)
# [0129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0129. 求根节点到叶节点数字之和 - 力扣](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。每条从根节点到叶节点的路径都代表一个数字。例如，从根节点到叶节点的路径是 `1` -> `2` -> `3`，表示数字 `123`。

**要求**：计算从根节点到叶节点生成的所有数字的和。

**说明**：

- **叶节点**：指没有子节点的节点。
- 树中节点的数目在范围 $[1, 1000]$ 内。
- $0 \le Node.val \le 9$。
- 树的深度不超过 $10$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```python
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```python
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

## 解题思路

### 思路 1：深度优先搜索

1. 记录下路径上所有节点构成的数字，使用变量 `pre_total` 保存下当前路径上构成的数字。
2. 如果遇到叶节点，则直接返回当前数字。
3. 如果没有遇到叶节点，则递归遍历左右子树，并累加对应结果。

### 思路 1：代码

```python
class Solution:
    def dfs(self, root, pre_total):
        if not root:
            return 0
        total = pre_total * 10 + root.val
        if not root.left and not root.right:
            return total
        return self.dfs(root.left, total) + self.dfs(root.right, total)

    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        return self.dfs(root, 0)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。



# [0130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [0130. 被围绕的区域 - 力扣](https://leetcode.cn/problems/surrounded-regions/)

## 题目大意

**描述**：给定一个 `m * n` 的矩阵 `board`，由若干字符 `X` 和 `O` 构成。

**要求**：找到所有被 `X` 围绕的区域，并将这些区域里所有的 `O` 用 `X` 填充。

**说明**：

- $m == board.length$。
- $n == board[i].length$。
- $1 <= m, n <= 200$。
- $board[i][j]$ 为 `'X'` 或 `'O'`。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```python
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

- 示例 2：

```python
输入：board = [["X"]]
输出：[["X"]]
```

## 解题思路

### 思路 1：深度优先搜索

根据题意，任何边界上的 `O` 都不会被填充为`X`。而被填充 `X` 的 `O` 一定在内部不在边界上。

所以我们可以用深度优先搜索先搜索边界上的 `O` 以及与边界相连的 `O`，将其先标记为 `#`。

最后遍历一遍 `board`，将所有 `#` 变换为 `O`，将所有 `O` 变换为 `X`。

### 思路 1：代码

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        rows, cols = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < rows or not 0 <= y < cols or board[x][y] != 'O':
                return
            board[x][y] = '#'
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)

        for i in range(rows):
            dfs(i, 0)
            dfs(i, cols - 1)

        for j in range(cols - 1):
            dfs(0, j)
            dfs(rows - 1, j)

        for i in range(rows):
            for j in range(cols):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                elif board[i][j] == 'O':
                    board[i][j] = 'X'
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(n \times m)$。# [0131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

- 标签：字符串、动态规划、回溯
- 难度：中等

## 题目链接

- [0131. 分割回文串 - 力扣](https://leetcode.cn/problems/palindrome-partitioning/)

## 题目大意

给定一个字符串 `s`，将 `s` 分割成一些子串，保证每个子串都是「回文串」。返回 `s` 所有可能的分割方案。

## 解题思路

回溯算法，建立两个数组 res、path。res 用于存放所有满足题意的组合，path 用于存放当前满足题意的一个组合。

在回溯的时候判断当前子串是否为回文串，如果不是则跳过，如果是则继续向下一层遍历。

定义判断是否为回文串的方法和回溯方法，从 `start_index = 0` 的位置开始回溯。

- 如果 `start_index >= len(s)`，则将 path 中的元素加入到 res 数组中。
- 然后对 `[start_index, len(s) - 1]` 范围内的子串进行遍历取值。
  - 如果字符串 `s` 在范围 `[start_index, i]` 所代表的子串是回文串，则将其加入 path 数组。
  - 递归遍历 `[i + 1, len(s) - 1]` 范围上的子串。
  - 然后将遍历的范围 `[start_index, i]` 所代表的子串进行回退。
- 最终返回 res 数组。

## 代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, s: str, start_index: int):
        if start_index >= len(s):
            self.res.append(self.path[:])
            return
        for i in range(start_index, len(s)):
            if self.ispalindrome(s, start_index, i):
                self.path.append(s[start_index: i+1])
                self.backtrack(s, i + 1)
                self.path.pop()

    def ispalindrome(self, s: str, start: int, end: int):
        i, j = start, end
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    def partition(self, s: str) -> List[List[str]]:
        self.res.clear()
        self.path.clear()
        self.backtrack(s, 0)
        return self.res
```

# [0133. 克隆图](https://leetcode.cn/problems/clone-graph/)

- 标签：深度优先搜索、广度优先搜索、图、哈希表
- 难度：中等

## 题目链接

- [0133. 克隆图 - 力扣](https://leetcode.cn/problems/clone-graph/)

## 题目大意

**描述**：以每个节点的邻接列表形式（二维列表）给定一个无向连通图，其中 $adjList[i]$ 表示值为 $i + 1$ 的节点的邻接列表，$adjList[i][j]$ 表示值为 $i + 1$ 的节点与值为 $adjList[i][j]$ 的节点有一条边。

**要求**：返回该图的深拷贝。

**说明**：

- 节点数不超过 $100$。
- 每个节点值 $Node.val$ 都是唯一的，$1 \le Node.val \le 100$。
- 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
- 由于图是无向的，如果节点 $p$ 是节点 $q$ 的邻居，那么节点 $q$ 也必须是节点 $p$ 的邻居。
- 图是连通图，你可以从给定节点访问到所有节点。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)

```python
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)

```python
输入：adjList = [[2],[1]]
输出：[[2],[1]]
```

## 解题思路

所谓深拷贝，就是构建一张与原图结构、值均一样的图，但是所用的节点不再是原图节点的引用，即每个节点都要新建。

可以用深度优先搜索或者广度优先搜索来做。

### 思路 1：深度优先搜索

1. 使用哈希表 $visitedDict$ 来存储原图中被访问过的节点和克隆图中对应节点，键值对为「原图被访问过的节点：克隆图中对应节点」。
2. 从给定节点开始，以深度优先搜索的方式遍历原图。
   1. 如果当前节点被访问过，则返回隆图中对应节点。
   2. 如果当前节点没有被访问过，则创建一个新的节点，并保存在哈希表中。
   3. 遍历当前节点的邻接节点列表，递归调用当前节点的邻接节点，并将其放入克隆图中对应节点。
3. 递归结束，返回克隆节点。

### 思路 1：代码

```python
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        visited = dict()

        def dfs(node: 'Node') -> 'Node':
            if node in visited:
                return visited[node]

            clone_node = Node(node.val, [])
            visited[node] = clone_node
            for neighbor in node.neighbors:
                clone_node.neighbors.append(dfs(neighbor))
            return clone_node

        return dfs(node)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为图中节点数量。
- **空间复杂度**：$O(n)$。

### 思路 2：广度优先搜索

1. 使用哈希表 $visited$ 来存储原图中被访问过的节点和克隆图中对应节点，键值对为「原图被访问过的节点：克隆图中对应节点」。使用队列 $queue$ 存放节点。
2. 根据起始节点 $node$，创建一个新的节点，并将其添加到哈希表 $visited$ 中，即 `visited[node] = Node(node.val, [])`。然后将起始节点放入队列中，即 `queue.append(node)`。
3. 从队列中取出第一个节点 $node\underline{\hspace{0.5em}}u$。访问节点 $node\underline{\hspace{0.5em}}u$。
4. 遍历节点 $node\underline{\hspace{0.5em}}u$ 的所有未访问邻接节点 $node\underline{\hspace{0.5em}}v$（节点 $node\underline{\hspace{0.5em}}v$ 不在 $visited$ 中）。
5. 根据节点 $node\underline{\hspace{0.5em}}v$ 创建一个新的节点，并将其添加到哈希表 $visited$ 中，即 `visited[node_v] = Node(node_v.val, [])`。
6. 然后将节点 $node\underline{\hspace{0.5em}}v$ 放入队列 $queue$ 中，即 `queue.append(node_v)`。
7. 重复步骤 $3 \sim 6$，直到队列 $queue$ 为空。
8. 广度优先搜索结束，返回起始节点的克隆节点（即 $visited[node]$）。

### 思路 2：代码

```python
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return node
        
        visited = dict()
        queue = collections.deque()

        visited[node] = Node(node.val, [])
        queue.append(node)

        while queue:
            node_u = queue.popleft()
            for node_v in node_u.neighbors:
                if node_v not in visited:
                    visited[node_v] = Node(node_v.val, [])
                    queue.append(node_v)
                visited[node_u].neighbors.append(visited[node_v])
        
        return visited[node]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为图中节点数量。
- **空间复杂度**：$O(n)$。# [0134. 加油站](https://leetcode.cn/problems/gas-station/)

- 标签：贪心、数组
- 难度：中等

## 题目链接

- [0134. 加油站 - 力扣](https://leetcode.cn/problems/gas-station/)

## 题目大意

一条环路上有 N 个加油站，第 i 个加油站有 gas[i] 升汽油。

现在有一辆油箱无限容量的汽车，从第 i 个加油站开往第 i + 1 个加油站需要消耗汽油 cost[i] 升。如果汽车上携带的有两不够 cost[i]，则无法从第 i 个加油站开往第 i + 1 个加油站。

现在从其中一个加油站开始出发，且出发时油箱为空。如果能绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

## 解题思路

1. 暴力求解

分别考虑从第 0 个点、第 1 个点、…、第 i 个点出发，能否回到第 0 个点、第 1 个点、…、第 i 个点。

2. 贪心算法

- 如果加油站提供的油总和大于等于消耗的汽油量，则必定可以绕环路行驶一周
- 假设先不考虑油量为负的情况，我们从「第 0 个加油站」出发，环行一周。记录下汽油量 gas[i] 和 cost[i] 差值总和 sum_diff，同时记录下油箱剩余油量的最小值 min_sum。
- 如果差值总和 sum_diff < 0，则无论如何都不能环行一周。油不够啊，亲！！
- 如果 min_sum ≥ 0，则行驶过程中油箱始终有油，则可以从 0 个加油站出发环行一周。
- 如果 min_sum < 0，则说明行驶过程中油箱油不够了，那么考虑更换开始的起点。
  - 从右至左遍历，计算汽油量 gas[i] 和 cost[i] 差值，看哪个加油站能将  min_sum 填平。如果最终达到 min_sum ≥ 0，则说明从该点开始出发，油箱中的油始终不为空，则返回该点下标。
  - 如果找不到最返回 -1。

## 代码

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        sum_diff, min_sum = 0, float('inf')
        for i in range(len(gas)):
            sum_diff += gas[i] - cost[i]
            min_sum = min(min_sum, sum_diff)

        if sum_diff < 0:
            return -1

        if min_sum >= 0:
            return 0

        for i in range(len(gas)-1, -1, -1):
            min_sum += gas[i] - cost[i]
            if min_sum >= 0:
                return i
        return -1
```

## 参考链接

- [贪心算法/前缀和 - 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/solution/tan-xin-suan-fa-qian-zhui-he-by-antione/)
# [0135. 分发糖果](https://leetcode.cn/problems/candy/)

- 标签：贪心、数组
- 难度：困难

## 题目链接

- [0135. 分发糖果 - 力扣](https://leetcode.cn/problems/candy/)

## 题目大意

**描述**：$n$ 个孩子站成一排。老师会根据每个孩子的表现，给每个孩子进行评分。然后根据下面的规则给孩子们分发糖果：

- 每个孩子至少得 $1$ 个糖果。
- 评分更高的孩子必须比他两侧相邻位置上的孩子分得更多的糖果。

现在给定 $n$ 个孩子的表现分数数组 `ratings`，其中 `ratings[i]` 表示第 $i$ 个孩子的评分。

**要求**：返回最少需要准备的糖果数目。

**说明**：

- $n == ratings.length$。
- $1 \le n \le 2 \times 10^4$。
- $0 \le ratings[i] \le 2 * 10^4$。

**示例**：

- 示例 1：

```python
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

- 示例 2：

```python
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

## 解题思路

### 思路 1：贪心算法

先来看分发糖果的规则。

「每个孩子至少得 1 个糖果」：说明糖果数目至少为 N 个。

「评分更高的孩子必须比他两侧相邻位置上的孩子分得更多的糖果」：可以看做为以下两种条件：

- 当 $ratings[i - 1] < ratings[i]$ 时，第 i 个孩子的糖果数量比第 $i - 1$ 个孩子的糖果数量多；
- 当 $ratings[i] > ratings[i + 1]$ 时，第 i 个孩子的糖果数量比第$ i + 1$ 个孩子的糖果数量多。

根据以上信息，我们可以设定一个长度为 N 的数组 sweets 来表示每个孩子分得的最少糖果数，初始每个孩子分得糖果数都为 1。

然后遍历两遍数组，第一遍遍历满足当 $ratings[i - 1] < ratings[i]$ 时，第 $i$ 个孩子的糖果数量比第 $i - 1$ 个孩子的糖果数量多 $1$ 个。第二遍遍历满足当 $ratings[i] > ratings[i + 1]$ 时，第 $i$ 个孩子的糖果数量取「第 $i + 1$ 个孩子的糖果数量多 $1$ 个」和「第 $i + 1$ 个孩子目前拥有的糖果数量」中的最大值。

然后再遍历求所有孩子的糖果数量和即为答案。

### 思路 1：代码

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        size = len(ratings)
        sweets = [1 for _ in range(size)]

        for i in range(1, size):
            if ratings[i] > ratings[i - 1]:
                sweets[i] = sweets[i - 1] + 1

        for i in range(size - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                sweets[i] = max(sweets[i], sweets[i + 1] + 1)

        res = sum(sweets)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `ratings` 的长度。
- **空间复杂度**：$O(n)$。

# [0136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

- 标签：位运算、数组
- 难度：简单

## 题目链接

- [0136. 只出现一次的数字 - 力扣](https://leetcode.cn/problems/single-number/)

## 题目大意

**描述**：给定一个非空整数数组 `nums`，`nums` 中除了某个元素只出现一次以外，其余每个元素均出现两次。

**要求**：找出那个只出现了一次的元素。

**说明**：

- 要求不能使用额外的存储空间。

**示例**：

- 示例 1：

```python
输入: [2,2,1]
输出: 1
```

- 示例 2：

```python
输入: [4,1,2,1,2]
输出: 4
```

## 解题思路

### 思路 1：位运算

如果没有时间复杂度和空间复杂度的限制，可以使用哈希表 / 集合来存储每个元素出现的次数，如果哈希表中没有该数字，则将该数字加入集合，如果集合中有了该数字，则从集合中删除该数字，最终成对的数字都被删除了，只剩下单次出现的元素。

但是题目要求不使用额外的存储空间，就需要用到位运算中的异或运算。

> 异或运算 $\oplus$ 的三个性质：
>
> 1. 任何数和 $0$ 做异或运算，结果仍然是原来的数，即 $a \oplus 0 = a$。
> 2. 数和其自身做异或运算，结果是 $0$，即 $a \oplus a = 0$。
> 3. 异或运算满足交换率和结合律：$a \oplus b \oplus a = b \oplus a \oplus a = b \oplus (a \oplus a) = b \oplus 0 = b$。

根据异或运算的性质，对 $n$ 个数不断进行异或操作，最终可得到单次出现的元素。

### 思路 1：代码

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        ans = 0
        for i in range(len(nums)):
            ans ^= nums[i]
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。# [0137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

- 标签：位运算、数组
- 难度：中等

## 题目链接

- [0137. 只出现一次的数字 II - 力扣](https://leetcode.cn/problems/single-number-ii/)

## 题目大意

**描述**：给定一个整数数组 $nums$，除了某个元素仅出现一次外，其余每个元素恰好出现三次。

**要求**：找到并返回那个只出现了一次的元素。

**说明**：

- $1 \le nums.length \le 3 * 10^4$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- $nums$ 中，除某个元素仅出现一次外，其余每个元素都恰出现三次。

**示例**：

- 示例 1：

```python
输入：nums = [2,2,3,2]
输出：3
```

- 示例 2：

```python
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

## 解题思路

### 思路 1：哈希表

1. 利用哈希表统计出每个元素的出现次数。
2. 再遍历一次哈希表，找到仅出现一次的元素。

### 思路 1：代码

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums_dict = dict()
        for num in nums:
            if num in nums_dict:
                nums_dict[num] += 1
            else:
                nums_dict[num] = 1
        for key in nums_dict:
            value = nums_dict[key]
            if value == 1:
                return key
        return 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 $nums$ 的元素个数。
- **空间复杂度**：$O(n)$。

### 思路 2：位运算

将出现三次的元素换成二进制形式放在一起，其二进制对应位置上，出现 $1$ 的个数一定是 $3$ 的倍数（包括 $0$）。此时，如果在放进来只出现一次的元素，则某些二进制位置上出现 $1$ 的个数就不是 $3$ 的倍数了。

将这些二进制位置上出现 $1$ 的个数不是 $3$ 的倍数位置值置为 $1$，是 $3$ 的倍数则置为 $0$。这样对应下来的二进制就是答案所求。

注意：因为 Python 的整数没有位数限制，所以不能通过最高位确定正负。所以 Python 中负整数的补码会被当做正整数。所以在遍历到最后 $31$ 位时进行 $ans -= (1 << 31)$ 操作，目的是将负数的补码转换为「负号 + 原码」的形式。这样就可以正常识别二进制下的负数。参考：[Two's Complement Binary in Python? - Stack Overflow](https://stackoverflow.com/questions/12946116/twos-complement-binary-in-python/12946226)

### 思路 2：代码

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            count = 0
            for j in range(len(nums)):
                count += (nums[j] >> i) & 1
            if count % 3 != 0:
                if i == 31:
                    ans -= (1 << 31)
                else:
                    ans = ans | 1 << i
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \log m)$，其中 $n$ 是数组 $nums$ 的长度，$m$ 是数据范围，本题中 $m = 32$。
- **空间复杂度**：$O(1)$。

# [0138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

- 标签：哈希表、链表
- 难度：中等

## 题目链接

- [0138. 复制带随机指针的链表 - 力扣](https://leetcode.cn/problems/copy-list-with-random-pointer/)

## 题目大意

**描述**：给定一个链表的头节点 `head`，链表中每个节点除了 `next` 指针之外，还包含一个随机指针 `random`，该指针可以指向链表中的任何节点或者空节点。

**要求**：将该链表进行深拷贝。返回复制链表的头节点。

**说明**：

- $0 \le n \le 1000$。
- $-10^4 \le Node.val \le 10^4$。
- `Node.random` 为 `null` 或指向链表中的节点。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```python
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```python
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

## 解题思路

### 思路 1：迭代

1. 遍历链表，利用哈希表，以 `旧节点: 新节点` 为映射关系，将节点关系存储下来。
2. 再次遍历链表，将新链表的 `next` 和 `random` 指针设置好。

### 思路 1：代码

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return None
        node_dict = dict()
        curr = head
        while curr:
            new_node = Node(curr.val, None, None)
            node_dict[curr] = new_node
            curr = curr.next
        curr = head
        while curr:
            if curr.next:
                node_dict[curr].next = node_dict[curr.next]
            if curr.random:
                node_dict[curr].random = node_dict[curr.random]
            curr = curr.next
        return node_dict[head]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0139. 单词拆分](https://leetcode.cn/problems/word-break/)

- 标签：字典树、记忆化搜索、数组、哈希表、字符串、动态规划
- 难度：中等

## 题目链接

- [0139. 单词拆分 - 力扣](https://leetcode.cn/problems/word-break/)

## 题目大意

**描述**：给定一个非空字符串 $s$ 和一个包含非空单词的列表 $wordDict$ 作为字典。

**要求**：判断是否可以利用字典中出现的单词拼接出 $s$ 。

**说明**：

- 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
- $1 \le s.length \le 300$。
- $1 \le wordDict.length \le 1000$。
- $1 \le wordDict[i].length \le 20$。
- $s$ 和 $wordDict[i]$ 仅有小写英文字母组成。
- $wordDict$ 中的所有字符串互不相同。

**示例**：

- 示例 1：

```python
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

- 示例 2：

```python
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照单词结尾位置进行阶段划分。

###### 2. 定义状态

$s$ 能否拆分为单词表的单词，可以分解为：

- 前 $i$ 个字符构成的字符串，能否分解为单词。
- 剩余字符串，能否分解为单词。

定义状态 $dp[i]$ 表示：长度为 $i$ 的字符串 $s[0: i]$ 能否拆分成单词，如果为 $True$ 则表示可以拆分，如果为 $False$ 则表示不能拆分。

###### 3. 状态转移方程

- 如果 $s[0: j]$ 可以拆分为单词（即 $dp[j] == True$），并且字符串 $s[j: i]$ 出现在字典中，则 `dp[i] = True`。
- 如果 $s[0: j]$ 不可以拆分为单词（即 $dp[j] == False$），或者字符串 $s[j: i]$ 没有出现在字典中，则 `dp[i] = False`。

###### 4. 初始条件

- 长度为 $0$ 的字符串 $s[0: i]$ 可以拆分为单词，即 $dp[0] = True$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示：长度为 $i$ 的字符串 $s[0: i]$ 能否拆分成单词。则最终结果为 $dp[size]$，$size$ 为字符串长度。

### 思路 1：代码

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        size = len(s)
        dp = [False for _ in range(size + 1)]
        dp[0] = True
        for i in range(size + 1):
            for j in range(i):
                if dp[j] and s[j: i] in wordDict:
                    dp[i] = True
        return dp[size]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n)$。

# [0140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

- 标签：字典树、记忆化搜索、数组、哈希表、字符串、动态规划、回溯
- 难度：困难

## 题目链接

- [0140. 单词拆分 II - 力扣](https://leetcode.cn/problems/word-break-ii/)

## 题目大意

给定一个非空字符串 `s` 和一个包含非空单词列表的字典 `wordDict`。

要求：在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

- 分隔时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

## 解题思路

回溯 + 记忆化搜索。

对于字符串 `s`，如果某个位置左侧部分是单词列表中的单词，则拆分出该单词，然后对 `s` 右侧剩余部分进行递归拆分。如果可以将整个字符串 `s` 拆分成单词列表中的单词，则得到一个句子。

使用 `memo` 数组进行记忆化存储，这样可以减少重复计算。

## 代码

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        size = len(s)
        memo = [None for _ in range(size + 1)]

        def dfs(start):
            if start > size - 1:
                return [[]]
            if memo[start]:
                return memo[start]
            res = []
            for i in range(start, size):
                word = s[start: i + 1]
                if word in wordDict:
                    rest_res = dfs(i + 1)
                    for item in rest_res:
                        res.append([word] + item)
            memo[start] = res
            return res
        res = dfs(0)
        ans = []
        for item in res:
            ans.append(" ".join(item))
        return ans
```

# [0141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

- 标签：哈希表、链表、双指针
- 难度：简单

## 题目链接

- [0141. 环形链表 - 力扣](https://leetcode.cn/problems/linked-list-cycle/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：判断链表中是否有环。如果有环则返回 `True`，否则返回 `False`。

**说明**：

- 链表中节点的数目范围是 $[0, 10^4]$。
- $-10^5 \le Node.val \le 10^5$。
- `pos` 为 `-1` 或者链表中的一个有效索引。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```python
输入：head = [3,2,0,-4], pos = 1
输出：True
解释：链表中有一个环，其尾部连接到第二个节点。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```python
输入：head = [1,2], pos = 0
输出：True
解释：链表中有一个环，其尾部连接到第一个节点。
```

## 解题思路

### 思路 1：哈希表

最简单的思路是遍历所有节点，每次遍历节点之前，使用哈希表判断该节点是否被访问过。如果访问过就说明存在环，如果没访问过则将该节点添加到哈希表中，继续遍历判断。

### 思路 1：代码

```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        nodeset = set()

        while head:
            if head in nodeset:
                return True
            nodeset.add(head)
            head = head.next
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：快慢指针（Floyd 判圈算法）

这种方法类似于在操场跑道跑步。两个人从同一位置同时出发，如果跑道有环（环形跑道），那么快的一方总能追上慢的一方。

基于上边的想法，Floyd 用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的）。如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。

### 思路 2：代码

```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if head == None or head.next == None:
            return False

        slow = head
        fast = head.next

        while slow != fast:
            if fast == None or fast.next == None:
                return False
            slow = slow.next
            fast = fast.next.next

        return True
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。   # [0142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

- 标签：哈希表、链表、双指针
- 难度：中等

## 题目链接

- [0142. 环形链表 II - 力扣](https://leetcode.cn/problems/linked-list-cycle-ii/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：判断链表中是否有环，如果有环则返回入环的第一个节点，无环则返回 `None`。

**说明**：

- 链表中节点的数目范围在范围 $[0, 10^4]$ 内。
- $-10^5 \le Node.val \le 10^5$。
- `pos` 的值为 `-1` 或者链表中的一个有效索引。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```python
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```python
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

## 解题思路

### 思路 1：快慢指针（Floyd 判圈算法）

1. 利用两个指针，一个慢指针 `slow` 每次前进一步，快指针 `fast` 每次前进两步（两步或多步效果是等价的）。
2. 如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环。
3. 否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。
4. 如果有环，则再定义一个指针 `ans`，和慢指针一起每次移动一步，两个指针相遇的位置即为入口节点。

这是因为：假设入环位置为 `A`，快慢指针在 `B` 点相遇，则相遇时慢指针走了 $a + b$ 步，快指针走了 $a + n(b+c) + b$ 步。

因为快指针总共走的步数是慢指针走的步数的两倍，即 $2(a + b) = a + n(b + c) + b$，所以可以推出：$a = c + (n-1)(b + c)$。

我们可以发现：从相遇点到入环点的距离 $c$ 加上 $n-1$ 圈的环长 $b + c$ 刚好等于从链表头部到入环点的距离。

### 思路 1：代码

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while True:
            if not fast or not fast.next:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break

        ans = head
        while ans != slow:
            ans, slow = ans.next, slow.next
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [0143. 重排链表](https://leetcode.cn/problems/reorder-list/)

- 标签：栈、递归、链表、双指针
- 难度：中等

## 题目链接

- [0143. 重排链表 - 力扣](https://leetcode.cn/problems/reorder-list/)

## 题目大意

**描述**：给定一个单链表 $L$ 的头节点 $head$，单链表 $L$ 表示为：$L_0 \rightarrow L_1 \rightarrow L_2 \rightarrow ... \rightarrow L_{n-1} \rightarrow L_n$。

**要求**：将单链表 $L$ 重新排列为：$L_0 \rightarrow L_n \rightarrow L_1 \rightarrow L_{n-1} \rightarrow L_2 \rightarrow L_{n-2} \rightarrow L_3 \rightarrow L_{n-3} \rightarrow ...$。

**说明**：

- 需要将实际节点进行交换。

**示例**：

- 示例 1：

![](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```python
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

- 示例 2：

![](https://pic.leetcode-cn.com/1626420320-YUiulT-image.png)

```python
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

## 解题思路

### 思路 1：线性表

因为链表无法像数组那样直接进行随机访问。所以我们可以先将链表转为线性表，然后直接按照提要要求的排列顺序访问对应数据元素，重新建立链表。

### 思路 1：代码

```python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return

        vec = []
        node = head
        while node:
            vec.append(node)
            node = node.next

        left, right = 0, len(vec) - 1
        while left < right:
            vec[left].next = vec[right]
            left += 1
            if left == right:
                break
            vec[right].next = vec[left]
            right -= 1
        vec[left].next = None
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

- 标签：栈、树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0144. 二叉树的前序遍历 - 力扣](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：返回该二叉树的前序遍历结果。

**说明**：

- 树中节点数目在范围 $[0, 100]$ 内。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```python
输入：root = [1,null,2,3]
输出：[1,2,3]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```python
输入：root = [1,null,2]
输出：[1,2]
```

## 解题思路

### 思路 1：递归遍历

二叉树的前序遍历递归实现步骤为：

1. 判断二叉树是否为空，为空则直接返回。
2. 先访问根节点。
3. 然后递归遍历左子树。
4. 最后递归遍历右子树。

### 思路 1：代码

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        
        def preorder(root):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)

        preorder(root)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。

### 思路 2：模拟栈迭代遍历

二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用一个显式栈 `stack` 来模拟递归的过程。

前序遍历的顺序为：根节点 - 左子树 - 右子树，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终为前序遍历顺序。 

二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
   1. 弹出栈顶元素 `node`，并访问该元素。
   2. 如果 `node` 的右子树不为空，则将 `node` 的右子树入栈。
   3. 如果 `node` 的左子树不为空，则将 `node` 的左子树入栈。

### 思路 2：代码

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:                        # 二叉树为空直接返回
            return []
            
        res = []
        stack = [root]

        while stack:                        # 栈不为空
            node = stack.pop()              # 弹出根节点
            res.append(node.val)            # 访问根节点
            if node.right:
                stack.append(node.right)    # 右子树入栈
            if node.left:
                stack.append(node.left)     # 左子树入栈

        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。# [0145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

- 标签：栈、树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0145. 二叉树的后序遍历 - 力扣](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：返回该二叉树的后序遍历结果。

**说明**：

- 树中节点数目在范围 $[0, 100]$ 内。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```python
输入：root = [1,null,2,3]
输出：[3,2,1]
```

- 示例 2：

```python
输入：root = []
输出：[]
```

## 解题思路

### 思路 1：递归遍历

二叉树的后序遍历递归实现步骤为：

1. 判断二叉树是否为空，为空则直接返回。
2. 先递归遍历左子树。
3. 然后递归遍历右子树。
4. 最后访问根节点。

### 思路 1：代码

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        def postorder(root):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)

        postorder(root)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。

### 思路 2：模拟栈迭代遍历

我们可以使用一个显式栈 `stack` 来模拟二叉树的后序遍历递归的过程。

与前序、中序遍历不同，在后序遍历中，根节点的访问要放在左右子树访问之后。因此，我们要保证：**在左右孩子节点访问结束之前，当前节点不能提前出栈**。

我们应该从根节点开始，先将根节点放入栈中，然后依次遍历左子树，不断将当前子树的根节点放入栈中，直到遍历到左子树最左侧的那个节点，从栈中弹出该元素，并判断该元素的右子树是否已经访问完毕，如果访问完毕，则访问该元素。如果未访问完毕，则访问该元素的右子树。

二叉树的后序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个空栈，使用 `prev` 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕。
3. 当根节点或者栈不为空时，从当前节点开始：
   1. 如果当前节点有左子树，则不断遍历左子树，并将当前根节点压入栈中。
   2. 如果当前节点无左子树，则弹出栈顶元素 `node`。
   3. 如果栈顶元素 `node` 无右子树（即 `not node.right`）或者右子树已经访问完毕（即 `node.right == prev`），则访问该元素，然后记录前一节点，并将当前节点标记为空节点。
   4. 如果栈顶元素有右子树，则将栈顶元素重新压入栈中，继续访问栈顶元素的右子树。

### 思路 2：代码

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []
        prev = None                 # 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕
        
        while root or stack:        # 根节点或栈不为空
            while root:
                stack.append(root)  # 将当前树的根节点入栈
                root = root.left    # 继续访问左子树，找到最左侧节点

            node = stack.pop()      # 遍历到最左侧，当前节点无左子树时，将最左侧节点弹出

            # 如果当前节点无右子树或者右子树访问完毕
            if not node.right or node.right == prev:
                res.append(node.val)# 访问该节点
                prev = node         # 记录前一节点
                root = None         # 将当前根节点标记为空
            else:
                stack.append(node)  # 右子树尚未访问完毕，将当前节点重新压回栈中
                root = node.right   # 继续访问右子树
                
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。# [0147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

- 标签：链表、排序
- 难度：中等

## 题目链接

- [0147. 对链表进行插入排序 - 力扣](https://leetcode.cn/problems/insertion-sort-list/)

## 题目大意

**描述**：给定链表的头节点 `head`。

**要求**：对链表进行插入排序。

**说明**：

- 插入排序算法：
  - 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
  - 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
  - 重复直到所有输入数据插入完为止。
- 列表中的节点数在 $[1, 5000]$ 范围内。
- $-5000 \le Node.val \le 5000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg)

```python
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg)

```python
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

## 解题思路

### 思路 1：链表插入排序

1. 先使用哑节点 `dummy_head` 构造一个指向 `head` 的指针，使得可以从 `head` 开始遍历。

2. 维护 `sorted_list` 为链表的已排序部分的最后一个节点，初始时，`sorted_list = head`。
3. 维护 `prev` 为插入元素位置的前一个节点，维护 `cur` 为待插入元素。初始时，`prev = head`，`cur = head.next`。
4. 比较 `sorted_list` 和 `cur` 的节点值。

   - 如果 `sorted_list.val <= cur.val`，说明 `cur` 应该插入到 `sorted_list` 之后，则将 `sorted_list` 后移一位。
   - 如果 `sorted_list.val > cur.val`，说明 `cur` 应该插入到 `head` 与 `sorted_list` 之间。则使用 `prev` 从 `head` 开始遍历，直到找到插入 `cur` 的位置的前一个节点位置。然后将 `cur` 插入。

5. 令 `cur = sorted_list.next`，此时 `cur` 为下一个待插入元素。
6. 重复 4、5 步骤，直到 `cur` 遍历结束为空。返回 `dummy_head` 的下一个节点。

### 思路 1：代码

```python

    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        dummy_head = ListNode(-1)
        dummy_head.next = head
        sorted_list = head
        cur = head.next 
        
        while cur:
            if sorted_list.val <= cur.val:
                # 将 cur 插入到 sorted_list 之后
                sorted_list = sorted_list.next 
            else:
                prev = dummy_head
                while prev.next.val <= cur.val:
                    prev = prev.next
                # 将 cur 到链表中间
                sorted_list.next = cur.next
                cur.next = prev.next
                prev.next = cur
            cur = sorted_list.next 
        
        return dummy_head.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

# [0148. 排序链表](https://leetcode.cn/problems/sort-list/)

- 标签：链表、双指针、分治、排序、归并排序
- 难度：中等

## 题目链接

- [0148. 排序链表 - 力扣](https://leetcode.cn/problems/sort-list/)

## 题目大意

**描述**：给定链表的头节点 `head`。

**要求**：按照升序排列并返回排序后的链表。

**说明**：

- 链表中节点的数目在范围 $[0, 5 * 10^4]$ 内。
- $-10^5 \le Node.val \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```python
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```python
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

## 解题思路

### 思路 1：链表冒泡排序（超时）

1. 使用三个指针 `node_i`、`node_j` 和 `tail`。其中 `node_i` 用于控制外循环次数，循环次数为链节点个数（链表长度）。`node_j` 和 `tail` 用于控制内循环次数和循环结束位置。

2. 排序开始前，将 `node_i` 、`node_j` 置于头节点位置。`tail` 指向链表末尾，即 `None`。

3. 比较链表中相邻两个元素 `node_j.val` 与 `node_j.next.val` 的值大小，如果 `node_j.val > node_j.next.val`，则值相互交换。否则不发生交换。然后向右移动 `node_j` 指针，直到 `node_j.next == tail` 时停止。

4. 一次循环之后，将 `tail` 移动到 `node_j` 所在位置。相当于 `tail` 向左移动了一位。此时 `tail` 节点右侧为链表中最大的链节点。

5. 然后移动 `node_i` 节点，并将 `node_j` 置于头节点位置。然后重复第 3、4 步操作。
6. 直到 `node_i` 节点移动到链表末尾停止，排序结束。
7. 返回链表的头节点 `head`。

### 思路 1：代码

```python
class Solution:
    def bubbleSort(self, head: ListNode):
        node_i = head
        tail = None
        # 外层循环次数为 链表节点个数
        while node_i:
            node_j = head
            while node_j and node_j.next != tail:
                if node_j.val > node_j.next.val:
                    # 交换两个节点的值
                    node_j.val, node_j.next.val = node_j.next.val, node_j.val
                node_j = node_j.next
            # 尾指针向前移动 1 位，此时尾指针右侧为排好序的链表
            tail = node_j
            node_i = node_i.next
            
        return head

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.bubbleSort(head)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：链表选择排序（超时）

1. 使用两个指针 `node_i`、`node_j`。`node_i` 既可以用于控制外循环次数，又可以作为当前未排序链表的第一个链节点位置。
2. 使用 `min_node` 记录当前未排序链表中值最小的链节点。
3. 每一趟排序开始时，先令 `min_node = node_i`（即暂时假设链表中 `node_i` 节点为值最小的节点，经过比较后再确定最小值节点位置）。
4. 然后依次比较未排序链表中 `node_j.val` 与 `min_node.val` 的值大小。如果 `node_j.val < min_node.val`，则更新 `min_node` 为 `node_j`。
5. 这一趟排序结束时，未排序链表中最小值节点为 `min_node`，如果 `node_i != min_node`，则将 `node_i` 与 `min_node` 值进行交换。如果 `node_i == min_node`，则不用交换。
6. 排序结束后，继续向右移动 `node_i`，重复上述步骤，在剩余未排序链表中寻找最小的链节点，并与 `node_i` 进行比较和交换，直到 `node_i == None` 或者 `node_i.next == None` 时，停止排序。
7. 返回链表的头节点 `head`。

### 思路 2：代码

```python
class Solution:
    def sectionSort(self, head: ListNode):
        node_i = head
        # node_i 为当前未排序链表的第一个链节点
        while node_i and node_i.next:
            # min_node 为未排序链表中的值最小节点
            min_node = node_i
            node_j = node_i.next
            while node_j:
                if node_j.val < min_node.val:
                    min_node = node_j
                node_j = node_j.next
            # 交换值最小节点与未排序链表中第一个节点的值
            if node_i != min_node:
                node_i.val, min_node.val = min_node.val, node_i.val
            node_i = node_i.next
        
        return head

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.sectionSort(head)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 3：链表插入排序（超时）

1. 先使用哑节点 `dummy_head` 构造一个指向 `head` 的指针，使得可以从 `head` 开始遍历。
2. 维护 `sorted_list` 为链表的已排序部分的最后一个节点，初始时，`sorted_list = head`。
3. 维护 `prev` 为插入元素位置的前一个节点，维护 `cur` 为待插入元素。初始时，`prev = head`，`cur = head.next`。
4. 比较 `sorted_list` 和 `cur` 的节点值。

   - 如果 `sorted_list.val <= cur.val`，说明 `cur` 应该插入到 `sorted_list` 之后，则将 `sorted_list` 后移一位。
   - 如果 `sorted_list.val > cur.val`，说明 `cur` 应该插入到 `head` 与 `sorted_list` 之间。则使用 `prev` 从 `head` 开始遍历，直到找到插入 `cur` 的位置的前一个节点位置。然后将 `cur` 插入。

5. 令 `cur = sorted_list.next`，此时 `cur` 为下一个待插入元素。
6. 重复 4、5 步骤，直到 `cur` 遍历结束为空。返回 `dummy_head` 的下一个节点。

### 思路 3：代码

```python
class Solution:
    def insertionSort(self, head: ListNode):
        if not head or not head.next:
            return head
        
        dummy_head = ListNode(-1)
        dummy_head.next = head
        sorted_list = head
        cur = head.next 
        
        while cur:
            if sorted_list.val <= cur.val:
                # 将 cur 插入到 sorted_list 之后
                sorted_list = sorted_list.next 
            else:
                prev = dummy_head
                while prev.next.val <= cur.val:
                    prev = prev.next
                # 将 cur 到链表中间
                sorted_list.next = cur.next
                cur.next = prev.next
                prev.next = cur
            cur = sorted_list.next 
        
        return dummy_head.next

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.insertionSort(head)
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 4：链表归并排序（通过）

1. **分割环节**：找到链表中心链节点，从中心节点将链表断开，并递归进行分割。
   1. 使用快慢指针 `fast = head.next`、`slow = head`，让 `fast` 每次移动 `2` 步，`slow` 移动 `1` 步，移动到链表末尾，从而找到链表中心链节点，即 `slow`。
   2. 从中心位置将链表从中心位置分为左右两个链表 `left_head` 和 `right_head`，并从中心位置将其断开，即 `slow.next = None`。
   3. 对左右两个链表分别进行递归分割，直到每个链表中只包含一个链节点。
2. **归并环节**：将递归后的链表进行两两归并，完成一遍后每个子链表长度加倍。重复进行归并操作，直到得到完整的链表。
   1. 使用哑节点 `dummy_head` 构造一个头节点，并使用 `cur` 指向 `dummy_head` 用于遍历。
   2. 比较两个链表头节点 `left` 和 `right` 的值大小。将较小的头节点加入到合并后的链表中。并向后移动该链表的头节点指针。
   3. 然后重复上一步操作，直到两个链表中出现链表为空的情况。
   4. 将剩余链表插入到合并中的链表中。
   5. 将哑节点 `dummy_dead` 的下一个链节点 `dummy_head.next` 作为合并后的头节点返回。

### 思路 4：代码

```python
class Solution:
    def merge(self, left, right):
        # 归并环节
        dummy_head = ListNode(-1)
        cur = dummy_head
        while left and right:
            if left.val <= right.val:
                cur.next = left
                left = left.next
            else:
                cur.next = right
                right = right.next
            cur = cur.next
        
        if left:
            cur.next = left
        elif right:
            cur.next = right
            
        return dummy_head.next
        
    def mergeSort(self, head: ListNode):
        # 分割环节
        if not head or not head.next:
            return head
        
        # 快慢指针找到中心链节点
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next 
            fast = fast.next.next 
        
        # 断开左右链节点
        left_head, right_head = head, slow.next 
        slow.next = None
        
        # 归并操作
        return self.merge(self.mergeSort(left_head), self.mergeSort(right_head))

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.mergeSort(head)
```

### 思路 4：复杂度分析

- **时间复杂度**：$O(n \times \log_2n)$。
- **空间复杂度**：$O(1)$。

### 思路 5：链表快速排序（超时）

1. 从链表中找到一个基准值 `pivot`，这里以头节点为基准值。
2. 然后通过快慢指针 `node_i`、`node_j` 在链表中移动，使得 `node_i` 之前的节点值都小于基准值，`node_i` 之后的节点值都大于基准值。从而把数组拆分为左右两个部分。
3. 再对左右两个部分分别重复第二步，直到各个部分只有一个节点，则排序结束。

> 注意：
>
> 虽然链表快速排序算法的平均时间复杂度为 $O(n \times \log_2n)$。但链表快速排序算法中基准值 `pivot` 的取值做不到数组快速排序算法中的随机选择。一旦给定序列是有序链表，时间复杂度就会退化到 $O(n^2)$。这也是这道题目使用链表快速排序容易超时的原因。

### 思路 5：代码

```python
class Solution:
    def partition(self, left: ListNode, right: ListNode):
        # 左闭右开，区间没有元素或者只有一个元素，直接返回第一个节点
        if left == right or left.next == right:
            return left
        # 选择头节点为基准节点
        pivot = left.val
        # 使用 node_i, node_j 双指针，保证 node_i 之前的节点值都小于基准节点值，node_i 与 node_j 之间的节点值都大于等于基准节点值
        node_i, node_j = left, left.next
        
        while node_j != right:
            # 发现一个小与基准值的元素
            if node_j.val < pivot:
                # 因为 node_i 之前节点都小于基准值，所以先将 node_i 向右移动一位（此时 node_i 节点值大于等于基准节点值）
                node_i = node_i.next
                # 将小于基准值的元素 node_j 与当前 node_i 换位，换位后可以保证 node_i 之前的节点都小于基准节点值
                node_i.val, node_j.val = node_j.val, node_i.val
            node_j = node_j.next
        # 将基准节点放到正确位置上
        node_i.val, left.val = left.val, node_i.val
        return node_i
        
    def quickSort(self, left: ListNode, right: ListNode):
        if left == right or left.next == right:
            return left
        pi = self.partition(left, right)
        self.quickSort(left, pi)
        self.quickSort(pi.next, right)
        return left

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        return self.quickSort(head, None)
```

### 思路 5：复杂度分析

- **时间复杂度**：$O(n \times \log_2n)$。
- **空间复杂度**：$O(1)$。

### 思路 6：链表计数排序（通过）

1. 使用 `cur` 指针遍历一遍链表。找出链表中最大值 `list_max` 和最小值 `list_min`。
2. 使用数组 `counts` 存储节点出现次数。
3. 再次使用 `cur` 指针遍历一遍链表。将链表中每个值为 `cur.val` 的节点出现次数，存入数组对应第 `cur.val - list_min` 项中。
4. 反向填充目标链表：
   1. 建立一个哑节点 `dummy_head`，作为链表的头节点。使用 `cur` 指针指向 `dummy_head`。
   2. 从小到大遍历一遍数组 `counts`。对于每个 `counts[i] != 0` 的元素建立一个链节点，值为 `i + list_min`，将其插入到 `cur.next` 上。并向右移动 `cur`。同时 `counts[i] -= 1`。直到 `counts[i] == 0` 后继续向后遍历数组 `counts`。
5. 将哑节点 `dummy_dead` 的下一个链节点 `dummy_head.next` 作为新链表的头节点返回。

### 思路 6：代码

```python
class Solution:
    def countingSort(self, head: ListNode):
        if not head:
            return head
        
        # 找出链表中最大值 list_max 和最小值 list_min
        list_min, list_max = float('inf'), float('-inf')
        cur = head
        while cur:
            if cur.val < list_min:
                list_min = cur.val
            if cur.val > list_max:
                list_max = cur.val
            cur = cur.next
            
        size = list_max - list_min + 1
        counts = [0 for _ in range(size)]
        
        cur = head
        while cur:
            counts[cur.val - list_min] += 1
            cur = cur.next
            
        dummy_head = ListNode(-1)
        cur = dummy_head
        for i in range(size):
            while counts[i]:
                cur.next = ListNode(i + list_min)
                counts[i] -= 1
                cur = cur.next
        return dummy_head.next

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.countingSort(head)
```

### 思路 6：复杂度分析

- **时间复杂度**：$O(n + k)$，其中 $k$ 代表待排序链表中所有元素的值域。
- **空间复杂度**：$O(k)$。

### 思路 7：链表桶排序（通过）

1. 使用 `cur` 指针遍历一遍链表。找出链表中最大值 `list_max` 和最小值 `list_min`。
2. 通过 `(最大值 - 最小值) / 每个桶的大小` 计算出桶的个数，即 `bucket_count = (list_max - list_min) // bucket_size + 1`  个桶。
3. 定义数组 `buckets` 为桶，桶的个数为 `bucket_count` 个。
4. 使用 `cur` 指针再次遍历一遍链表，将每个元素装入对应的桶中。
5. 对每个桶内的元素单独排序，可以使用链表插入排序（超时）、链表归并排序（通过）、链表快速排序（超时）等算法。
6. 最后按照顺序将桶内的元素拼成新的链表，并返回。

### 思路 7：代码

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    # 将链表节点值 val 添加到对应桶 buckets[index] 中
    def insertion(self, buckets, index, val):
        if not buckets[index]:
            buckets[index] = ListNode(val)
            return
        
        node = ListNode(val)
        node.next = buckets[index]
        buckets[index] = node
        
    # 归并环节
    def merge(self, left, right):
        dummy_head = ListNode(-1)
        cur = dummy_head
        while left and right:
            if left.val <= right.val:
                cur.next = left
                left = left.next
            else:
                cur.next = right
                right = right.next
            cur = cur.next
            
        if left:
            cur.next = left
        elif right:
            cur.next = right
            
        return dummy_head.next
    
    def mergeSort(self, head: ListNode):
        # 分割环节
        if not head or not head.next:
            return head
        
        # 快慢指针找到中心链节点
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next 
            fast = fast.next.next 
            
        # 断开左右链节点
        left_head, right_head = head, slow.next 
        slow.next = None
        
        # 归并操作
        return self.merge(self.mergeSort(left_head), self.mergeSort(right_head))        
    
    def bucketSort(self, head: ListNode, bucket_size=5):
        if not head:
            return head
        
        # 找出链表中最大值 list_max 和最小值 list_min
        list_min, list_max = float('inf'), float('-inf')
        cur = head
        while cur:
            if cur.val < list_min:
                list_min = cur.val
            if cur.val > list_max:
                list_max = cur.val
            cur = cur.next
            
        # 计算桶的个数，并定义桶
        bucket_count = (list_max - list_min) // bucket_size + 1
        buckets = [[] for _ in range(bucket_count)]
        
        # 将链表节点值依次添加到对应桶中
        cur = head
        while cur:
            index = (cur.val - list_min) // bucket_size
            self.insertion(buckets, index, cur.val)
            cur = cur.next
            
        dummy_head = ListNode(-1)
        cur = dummy_head
        # 将元素依次出桶，并拼接成有序链表
        for bucket_head in buckets:
            bucket_cur = self.mergeSort(bucket_head)
            while bucket_cur:
                cur.next = bucket_cur
                cur = cur.next
                bucket_cur = bucket_cur.next
                
        return dummy_head.next
    
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.bucketSort(head)
```

### 思路 7：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n + m)$。$m$ 为桶的个数。

### 思路 8：链表基数排序（解答错误，普通链表基数排序只适合非负数）

1. 使用 `cur` 指针遍历链表，获取节点值位数最长的位数 `size`。
2. 从个位到高位遍历位数。因为 `0` ~ `9` 共有 `10` 位数字，所以建立 `10` 个桶。
3. 以每个节点对应位数上的数字为索引，将节点值放入到对应桶中。
4. 建立一个哑节点 `dummy_head`，作为链表的头节点。使用 `cur` 指针指向 `dummy_head`。
5. 将桶中元素依次取出，并根据元素值建立链表节点，并插入到新的链表后面。从而生成新的链表。
6. 之后依次以十位，百位，…，直到最大值元素的最高位处值为索引，放入到对应桶中，并生成新的链表，最终完成排序。
7. 将哑节点 `dummy_dead` 的下一个链节点 `dummy_head.next` 作为新链表的头节点返回。

### 思路 8：代码

```python
class Solution:
    def radixSort(self, head: ListNode):       
        # 计算位数最长的位数
        size = 0
        cur = head
        while cur:
            val_len = len(str(cur.val))
            if val_len > size:
                size = val_len
            cur = cur.next
        
        # 从个位到高位遍历位数
        for i in range(size):
            buckets = [[] for _ in range(10)]
            cur = head
            while cur:
                # 以每个节点对应位数上的数字为索引，将节点值放入到对应桶中
                buckets[cur.val // (10 ** i) % 10].append(cur.val)
                cur = cur.next
            
            # 生成新的链表
            dummy_head = ListNode(-1)
            cur = dummy_head
            for bucket in buckets:
                for num in bucket:
                    cur.next = ListNode(num)
                    cur = cur.next
            head = dummy_head.next
            
        return head
    
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.radixSort(head)
```

### 思路 8：复杂度分析

- **时间复杂度**：$O(n \times k)$。其中 $n$ 是待排序元素的个数，$k$ 是数字位数。$k$ 的大小取决于数字位的选择（十进制位、二进制位）和待排序元素所属数据类型全集的大小。
- **空间复杂度**：$O(n + k)$。

## 参考资料

- 【文章】[单链表的冒泡排序_zhao_miao的博客 - CSDN博客](https://blog.csdn.net/zhao_miao/article/details/81708454)
- 【文章】[链表排序总结（全）（C++）- 阿祭儿 - CSDN博客](https://blog.csdn.net/qq_32523711/article/details/107402873)
- 【题解】[快排、冒泡、选择排序实现列表排序 - 排序链表 - 力扣](https://leetcode.cn/problems/sort-list/solution/kuai-pai-mou-pao-xuan-ze-pai-xu-shi-xian-ula7/)
- 【题解】[归并排序+快速排序 - 排序链表 - 力扣](https://leetcode.cn/problems/sort-list/solution/gui-bing-pai-xu-kuai-su-pai-xu-by-datacruiser/)
- 【题解】[排序链表（递归+迭代）详解 - 排序链表 - 力扣](https://leetcode.cn/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/)
- 【题解】[Sort List （归并排序链表） - 排序链表 - 力扣](https://leetcode.cn/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/)
# [0149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

- 标签：几何、数组、哈希表、数学
- 难度：困难

## 题目链接

- [0149. 直线上最多的点数 - 力扣](https://leetcode.cn/problems/max-points-on-a-line/)

## 题目大意

给定一个平面上的 n 个点的坐标数组 points，求解最多有多少个点在同一条直线上。

## 解题思路

两个点可以确定一条直线，固定其中一个点，求其他点与该点的斜率，斜率相同的点则在同一条直线上。可以考虑把斜率当做哈希表的键值，存储经过该点，不同斜率的直线上经过的点数目。

对于点 i，查找经过该点的直线只需要考虑 (i+1,n-1) 位置上的点即可，因为 i-1 之前的点已经在遍历点 i-2 的时候考虑过了。

斜率的计算公式为 $\frac{dy}{dx} = \frac{y_j - y_i}{x_j - x_i}$。

因为斜率是小数会有精度误差，所以我们考虑使用 (dx, dy) 的元组作为哈希表的 key。

>  注意：
>
> 需要处理倍数关系，dy、dx 异号情况，以及处理垂直直线（两点横坐标差为 0）的水平直线（两点横坐标差为 0）的情况。

## 代码

```python
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n < 3:
            return n
        ans = 0
        for i in range(n):
            line_dict = dict()
            line_dict[0] = 0
            same = 1
            for j in range(i+1, n):
                dx = points[j][0] - points[i][0]
                dy = points[j][1] - points[i][1]
                if dx == 0 and dy == 0:
                    same += 1
                    continue
                gcd_dx_dy = math.gcd(abs(dx), abs(dy))
                if (dx > 0 and dy > 0) or (dx < 0 and dy < 0):
                    dx = abs(dx) // gcd_dx_dy
                    dy = abs(dy) // gcd_dx_dy
                elif dx < 0 and dy > 0:
                    dx = -dx // gcd_dx_dy
                    dy = -dy // gcd_dx_dy
                elif dx > 0 and dy < 0:
                    dx = dx // gcd_dx_dy
                    dy = dy // gcd_dx_dy
                elif dx == 0 and dy != 0:
                    dy = 1
                elif dx != 0 and dy == 0:
                    dx = 1
                key = (dx, dy)
                if key in line_dict:
                    line_dict[key] += 1
                else:
                    line_dict[key] = 1
            ans = max(ans, same + max(line_dict.values()))
        return ans
```

# [0150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

- 标签：栈、数组、数学
- 难度：中等

## 题目链接

- [0150. 逆波兰表达式求值 - 力扣](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

## 题目大意

**描述**：给定一个字符串数组 `tokens`，表示「逆波兰表达式」。

**要求**：求解表达式的值。

**说明**：

- **逆波兰表达式**：也称为后缀表达式。
  - 中缀表达式 `( 1 + 2 ) * ( 3 + 4 ) `，对应的逆波兰表达式为 ` ( ( 1 2 + ) ( 3 4 + ) * )` 。

- $1 \le tokens.length \le 10^4$。
- `tokens[i]` 是一个算符（`+`、`-`、`*` 或 `/`），或是在范围 $[-200, 200]$ 内的一个整数。

**示例**：

- 示例 1：

```python
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

- 示例 2：

```python
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

## 解题思路

### 思路 1：栈

这道题是栈的典型应用。我们先来简单介绍一下逆波兰表达式。

逆波兰表达式，也叫做后缀表达式，特点是：没有括号，运算符总是放在和它相关的操作数之后。
我们平常见到的表达式是中缀表达式，可写为：`A 运算符 B`。其中 `A`、`B` 都是操作数。
而后缀表达式可写为：`A B 运算符`。

逆波兰表达式的计算遵循从左到右的规律。我们在计算逆波兰表达式的值时，可以使用一个栈来存放当前的操作数，从左到右依次遍历逆波兰表达式，计算出对应的值。具体操作步骤如下：

1. 使用列表 `stack` 作为栈存放操作数，然后遍历表达式的字符串数组。
2. 如果当前字符为运算符，则取出栈顶两个元素，在进行对应的运算之后，再将运算结果入栈。
3. 如果当前字符为数字，则直接将数字入栈。
4. 遍历结束后弹出栈中最后剩余的元素，这就是最终结果。

### 思路 1：代码

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token == '+':
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                stack.append(int(1 / stack.pop() * stack.pop()))
            else:
                stack.append(int(token))
        return stack.pop()
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [0151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

- 标签：双指针、字符串
- 难度：中等

## 题目链接

- [0151. 反转字符串中的单词 - 力扣](https://leetcode.cn/problems/reverse-words-in-a-string/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：反转字符串中所有单词的顺序。

**说明**：

- **单词**：由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的单词分隔开。
- 输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。
- 返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
- $1 \le s.length \le 10^4$。
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中至少存在一个单词。

**示例**：

- 示例 1：

```python
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

- 示例 2：

```python
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

## 解题思路

### 思路 1：调用库函数

直接调用 Python 的库函数，对字符串进行切片，翻转，然后拼合成字符串。

### 思路 1：代码

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是字符串 `s` 的长度。
- **空间复杂度**：$O(1)$。

### 思路 2：模拟

第二种思路根据 API 的思路写出模拟代码，具体步骤如下：

- 使用数组 `words` 存放单词，使用字符串变量 `cur` 存放当前单词。
- 遍历字符串，对于当前字符 `ch`。
- 如果遇到空格，则：
  - 如果当前单词不为空，则将当前单词存入数组 `words` 中，并将当前单词置为空串
- 如果遇到字符，则：
  - 将其存入当前单词中，即 `cur += ch`。
- 如果遍历完，当前单词不为空，则将当前单词存入数组 `words` 中。
- 然后对数组 `words` 进行翻转操作，令 `words[i]`, `words[len(words) - 1 - i]` 交换元素。
- 最后将 `words` 中的单词连接起来，中间拼接上空格，将其作为答案返回。

### 思路 2：代码

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        words = []
        cur = ""
        for ch in s:
            if ch == ' ':
                if cur:
                    words.append(cur)
                    cur = ""
            else:
                cur += ch
        
        if cur:
            words.append(cur)
               
        for i in range(len(words) // 2):
            words[i], words[len(words) - 1 - i] = words[len(words) - 1 - i], words[i]
        
        return " ".join(words)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是字符串 `s` 的长度。
- **空间复杂度**：$O(1)$。# [0152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0152. 乘积最大子数组 - 力扣](https://leetcode.cn/problems/maximum-product-subarray/)

## 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：找出数组中乘积最大的连续子数组（最少包含一个数字），并返回该子数组对应的乘积。

**说明**：

- 测试用例的答案是一个 32-位整数。
- **子数组**：数组的连续子序列。
- $1 \le nums.length \le 2 * 10^4$。
- $-10 \le nums[i] \le 10$。
- `nums` 的任何前缀或后缀的乘积都保证是一个 32-位整数。

**示例**：

- 示例 1：

```python
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

- 示例 2：

```python
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 解题思路

### 思路 1：动态规划

这道题跟「[0053. 最大子序和](https://leetcode.cn/problems/maximum-subarray/)」有点相似，不过一个求的是和的最大值，这道题求解的是乘积的最大值。

乘积有个特殊情况，两个正数、两个负数相乘都会得到正数。所以求解的时候需要考虑负数的情况。

若想要最终的乘积最大，则应该使子数组中的正数元素尽可能的大，负数元素尽可能的小。所以我们可以维护一个最大值变量和最小值变量。

###### 1. 划分阶段

按照子数组的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp_max[i]` 为：以第 $i$ 个元素结尾的乘积最大子数组的乘积。

定义状态 `dp_min[i]` 为：以第 $i$ 个元素结尾的乘积最小子数组的乘积。

###### 3. 状态转移方程

- `dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i], dp_min[i - 1] * nums[i])`
- `dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i], dp_max[i - 1] * nums[i])`

###### 4. 初始条件

- 以第 $0$ 个元素结尾的乘积最大子数组的乘积为 `nums[0]`，即 `dp_max[0] = nums[0]`。
- 以第 $0$ 个元素结尾的乘积最小子数组的乘积为 `nums[0]`，即 `dp_min[0] = nums[0]`。

###### 5. 最终结果

根据状态定义，最终结果为 $dp_{max}$ 中最大值，即乘积最大子数组的乘积。

### 思路 1：代码

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        size = len(nums)
        dp_max = [0 for _ in range(size)]
        dp_min = [0 for _ in range(size)]
        dp_max[0] = nums[0]
        dp_min[0] = nums[0]
        ans = nums[0]
        for i in range(1, size):
            dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i], dp_min[i - 1] * nums[i])
            dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i], dp_max[i - 1] * nums[i])
        return max(dp_max)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为整数数组 `nums` 的元素个数。
- **空间复杂度**：$O(n)$。

### 思路 2：动态规划 + 滚动优化

因为状态转移方程中只涉及到当前元素和前一个元素，所以我们也可以不使用数组，只使用两个变量来维护 $dp_{max}[i]$ 和 $dp_{min}[i]$。

### 思路 2：代码

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        size = len(nums)
        max_num, min_num = nums[0], nums[0]
        ans = nums[0]
        for i in range(1, size):
            temp_max = max_num
            temp_min = min_num
            max_num = max(temp_max * nums[i], nums[i], temp_min * nums[i])
            min_num = min(temp_min * nums[i], nums[i], temp_max * nums[i])
            ans = max(max_num, ans)
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为整数数组 `nums` 的元素个数。
- **空间复杂度**：$O(1)$。
# [0153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0153. 寻找旋转排序数组中的最小值 - 力扣](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

## 题目大意

**描述**：给定一个数组 $nums$，$nums$ 是有升序数组经过「旋转」得到的。但是旋转次数未知。数组中不存在重复元素。

**要求**：找出数组中的最小元素。

**说明**：

- 旋转操作：将数组整体右移若干位置。
- $n == nums.length$。
- $1 \le n \le 5000$。
- $-5000 \le nums[i] \le 5000$。
- $nums$ 中的所有整数互不相同。
- $nums$ 原来是一个升序排序的数组，并进行了 $1$ 至 $n$ 次旋转。

**示例**：

- 示例 1：

```python
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

- 示例 2：

```python
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

## 解题思路

### 思路 1：二分查找

数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。

第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。

```python
          *
        *
      *
    *
  *
*
```

```python
    *
  *
*
          *
        *
      *
```

最直接的办法就是遍历一遍，找到最小值。但是还可以有更好的方法。考虑用二分查找来降低算法的时间复杂度。

创建两个指针 $left$、$right$，分别指向数组首尾。让后计算出两个指针中间值 $mid$。将 $mid$ 与两个指针做比较。

1. 如果 $nums[mid] > nums[right]$，则最小值不可能在 $mid$ 左侧，一定在 $mid$ 右侧，则将 $left$ 移动到 $mid + 1$ 位置，继续查找右侧区间。
2. 如果 $nums[mid] \le nums[right]$，则最小值一定在 $mid$ 左侧，或者 $mid$ 位置，将 $right$ 移动到 $mid$ 位置上，继续查找左侧区间。

### 思路 1：代码

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

- 标签：数组、二分查找
- 难度：困难

## 题目链接

- [154. 寻找旋转排序数组中的最小值 II - 力扣](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

## 题目大意

**描述**：给定一个数组 $nums$，$nums$ 是有升序数组经过 $1 \sim n$ 次「旋转」得到的。但是旋转次数未知。数组中可能存在重复元素。

**要求**：找出数组中的最小元素。

**说明**：

- 旋转：将数组整体右移 $1$ 位。数组 $[a[0], a[1], a[2], ..., a[n-1]]$ 旋转一次的结果为数组 $[a[n-1], a[0], a[1], a[2], ..., a[n-2]]$。
- $n == nums.length$。
- $1 \le n \le 5000$。
- $-5000 \le nums[i] \le 5000$
- $nums$ 原来是一个升序排序的数组，并进行了 $1 \sim n$ 次旋转。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,5]
输出：1
```

- 示例 2：

```python
输入：nums = [2,2,2,0,1]
输出：0
```

## 解题思路

### 思路 1：二分查找

数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。

第一种的最小值在最左边。

```
          *
        *
      *
    *
  *
*
```

第二种最小值在第二段升序序列的第一个元素。

```
    *
  *
*
          *
        *
      *
```

最直接的办法就是遍历一遍，找到最小值。但是还可以有更好的方法。考虑用二分查找来降低算法的时间复杂度。

创建两个指针 $left$、$right$，分别指向数组首尾。然后计算出两个指针中间值 $mid$。将 $mid$ 与右边界进行比较。

1. 如果 $nums[mid] > nums[right]$，则最小值不可能在 $mid$ 左侧，一定在 $mid$ 右侧，则将 $left$ 移动到 $mid + 1$ 位置，继续查找右侧区间。
2. 如果 $nums[mid] < nums[right]$，则最小值一定在 $mid$ 左侧，令右边界 $right$ 为 $mid$，继续查找左侧区间。
3. 如果 $nums[mid] == nums[right]$，无法判断在 $mid$ 的哪一侧，可以采用 `right = right - 1` 逐步缩小区域。

### 思路 1：代码

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
            else:
                right = right - 1
        return nums[left]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0155. 最小栈](https://leetcode.cn/problems/min-stack/)

- 标签：栈、设计
- 难度：中等

## 题目链接

- [0155. 最小栈 - 力扣](https://leetcode.cn/problems/min-stack/)

## 题目大意

**要求**：设计一个「栈」。实现  `push` ，`pop` ，`top` ，`getMin` 操作，其中 `getMin` 要求能在常数时间内实现。

**说明**：

- $-2^{31} \le val \le 2^{31} - 1$。
- `pop`、`top` 和 `getMin` 操作总是在非空栈上调用
- `push`，`pop`，`top` 和 `getMin` 最多被调用 $3 * 10^4$ 次。

**示例**：

- 示例 1：

```python
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

## 解题思路

题目要求在常数时间内获取最小值，所以我们不能在 `getMin` 操作时，再去计算栈中的最小值。而是应该在 `push`、`pop` 操作时就已经计算好了最小值。我们有两种思路来解决这道题。

### 思路 1：辅助栈

使用辅助栈保存当前栈中的最小值。在元素入栈出栈时，两个栈同步保持插入和删除。具体做法如下：

- `push` 操作：当一个元素入栈时，取辅助栈的栈顶存储的最小值，与当前元素进行比较得出最小值，将最小值插入到辅助栈中；该元素也插入到正常栈中。
- `pop` 操作：当一个元素要出栈时，将辅助栈的栈顶元素一起弹出。
- `top` 操作：返回正常栈的栈顶元素值。
- `getMin` 操作：返回辅助栈的栈顶元素值。

### 思路 1：代码

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.minstack = []

    def push(self, val: int) -> None:
        if not self.stack:
            self.stack.append(val)
            self.minstack.append(val)
        else:
            self.stack.append(val)
            self.minstack.append(min(val, self.minstack[-1]))
        
    def pop(self) -> None:
        self.stack.pop()
        self.minstack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minstack[-1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。栈的插入、删除、读取操作都是 $O(1)$。
- **空间复杂度**：$O(n)$。其中 $n$ 为总操作数。

### 思路 2：单个栈

使用单个栈，保存元组：（当前元素值，当前栈内最小值）。具体操作如下：

-  `push` 操作：如果栈不为空，则判断当前元素值与栈顶元素所保存的最小值，并更新当前最小值，然后将新元素和当前最小值组成的元组保存到栈中。
-  `pop`操作：正常出栈，即将栈顶元素弹出。
-  `top` 操作：返回栈顶元素保存的值。
-  `getMin` 操作：返回栈顶元素保存的最小值。

### 思路 2：代码

```python
class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    class Node:
        def __init__(self, x):
            self.val = x
            self.min = x

    def push(self, val: int) -> None:
        node = self.Node(val)
        if len(self.stack) == 0:
            self.stack.append(node)
        else:
            topNode = self.stack[-1]
            if node.min > topNode.min:
                node.min = topNode.min

            self.stack.append(node)

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1].val

    def getMin(self) -> int:
        return self.stack[-1].min
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(1)$。栈的插入、删除、读取操作都是 $O(1)$。
- **空间复杂度**：$O(n)$。其中 $n$ 为总操作数。# [0159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0159. 至多包含两个不同字符的最长子串 - 力扣](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)

## 题目大意

给定一个字符串 s，找出之多包含两个不同字符的最长子串 t，并返回该子串的长度。

## 解题思路

使用滑动窗口来求解。

left，right 指向字符串开始位置。

不断向右移动 right 指针，使用 count 变量来统计滑动窗口中共有多少个字符，以及使用哈希表来统计当前字符的频数。

当滑动窗口的字符多于 2 个时，向右 移动 left 指针，并减少哈希表中对应原 left 指向字符的频数。

最后使用 max_count 来维护最长子串 t 的长度。

## 代码

```python
import collections
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        max_count = 0
        k = 2
        counts = collections.defaultdict(int)
        count = 0
        left, right = 0, 0
        while right < len(s):
            if counts[s[right]] == 0:
                count += 1
            counts[s[right]] += 1
            right += 1
            if count > k:
                if counts[s[left]] == 1:
                    count -= 1
                counts[s[left]] -= 1
                left += 1
            max_count = max(max_count, right - left)
        return max_count
```

# [0160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

- 标签：哈希表、链表、双指针
- 难度：简单

## 题目链接

- [0160. 相交链表 - 力扣](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

## 题目大意

**描述**：给定 `listA`、`listB` 两个链表。

**要求**：判断两个链表是否相交，返回相交的起始点。如果不相交，则返回 `None`。

**说明**：

- `listA` 中节点数目为 $m$。
- `listB` 中节点数目为 $n$。
- $1 \le m, n \le 3 * 10^4$。
- $1 \le Node.val \le 10^5$。
- $0 \le skipA \le m$。
- $0 \le skipB \le n$。
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 $0$。
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```python
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)

```python
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

## 解题思路

### 思路 1：双指针

如果两个链表相交，那么从相交位置开始，到结束，必有一段等长且相同的节点。假设链表 `listA` 的长度为 $m$、链表 `listB` 的长度为 $n$，他们的相交序列有 $k$ 个，则相交情况可以如下如所示：

![](https://qcdn.itcharge.cn/images/20210401113538.png)

现在问题是如何找到 $m - k$ 或者 $n - k$ 的位置。

考虑将链表 `listA` 的末尾拼接上链表 `listB`，链表 `listB` 的末尾拼接上链表 `listA`。

然后使用两个指针 `pA` 、`pB`，分别从链表 `listA`、链表 `listB` 的头节点开始遍历，如果走到共同的节点，则返回该节点。

否则走到两个链表末尾，返回 `None`。

![](https://qcdn.itcharge.cn/images/20210401114100.png)

### 思路 1：代码

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if headA == None or headB == None:
            return None
        pA = headA
        pB = headB
        while pA != pB:
            pA = pA.next if pA != None else headB
            pB = pB.next if pB != None else headA
        return pA
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$。
- **空间复杂度**：$O(1)$。

# [0162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0162. 寻找峰值 - 力扣](https://leetcode.cn/problems/find-peak-element/)

## 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：找到峰值元素并返回其索引。必须实现时间复杂度为 $O(\log n)$ 的算法来解决此问题。

**说明**：

- **峰值元素**：指其值严格大于左右相邻值的元素。
- 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
- 可以假设 $nums[-1] = nums[n] = -∞$。
- $1 \le nums.length \le 1000$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- 对于所有有效的 $i$ 都有 $nums[i] != nums[i + 1]$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

- 示例 2：

```python
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。
```

## 解题思路

### 思路 1：二分查找

1. 使用两个指针 `left`、`right` 。`left` 指向数组第一个元素，`right` 指向数组最后一个元素。
2. 取区间中间节点 `mid`，并比较 `nums[mid]` 和 `nums[mid + 1]` 的值大小。
   1. 如果 `nums[mid]` 小于 `nums[mid + 1]`，则右侧存在峰值，令 `left = mid + 1`。
   2. 如果 `nums[mid]` 大于等于 `nums[mid + 1]`，则左侧存在峰值，令 `right = mid`。
3. 最后，当 `left == right` 时，跳出循环，返回 `left`。

### 思路 1：代码

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < nums[mid + 1]:
                left = mid + 1
            else:
                right = mid
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log_2 n)$。
- **空间复杂度**：$O(1)$。# [0164. 最大间距](https://leetcode.cn/problems/maximum-gap/)

- 标签：数组、桶排序、基数排序、排序
- 难度：困难

## 题目链接

- [0164. 最大间距 - 力扣](https://leetcode.cn/problems/maximum-gap/)

## 题目大意

**描述**：给定一个无序数组 $nums$。

**要求**：找出数组在排序之后，相邻元素之间最大的差值。如果数组元素个数小于 $2$，则返回 $0$。

**说明**：

- 所有元素都是非负整数，且数值在 $32$ 位有符号整数范围内。
- 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

**示例**：

- 示例 1：

```python
输入: nums = [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```

- 示例 2：

```python
输入: nums = [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```

## 解题思路

### 思路 1：基数排序

这道题的难点在于要求时间复杂度和空间复杂度为 $O(n)$。

这道题分为两步：

1. 数组排序。
2. 计算相邻元素之间的差值。

第 2 步直接遍历数组求解即可，时间复杂度为 $O(n)$。所以关键点在于找到一个时间复杂度和空间复杂度为 $O(n)$ 的排序算法。根据题意可知所有元素都是非负整数，且数值在 32 位有符号整数范围内。所以我们可以选择基数排序。基数排序的步骤如下：

- 遍历数组元素，获取数组最大值元素，并取得位数。
- 以个位元素为索引，对数组元素排序。
- 合并数组。
- 之后依次以十位，百位，…，直到最大值元素的最高位处值为索引，进行排序，并合并数组，最终完成排序。

最后，还要注意数组元素个数小于 $2$ 的情况需要特别判断一下。

### 思路 1：代码

```python
class Solution:
    def radixSort(self, arr):
        size = len(str(max(arr)))

        for i in range(size):
            buckets = [[] for _ in range(10)]
            for num in arr:
                buckets[num // (10 ** i) % 10].append(num)
            arr.clear()
            for bucket in buckets:
                for num in bucket:
                    arr.append(num)

        return arr

    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        arr = self.radixSort(nums)
        return max(arr[i] - arr[i - 1] for i in range(1, len(arr)))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。# [0166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

- 标签：哈希表、数学、字符串
- 难度：中等

## 题目链接

- [0166. 分数到小数 - 力扣](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

## 题目大意

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，要求以字符串的形式返回该分数对应小数结果。

- 如果小数部分为循环小数，则将循环的小数部分括在括号内。

## 解题思路

先处理特殊数据，例如 0、负数等。

然后利用整除运算，计算出分数的整数部分。在根据取余运算结果，判断是否含有小数部分。

因为小数部分可能会有循环部分，所以使用哈希表来判断是否出现了循环小数。哈希表所存键值为 数字：数字开始位置。

然后计算小数部分，每次将被除数 * 10 然后对除数进行整除，再对被除数进行取余操作，直到被除数变为 0，或者在字典中出现了循环小数为止。

## 代码

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return '0'
        res = []
        if numerator ^ denominator < 0:
            res.append('-')
        numerator, denominator = abs(numerator), abs(denominator)
        res.append(str(numerator // denominator))
        numerator %= denominator
        if numerator == 0:
            return ''.join(res)
        res.append('.')

        record = dict()
        while numerator:
            if numerator not in record:
                record[numerator] = len(res)
                numerator *= 10
                res.append(str(numerator // denominator))
                numerator %= denominator
            else:
                res.insert(record[numerator], '(')
                res.append(')')
                break
        return ''.join(res)
```

# [0167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

- 标签：数组、双指针、二分查找
- 难度：中等

## 题目链接

- [0167. 两数之和 II - 输入有序数组 - 力扣](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

## 题目大意

**描述**：给定一个下标从 $1$ 开始计数、升序排列的整数数组：$numbers$ 和一个目标值 $target$。

**要求**：从数组中找出满足相加之和等于 $target$ 的两个数，并返回两个数在数组中下的标值。

**说明**：

- $2 \le numbers.length \le 3 \times 10^4$。
- $-1000 \le numbers[i] \le 1000$。
- $numbers$ 按非递减顺序排列。
- $-1000 \le target \le 1000$。
- 仅存在一个有效答案。

**示例**：

- 示例 1：

```python
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9。因此 index1 = 1, index2 = 2。返回 [1, 2]。
```

- 示例 2：

```python
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6。因此 index1 = 1, index2 = 3。返回 [1, 3]。
```

## 解题思路

这道题如果暴力遍历数组，从中找到相加之和等于 $target$ 的两个数，时间复杂度为 $O(n^2)$，可以尝试一下。

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        size = len(numbers)
        for i in range(size):
            for j in range(i + 1, size):
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]
        return [-1, -1]
```

结果不出意外的超时了。所以我们要想办法降低时间复杂度。

### 思路 1：二分查找

因为数组是有序的，可以考虑使用二分查找来减少时间复杂度。具体做法如下：

1. 使用一重循环遍历数组，先固定第一个数，即 $numsbers[i]$。
2. 然后使用二分查找的方法寻找符合要求的第二个数。
3. 使用两个指针 $left$，$right$。$left$ 指向数组第一个数的下一个数，$right$ 指向数组值最大元素位置。
4. 判断第一个数 $numsbers[i]$ 和两个指针中间元素 $numbers[mid]$ 的和与目标值的关系。
   1. 如果 $numbers[mid] + numbers[i] < target$，排除掉不可能区间 $[left, mid]$，在 $[mid + 1, right]$ 中继续搜索。
   2. 如果 $numbers[mid] + numbers[i] \ge target$，则第二个数可能在 $[left, mid]$ 中，则在 $[left, mid]$ 中继续搜索。
5. 直到 $left$ 和 $right$ 移动到相同位置停止检测。如果 $numbers[left] + numbers[i] == target$，则返回两个元素位置 $[left + 1, i + 1]$（下标从 $1$ 开始计数）。
6. 如果最终仍没找到，则返回 $[-1, -1]$。

### 思路 1：代码

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers)):
            left, right = i + 1, len(numbers) - 1
            while left < right:
                mid = left + (right - left) // 2
                if numbers[mid] + numbers[i] < target:
                    left = mid + 1
                else:
                    right = mid
            if numbers[left] + numbers[i] == target:
                return [i + 1, left + 1]

        return [-1, -1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：对撞指针

可以考虑使用对撞指针来减少时间复杂度。具体做法如下：

1. 使用两个指针 $left$，$right$。$left$ 指向数组第一个值最小的元素位置，$right$ 指向数组值最大元素位置。
2. 判断两个位置上的元素的和与目标值的关系。
   1. 如果元素和等于目标值，则返回两个元素位置。
   2. 如果元素和大于目标值，则让 $right$ 左移，继续检测。
   3. 如果元素和小于目标值，则让 $left$ 右移，继续检测。
3. 直到 $left$ 和 $right$ 移动到相同位置停止检测。
4. 如果最终仍没找到，则返回 $[-1, -1]$。

### 思路 2：代码

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers) - 1
        while left < right:
            total = numbers[left] + numbers[right]
            if total == target:
                return [left + 1, right + 1]
            elif total < target:
                left += 1
            else:
                right -= 1
        return [-1, -1]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [0168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/)

- 标签：数学、字符串
- 难度：简单

## 题目链接

- [0168. Excel表列名称 - 力扣](https://leetcode.cn/problems/excel-sheet-column-title/)

## 题目大意

描述：给定一个正整数 columnNumber。

要求：返回它在 Excel 表中相对应的列名称。

1 -> A，2 -> B，3 -> C，…，26 -> Z，…，28 -> AB

## 解题思路

实质上就是 10 进制转 26 进制。不过映射范围是 1~26，而不是 0~25，如果将 columnNumber 直接对 26 取余，则结果为 0~25，而本题余数为 1~26。可以直接将 columnNumber = columnNumber - 1，这样就可以将范围变为 0~25 就更加容易判断了。

## 代码

```python
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        s = ""
        while columnNumber:
            columnNumber -= 1
            s = chr(65 + columnNumber % 26) + s
            columnNumber //= 26
        return s
```

# [0169. 多数元素](https://leetcode.cn/problems/majority-element/)

- 标签：数组、哈希表、分治、计数、排序
- 难度：简单

## 题目链接

- [0169. 多数元素 - 力扣](https://leetcode.cn/problems/majority-element/)

## 题目大意

**描述**：给定一个大小为 $n$ 的数组 `nums`。

**要求**：返回其中相同元素个数最多的元素。

**说明**：

- $n == nums.length$。
- $1 \le n \le 5 * 10^4$。
- $-10^9 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [3,2,3]
输出：3
```

- 示例 2：

```python
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

## 解题思路

### 思路 1：哈希表

1. 遍历数组 `nums`。
2. 对于当前元素 `num`，用哈希表统计每个元素 `num` 出现的次数。
3. 再遍历一遍哈希表，找出元素个数最多的元素即可。

### 思路 1：代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        numDict = dict()
        for num in nums:
            if num in numDict:
                numDict[num] += 1
            else:
                numDict[num] = 1
        max = float('-inf')
        max_index = -1
        for num in numDict:
            if numDict[num] > max:
                max = numDict[num]
                max_index = num
        return max_index
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：分治算法

如果 `num` 是数组 `nums` 的众数，那么我们将 `nums` 分为两部分，则 `num` 至少是其中一部分的众数。

则我们可以用分治法来解决这个问题。具体步骤如下：

1. 将数组 `nums` 递归地将当前序列平均分成左右两个数组，直到所有子数组长度为 `1`。
2. 长度为 $1$ 的子数组众数肯定是数组中唯一的数，将其返回即可。
3. 将两个子数组依次向上两两合并。
   1. 如果两个子数组的众数相同，则说明合并后的数组众数为：两个子数组的众数。
   2. 如果两个子数组的众数不同，则需要比较两个众数在整个区间的众数。

4. 最后返回整个数组的众数。

### 思路 2：代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        def get_mode(low, high):
            if low == high:
                return nums[low]
            
            mid = low + (high - low) // 2
            left_mod = get_mode(low, mid)
            right_mod = get_mode(mid + 1, high)

            if left_mod == right_mod:
                return left_mod

            left_mod_cnt, right_mod_cnt = 0, 0
            for i in range(low, high + 1):
                if nums[i] == left_mod:
                    left_mod_cnt += 1
                if nums[i] == right_mod:
                    right_mod_cnt += 1
            
            if left_mod_cnt > right_mod_cnt:
                return left_mod
            return right_mod

        return get_mode(0, len(nums) - 1)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(\log n)$。# [0170. 两数之和 III - 数据结构设计](https://leetcode.cn/problems/two-sum-iii-data-structure-design/)

- 标签：设计、数组、哈希表、双指针、数据流
- 难度：简单

## 题目链接

- [0170. 两数之和 III - 数据结构设计 - 力扣](https://leetcode.cn/problems/two-sum-iii-data-structure-design/)

## 题目大意

设计一个接受整数流的数据结构，使该数据结构支持检查是否存在两数之和等于特定值。

实现 TwoSum 类：

- `TwoSum()`：使用空数组初始化 TwoSum 对象
- `def add(self, number: int) -> None:`向数据结构添加一个数 number
- `def find(self, value: int) -> bool:`寻找数据结构中是否存在一对整数，使得两数之和与给定的值 value 相等。如果存在，返回 True ；否则，返回 False 。

## 解题思路

使用哈希表存储数组元素值与元素频数的关系。哈希表中键值对信息为 number: count。count 为 number 在数组中的频数。

- `add(number)` 函数中：在哈希表添加 number 与其频数之间的关系。
- `find(number)` 函数中：遍历哈希表，对于每个 number，检测哈希表中是否存在 value - number，如果存在则终止循环并返回结果。
  - 如果 `number == value - number`，则判断哈希表中 number 的数目是否大于等于 2。

## 代码

```python
class TwoSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.num_counts = dict()


    def add(self, number: int) -> None:
        """
        Add the number to an internal data structure..
        """
        if number in self.num_counts:
            self.num_counts[number] += 1
        else:
            self.num_counts[number] = 1


    def find(self, value: int) -> bool:
        """
        Find if there exists any pair of numbers which sum is equal to the value.
        """
        for number in self.num_counts.keys():
            number2 = value - number
            if number == number2:
                if self.num_counts[number] > 1:
                    return True
            else:
                if number2 in self.num_counts:
                    return True
        return False
```
# [0171. Excel 表列序号](https://leetcode.cn/problems/excel-sheet-column-number/)

- 标签：数学、字符串
- 难度：简单

## 题目链接

- [0171. Excel 表列序号 - 力扣](https://leetcode.cn/problems/excel-sheet-column-number/)

## 题目大意

给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。

要求：返回该列名称对应的列序号。

## 解题思路

Excel 表的列名称由大写字母组成，共有 26 个，因此列名称的表示实质是 26 进制，需要将 26 进制转换成十进制。转换过程如下：

- 将每一位对应列名称转换成整数（注意列序号从 `1` 开始）。
- 将当前结果乘上进制数（`26`），然后累加上当前位上的整数。

最后输出答案。

## 代码

```python
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        ans = 0
        for ch in columnTitle:
            num = ord(ch) - ord('A') + 1
            ans = ans * 26 + num
        return ans
```

# [0172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)

- 标签：数学
- 难度：中等

## 题目链接

- [0172. 阶乘后的零 - 力扣](https://leetcode.cn/problems/factorial-trailing-zeroes/)

## 题目大意

给定一个整数 `n`。

要求：返回 `n!` 结果中尾随零的数量。

注意：$0 <= n <= 10^4$

## 解题思路

阶乘中，末尾 `0` 的来源只有 `2 * 5`。所以尾随 `0` 的个数为 `2` 的倍数个数和 `5` 的倍数个数的最小值。又因为 `2 < 5`，`2` 的倍数个数肯定小于等于 `5` 的倍数，所以直接统计 `5` 的倍数个数即可。

## 代码

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n > 0:
            count += n // 5
            n = n // 5
        return count
```

# [0173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

- 标签：栈、树、设计、二叉搜索树、二叉树、迭代器
- 难度：中等

## 题目链接

- [0173. 二叉搜索树迭代器 - 力扣](https://leetcode.cn/problems/binary-search-tree-iterator/)

## 题目大意

**要求**：实现一个二叉搜索树的迭代器 BSTIterator。表示一个按中序遍历二叉搜索树（BST）的迭代器：

- `def __init__(self, root: TreeNode):`：初始化 BSTIterator 类的一个对象，会给出二叉搜索树的根节点。
- `def hasNext(self) -> bool:`：如果向右指针遍历存在数字，则返回 True，否则返回 False。
- `def next(self) -> int:`：将指针向右移动，返回指针处的数字。

**说明**：

- 指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。
- 可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 的中序遍历中至少存在一个下一个数字。
- 树中节点的数目在范围 $[1, 10^5]$ 内。
- $0 \le Node.val \le 10^6$。
- 最多调用 $10^5$ 次 `hasNext` 和 `next` 操作。
- 进阶：设计一个满足下述条件的解决方案，`next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)` ，并使用 `O(h)` 内存。其中 `h` 是树的高度。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

```python
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]
```

## 解题思路

### 思路 1：中序遍历二叉搜索树

中序遍历的顺序是：左、根、右。我们使用一个栈来保存节点，以便于迭代的时候取出对应节点。

- 初始的遍历当前节点的左子树，将其路径上的节点存储到栈中。
- 调用 next 方法的时候，从栈顶取出节点，因为之前已经将路径上的左子树全部存入了栈中，所以此时该节点的左子树为空，这时候取出节点右子树，再将右子树的左子树进行递归遍历，并将其路径上的节点存储到栈中。
- 调用 hasNext 的方法的时候，直接判断栈中是否有值即可。

### 思路 1：代码

```python
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack = []
        self.in_order(root)

    def in_order(self, node):
        while node:
            self.stack.append(node)
            node = node.left

    def next(self) -> int:
        node = self.stack.pop()
        if node.right:
            self.in_order(node.right)
        return node.val

    def hasNext(self) -> bool:
        return len(self.stack) != 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中节点数量。
- **空间复杂度**：$O(n)$。

# [0179. 最大数](https://leetcode.cn/problems/largest-number/)

- 标签：贪心、数组、字符串、排序
- 难度：中等

## 题目链接

- [0179. 最大数 - 力扣](https://leetcode.cn/problems/largest-number/)

## 题目大意

**描述**：给定一个非负整数数组 `nums`。

**要求**：重新排列数组中每个数的顺序，使之将数组中所有数字按顺序拼接起来所组成的整数最大。

**说明**：

- $1 \le nums.length \le 100$。
- $0 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [10,2]
输出："210"
```

- 示例 2：

```python
输入：nums = [3,30,34,5,9]
输出："9534330"
```

## 解题思路

### 思路 1：排序

本质上是给数组进行排序。假设 `x`、`y` 是数组 `nums` 中的两个元素。如果拼接字符串 `x + y < y + x`，则 `y > x `。`y` 应该排在 `x` 前面。反之，则 `y < x`。

按照上述规则，对原数组进行排序即可。这里我们使用了 `functools.cmp_to_key` 自定义排序函数。

### 思路 1：代码

```python
import functools

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def cmp(a, b):
            if a + b == b + a:
                return 0
            elif a + b > b + a:
                return 1
            else:
                return -1
        nums_s = list(map(str, nums))
        nums_s.sort(key=functools.cmp_to_key(cmp), reverse=True)
        return str(int(''.join(nums_s)))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。其中 $n$ 是给定数组 `nums` 的大小。
- **空间复杂度**：$O(n)$。# [0188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [0188. 买卖股票的最佳时机 IV - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

## 题目大意

给定一个数组 `prices` 代表一只股票，其中 `prices[i]` 代表这只股票第 `i` 天的价格。再给定一个整数 `k`，表示最多可完成 `k` 笔交易，且不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。

现在要求：计算所能获取的最大利润。

## 解题思路

动态规划求解。这道题是「[0123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)」的升级版，不过思路一样

最多可完成两笔交易意味着总共有三种情况：买卖一次，买卖两次，不买卖。

具体到每一天结束总共有 `2 * k + 1` 种状态：

0. 未进行买卖状态；
1. 第 `1` 次买入状态；
2. 第 `1` 次卖出状态；
3. 第 `2` 次买入状态；
4. 第 `2` 次卖出状态。
5. ...
6. 第 `m` 次买入状态。
7. 第 `m` 次卖出状态。

因为买入、卖出为两种状态，干脆我们直接让偶数序号表示买入状态，奇数序号表示卖出状态。

所以我们可以定义状态 `dp[i][j]` ，表示为：第 `i` 天第 `j` 种情况（`0 <= j <= 2 * k`）下，所获取的最大利润。

注意：这里第 `j` 种情况，并不一定是这一天一定要买入或卖出，而是这一天所处于的买入卖出状态。比如说前一天是第一次买入，第二天没有操作，则第二天就沿用前一天的第一次买入状态。

接下来确定状态转移公式：

- 第 `0` 种状态下显然利润为 `0`，可以直接赋值为昨天获取的最大利润，即 `dp[i][0] = dp[i - 1][0]`。
- 第 `1` 次买入状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天买入状态所得的最大利润：`dp[i][1] = dp[i - 1][1]`。
  - 第 `1` 次买入：`dp[i][1] = dp[i - 1][0] - prices[i]`。
- 第 `1` 次卖出状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][2] = dp[i - 1][2]`。
  - 第 `1` 次卖出：`dp[i][2] = dp[i - 1][1] + prices[i]`。
- 第 `2` 次买入状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天买入状态所得的最大利润：`dp[i][3] = dp[i - 1][3]`。
  - 第 `2` 次买入：`dp[i][3] = dp[i - 1][2] - prices[i]`。
- 第 `2` 次卖出状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][4] = dp[i - 1][4]`。
  - 第 `2` 次卖出：`dp[i][4] = dp[i - 1][3] + prices[i]`。
- ...
- 第 `m` 次（`j = 2 * m`）买入状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][j] = dp[i - 1][j]`。
  - 第 `m` 次买入：`dp[i][j] = dp[i - 1][j - 1] - prices[i]`。
- 第 `m` 次（`j = 2 * m + 1`）卖出状态下可以有两种状态推出，取最大的那一种赋值：
  - 不做任何操作，直接沿用前一天卖出状态所得的最大利润：`dp[i][j] = dp[i - 1][j]`。
  - 第 `m` 次卖出：`dp[i][j] = dp[i - 1][j - 1] + prices[i]`。

下面确定初始化的边界值：

可以很明显看出第一天不做任何操作就是 `dp[0][0] = 0`，第 `m` 次买入（`j = 2 * m`）就是 `dp[0][j] = -prices[i]`。

第 `m` 次（`j = 2 * m + 1`）卖出的话，可以视作为没有盈利（当天买卖，价格没有变化），即 `dp[0][j] = 0`。

在递推结束后，最大利润肯定是无操作、第 `m` 次卖出这几种种情况里边，且为最大值。我们在维护的时候维护的是最大值，则第 `m` 次卖出所获得的利润肯定大于等于 0。而且，如果最优情况为 `m - 1` 笔交易，那么在转移状态时，我们允许在一天内进行多次交易，则 `m - 1` 笔交易的状态可以转移至  `m` 笔交易，最终都可以转移至 `k` 比交易。

所以最终答案为 `dp[size - 1][2 * k]`。`size` 为股票天数。

## 代码

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        size = len(prices)
        if size == 0:
            return 0

        dp = [[0 for _ in range(2 * k + 1)] for _ in range(size)]

        for j in range(1, 2 * k, 2):
            dp[0][j] = -prices[0]

        for i in range(1, size):
            for j in range(1, 2 * k + 1):
                if j % 2 == 1:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])
        return dp[size - 1][2 * k]
```

# [0189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

- 标签：数组、数学、双指针
- 难度：中等

## 题目链接

- [0189. 轮转数组 - 力扣](https://leetcode.cn/problems/rotate-array/)

## 题目大意

**描述**：给定一个数组 $nums$，再给定一个数字 $k$。

**要求**：将数组中的元素向右移动 $k$ 个位置。

**说明**：

- $1 \le nums.length \le 10^5$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- $0 \le k \le 10^5$。
- 使用空间复杂度为 $O(1)$ 的原地算法解决这个问题。

**示例**：

- 示例 1：

```python
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

- 示例 2：

```py
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

## 解题思路

### 思路 1： 数组翻转

可以用一个新数组，先保存原数组的后 $k$ 个元素，再保存原数组的前 $n - k$ 个元素。但题目要求不使用额外的数组空间，那么就需要在原数组上做操作。

我们可以先把整个数组翻转一下，这样后半段元素就到了前边，前半段元素就到了后边，只不过元素顺序是反着的。我们再从 $k$ 位置分隔开，将 $[0...k - 1]$ 区间上的元素和 $[k...n - 1]$ 区间上的元素再翻转一下，就得到了最终结果。

具体步骤：

1. 将数组 $[0, n - 1]$ 位置上的元素全部翻转。
2. 将数组 $[0, k - 1]$ 位置上的元素进行翻转。
3. 将数组 $[k, n - 1]$ 位置上的元素进行翻转。

### 思路 1：代码

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k = k % n
        self.reverse(nums, 0, n-1)
        self.reverse(nums, 0, k-1)
        self.reverse(nums, k, n-1)
    def reverse(self, nums: List[int], left: int, right: int) -> None:
        while left < right :
            tmp = nums[left]
            nums[left] = nums[right]
            nums[right] = tmp
            left += 1
            right -= 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。翻转的时间复杂度为 $O(n)$ 。
- **空间复杂度**：$O(1)$。# [0190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)

- 标签：位运算、分治
- 难度：简单

## 题目链接

- [0190. 颠倒二进制位 - 力扣](https://leetcode.cn/problems/reverse-bits/)

## 题目大意

**描述**：给定一个 $32$ 位无符号整数 $n$。

**要求**：将 $n$ 所有二进位进行翻转，并返回翻转后的整数。

**说明**：

- 输入是一个长度为 $32$ 的二进制字符串。

**示例**：

- 示例 1：

```python
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

- 示例 2：

```python
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111。
```

## 解题思路

### 思路 1：逐位翻转

1. 用一个变量 $res$ 存储翻转后的结果。
2. 将 $n$ 不断进行右移（即 `n >> 1`），从低位到高位进行枚举，此时 $n$ 的最低位就是我们枚举的二进位。
3. 同时 $res$ 不断左移（即 `res << 1`），并将当前枚举的二进位翻转后的结果（即 `n & 1`）拼接到 $res$ 的末尾（即 `(res << 1) | (n & 1)`）。

### 思路 1：代码

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            res = (res << 1) | (n & 1)
            n >>= 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。# [0191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

- 标签：位运算、分治
- 难度：简单

## 题目链接

- [0191. 位1的个数 - 力扣](https://leetcode.cn/problems/number-of-1-bits/)

## 题目大意

**描述**：给定一个无符号整数 $n$。

**要求**：统计其对应二进制表达式中 $1$ 的个数。

**说明**：

- 输入必须是长度为 $32$ 的二进制串。

**示例**：

- 示例 1：

```python
输入：n = 00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

- 示例 2：

```python
输入：n = 00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

## 解题思路

### 思路 1：循环按位计算

1. 对整数 $n$ 的每一位进行按位与运算，并统计结果。

### 思路 1：代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n:
            ans += (n & 1)
            n = n >> 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(k)$，其中 $k$ 是二进位的位数，$k = 32$。
- **空间复杂度**：$O(1)$。

### 思路 2：改进位运算

利用 `n & (n - 1)`。这个运算刚好可以将 $n$ 的二进制中最低位的 $1$ 变为 $0$。 

比如 $n = 6$ 时，$6 = 110_{(2)}$，$6 - 1 = 101_{(2)}$，`110 & 101 = 100`。

利用这个位运算，不断的将 $n$ 中最低位的 $1$ 变为 $0$，直到 $n$ 变为 $0$ 即可，其变换次数就是我们要求的结果。

### 思路 2：代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n:
            n = n & (n - 1)
            ans += 1
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0198. 打家劫舍 - 力扣](https://leetcode.cn/problems/house-robber/)

## 题目大意

**描述**：给定一个数组 $nums$，$nums[i]$ 代表第 $i$ 间房屋存放的金额。相邻的房屋装有防盗系统，假如相邻的两间房屋同时被偷，系统就会报警。

**要求**：假如你是一名专业的小偷，计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**说明**：

- $1 \le nums.length \le 100$。
- $0 \le nums[i] \le 400$。

**示例**：

- 示例 1：

```python
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4。
```

- 示例 2：

```python
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照房屋序号进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：前 $i$ 间房屋所能偷窃到的最高金额。

###### 3. 状态转移方程

$i$ 间房屋的最后一个房子是 $nums[i - 1]$。

如果房屋数大于等于 $2$ 间，则偷窃第 $i - 1$ 间房屋的时候，就有两种状态：

1. 偷窃第 $i - 1$ 间房屋，那么第 $i - 2$ 间房屋就不能偷窃了，偷窃的最高金额为：前 $i - 2$ 间房屋的最高总金额 + 第 $i - 1$ 间房屋的金额，即 $dp[i] = dp[i - 2] + nums[i - 1]$；
1. 不偷窃第 $i - 1$ 间房屋，那么第 $i - 2$ 间房屋可以偷窃，偷窃的最高金额为：前 $i - 1$ 间房屋的最高总金额，即 $dp[i] = dp[i - 1]$。

然后这两种状态取最大值即可，即状态转移方程为：

$dp[i] = \begin{cases} nums[0] & i = 1 \cr max(dp[i - 2] + nums[i - 1], dp[i - 1]) & i \ge 2\end{cases}$

###### 4. 初始条件

- 前 $0$ 间房屋所能偷窃到的最高金额为 $0$，即 $dp[0] = 0$。
- 前 $1$ 间房屋所能偷窃到的最高金额为 $nums[0]$，即：$dp[1] = nums[0]$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：前 $i$ 间房屋所能偷窃到的最高金额。则最终结果为 $dp[size]$，$size$ 为总的房屋数。

### 思路 1：代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return 0
 
        dp = [0 for _ in range(size + 1)]
        dp[0] = 0
        dp[1] = nums[0]
        
        for i in range(2, size + 1):
            dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])

        return dp[size]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

# [0199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0199. 二叉树的右视图 - 力扣](https://leetcode.cn/problems/binary-tree-right-side-view/)

## 题目大意

**描述**：给定一棵二叉树的根节点 `root`。

**要求**：按照从顶部到底部的顺序，返回从右侧能看到的节点值。

**说明**：

- 二叉树的节点个数的范围是 $[0,100]$。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```python
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

- 示例 2：

```python
输入: [1,null,3]
输出: [1,3]
```

## 解题思路

### 思路 1：广度优先搜索

使用广度优先搜索对二叉树进行层次遍历。在遍历每层节点的时候，只需要将最后一个节点加入结果数组即可。

### 思路 1：代码

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            size = len(queue)
            for i in range(size):
                curr = queue.pop(0)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if i == size - 1:
                order.append(curr.val)
        return order
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。



# [0200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [0200. 岛屿数量 - 力扣](https://leetcode.cn/problems/number-of-islands/)

## 题目大意

**描述**：给定一个由字符 `'1'`（陆地）和字符 `'0'`（水）组成的的二维网格 $grid$。

**要求**：计算网格中岛屿的数量。

**说明**：

- 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
- 此外，你可以假设该网格的四条边均被水包围。
- $m == grid.length$。
- $n == grid[i].length$。
- $1 \le m, n \le 300$。
- $grid[i][j]$ 的值为 `'0'` 或 `'1'`。

**示例**：

- 示例 1：

```python
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

- 示例 2：

```python
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

## 解题思路

如果把上下左右相邻的字符 `'1'` 看做是 `1` 个连通块，这道题的目的就是求解一共有多少个连通块。

使用深度优先搜索或者广度优先搜索都可以。

### 思路 1：深度优先搜索

1. 遍历 $grid$。
2. 对于每一个字符为 `'1'` 的元素，遍历其上下左右四个方向，并将该字符置为 `'0'`，保证下次不会被重复遍历。
3. 如果超出边界，则返回 $0$。
4. 对于 $(i, j)$ 位置的元素来说，递归遍历的位置就是 $(i - 1, j)$、$(i, j - 1)$、$(i + 1, j)$、$(i, j + 1)$ 四个方向。每次遍历到底，统计数记录一次。
5. 最终统计出深度优先搜索的次数就是我们要求的岛屿数量。

### 思路 1：代码

```python
class Solution:
    def dfs(self, grid, i, j):
        n = len(grid)
        m = len(grid[0])
        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '0':
            return 0
        grid[i][j] = '0'
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)

    def numIslands(self, grid: List[List[str]]) -> int:
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    self.dfs(grid, i, j)
                    count += 1
        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(m \times n)$。

# [0201. 数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

- 标签：位运算
- 难度：中等

## 题目链接

- [0201. 数字范围按位与 - 力扣](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

## 题目大意

**描述**：给定两个整数 $left$ 和 $right$，表示区间 $[left, right]$。

**要求**：返回此区间内所有数字按位与的结果（包含 $left$、$right$ 端点）。

**说明**：

- $0 \le left \le right \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：left = 5, right = 7
输出：4
```

- 示例 2：

```python
输入：left = 1, right = 2147483647
输出：0
```

## 解题思路

### 思路 1：位运算

很容易想到枚举算法：对于区间 $[left, right]$，如果使用枚举算法，对区间范围内的数依次进行按位与操作，最后输出结果。

但是枚举算法在区间范围很大的时候会超时，所以我们应该换个思路来解决这道题。

我们知道与运算的规则如下：

- `0 & 0 == 0`
- `0 & 1 == 0`
- `1 & 0 == 0`
- `1 & 1 == 1`。

只有对应位置上都为 $1$ 的情况下，按位与才能得到 $1$。而对应位置上只要出现 $0$，则该位置上最终的按位与结果一定为 $0$。

那么我们可以先来求一下区间所有数对应二进制的公共前缀，假设这个前缀的长度为 $x$。

公共前缀部分因为每个位置上的二进制值完全一样，所以按位与的结果也相同。

接下来考虑除了公共前缀的剩余的二进制位部分。

这时候剩余部分有两种情况：

- $x = 31$。则 $left == right$，其按位与结果就是 $left$ 本身。
- $0 \le x < 31$。这种情况下因为 $left < right$，所以 $left$ 的第 $x + 1$ 位必然为 $0$，$right$ 的第 $x + 1$ 位必然为 $1$。
  - 注意：$left$、$right$ 第 $x + 1$ 位上不可能同为 $0$ 或 $1$，这样就是公共前缀了。
  - 注意：同样不可能是 $left$ 第 $x + 1$ 位为 $1$，$right$ 第 $x + 1$ 位为 $0$，这样就是 $left > right$ 了。

而从第 $x + 1$ 位起，从 $left$ 到 $right$。肯定会经过 $10000...$ 的位置，从而使得除了公共前缀的剩余部分（后面的 $31 - x$ 位）的按位与结果一定为 $0$。

举个例子，$x = 27$，则除了公共前缀的剩余部分长度为 $4$。则剩余部分从 $0XXX$ 到 $1XXX$ 必然会经过 $1000$，则剩余部分的按位与结果为 $0000$。

那么这道题就转变为了求 $[left, right]$ 区间范围内所有数的二进制公共前缀，然后在后缀位置上补上 $0$。

求解公共前缀，我们借助于 Brian Kernigham 算法中的 `n & (n - 1)` 公式来计算。

- `n & (n - 1)` 公式：对 $n$ 和 $n - 1$ 进行按位与运算后，$n$ 最右边的 $1$ 会变成 $0$，也就是清除了 $n$ 对应二进制的最右侧的 $1$。比如 $n = 10110100_{(2)}$，进行 `n & (n - 1)` 操作之后，就变为了 $n = 10110000_{(2)}$。

具体计算步骤如下：

1. 对于给定的区间范围 $[left, right]$，对 $right$ 进行 `right & (right - 1)` 迭代。
2. 直到 $right$ 小于等于 $left$，此时区间内非公共前缀的 $1$ 均变为了 $0$。
3. 最后输出 $right$ 作为答案。

### 思路 1：位运算代码

```python
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        while left < right:
            right = right & (right - 1)
        return right
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

## 参考资料

- 【题解】[巨好理解的位运算思路 - 数字范围按位与 - 力扣](https://leetcode.cn/problems/bitwise-and-of-numbers-range/solution/ju-hao-li-jie-de-wei-yun-suan-si-lu-by-time-limit/)
# [0202. 快乐数](https://leetcode.cn/problems/happy-number/)

- 标签：哈希表、数学、双指针
- 难度：简单

## 题目链接

- [0202. 快乐数 - 力扣](https://leetcode.cn/problems/happy-number/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：判断 $n$ 是否为快乐数。

**说明**：

- 快乐数定义：

  - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
  - 然后重复这个过程直到这个数变为 $1$，也可能是 无限循环 但始终变不到 $1$。
  - 如果 可以变为 $1$，那么这个数就是快乐数。
- $1 \le n \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：n = 19
输出：True
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

- 示例 2：

```python
输入：n = 2
输出：False
```

## 解题思路

### 思路 1：哈希表 / 集合

根据题意，不断重复操作，数可能变为 $1$，也可能是无限循环。无限循环其实就相当于链表形成了闭环，可以用哈希表来存储为一位生成的数，每次判断该数是否存在于哈希表中。如果已经出现在哈希表里，则说明进入了无限循环，该数就不是快乐数。如果没有出现则将该数加入到哈希表中，进行下一次计算。不断重复这个过程，直到形成闭环或者变为 $1$。

### 思路 1：代码

```python
class Solution:
    def getNext(self, n: int):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum


    def isHappy(self, n: int) -> bool:
        num_set = set()
        while n != 1 and n not in num_set:
            num_set.add(n)
            n = self.getNext(n)
        return n == 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。

# [0203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [0203. 移除链表元素 - 力扣](https://leetcode.cn/problems/remove-linked-list-elements/)

## 题目大意

**描述**：给定一个链表的头节点 `head` 和一个值 `val`。

**要求**：删除链表中值为 `val` 的节点，并返回新的链表头节点。

**说明**：

- 列表中的节点数目在范围 $[0, 10^4]$ 内。
- $1 \le Node.val \le 50$。
- $0 \le val \le 50$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

```python
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

- 示例 2：

```python
输入：head = [], val = 1
输出：[]
```

## 解题思路

### 思路 1：迭代

- 使用两个指针 `prev` 和 `curr`。`prev` 指向前一节点和当前节点，`curr` 指向当前节点。
- 从前向后遍历链表，遇到值为 `val` 的节点时，将 `prev` 的 `next` 指针指向当前节点的下一个节点，继续递归遍历。没有遇到则将 `prev` 指针向后移动一步。
- 向右移动 `curr`，继续遍历。

需要注意的是：因为要删除的节点可能包含了头节点，我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则直接删除原头节点，然后最后返回新建头节点的下一个节点即可。

### 思路 1：代码

```python
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        newHead = ListNode(0, head)
        newHead.next = head

        prev, curr = newHead, head
        while curr:
            if curr.val == val:
                prev.next = curr.next
            else:
                prev = curr
            curr = curr.next
        return newHead.next
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0204. 计数质数](https://leetcode.cn/problems/count-primes/)

- 标签：数组、数学、枚举、数论
- 难度：中等

## 题目链接

- [0204. 计数质数 - 力扣](https://leetcode.cn/problems/count-primes/)

## 题目大意

**描述**：给定 一个非负整数 $n$。

**要求**：统计小于 $n$ 的质数数量。

**说明**：

- $0 \le n \le 5 * 10^6$。

**示例**：

- 示例 1：

```python
输入 n = 10
输出 4
解释 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7。
```

- 示例 2：

```python
输入：n = 1
输出：0
```

## 解题思路

### 思路 1：枚举算法（超时）

对于小于 $n$ 的每一个数 $x$，我们可以枚举区间 $[2, x - 1]$ 上的数是否是 $x$ 的因数，即是否存在能被 $x$ 整数的数。如果存在，则该数 $x$ 不是质数。如果不存在，则该数 $x$ 是质数。

这样我们就可以通过枚举 $[2, n - 1]$ 上的所有数 $x$，并判断 $x$ 是否为质数。

在遍历枚举的同时，我们维护一个用于统计小于 $n$ 的质数数量的变量 `cnt`。如果符合要求，则将计数 `cnt` 加 $1$。最终返回该数目作为答案。

考虑到如果 $i$ 是 $x$ 的因数，则 $\frac{x}{i}$ 也必然是 $x$ 的因数，则我们只需要检验这两个因数中的较小数即可。而较小数一定会落在 $[2, \sqrt x]$ 上。因此我们在检验 $x$ 是否为质数时，只需要枚举 $[2, \sqrt x]$ 中的所有数即可。

利用枚举算法单次检查单个数的时间复杂度为 $O(\sqrt{n})$，检查 $n$ 个数的整体时间复杂度为 $O(n \sqrt{n})$。

### 思路 1：代码

```python
class Solution:
    def isPrime(self, x):
        for i in range(2, int(pow(x, 0.5)) + 1):
            if x % i == 0:
                return False
        return True

    def countPrimes(self, n: int) -> int:
        cnt = 0
        for x in range(2, n):
            if self.isPrime(x):
                cnt += 1
        return cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \sqrt{n})$。
- **空间复杂度**：$O(1)$。

### 思路 2：埃氏筛法

可以用「埃氏筛」进行求解。这种方法是由古希腊数学家埃拉托斯尼斯提出的，具体步骤如下：

- 使用长度为 $n$ 的数组 `is_prime` 来判断一个数是否是质数。如果 `is_prime[i] == True` ，则表示 $i$ 是质数，如果 `is_prime[i] == False`，则表示 $i$ 不是质数。并使用变量 `count` 标记质数个数。
- 然后从 $[2, n - 1]$ 的第一个质数（即数字 $2$） 开始，令 `count` 加 $1$，并将该质数在 $[2, n - 1]$ 范围内所有倍数（即 $4$、$6$、$8$、...）都标记为非质数。
- 然后根据数组 `is_prime` 中的信息，找到下一个没有标记为非质数的质数（即数字  $3$），令 `count` 加 $1$，然后将该质数在 $[2, n - 1]$ 范围内的所有倍数（即 $6$、$9$、$12$、…）都标记为非质数。
- 以此类推，直到所有小于或等于 $n - 1$ 的质数和质数的倍数都标记完毕时，输出 `count`。

优化：对于一个质数 $x$，我们可以直接从 $x \times x$ 开始标记，这是因为 $2 \times x$、$3 \times x$、… 这些数已经在 $x$ 之前就被其他数的倍数标记过了，例如 $2$ 的所有倍数、$3$ 的所有倍数等等。

### 思路 2：代码

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        is_prime = [True] * n
        count = 0
        for i in range(2, n):
            if is_prime[i]:
                count += 1
                for j in range(i * i, n, i):
                    is_prime[j] = False
        return count
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log_2{log_2n})$。
- **空间复杂度**：$O(n)$。

# [0205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

- 标签：哈希表、字符串
- 难度：简单

## 题目链接

- [0205. 同构字符串 - 力扣](https://leetcode.cn/problems/isomorphic-strings/)

## 题目大意

**描述**：给定两个字符串 $s$ 和 $t$。

**要求**：判断字符串 $s$ 和 $t$ 是否是同构字符串。

**说明**：

- **同构字符串**：如果 $s$ 中的字符可以按某种映射关系替换得到 $t$ 相同位置上的字符，那么两个字符串是同构的。
- 每个字符都应当映射到另一个字符，且不改变字符顺序。不同字符不能映射到统一字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
- $1 \le s.length \le 5 \times 10^4$。
- $t.length == s.length$。
- $s$ 和 $t$ 由任意有效的 ASCII 字符组成。

**示例**：

- 示例 1：

```python
输入：s = "egg", t = "add"
输出：True
```

- 示例 2：

```python
输入：s = "foo", t = "bar"
输出：False
```

## 解题思路

### 思路 1：哈希表

根据题目意思，字符串 $s$ 和 $t$ 每个位置上的字符是一一对应的。$s$ 的每个字符都与 $t$ 对应位置上的字符对应。可以考虑用哈希表来存储 $s[i]: t[i]$ 的对应关系。但是这样不能只能保证对应位置上的字符是对应的，但不能保证是唯一对应的。所以还需要另一个哈希表来存储 $t[i]:s[i]$ 的对应关系来判断是否是唯一对应的。

### 思路 1：代码

```python
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        s_dict = dict()
        t_dict = dict()
        for i in range(len(s)):
            if s[i] in s_dict and s_dict[s[i]] != t[i]:
                return False
            if t[i] in t_dict and t_dict[t[i]] != s[i]:
                return False
            s_dict[s[i]] = t[i]
            t_dict[t[i]] = s[i]
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串长度。
- **空间复杂度**：$O(|S|)$ ，其中 $S$ 是字符串字符集。

# [0206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [0206. 反转链表 - 力扣](https://leetcode.cn/problems/reverse-linked-list/)

## 题目大意

**描述**：给定一个单链表的头节点 `head`。

**要求**：将该单链表进行反转。可以迭代或递归地反转链表。

**说明**：

- 链表中节点的数目范围是 $[0, 5000]$。
- $-5000 \le Node.val \le 5000$。

**示例**：

- 示例 1：

```python
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
解释：
翻转前    1->2->3->4->5->NULL
反转后    5->4->3->2->1->NULL
```

## 解题思路

### 思路 1：迭代

1. 使用两个指针 `cur` 和 `pre` 进行迭代。`pre` 指向 `cur` 前一个节点位置。初始时，`pre` 指向 `None`，`cur` 指向 `head`。

2. 将 `pre` 和 `cur` 的前后指针进行交换，指针更替顺序为：
   1. 使用 `next` 指针保存当前节点 `cur` 的后一个节点，即 `next = cur.next`；
   2. 断开当前节点 `cur` 的后一节点链接，将 `cur` 的 `next` 指针指向前一节点 `pre`，即 `cur.next = pre`；
   3. `pre` 向前移动一步，移动到 `cur` 位置，即 `pre = cur`；
   4. `cur` 向前移动一步，移动到之前 `next` 指针保存的位置，即 `cur = next`。
3. 继续执行第 2 步中的 1、2、3、4。
4. 最后等到 `cur` 遍历到链表末尾，即 `cur == None`，时，`pre` 所在位置就是反转后链表的头节点，返回新的头节点 `pre`。

使用迭代法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111133639.png)

### 思路 1：代码

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur != None:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        return pre
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：递归

具体做法如下：

1. 首先定义递归函数含义为：将链表反转，并返回反转后的头节点。
2. 然后从 `head.next` 的位置开始调用递归函数，即将 `head.next` 为头节点的链表进行反转，并返回该链表的头节点。
3. 递归到链表的最后一个节点，将其作为最终的头节点，即为 `new_head`。
4. 在每次递归函数返回的过程中，改变 `head` 和 `head.next` 的指向关系。也就是将 `head.next` 的`next` 指针先指向当前节点 `head`，即 `head.next.next = head `。
5. 然后让当前节点 `head` 的 `next` 指针指向 `None`，从而实现从链表尾部开始的局部反转。
6. 当递归从末尾开始顺着递归栈的退出，从而将整个链表进行反转。
7. 最后返回反转后的链表头节点 `new_head`。

使用递归法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111134246.png)

### 思路 2：代码

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None or head.next == None:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$。最多需要 $n$ 层栈空间。

## 参考资料

- 【题解】[反转链表 - 反转链表 - 力扣](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/)
- 【题解】[【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/)
# [0207. 课程表](https://leetcode.cn/problems/course-schedule/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [0207. 课程表 - 力扣](https://leetcode.cn/problems/course-schedule/)

## 题目大意

**描述**：给定一个整数 $numCourses$，代表这学期必须选修的课程数量，课程编号为 $0 \sim numCourses - 1$。再给定一个数组 $prerequisites$ 表示先修课程关系，其中 $prerequisites[i] = [ai, bi]$ 表示如果要学习课程 $ai$ 则必须要先完成课程 $bi$。

**要求**：判断是否可能完成所有课程的学习。如果可以，返回 `True`，否则，返回 `False`。

**说明**：

- $1 \le numCourses \le 10^5$。
- $0 \le prerequisites.length \le 5000$。
- $prerequisites[i].length == 2$。
- $0 \le ai, bi < numCourses$。
- $prerequisites[i]$ 中所有课程对互不相同。

**示例**：

- 示例 1：

```python
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。这是可能的。
```

- 示例 2：

```python
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

## 解题思路

### 思路 1：拓扑排序

1. 使用哈希表 $graph$ 存放课程关系图，并统计每门课程节点的入度，存入入度列表 $indegrees$。
2. 借助队列 $S$，将所有入度为 $0$ 的节点入队。
3. 从队列中选择一个节点 $u$，并令课程数减 $1$。
4. 从图中删除该顶点 $u$，并且删除从该顶点出发的有向边 $<u, v>$（也就是把该顶点可达的顶点入度都减 $1$）。如果删除该边后顶点 $v$ 的入度变为 $0$，则将其加入队列 $S$ 中。
5. 重复上述步骤 $3 \sim 4$，直到队列中没有节点。
6. 最后判断剩余课程数是否为 $0$，如果为 $0$，则返回 `True`，否则，返回 `False`。

### 思路 1：代码

```python
import collections

class Solution:
    def topologicalSorting(self, numCourses, graph):
        indegrees = {u: 0 for u in graph}
        for u in graph:
            for v in graph[u]:
                indegrees[v] += 1
        
        S = collections.deque([u for u in indegrees if indegrees[u] == 0])
        
        while S:
            u = S.pop()
            numCourses -= 1
            for v in graph[u]:
                indegrees[v] -= 1
                if indegrees[v] == 0:
                    S.append(v)
        
        if numCourses == 0:
            return True
        return False

    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = dict()
        for i in range(numCourses):
            graph[i] = []
            
        for v, u in prerequisites:
            graph[u].append(v)
            
        return self.topologicalSorting(numCourses, graph)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 为课程数，$m$ 为先修课程的要求数。
- **空间复杂度**：$O(n + m)$。

# [0208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [0208. 实现 Trie (前缀树) - 力扣](https://leetcode.cn/problems/implement-trie-prefix-tree/)

## 题目大意

**要求**：实现前缀树数据结构的相关类 `Trie` 类。

`Trie` 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word`。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `True`（即，在检索之前已经插入）；否则，返回 `False`。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `True`；否则，返回 `False`。

**说明**：

- $1 \le word.length, prefix.length \le 2000$。
- `word` 和 `prefix` 仅由小写英文字母组成。
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 $3 * 10^4$ 次。

**示例**：

- 示例 1：

```python
输入：
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出：
[null, null, true, false, true, null, true]

解释：
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

## 解题思路

### 思路 1：前缀树（字典树）

前缀树（字典树）是一棵多叉树，其中每个节点包含指向子节点的指针数组 `children`，以及布尔变量 `isEnd`。`children` 用于存储当前字符节点，一般长度为所含字符种类个数，也可以使用哈希表代替指针数组。`isEnd` 用于判断该节点是否为字符串的结尾。

下面依次讲解插入、查找前缀的具体步骤：

**插入字符串**：

- 从根节点开始插入字符串。对于待插入的字符，有两种情况：
  - 如果该字符对应的节点存在，则沿着指针移动到子节点，继续处理下一个字符。
  - 如果该字符对应的节点不存在，则创建一个新的节点，保存在 `children` 中对应位置上，然后沿着指针移动到子节点，继续处理下一个字符。
- 重复上述步骤，直到最后一个字符，然后将该节点标记为字符串的结尾。

**查找前缀**：

- 从根节点开始查找前缀，对于待查找的字符，有两种情况：
  - 如果该字符对应的节点存在，则沿着指针移动到子节点，继续查找下一个字符。
  - 如果该字符对应的节点不存在，则说明字典树中不包含该前缀，直接返回空指针。
- 重复上述步骤，直到最后一个字符搜索完毕，则说明字典树中存在该前缀。

### 思路 1：代码

```python
class Node:
    def __init__(self):
        self.children = dict()
        self.isEnd = False

class Trie:

    def __init__(self):
        self.root = Node()

    def insert(self, word: str) -> None:
        cur = self.root
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Node()
            cur = cur.children[ch]
        cur.isEnd = True 

    def search(self, word: str) -> bool:
        cur = self.root
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for ch in prefix:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]
        return cur is not None
```

### 思路 1：复杂度分析

- **时间复杂度**：初始化为 $O(1)$。插入操作、查找操作的时间复杂度为 $O(|S|)$。其中 $|S|$ 是每次插入或查找字符串的长度。
- **空间复杂度**：$O(|T| \times \sum)$。其中 $|T|$ 是所有插入字符串的长度之和，$\sum$ 是字符集的大小。

# [0209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

- 标签：数组、二分查找、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [0209. 长度最小的子数组 - 力扣](https://leetcode.cn/problems/minimum-size-subarray-sum/)

## 题目大意

**描述**：给定一个只包含正整数的数组 $nums$ 和一个正整数 $target$。

**要求**：找出数组中满足和大于等于 $target$ 的长度最小的「连续子数组」，并返回其长度。如果不存在符合条件的子数组，返回 $0$。

**说明**：

- $1 \le target \le 10^9$。
- $1 \le nums.length \le 10^5$。
- $1 \le nums[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

- 示例 2：

```python
输入：target = 4, nums = [1,4,4]
输出：1
```

## 解题思路

### 思路 1：滑动窗口（不定长度）

最直接的做法是暴力枚举，时间复杂度为 $O(n^2)$。但是我们可以利用滑动窗口的方法，在时间复杂度为 $O(n)$ 的范围内解决问题。

用滑动窗口来记录连续子数组的和，设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口中的和刚好大于等于 $target$。

1. 一开始，$left$、$right$ 都指向 $0$。
2. 向右移动 $right$，将最右侧元素加入当前窗口和 $window\underline{\hspace{0.5em}}sum$ 中。
3. 如果 $window\underline{\hspace{0.5em}}sum \ge target$，则不断右移 $left$，缩小滑动窗口长度，并更新窗口和的最小值，直到 $window\underline{\hspace{0.5em}}sum < target$。
4. 然后继续右移 $right$，直到 $right \ge len(nums)$ 结束。
5. 输出窗口和的最小值作为答案。

### 思路 1：代码

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        size = len(nums)
        ans = size + 1
        left = 0
        right = 0
        window_sum = 0

        while right < size:
            window_sum += nums[right]

            while window_sum >= target:
                ans = min(ans, right - left + 1)
                window_sum -= nums[left]
                left += 1

            right += 1

        return ans if ans != size + 1 else 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [0210. 课程表 II - 力扣](https://leetcode.cn/problems/course-schedule-ii/)

## 题目大意

**描述**：给定一个整数 $numCourses$，代表这学期必须选修的课程数量，课程编号为 $0 \sim numCourses - 1$。再给定一个数组 $prerequisites$ 表示先修课程关系，其中 $prerequisites[i] = [ai, bi]$ 表示如果要学习课程 $ai$ 则必须要先完成课程 $bi$。

**要求**：返回学完所有课程所安排的学习顺序。如果有多个正确的顺序，只要返回其中一种即可。如果无法完成所有课程，则返回空数组。

**说明**：

- $1 \le numCourses \le 2000$。
- $0 \le prerequisites.length \le numCourses \times (numCourses - 1)$。
- $prerequisites[i].length == 2$。
- $0 \le ai, bi < numCourses$。
- $ai \ne bi$。
- 所有$[ai, bi]$ 互不相同。

**示例**：

- 示例 1：

```python
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1]。
```

- 示例 2：

```python
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3]。
```

## 解题思路

### 思路 1：拓扑排序

这道题是「[0207. 课程表](https://leetcode.cn/problems/course-schedule/)」的升级版，只需要在上一题的基础上增加一个答案数组 $order$ 即可。

1. 使用哈希表 $graph$ 存放课程关系图，并统计每门课程节点的入度，存入入度列表 $indegrees$。
2. 借助队列 $S$，将所有入度为 $0$ 的节点入队。
3. 从队列中选择一个节点 $u$，并将其加入到答案数组 $order$ 中。
4. 从图中删除该顶点 $u$，并且删除从该顶点出发的有向边 $<u, v>$（也就是把该顶点可达的顶点入度都减 $1$）。如果删除该边后顶点 $v$ 的入度变为 $0$，则将其加入队列 $S$ 中。
5. 重复上述步骤 $3 \sim 4$，直到队列中没有节点。
6. 最后判断总的顶点数和拓扑序列中的顶点数是否相等，如果相等，则返回答案数组 $order$，否则，返回空数组。

### 思路 1：代码

```python
import collections

class Solution:
    # 拓扑排序，graph 中包含所有顶点的有向边关系（包括无边顶点）
    def topologicalSortingKahn(self, graph: dict):
        indegrees = {u: 0 for u in graph}   # indegrees 用于记录所有顶点入度
        for u in graph:
            for v in graph[u]:
                indegrees[v] += 1           # 统计所有顶点入度
        
        # 将入度为 0 的顶点存入集合 S 中
        S = collections.deque([u for u in indegrees if indegrees[u] == 0])
        order = []                          # order 用于存储拓扑序列
        
        while S:
            u = S.pop()                     # 从集合中选择一个没有前驱的顶点 0
            order.append(u)                 # 将其输出到拓扑序列 order 中
            for v in graph[u]:              # 遍历顶点 u 的邻接顶点 v
                indegrees[v] -= 1           # 删除从顶点 u 出发的有向边
                if indegrees[v] == 0:       # 如果删除该边后顶点 v 的入度变为 0
                    S.append(v)             # 将其放入集合 S 中
        
        if len(indegrees) != len(order):    # 还有顶点未遍历（存在环），无法构成拓扑序列
            return []
        return order                        # 返回拓扑序列
    
    
    def findOrder(self, numCourses: int, prerequisites):
        graph = dict()
        for i in range(numCourses):
            graph[i] = []
            
        for v, u in prerequisites:
            graph[u].append(v)
            
        return self.topologicalSortingKahn(graph)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 为课程数，$m$ 为先修课程的要求数。
- **空间复杂度**：$O(n + m)$。

# [0211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

- 标签：深度优先搜索、设计、字典树、字符串
- 难度：中等

## 题目链接

- [0211. 添加与搜索单词 - 数据结构设计 - 力扣](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

## 题目大意

**要求**：设计一个数据结构，支持「添加新单词」和「查找字符串是否与任何先前添加的字符串匹配」。

实现词典类 WordDictionary：

- `WordDictionary()` 初始化词典对象。
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `True`；否则，返回 `False`。`word` 中可能包含一些 `.`，每个 `.` 都可以表示任何一个字母。

**说明**：

- $1 \le word.length \le 25$。
- `addWord` 中的 `word` 由小写英文字母组成。
- `search` 中的 `word` 由 `'.'` 或小写英文字母组成。
- 最多调用 $10^4$ 次 `addWord` 和 `search`。

**示例**：

- 示例 1：

```python
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // 返回 False
wordDictionary.search("bad"); // 返回 True
wordDictionary.search(".ad"); // 返回 True
wordDictionary.search("b.."); // 返回 True
```

## 解题思路

### 思路 1：字典树

使用前缀树（字典树）。具体做法如下：

- 初始化词典对象时，构造一棵字典树。
- 添加 `word` 时，将 `word` 插入到字典树中。
- 搜索 `word` 时：
  - 如果遇到 `.`，则递归匹配当前节点所有子节点，并依次向下查找。匹配到了，则返回 `True`，否则返回 `False`。
  - 如果遇到其他小写字母，则按 `word` 顺序匹配节点。
  - 如果当前节点为 `word` 的结尾，则放回 `True`。

### 思路 1：代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """

        def dfs(index, node) -> bool:
            if index == len(word):
                return node.isEnd

            ch = word[index]
            if ch == '.':
                for child in node.children.values():
                    if child is not None and dfs(index + 1, child):
                        return True
            else:
                if ch not in node.children:
                    return False
                child = node.children[ch]
                if child is not None and dfs(index + 1, child):
                    return True
            return False

        return dfs(0, self)


class WordDictionary:

    def __init__(self):
        self.trie_tree = Trie()


    def addWord(self, word: str) -> None:
        self.trie_tree.insert(word)


    def search(self, word: str) -> bool:
        return self.trie_tree.search(word)
```

### 思路 1：复杂度分析

- **时间复杂度**：初始化操作为 $O(1)$。添加单词为 $O(|S|)$，搜索单词的平均时间复杂度为 $O(|S|)$，最坏情况下所有字符都是 `'.'`，所以最坏时间复杂度为 $O(|S|^\sum)$。其中 $|S|$  为单词长度，$\sum$ 为字符集的大小，此处为 $26$。
- **空间复杂度**：$O(|T| * n)$。其中 $|T|$ 为所有添加单词的最大长度，$n$ 为添加字符串个数。

# [0212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

- 标签：字典树、数组、字符串、回溯、矩阵
- 难度：困难

## 题目链接

- [0212. 单词搜索 II - 力扣](https://leetcode.cn/problems/word-search-ii/)

## 题目大意

给定一个 `m * n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`。

要求：找出所有同时在二维网格和字典中出现的单词。

注意：单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中「相邻」单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

## 解题思路

- 先将单词列表 `words` 中的所有单词存入字典树中。

- 然后遍历二维字符网络 `board` 的每一个字符 `board[i][j]`。

- 从当前单元格出发，从上下左右四个方向深度优先搜索遍历路径。每经过一个单元格，就将该单元格的字母修改为特殊字符，避免重复遍历，深度优先搜索完毕之后再恢复该单元格。
  - 如果当前路径恰好是 `words` 列表中的单词，则将结果添加到答案数组中。
  - 如果是 `words` 列表中单词的前缀，则继续搜索。
  - 如果不是 `words` 列表中单词的前缀，则停止搜索。
- 最后输出答案数组。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.word = ""


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.word = word


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        rows = len(board)
        cols = len(board[0])

        def dfs(cur, row, col):
            ch = board[row][col]
            if ch not in cur.children:
                return

            cur = cur.children[ch]
            if cur.isEnd:
                ans.add(cur.word)

            board[row][col] = "#"
            for direct in directs:
                new_row = row + direct[0]
                new_col = col + direct[1]
                if 0 <= new_row < rows and 0 <= new_col < cols:
                    dfs(cur, new_row, new_col)
            board[row][col] = ch

        ans = set()
        for i in range(rows):
            for j in range(cols):
                dfs(trie_tree, i, j)

        return list(ans)
```

# [0213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0213. 打家劫舍 II - 力扣](https://leetcode.cn/problems/house-robber-ii/)

## 题目大意

**描述**：给定一个数组 $nums$，$num[i]$ 代表第 $i$ 间房屋存放的金额，假设房屋可以围成一圈，最后一间房屋跟第一间房屋可以相连。相邻的房屋装有防盗系统，假如相邻的两间房屋同时被偷，系统就会报警。

**要求**：假如你是一名专业的小偷，计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**说明**：

- $1 \le nums.length \le 100$。
- $0 \le nums[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

- 示例 2：

```python
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4。
```

## 解题思路

### 思路 1：动态规划

这道题可以看做是「[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)」的升级版。

如果房屋数大于等于 $3$ 间，偷窃了第 $1$ 间房屋，则不能偷窃最后一间房屋。同样偷窃了最后一间房屋则不能偷窃第 $1$ 间房屋。

假设总共房屋数量为 $size$，这种情况可以转换为分别求解 $[0, size - 2]$ 和 $[1, size - 1]$ 范围下首尾不相连的房屋所能偷窃的最高金额，然后再取这两种情况下的最大值。而求解 $[0, size - 2]$ 和 $[1, size - 1]$ 范围下首尾不相连的房屋所能偷窃的最高金额问题就跟「[198. 打家劫舍](https://leetcode.cn/problems/house-robber)」所求问题一致了。

这里来复习一下「[198. 打家劫舍](https://leetcode.cn/problems/house-robber)」的解题思路。

###### 1. 划分阶段

按照房屋序号进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：前 $i$ 间房屋所能偷窃到的最高金额。

###### 3. 状态转移方程

$i$ 间房屋的最后一个房子是 $nums[i - 1]$。

如果房屋数大于等于 $2$ 间，则偷窃第 $i - 1$ 间房屋的时候，就有两种状态：

1. 偷窃第 $i - 1$ 间房屋，那么第 $i - 2$ 间房屋就不能偷窃了，偷窃的最高金额为：前 $i - 2$ 间房屋的最高总金额 + 第 $i - 1$ 间房屋的金额，即 $dp[i] = dp[i - 2] + nums[i - 1]$；
1. 不偷窃第 $i - 1$ 间房屋，那么第 $i - 2$ 间房屋可以偷窃，偷窃的最高金额为：前 $i - 1$ 间房屋的最高总金额，即 $dp[i] = dp[i - 1]$。

然后这两种状态取最大值即可，即状态转移方程为：

$dp[i] = \begin{cases} nums[0] & i = 1 \cr max(dp[i - 2] + nums[i - 1], dp[i - 1]) & i \ge 2\end{cases}$

###### 4. 初始条件

- 前 $0$ 间房屋所能偷窃到的最高金额为 $0$，即 $dp[0] = 0$。
- 前 $1$ 间房屋所能偷窃到的最高金额为 $nums[0]$，即：$dp[1] = nums[0]$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：前 $i$ 间房屋所能偷窃到的最高金额。假设求解 $[0, size - 2]$ 和 $[1, size - 1]$ 范围下（ $size$ 为总的房屋数）首尾不相连的房屋所能偷窃的最高金额问题分别为 $ans1$、$ans2$，则最终结果为 $max(ans1, ans2)$。

### 思路 1：动态规划代码

```python
class Solution:
    def helper(self, nums):
        size = len(nums)
        if size == 0:
            return 0
 
        dp = [0 for _ in range(size + 1)]
        dp[0] = 0
        dp[1] = nums[0]
        
        for i in range(2, size + 1):
            dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])

        return dp[size]

    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 1:
            return nums[0]
        
        ans1 = self.helper(nums[:size - 1])
        ans2 = self.helper(nums[1:])
        return max(ans1, ans2)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

# [0215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

- 标签：数组、分治、快速排序、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0215. 数组中的第K个最大元素 - 力扣](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 题目大意

**描述**：给定一个未排序的整数数组 $nums$ 和一个整数 $k$。

**要求**：返回数组中第 $k$ 个最大的元素。

**说明**：

- 要求使用时间复杂度为 $O(n)$ 的算法解决此问题。
- $1 \le k \le nums.length \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

- 示例 2：

```python
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

## 解题思路

很不错的一道题，面试常考。

直接可以想到的思路是：排序后输出数组上对应第 $k$ 位大的数。所以问题关键在于排序方法的复杂度。

冒泡排序、选择排序、插入排序时间复杂度 $O(n^2)$ 太高了，很容易超时。

可考虑堆排序、归并排序、快速排序。

这道题的要求是找到第 $k$ 大的元素，使用归并排序只有到最后排序完毕才能返回第 $k$ 大的数。而堆排序每次排序之后，就会确定一个元素的准确排名，同理快速排序也是如此。

### 思路 1：堆排序

升序堆排序的思路如下：

1. 将无序序列构造成第 $1$ 个大顶堆（初始堆），使得 $n$ 个元素的最大值处于序列的第 $1$ 个位置。

2. **调整堆**：交换序列的第 $1$ 个元素（最大值元素）与第 $n$ 个元素的位置。将序列前 $n - 1$ 个元素组成的子序列调整成一个新的大顶堆，使得 $n - 1$ 个元素的最大值处于序列第 $1$ 个位置，从而得到第 $2$ 个最大值元素。

3. **调整堆**：交换子序列的第 $1$ 个元素（最大值元素）与第 $n - 1$ 个元素的位置。将序列前 $n - 2$ 个元素组成的子序列调整成一个新的大顶堆，使得 $n - 2$ 个元素的最大值处于序列第 $1$ 个位置，从而得到第 $3$ 个最大值元素。

4. 依次类推，不断交换子序列的第 $1$ 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到获取第 $k$ 个最大值元素为止。


### 思路 1：代码

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 调整为大顶堆
        def heapify(nums, index, end):
            left = index * 2 + 1
            right = left + 1
            while left <= end:
                # 当前节点为非叶子节点
                max_index = index
                if nums[left] > nums[max_index]:
                    max_index = left
                if right <= end and nums[right] > nums[max_index]:
                    max_index = right
                if index == max_index:
                    # 如果不用交换，则说明已经交换结束
                    break
                nums[index], nums[max_index] = nums[max_index], nums[index]
                # 继续调整子树
                index = max_index
                left = index * 2 + 1
                right = left + 1
                
        # 初始化大顶堆
        def buildMaxHeap(nums):
            size = len(nums)
            # (size-2) // 2 是最后一个非叶节点，叶节点不用调整
            for i in range((size - 2) // 2, -1, -1):
                heapify(nums, i, size - 1)
            return nums

        buildMaxHeap(nums)
        size = len(nums)
        for i in range(k-1):
            nums[0], nums[size-i-1] = nums[size-i-1], nums[0]
            heapify(nums, 0, size-i-2)
        return nums[0]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：快速排序

使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。

这样，只要某次划分的元素恰好是第 $k$ 个下标就找到了答案。并且我们只需关注第 $k$ 个最大元素所在区间的排序情况，与第 $k$ 个最大元素无关的区间排序都可以忽略。这样进一步减少了执行步骤。

### 思路 2：代码

```python
import random

class Solution:
    # 随机哨兵划分：从 nums[low: high + 1] 中随机挑选一个基准数，并进行移位排序
    def randomPartition(self, nums: [int], low: int, high: int) -> int:
        # 随机挑选一个基准数
        i = random.randint(low, high)
        # 将基准数与最低位互换
        nums[i], nums[low] = nums[low], nums[i]
        # 以最低位为基准数，然后将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。最后将基准数放到正确位置上
        return self.partition(nums, low, high)
    
    # 哨兵划分：以第 1 位元素 nums[low] 为基准数，然后将比基准数小的元素移动到基准数左侧，将比基准数大的元素移动到基准数右侧，最后将基准数放到正确位置上
    def partition(self, nums: [int], low: int, high: int) -> int:        
        # 以第 1 位元素为基准数
        pivot = nums[low]
        
        i, j = low, high
        while i < j:
            # 从右向左找到第 1 个小于基准数的元素
            while i < j and nums[j] >= pivot:
                j -= 1
            # 从左向右找到第 1 个大于基准数的元素
            while i < j and nums[i] <= pivot:
                i += 1
            # 交换元素
            nums[i], nums[j] = nums[j], nums[i]
        
        # 将基准数放到正确位置上
        nums[j], nums[low] = nums[low], nums[j]
        return j

    def quickSort(self, nums: [int], low: int, high: int, k: int, size: int) -> [int]:
        if low < high:
            # 按照基准数的位置，将数组划分为左右两个子数组
            pivot_i = self.randomPartition(nums, low, high)
            if pivot_i == size - k:
                return nums[size - k]
            if pivot_i > size - k:
                self.quickSort(nums, low, pivot_i - 1, k, size)
            if pivot_i < size - k:
                self.quickSort(nums, pivot_i + 1, high, k, size)

        return nums[size - k]


    def findKthLargest(self, nums: List[int], k: int) -> int:
        size = len(nums)
        return self.quickSort(nums, 0, len(nums) - 1, k, size)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。证明过程可参考「算法导论 9.2：期望为线性的选择算法」。
- **空间复杂度**：$O(\log n)$。递归使用栈空间的空间代价期望为 $O(\log n)$。

### 思路 3：借用标准库（不建议）

提交代码中的最快代码是调用了 Python 的 `sort` 方法。这种做法适合在打算法竞赛的时候节省时间，日常练习可以尝试一下自己写。

### 思路 3：代码

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums) - k]
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

### 思路 4：优先队列

1. 遍历数组元素，对于挡圈元素 $num$：
   1. 如果优先队列中的元素个数小于 $k$ 个，则将当前元素 $num$ 放入优先队列中。
   2. 如果优先队列中的元素个数大于等于 $k$ 个，并且当前元素 $num$ 大于优先队列的队头元素，则弹出队头元素，并将当前元素 $num$ 插入到优先队列中。
2. 遍历完，此时优先队列的队头元素就是第 $k$ 个最大元素，将其弹出并返回即可。

这里我们借助了 Python 中的 `heapq` 模块实现优先队列算法，这一步也可以通过手写堆的方式实现优先队列。

### 思路 4：代码

```python
import heapq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        res = []
        for num in nums:
            if len(res) < k:
                heapq.heappush(res, num)
            elif num > res[0]:
                heapq.heappop(res)
                heapq.heappush(res, num)
        return heapq.heappop(res)
```

### 思路 4：复杂度分析

- **时间复杂度**：$O(n \times \log k)$。
- **空间复杂度**：$O(k)$。# [0217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/)

- 标签：数组、哈希表、排序
- 难度：简单

## 题目链接

- [0217. 存在重复元素 - 力扣](https://leetcode.cn/problems/contains-duplicate/)

## 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：判断是否存在重复元素。如果有元素在数组中出现至少两次，返回 `True`；否则返回 `False`。

**说明**：

- $1 \le nums.length \le 10^5$。
- $-10^9 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,1]
输出：True
```

- 示例 2：

```python
输入：nums = [1,2,3,4]
输出：False
```

## 解题思路

### 思路 1：哈希表

- 使用一个哈希表存储元素和对应元素数量。
- 遍历元素，如果哈希表中出现了该元素，则直接输出 `True`。如果没有出现，则向哈希表中插入该元素。
- 如果遍历完也没发现重复元素，则输出 `False`。

### 思路 1：代码

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numDict = dict()
        for num in nums:
            if num in numDict:
                return True
            else:
                numDict[num] = num
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：集合

- 使用一个 `set` 集合存储数组中所有元素。
- 如果集合中元素个数与数组元素个数不同，则说明出现了重复元素，返回 `True`。
- 如果集合中元素个数与数组元素个数相同，则说明没有出现了重复元素，返回 `False`。

### 思路 2：集合代码

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 3：排序

- 对数组进行排序。
- 排序之后，遍历数组，判断相邻元素之间是否出现重复元素。
- 如果相邻元素相同，则说明出现了重复元素，返回 `True`。
- 如果遍历完也没发现重复元素，则输出 `False`。

### 思路 3：排序代码

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i - 1] == nums[i]:
                return True
        return False
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。# [0218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/)

- 标签：树状数组、线段树、数组、分治、有序集合、扫描线、堆（优先队列）
- 难度：困难

## 题目链接

- [0218. 天际线问题 - 力扣](https://leetcode.cn/problems/the-skyline-problem/)

## 题目大意

城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。

给定所有建筑物的位置和高度所组成的数组 `buildings`。其中三元素 `buildings[i] = [left_i, right_i, height_i]` 表示 `left_i` 是第 `i` 座建筑物左边界的 `x` 坐标。`right_i` 是第 `i` 座建筑物右边界的 `x` 坐标，`height_i` 是第 `i` 做建筑物的高度。

要求：返回由这些建筑物形成的天际线 。

- 天际线：由 “关键点” 组成的列表，格式 `[[x1, y1], [x2, y2], [x3, y3], ...]`，并按 `x` 坐标进行排序。
- 关键点：水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，`y` 坐标始终为 `0`，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

注意：输出天际线中不得有连续的相同高度的水平线。

- 例如 `[..., [2 3], [4 5], [7 5], [11 5], [12 7], ...]` 是不正确的答案；三条高度为 `5` 的线应该在最终输出中合并为一个：`[..., [2 3], [4 5], [12 7], ...]`。

示例：

![](https://assets.leetcode.com/uploads/2020/12/01/merged.jpg)

- 图 A 显示输入的所有建筑物的位置和高度。
- 图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。

## 解题思路

可以看出来：关键点的横坐标都在建筑物的左右边界上。

我们可以将左右边界最高处的坐标存入 `points` 数组中，然后按照建筑物左边界、右边界的高度进行排序。

然后用一条条「垂直于 x 轴的扫描线」，从所有建筑物的最左侧依次扫描到最右侧。从而将建筑物分割成规则的矩形。

不难看出：相邻的两个坐标的横坐标与矩形所能达到的最大高度构成了一个矩形。相邻两个坐标的横坐标可以从排序过的 `points` 数组中依次获取，矩形所能达到的最大高度可以用一个优先队列（堆）`max_heap` 来维护。使用数组 `ans` 来作为答案答案。

在依次从左到右扫描坐标时：

- 当扫描到建筑物的左边界时，说明必然存在一条向右延伸的边。此时将高度加入到优先队列中。
- 当扫描到建筑物的右边界时，说明从之前的左边界延伸的边结束了，此时将高度从优先队列中移除。

因为三条高度相同的线应该合并为一个，所以我们用 `prev` 来记录之前上一个矩形高度。

- 如果当前矩形高度 `curr` 与之前矩形高度 `prev` 相同，则跳过。
- 如果当前矩形高度 `curr` 与之前矩形高度 `prev `不相同，则将其加入到答案数组中，并更新上一矩形高度 `prev` 的值。

最后，输出答案 `ans`。

## 代码

```python
from sortedcontainers import SortedList

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        ans = []
        points = []
        for building in buildings:
            left, right, hight = building[0], building[1], building[2]
            points.append([left, -hight])
            points.append([right, hight])
        points.sort(key=lambda x:(x[0], x[1]))

        prev = 0
        max_heap = SortedList([prev])

        for point in points:
            x, height = point[0], point[1]
            if height < 0:
                max_heap.add(-height)
            else:
                max_heap.remove(height)

            curr = max_heap[-1]
            if curr != prev:
                ans.append([x, curr])
                prev = curr
        return ans
```

## 参考资料

- 【题解】[【宫水三叶】扫描线算法基本思路 & 优先队列维护当前最大高度 - 天际线问题 - 力扣](https://leetcode.cn/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/)
# [0219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

- 标签：数组、哈希表、滑动窗口
- 难度：简单

## 题目链接

- [0219. 存在重复元素 II - 力扣](https://leetcode.cn/problems/contains-duplicate-ii/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $k$。

**要求**：判断是否存在 $nums[i] == nums[j]$（$i \ne j$），并且 $i$ 和 $j$ 的差绝对值至多为 $k$。

**说明**：

- $1 \le nums.length \le 10^5$。
- $-10^9 <= nums[i] <= 10^9$。
- $0 \le k \le 10^5$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,1], k = 3
输出：True
```

## 解题思路

### 思路 1：哈希表

维护一个最多有 $k$ 个元素的哈希表。遍历 $nums$，对于数组中的每个整数 $nums[i]$，判断哈希表中是否存在这个整数。

- 如果存在，则说明出现了两次，且 $i \ne j$，直接返回 $True$。

- 如果不存在，则将 $nums[i]$ 加入哈希表。
- 判断哈希表长度是否超过了 $k$，如果超过了 $k$，则删除哈希表中最旧的元素 $nums[i - k]$。
- 如果遍历完仍旧找不到，则返回 $False$。

### 思路 1：代码

```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        nums_dict = dict()
        for i in range(len(nums)):
            if nums[i] in nums_dict:
                return True
            nums_dict[nums[i]] = 1
            if len(nums_dict) > k:
                del nums_dict[nums[i - k]]
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [0220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/)

- 标签：数组、桶排序、有序集合、排序、滑动窗口
- 难度：中等

## 题目链接

- [0220. 存在重复元素 III - 力扣](https://leetcode.cn/problems/contains-duplicate-iii/)

## 题目大意

**描述**：给定一个整数数组 $nums$，以及两个整数 $k$、$t$。

**要求**：判断数组中是否存在两个不同下标的 $i$ 和 $j$，其对应元素满足 $abs(nums[i] - nums[j]) \le t$，同时满足 $abs(i - j) \le k$。如果满足条件则返回 `True`，不满足条件返回 `False`。

**说明**：

- $0 \le nums.length \le 2 \times 10^4$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- $0 \le k \le 10^4$。
- $0 \le t \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,1], k = 3, t = 0
输出：True
```

- 示例 2：

```python
输入：nums = [1,0,1,1], k = 1, t = 2
输出：True
```

## 解题思路

题目中需要满足两个要求，一个是元素值的要求（$abs(nums[i] - nums[j]) \le t$） ，一个是下标范围的要求（$abs(i - j) \le k$）。

对于任意一个位置 $i$ 来说，合适的 $j$ 应该在区间 $[i - k, i + k]$ 内，同时 $nums[j]$ 值应该在区间 $[nums[i] - t, nums[i] + t]$ 内。

最简单的做法是两重循环遍历数组，第一重循环遍历位置 $i$，第二重循环遍历 $[i - k, i + k]$ 的元素，判断是否满足 $abs(nums[i] - nums[j]) \le t$。但是这样做的时间复杂度为 $O(n \times k)$，其中 $n$ 是数组 $nums$ 的长度。

我们需要优化一下检测相邻 $2 \times k$ 个元素是否满足 $abs(nums[i] - nums[j]) \le t$ 的方法。有两种思路：「桶排序」和「滑动窗口（固定长度）」。

### 思路 1：桶排序

1. 利用桶排序的思想，将桶的大小设置为 $t + 1$。只需要使用一重循环遍历位置 $i$，然后根据 $\lfloor \frac{nums[i]}{t + 1} \rfloor$，从而决定将 $nums[i]$ 放入哪个桶中。
2. 这样在同一个桶内各个元素之间的差值绝对值都小于等于 $t$。而相邻桶之间的元素，只需要校验一下两个桶之间的差值是否不超过 $t$。这样就可以以 $O(1)$ 的时间复杂度检测相邻 $2 \times k$ 个元素是否满足 $abs(nums[i] - nums[j]) \le t$。
3. 而 $abs(i - j) \le k$ 条件则可以通过在一重循环遍历时，将超出范围的 $nums[i - k]$ 从对应桶中删除，从而保证桶中元素一定满足 $abs(i - j) \le k$。

具体步骤如下：

1. 将每个桶的大小设置为 $t + 1$。我们将元素按照大小依次放入不同的桶中。
2. 遍历数组 $nums$ 中的元素，对于元素$ nums[i]$ ：
   1. 如果 $nums[i]$ 放入桶之前桶里已经有元素了，那么这两个元素必然满足 $abs(nums[i] - nums[j]) \le t$，
   2. 如果之前桶里没有元素，那么就将 $nums[i]$ 放入对应桶中。
   3. 再判断左右桶的左右两侧桶中是否有元素满足 $abs(nums[i] - nums[j]) <= t$。
   4. 然后将 $nums[i - k]$ 之前的桶清空，因为这些桶中的元素与 $nums[i]$ 已经不满足 $abs(i - j) \le k$ 了。
3. 最后上述满足条件的情况就返回 `True`，最终遍历完仍不满足条件就返回 `False`。

### 思路 1：代码

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        bucket_dict = dict()
        for i in range(len(nums)):
            # 将 nums[i] 划分到大小为 t + 1 的不同桶中
            num = nums[i] // (t + 1)

            # 桶中已经有元素了
            if num in bucket_dict:
                return True

            # 把 nums[i] 放入桶中
            bucket_dict[num] = nums[i]

            # 判断左侧桶是否满足条件
            if (num - 1) in bucket_dict and abs(bucket_dict[num - 1] - nums[i]) <= t:
                return True
            # 判断右侧桶是否满足条件
            if (num + 1) in bucket_dict and abs(bucket_dict[num + 1] - nums[i]) <= t:
                return True
            # 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了
            if i >= k:
                bucket_dict.pop(nums[i - k] // (t + 1))

        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。$n$ 是给定数组长度。
- **空间复杂度**：$O(min(n, k))$。桶中最多包含 $min(n, k + 1)$ 个元素。

### 思路 2：滑动窗口（固定长度）

1. 使用一个长度为 $k$ 的滑动窗口，每次遍历到 $nums[right]$ 时，滑动窗口内最多包含 $nums[right]$ 之前最多 $k$ 个元素。只需要检查前 $k$ 个元素是否在 $[nums[right] - t, nums[right] + t]$ 区间内即可。
2. 检查 $k$ 个元素是否在 $[nums[right] - t, nums[right] + t]$ 区间，可以借助保证有序的数据结构（比如 `SortedList`）+ 二分查找来解决，从而减少时间复杂度。

具体步骤如下：

1. 使用有序数组类 $window$ 维护一个长度为 $k$ 的窗口，满足数组内元素有序，且支持增加和删除操作。
2. $left$、$right$ 都指向序列的第一个元素。即：`left = 0`，`right = 0`。
3. 将当前元素填入窗口中，即 `window.add(nums[right])`。
4. 当窗口元素大于 $k$ 个时，即当 $right - left > k$ 时，移除窗口最左侧元素，并向右移动 $left$。
5. 当窗口元素小于等于 $k$ 个时：
   1. 使用二分查找算法，查找 $nums[right]$ 在 $window$ 中的位置 $idx$。
   2. 判断 $window[idx]$ 与相邻位置上元素差值绝对值，若果满足 $abs(window[idx] - window[idx - 1]) \le t$ 或者 $abs(window[idx + 1] - window[idx]) \le t$ 时返回 `True`。
6. 向右移动 $right$。
7. 重复 $3 \sim 6$ 步，直到 $right$ 到达数组末尾，如果还没找到满足条件的情况，则返回 `False`。

### 思路 2：代码

```python
from sortedcontainers import SortedList

class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        size = len(nums)
        window = SortedList()
        left, right = 0, 0
        while right < size:
            window.add(nums[right])
            
            if right - left > k:
                window.remove(nums[left])
                left += 1
            
            idx = bisect.bisect_left(window, nums[right])
            
            if idx > 0 and abs(window[idx] - window[idx - 1]) <= t:
                return True
            if idx < len(window) - 1 and abs(window[idx + 1] - window[idx]) <= t:
                return True

            right += 1

        return False
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log (min(n, k)))$。
- **空间复杂度**：$O(min(n, k))$。

## 参考资料

- 【题解】[利用桶的原理O(n)，Python3 - 存在重复元素 III - 力扣](https://leetcode.cn/problems/contains-duplicate-iii/solution/li-yong-tong-de-yuan-li-onpython3-by-zhou-pen-chen/)
# [0221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

- 标签：数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [0221. 最大正方形 - 力扣](https://leetcode.cn/problems/maximal-square/)

## 题目大意

**描述**：给定一个由 `'0'` 和 `'1'` 组成的二维矩阵 $matrix$。

**要求**：找到只包含 `'1'` 的最大正方形，并返回其面积。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 300$。
- $matrix[i][j]$ 为 `'0'` 或 `'1'`。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

```python
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

```python
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照正方形的右下角坐标进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。

###### 3. 状态转移方程

只有当矩阵位置 $(i, j)$ 值为 $1$ 时，才有可能存在正方形。

- 如果矩阵位置 $(i, j)$ 上值为 $0$，则 $dp[i][j] = 0$。
- 如果矩阵位置 $(i, j)$ 上值为 $1$，则 $dp[i][j]$ 的值由该位置上方、左侧、左上方三者共同约束的，为三者中最小值加 $1$。即：$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1$。

###### 4. 初始条件

- 默认所有以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长都为 $0$，即 $dp[i][j] = 0$。

###### 5. 最终结果

根据我们之前定义的状态， $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。则最终结果为所有 $dp[i][j]$ 中的最大值。

### 思路 1：代码

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        rows, cols = len(matrix), len(matrix[0])
        max_size = 0
        dp = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
                    max_size = max(max_size, dp[i][j])
        return max_size * max_size
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$、$n$ 分别为二维矩阵 $matrix$ 的行数和列数。
- **空间复杂度**：$O(m \times n)$。
# [0222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

- 标签：树、深度优先搜索、二分查找、二叉树
- 难度：中等

## 题目链接

- [0222. 完全二叉树的节点个数 - 力扣](https://leetcode.cn/problems/count-complete-tree-nodes/)

## 题目大意

给定一棵完全二叉树的根节点 `root`，返回该树的节点个数。

- 完全二叉树：除了最底层节点可能没有填满外，其余各层节点数都达到了最大值，并且最下面一层的节点都集中在盖层最左边的若干位置。若最底层在第 `h` 层，则该层包含 $1 \sim 2^h$ 个节点。

## 解题思路

根据题意可知公式：当前根节点的节点个数 = 左子树节点个数 + 右子树节点个数 + 1。

根据上述公式递归遍历左右子树节点，并返回左右子树节点数 + 1。

## 代码

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

# [0223. 矩形面积](https://leetcode.cn/problems/rectangle-area/)

- 标签：几何、数学
- 难度：中等

## 题目链接

- [0223. 矩形面积 - 力扣](https://leetcode.cn/problems/rectangle-area/)

## 题目大意

给定两个矩形的左下角坐标、右上角坐标 `(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)`。其中 `(ax1, ay1)` 表示第一个矩形左下角坐标，`(ax2, ay2)` 表示第一个矩形右上角坐标，`(bx1, by1)` 表示第二个矩形左下角坐标，`(bx2, by2)` 表示第二个矩形右上角坐标。

要求：计算出两个矩形覆盖的总面积。

## 解题思路

两个矩形覆盖的总面积 = 第一个矩形面积 + 第二个矩形面积 - 重叠部分面积。

需要分别计算出两个矩形面积，还有求出相交部分的长、宽，并计算出对应重叠部分的面积。

## 代码

```python
class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        area_a = (ax2 - ax1) * (ay2 - ay1)
        area_b = (bx2 - bx1) * (by2 - by1)
        overlap_width = max(0, min(ax2, bx2) - max(ax1, bx1))
        overlap_height = max(0, min(ay2, by2) - max(ay1, by1))
        area_overlap = overlap_width * overlap_height

        return area_a + area_b - area_overlap
```

# [0225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

- 标签：栈、设计、队列
- 难度：简单

## 题目链接

- [0225. 用队列实现栈 - 力扣](https://leetcode.cn/problems/implement-stack-using-queues/)

## 题目大意

**要求**：仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的四种操作：`push`、`top`、`pop` 和 `empty`。

要求实现 `MyStack` 类：

- `void push(int x)` 将元素 `x` 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `True`；否则，返回 `False`。

**说明**：

- 只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 所使用的语言也许不支持队列。 你可以使用 `list` （列表）或者 `deque`（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例**：

- 示例 1：

```python
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

## 解题思路

### 思路 1：双队列

使用两个队列。`pushQueue` 用作入栈，`popQueue` 用作出栈。

- `push` 操作：将新加入的元素压入 `pushQueue` 队列中，并且将之前保存在 `popQueue` 队列中的元素从队头开始依次压入 `pushQueue` 中，此时 `pushQueue` 队列中头节点存放的是新加入的元素，尾部存放的是之前的元素。 而 `popQueue` 则为空。再将 `pushQueue` 和 `popQueue` 相互交换，保持 `pushQueue` 为空，`popQueue` 则用于 `pop`、`top` 等操作。
- `pop` 操作：直接将 `popQueue` 队头元素取出。
- `top` 操作：返回 `popQueue` 队头元素。
- `empty`：判断 `popQueue` 是否为空。

### 思路 1：代码

```python
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.pushQueue = collections.deque()
        self.popQueue = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.pushQueue.append(x)
        while self.popQueue:
           self.pushQueue.append(self.popQueue.popleft())
        self.pushQueue, self.popQueue = self.popQueue, self.pushQueue

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.popQueue.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.popQueue[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.popQueue


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

### 思路 1：复杂度分析

- **时间复杂度**：入栈操作的时间复杂度为 $O(n)$。出栈、取栈顶元素、判断栈是否为空的时间复杂度为 $O(1)$。
- **空间复杂度**：$O(n)$。# [0226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0226. 翻转二叉树 - 力扣](https://leetcode.cn/problems/invert-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：将该二叉树进行左右翻转。

**说明**：

- 树中节点数目范围在 $[0, 100]$ 内。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```python
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```python
输入：root = [2,1,3]
输出：[2,3,1]
```

## 解题思路

### 思路 1：递归遍历

根据我们的递推三步走策略，写出对应的递归代码。

1. 写出递推公式：

   1. 递归遍历翻转左子树。
   2. 递归遍历翻转右子树。
   3. 交换当前根节点 `root` 的左右子树。

2. 明确终止条件：当前节点 `root` 为 `None`。

3. 翻译为递归代码：
   1. 定义递归函数：`invertTree(self, root)` 表示输入参数为二叉树的根节点 `root`，返回结果为翻转后二叉树的根节点。

   2. 书写递归主体：

      ```python
      left = self.invertTree(root.left)
      right = self.invertTree(root.right)
      root.left = right
      root.right = left
      return root
      ```

   3. 明确递归终止条件：`if not root: return None`

4. 返回根节点 `root`。

### 思路 1：代码

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left = right
        root.right = left
        return root
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

- 标签：栈、数学、字符串
- 难度：中等

## 题目链接

- [0227. 基本计算器 II - 力扣](https://leetcode.cn/problems/basic-calculator-ii/)

## 题目大意

**描述**：给定一个字符串表达式 `s`，表达式中所有整数为非负整数，运算符只有 `+`、`-`、`*`、`/`，没有括号。

**要求**：实现一个基本计算器来计算并返回它的值。

**说明**：

- $1 \le s.length \le 3 * 10^5$。
- `s` 由整数和算符（`+`、`-`、`*`、`/`）组成，中间由一些空格隔开。
- `s` 表示一个有效表达式。
- 表达式中的所有整数都是非负整数，且在范围 $[0, 2^{31} - 1]$ 内。
- 题目数据保证答案是一个 32-bit 整数。

**示例**：

- 示例 1：

```python
输入：s = "3+2*2"
输出：7
```

- 示例 2：

```python
输入：s = " 3/2 "
输出：1
```

## 解题思路

### 思路 1：栈

计算表达式中，乘除运算优先于加减运算。我们可以先进行乘除运算，再将进行乘除运算后的整数值放入原表达式中相应位置，再依次计算加减。

可以考虑使用一个栈来保存进行乘除运算后的整数值。正整数直接压入栈中，负整数，则将对应整数取负号，再压入栈中。这样最终计算结果就是栈中所有元素的和。

具体做法：

1. 遍历字符串 `s`，使用变量 `op` 来标记数字之前的运算符，默认为 `+`。
2. 如果遇到数字，继续向后遍历，将数字进行累积，得到完整的整数 num。判断当前 op 的符号。
   1. 如果 `op` 为 `+`，则将 `num` 压入栈中。
   2. 如果 `op` 为 `-`，则将 `-num` 压入栈中。
   3. 如果 `op` 为 `*`，则将栈顶元素 `top` 取出，计算 `top * num`，并将计算结果压入栈中。
   4. 如果 `op` 为 `/`，则将栈顶元素 `top` 取出，计算 `int(top / num)`，并将计算结果压入栈中。
3. 如果遇到 `+`、`-`、`*`、`/` 操作符，则更新 `op`。
4. 最后将栈中整数进行累加，并返回结果。

### 思路 1：代码

```python
class Solution:
    def calculate(self, s: str) -> int:
        size = len(s)
        stack = []
        op = '+'
        index = 0
        while index < size:
            if s[index] == ' ':
                index += 1
                continue
            if s[index].isdigit():
                num = ord(s[index]) - ord('0')
                while index + 1 < size and s[index+1].isdigit():
                    index += 1
                    num = 10 * num + ord(s[index]) - ord('0')
                if op == '+':
                    stack.append(num)
                elif op == '-':
                    stack.append(-num)
                elif op == '*':
                    top = stack.pop()
                    stack.append(top * num)
                elif op == '/':
                    top = stack.pop()
                    stack.append(int(top / num))
            elif s[index] in "+-*/":
                op = s[index]
            index += 1
        return sum(stack)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0231. 2 的幂](https://leetcode.cn/problems/power-of-two/)

- 标签：位运算、递归、数学
- 难度：简单

## 题目链接

- [0231. 2 的幂 - 力扣](https://leetcode.cn/problems/power-of-two/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：判断该整数 $n$ 是否是 $2$ 的幂次方。如果是，返回 `True`；否则，返回 `False`。

**说明**：

- $-2^{31} \le n \le 2^{31} - 1$

**示例**：

- 示例 1：

```python
输入：n = 1
输出：True
解释：2^0 = 1
```

- 示例 2：

```python
输入：n = 16
输出：True
解释：2^4 = 16
```

## 解题思路

### 思路 1：循环判断

1. 不断判断 $n$ 是否能整除 $2$。
   1. 如果不能整除，则返回 `False`。
   2. 如果能整除，则让 $n$ 整除 $2$，直到 $n < 2$。
2. 如果最后 $n == 1$，则返回 `True`，否则则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False

        while n % 2 == 0:
            n //= 2
        return n == 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log_2 n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：数论判断

因为 $n$ 能取的最大值为 $2^{31}-1$。我们可以计算出：在 $n$ 的范围内，$2$ 的幂次方最大为 $2^{30} = 1073741824$。

因为 $2$ 为质数，则 $2^{30}$ 的除数只有 $2^0, 2^1, …, 2^{30}$。所以如果 $n$ 为 $2$ 的幂次方，则 $2^{30}$ 肯定能被 $n$ 整除，直接判断即可。

### 思路 2：代码

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and 1073741824 % n == 0
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。

# [0232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

- 标签：栈、设计、队列
- 难度：简单

## 题目链接

- [0232. 用栈实现队列 - 力扣](https://leetcode.cn/problems/implement-queue-using-stacks/)

## 题目大意

**要求**：仅使用两个栈实现先入先出队列。

要求实现 `MyQueue` 类：

- `void push(int x)` 将元素 `x` 推到队列的末尾。
- `int pop()` 从队列的开头移除并返回元素。
- `int peek()` 返回队列开头的元素。
- `boolean empty()` 如果队列为空，返回 `True`；否则，返回 `False`。

**说明**：

- 只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek / pop from top`, `size`, 和 `is empty` 操作是合法的。
- 可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- $1 <= x <= 9$。
- 最多调用 $100$ 次 `push`、`pop`、`peek` 和 `empty`。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）。
- 进阶：实现每个操作均摊时间复杂度为 `O(1)` 的队列。换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)`，即使其中一个操作可能花费较长时间。

**示例**：

- 示例 1：

```python
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

## 解题思路

### 思路 1：双栈

使用两个栈，`inStack` 用于输入，`outStack` 用于输出。

- `push` 操作：将元素压入 `inStack` 中。
- `pop` 操作：如果 `outStack` 输出栈为空，将 `inStack` 输入栈元素依次取出，按顺序压入 `outStack` 栈。这样 `outStack` 栈的元素顺序和之前 `inStack` 元素顺序相反，`outStack` 顶层元素就是要取出的队头元素，将其移出，并返回该元素。如果 `outStack` 输出栈不为空，则直接取出顶层元素。
- `peek` 操作：和 `pop` 操作类似，只不过最后一步不需要取出顶层元素，直接将其返回即可。
- `empty` 操作：如果 `inStack` 和 `outStack` 都为空，则队列为空，否则队列不为空。

### 思路 1：代码

```python
class MyQueue:

    def __init__(self):
        self.inStack = []
        self.outStack = []
        """
        Initialize your data structure here.
        """


    def push(self, x: int) -> None:
        self.inStack.append(x)
        """
        Push element x to the back of queue.
        """


    def pop(self) -> int:
        if(len(self.outStack) == 0):
            while(len(self.inStack) != 0):
                self.outStack.append(self.inStack[-1])
                self.inStack.pop()
        top = self.outStack[-1]
        self.outStack.pop()
        return top
        """
        Removes the element from in front of queue and returns that element.
        """


    def peek(self) -> int:
        if (len(self.outStack) == 0):
            while (len(self.inStack) != 0):
                self.outStack.append(self.inStack[-1])
                self.inStack.pop()
        top = self.outStack[-1]
        return top
        """
        Get the front element.
        """


    def empty(self) -> bool:
        return len(self.outStack) == 0 and len(self.inStack) == 0
        """
        Returns whether the queue is empty.
        """
```

### 思路 1：复杂度分析

- **时间复杂度**：`push` 和 `empty` 为 $O(1)$，`pop` 和 `peek` 为均摊 $O(1)$。
- **空间复杂度**：$O(n)$。

# [0233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

- 标签：递归、数学、动态规划
- 难度：困难

## 题目链接

- [0233. 数字 1 的个数 - 力扣](https://leetcode.cn/problems/number-of-digit-one/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：计算所有小于等于 $n$ 的非负整数中数字 $1$ 出现的个数。

**说明**：

- $0 \le n \le 10^9$。

**示例**：

- 示例 1：

```python
输入：n = 13
输出：6
```

- 示例 2：

```python
输入：n = 0
输出：0
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, cnt, isLimit):` 表示构造第 $pos$ 位及之后所有数位中数字 $1$ 出现的个数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True)` 开始递归。 `dfs(0, 0, True)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 初始数字 $1$ 出现的个数为 $0$。
   3. 开始时受到数字 $n$ 对应最高位数位的约束。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：返回数字 $1$ 出现的个数 $cnt$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
   1. 因为不需要考虑前导 $0$ 所以当前位数位所能选择的最小数字（$minX$）为 $0$。
   2. 根据 $isLimit$ 来决定填当前位数位所能选择的最大数字（$maxX$）。
   3. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
   4. 方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, cnt + (d == 1), isLimit and d == maxX)`。
      1. `cnt + (d == 1)` 表示之前数字 $1$ 出现的个数加上当前位为数字 $1$ 的个数。
      2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位 $pos$ 位限制。
6. 最后的方案数为 `dfs(0, 0, True)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # cnt: 之前数字 1 出现的个数。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        def dfs(pos, cnt, isLimit):
            if pos == len(s):
                return cnt
            
            ans = 0            
            # 不需要考虑前导 0，则最小可选择数字为 0
            minX = 0
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                ans += dfs(pos + 1, cnt + (d == 1), isLimit and d == maxX)
            return ans
    
        return dfs(0, 0, True)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。

# [0234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

- 标签：栈、递归、链表、双指针
- 难度：简单

## 题目链接

- [0234. 回文链表 - 力扣](https://leetcode.cn/problems/palindrome-linked-list/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：判断该链表是否为回文链表。

**说明**：

- 链表中节点数目在范围 $[1, 10^5]$ 内。
- $0 \le Node.val \le 9$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```python
输入：head = [1,2,2,1]
输出：True
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```python
输入：head = [1,2]
输出：False
```

## 解题思路

### 思路 1：利用数组 + 双指针

1. 利用数组，将链表元素依次存入。
2. 然后再使用两个指针，一个指向数组开始位置，一个指向数组结束位置。
3. 依次判断首尾对应元素是否相等，如果都相等，则为回文链表。如果不相等，则不是回文链表。

### 思路 1：代码

```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        nodes = []
        p1 = head
        while p1 != None:
            nodes.append(p1.val)
            p1 = p1.next
        return nodes == nodes[::-1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0235. 二叉搜索树的最近公共祖先 - 力扣](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

## 题目大意

**描述**：给定一个二叉搜索树的根节点 `root`，以及两个指定节点 `p` 和 `q`。

**要求**：找到该树中两个指定节点的最近公共祖先。

**说明**：

- **祖先**：若节点 `p` 在节点 `node` 的左子树或右子树中，或者 `p == node`，则称 `node` 是 `p` 的祖先。
- **最近公共祖先**：对于树的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `lca_node`，满足 `lca_node` 是 `p`、`q` 的祖先且 `lca_node` 的深度尽可能大（一个节点也可以是自己的祖先）。
- 所有节点的值都是唯一的。
- `p`、`q` 为不同节点且均存在于给定的二叉搜索树中。

**示例**：

- 示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

```python
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

- 示例 2：

```python
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

## 解题思路

### 思路 1：递归遍历

对于节点 `p`、节点 `q`，最近公共祖先就是从根节点分别到它们路径上的分岔点，也是路径中最后一个相同的节点，现在我们的问题就是求这个分岔点。

我们可以使用递归遍历查找二叉搜索树的最近公共祖先，具体方法如下。

1. 从根节点 `root` 开始遍历。
2. 如果当前节点的值大于 `p`、`q` 的值，说明 `p` 和 `q`  应该在当前节点的左子树，因此将当前节点移动到它的左子节点，继续遍历；
3. 如果当前节点的值小于 `p`、`q` 的值，说明 `p` 和 `q`  应该在当前节点的右子树，因此将当前节点移动到它的右子节点，继续遍历；
4. 如果当前节点不满足上面两种情况，则说明 `p` 和 `q` 分别在当前节点的左右子树上，则当前节点就是分岔点，直接返回该节点即可。

### 思路 1：代码

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        ancestor = root
        while True:
            if ancestor.val > p.val and ancestor.val > q.val:
                ancestor = ancestor.left
            elif ancestor.val < p.val and ancestor.val < q.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉搜索树的节点个数。
- **空间复杂度**：$O(1)$。# [0236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0236. 二叉树的最近公共祖先 - 力扣](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`，以及二叉树中两个节点 `p` 和 `q`。

**要求**：找到该二叉树中指定节点 `p`、`q` 的最近公共祖先。

**说明**：

- **祖先**：如果节点 `p` 在节点 `node` 的左子树或右子树中，或者 `p == node`，则称 `node` 是 `p` 的祖先。
- **最近公共祖先**：对于树的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `lca_node`，满足 `lca_node` 是 `p`、`q` 的祖先且 `lca_node` 的深度尽可能大（一个节点也可以是自己的祖先）。
- 树中节点数目在范围 $[2, 10^5]$ 内。
- $-10^9 \le Node.val \le 10^9$。
- 所有 `Node.val` 互不相同。
- `p != q`。
- `p` 和 `q` 均存在于给定的二叉树中。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```python
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```python
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

## 解题思路

### 思路 1：递归遍历

设 `lca_node` 为节点 `p`、`q` 的最近公共祖先。则 `lca_node` 只能是下面几种情况：

1. `p`、`q` 在 `lca_node` 的子树中，且分别在 `lca_node` 的两侧子树中。
2. `p == lca_node`，且 `q` 在 `lca_node` 的左子树或右子树中。
3. `q == lca_node`，且 `p` 在 `lca_node` 的左子树或右子树中。

下面递归求解 `lca_node`。递归需要满足以下条件：

- 如果 `p`、`q` 都不为空，则返回 `p`、`q` 的公共祖先。
- 如果 `p`、`q` 只有一个存在，则返回存在的一个。
- 如果 `p`、`q` 都不存在，则返回 `None`。

具体思路为：

1. 如果当前节点 `node` 等于 `p` 或者 `q`，那么 `node` 就是 `p`、`q` 的最近公共祖先，直接返回 `node`。
2. 如果当前节点 `node` 不为 `None`，则递归遍历左子树、右子树，并判断左右子树结果。
   1. 如果左右子树都不为空，则说明 `p`、`q` 在当前根节点的两侧，当前根节点就是他们的最近公共祖先。
   2. 如果左子树为空，则返回右子树。
   3. 如果右子树为空，则返回左子树。
   4. 如果左右子树都为空，则返回 `None`。
3. 如果当前节点 `node` 为 `None`，则说明 `p`、`q` 不在 `node` 的子树中，不可能为公共祖先，直接返回 `None`。

### 思路 1：代码

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == p or root == q:
            return root

        if root:
            node_left = self.lowestCommonAncestor(root.left, p, q)
            node_right = self.lowestCommonAncestor(root.right, p, q)
            if node_left and node_right:
                return root
            elif not node_left:
                return node_right
            else:
                return node_left
        return None
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。

# [0237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

- 标签：链表
- 难度：中等

## 题目链接

- [0237. 删除链表中的节点 - 力扣](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

## 题目大意

删除链表的给定节点。

## 解题思路

直接将该节点的后续节点覆盖该节点即可。即让该节点的值等于下一节点值，并让其 next 指针指向下一节点的下一节点。

## 代码

```python
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

# [0238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

- 标签：数组、前缀和
- 难度：中等

## 题目链接

- [0238. 除自身以外数组的乘积 - 力扣](https://leetcode.cn/problems/product-of-array-except-self/)

## 题目大意

**描述**：给定一个数组 nums。

**要求**：返回数组 $answer$，其中 $answer[i]$ 等于 $nums$ 中除 $nums[i]$ 之外其余各元素的乘积。

**说明**：

- 题目数据保证数组 $nums$ 之中任意元素的全部前缀元素和后缀的乘积都在 $32$ 位整数范围内。
- 请不要使用除法，且在 $O(n)$ 时间复杂度内解决问题。
- **进阶**：在 $O(1)$ 的额外空间复杂度内完成这个题目。
- $2 \le nums.length \le 10^5$。
- $-30 \le nums[i] \le 30$。

**示例**：

- 示例 1：

```python
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

- 示例 2：

```python
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

## 解题思路

### 思路 1：两次遍历

1. 构造一个答案数组 $res$，长度和数组 $nums$ 长度一致。
2. 先从左到右遍历一遍 $nums$ 数组，将 $nums[i]$ 左侧的元素乘积累积起来，存储到 $res$ 数组中。
3. 再从右到左遍历一遍，将 $nums[i]$ 右侧的元素乘积累积起来，再乘以原本 $res[i]$ 的值，即为 $nums$ 中除了 $nums[i]$ 之外的其他所有元素乘积。

### 思路 1：代码

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        size = len(nums)
        res = [1 for _ in range(size)]

        left = 1
        for i in range(size):
            res[i] *= left
            left *= nums[i]

        right = 1
        for i in range(size-1, -1, -1):
            res[i] *= right
            right *= nums[i]
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。



# [0239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

- 标签：队列、数组、滑动窗口、单调队列、堆（优先队列）
- 难度：困难

## 题目链接

- [0239. 滑动窗口最大值 - 力扣](https://leetcode.cn/problems/sliding-window-maximum/)

## 题目大意

**描述**：给定一个整数数组 `nums`，再给定一个整数 `k`，表示为大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。我们只能看到滑动窗口内的 `k` 个数字，滑动窗口每次只能向右移动一位。

**要求**：返回滑动窗口中的最大值。

**说明**：

- $1 \le nums.length \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。
- $1 \le k \le nums.length$。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

- 示例 2：

```python
输入：nums = [1], k = 1
输出：[1]
```

## 解题思路

暴力求解的话，需要使用二重循环遍历，其时间复杂度为 $O(n * k)$。根据题目给定的数据范围，肯定会超时。

我们可以使用优先队列来做。

### 思路 1：优先队列

1. 初始的时候将前 `k` 个元素加入优先队列的二叉堆中。存入优先队列的是数组值与索引构成的元组。优先队列将数组值作为优先级。
2. 然后滑动窗口从第 `k` 个元素开始遍历，将当前数组值和索引的元组插入到二叉堆中。
3. 当二叉堆堆顶元素的索引已经不在滑动窗口的范围中时，即 `q[0][1] <= i - k` 时，不断删除堆顶元素，直到最大值元素的索引在滑动窗口的范围中。
4. 将最大值加入到答案数组中，继续向右滑动。
5. 滑动结束时，输出答案数组。

### 思路 1：代码

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        size = len(nums)
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)
        res = [-q[0][0]]

        for i in range(k, size):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            res.append(-q[0][0])
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log_2n)$。
- **空间复杂度**：$O(k)$。

# [0240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

- 标签：二分查找、分治算法
- 难度：中等

## 题目链接

- [0240. 搜索二维矩阵 II - 力扣](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的有序整数矩阵 $matrix$。$matrix$ 中的每行元素从左到右升序排列，每列元素从上到下升序排列。再给定一个目标值 $target$。

**要求**：判断矩阵中是否可以找到 $target$，如果可以找到 $target$，返回 `True`，否则返回 `False`。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le n, m \le 300$。
- $-10^9 \le matrix[i][j] \le 10^9$。
- 每行的所有元素从左到右升序排列。
- 每列的所有元素从上到下升序排列。
- $-10^9 \le target \le 10^9$。

**示例**：

- 示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```python
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：True
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```python
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：False
```

## 解题思路

### 思路 1：二分查找

矩阵是有序的，可以考虑使用二分查找来做。

1. 迭代对角线元素，假设对角线元素的坐标为 $(row, col)$。把数组元素按对角线分为右上角部分和左下角部分。
2. 对于当前对角线元素右侧第 $row$ 行、对角线元素下侧第 $col$ 列分别进行二分查找。
   1. 如果找到目标，直接返回 `True`。
   2. 如果找不到目标，则缩小范围，继续查找。
   3. 直到所有对角线元素都遍历完，依旧没找到，则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def diagonalBinarySearch(self, matrix, diagonal, target):
        left = 0
        right = diagonal
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def rowBinarySearch(self, matrix, begin, cols, target):
        left = begin
        right = cols
        while left < right:
            mid = left + (right - left) // 2
            if matrix[begin][mid] < target:
                left = mid + 1
            elif matrix[begin][mid] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= cols and matrix[begin][left] == target

    def colBinarySearch(self, matrix, begin, rows, target):
        left = begin + 1
        right = rows
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][begin] < target:
                left = mid + 1
            elif matrix[mid][begin] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= rows and matrix[left][begin] == target

    def searchMatrix(self, matrix, target: int) -> bool:
        rows = len(matrix)
        if rows == 0:
            return False
        cols = len(matrix[0])
        if cols == 0:
            return False

        min_val = min(rows, cols)
        index = self.diagonalBinarySearch(matrix, min_val - 1, target)
        if matrix[index][index] == target:
            return True
        for i in range(index + 1):
            row_search = self.rowBinarySearch(matrix, i, cols - 1, target)
            col_search = self.colBinarySearch(matrix, i, rows - 1, target)
            if row_search or col_search:
                return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(min(m, n) \times (\log_2 m + \log_2 n))$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数。
- **空间复杂度**：$O(1)$。# [0241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

- 标签：递归、记忆化搜索、数学、字符串、动态规划
- 难度：中等

## 题目链接

- [0241. 为运算表达式设计优先级 - 力扣](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

## 题目大意

**描述**：给定一个由数字和运算符组成的字符串 `expression`。

**要求**：按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以按任意顺序返回答案。

**说明**：

- 生成的测试用例满足其对应输出值符合 $32$ 位整数范围，不同结果的数量不超过 $10^4$。
- $1 \le expression.length \le 20$。
- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
- 输入表达式中的所有整数值在范围 $[0, 99]$。

**示例**：

- 示例 1：

```python
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
```

- 示例 2：

```python
输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
```

## 解题思路

### 思路 1：分治算法

给定的字符串 `expression` 只包含有数字和字符，可以写成类似 `x op y` 的形式，其中 $x$、$y$ 为表达式或数字，$op$ 为字符。

则我们可以根据字符的位置，将其递归分解为 $x$、$y$ 两个部分，接着分别计算 $x$ 部分的结果与 $y$ 部分的结果。然后再将其合并。

### 思路 1：代码

```python
class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        res = []
        if len(expression) <= 2:
            res.append(int(expression))
            return res
        
        for i in range(len(expression)):
            ch = expression[i]
            if ch == '+' or ch == '-' or ch == '*':
                left_cnts = self.diffWaysToCompute(expression[ :i])
                right_cnts = self.diffWaysToCompute(expression[i + 1:])

                for left in left_cnts:
                    for right in right_cnts:
                        if ch == '+':
                            res.append(left + right)
                        elif ch == '-':
                            res.append(left - right)
                        else:
                            res.append(left * right)
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(C_n)$，其中 $n$ 为结果数组的大小，$C_n$ 是第 $n$ 个卡特兰数。
- **空间复杂度**：$O(C_n)$。
# [0242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

- 标签：哈希表、字符串、排序
- 难度：简单

## 题目链接

- [0242. 有效的字母异位词 - 力扣](https://leetcode.cn/problems/valid-anagram/)

## 题目大意

**描述**：给定两个字符串 $s$ 和 $t$。

**要求**：判断 $t$ 和 $s$ 是否使用了相同的字符构成（字符出现的种类和数目都相同）。

**说明**：

- **字母异位词**：如果 $s$ 和 $t$ 中每个字符出现的次数都相同，则称 $s$ 和 $t$ 互为字母异位词。
- $1 \le s.length, t.length \le 5 \times 10^4$。
- $s$ 和 $t$ 仅包含小写字母。

**示例**：

- 示例 1：

```python
输入: s = "anagram", t = "nagaram"
输出: True
```

- 示例 2：

```python
输入: s = "rat", t = "car"
输出: False
```

## 解题思路

### 思路 1：哈希表

1. 先判断字符串 $s$ 和 $t$ 的长度，不一样直接返回 `False`；
2. 分别遍历字符串 $s$ 和 $t$。先遍历字符串 $s$，用哈希表存储字符串 $s$ 中字符出现的频次；
3. 再遍历字符串 $t$，哈希表中减去对应字符的频次，出现频次小于 $0$ 则输出 `False`；
4. 如果没出现频次小于 $0$，则输出 `True`。

### 思路 1：代码

```python
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    strDict = dict()
    for ch in s:
        if ch in strDict:
            strDict[ch] += 1
        else:
            strDict[ch] = 1
    for ch in t:
        if ch in strDict:
            strDict[ch] -= 1
            if strDict[ch] < 0:
                return False
        else:
            return False
    return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$、$m$ 分别为字符串 $s$、$t$ 的长度。
- **空间复杂度**：$O(|S|)$，其中 $S$ 为字符集大小，此处 $S == 26$。

# [0249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)

- 标签：数组、哈希表、字符串
- 难度：中等

## 题目链接

- [0249. 移位字符串分组 - 力扣](https://leetcode.cn/problems/group-shifted-strings/)

## 题目大意

给定一个仅包含小写字母的字符串列表。其中每个字符串都可以进行「移位」操作，也就是将字符串中的每个字母变为其在字母表中后续的字母。比如：`abc` -> `bcd`。

要求：将该列表中满足「移位」操作规律的组合进行分组并返回。

## 解题思路

我们可以先将满足相同「移位」操作规律的组合翻译为相同的模式，然后利用哈希表进行存储。哈希表对应关系为 翻译后模式：该模式对应的原字符串列表。

## 代码

```python
import collections
class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        str_dict = collections.defaultdict(list)
        for string in strings:
            if string[0] == 'a':
                str_dict[string].append(string)
            else:
                list_string = list(string)
                for i in range(len(list_string)):
                    num = (ord(list_string[i]) - ord(string[0]) + 26) % 26
                    list_string[i] = chr(num + ord('a'))
                temp_string = ''.join(list_string)
                str_dict[temp_string].append(string)
        res = list()
        for string, sublist in str_dict.items():
            res.append(sublist)
        return res
```

# [0257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

- 标签：树、深度优先搜索、字符串、回溯、二叉树
- 难度：简单

## 题目链接

- [0257. 二叉树的所有路径 - 力扣](https://leetcode.cn/problems/binary-tree-paths/)

## 题目大意

给定一个二叉树，返回所有从根节点到叶子节点的路径。

## 解题思路

深度优先搜索。在递归遍历时，需考虑当前节点和左右孩子节点。

- 如果当前节点不是叶子节点，则当前拼接路径中加入该点，并继续递归遍历。
- 如果当前节点是叶子节点，则当前拼接路径中加入该点，并将当前路径加入答案数组。

## 代码

```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        res = []
        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            elif not root.right:
                dfs(root.left, path + "->")
            elif not root.left:
                dfs(root.right, path + "->")
            else:
                dfs(root.left, path + "->")
                dfs(root.right, path + "->")
        dfs(root, "")
        return res
```

# [0258. 各位相加](https://leetcode.cn/problems/add-digits/)

- 标签：数学、数论、模拟
- 难度：简单

## 题目链接

- [0258. 各位相加 - 力扣](https://leetcode.cn/problems/add-digits/)

## 题目大意

给定一个非负整数  num，反复将各个位上的数字相加，直到结果为一位数。

## 解题思路

根据题意，循环模拟累加即可。

## 代码

```python
class Solution:
    def addDigits(self, num: int) -> int:
        while num >= 10:
            cur = 0
            while num:
                cur += num % 10
                num //= 10
            num = cur
        return num
```

# [0259. 较小的三数之和](https://leetcode.cn/problems/3sum-smaller/)

- 标签：数组、双指针、二分查找、排序
- 难度：中等

## 题目链接

- [0259. 较小的三数之和 - 力扣](https://leetcode.cn/problems/3sum-smaller/)

## 题目大意

**描述**：给定一个长度为 $n$ 的整数数组和一个目标值 $target$。

**要求**：寻找能够使条件 $nums[i] + nums[j] + nums[k] < target$ 成立的三元组  ($i$, $j$, $k$) 的个数（$0 <= i < j < k < n$）。

**说明**：

- 最好在 $O(n^2)$ 的时间复杂度内解决问题。
- $n == nums.length$。
- $0 \le n \le 3500$。
- $-100 \le nums[i] \le 100$。
- $-100 \le target \le 100$。

**示例**：

- 示例 1：

```python
输入: nums = [-2,0,1,3], target = 2
输出: 2 
解释: 因为一共有两个三元组满足累加和小于 2:
     [-2,0,1]
     [-2,0,3]
```

- 示例 2：

```python
输入: nums = [], target = 0
输出: 0
```

## 解题思路

### 思路 1：排序 + 双指针

三元组直接枚举的时间复杂度是 $O(n^3)$，明显不符合题目要求。那么可以考虑使用双指针减少循环内的时间复杂度。具体做法如下：

- 先对数组进行从小到大排序。
- 遍历数组，对于数组元素 $nums[i]$，使用两个指针 $left$、$right$。$left$ 指向第 $i + 1$ 个元素位置，$right$ 指向数组的最后一个元素位置。
- 在区间 $[left, right]$ 中查找满足 $nums[i] + nums[left] + nums[right] < target$的方案数。
- 计算 $nums[i]$、$nums[left]$、$nums[right]$ 的和，将其与 $target$ 比较。
  - 如果 $nums[i] + nums[left] + nums[right] < target$，则说明 $i$、$left$、$right$ 作为三元组满足题目要求，同时说明区间 $[left, right]$ 中的元素作为 $right$ 都满足条件，此时将 $left$ 右移，继续判断。
  - 如果 $nums[i] + nums[left] + nums[right] \ge target$，则说明 $right$ 太大了，应该缩小 $right$，然后继续判断。
- 当 $left == right$ 时，区间搜索完毕，继续遍历 $nums[i + 1]$。

这种思路使用了两重循环，其中内层循环当 $left == right$ 时循环结束，时间复杂度为 $O(n)$，外层循环时间复杂度也是 $O(n)$。所以算法的整体时间复杂度为 $O(n^2)$，符合题目要求。

### 思路 1：代码

```python
class Solution:
    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        nums.sort()
        size = len(nums)
        res = 0
        for i in range(size):
            left, right = i + 1, size - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total < target:
                    res += (right - left)
                    left += 1
                else:
                    right -= 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(\log n)$。

# [0260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/)

- 标签：位运算、数组
- 难度：中等

## 题目链接

- [0260. 只出现一次的数字 III - 力扣](https://leetcode.cn/problems/single-number-iii/)

## 题目大意

**描述**：给定一个整数数组 $nums$。$nums$ 中恰好有两个元素只出现一次，其余所有元素均出现两次。

**要求**：找出只出现一次的那两个元素。可以按任意顺序返回答案。要求时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。

**说明**：

- $2 \le nums.length \le 3 \times 10^4$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。
- 除两个只出现一次的整数外，$nums$ 中的其他数字都出现两次。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

- 示例 2：

```python
输入：nums = [-1,0]
输出：[-1,0]
```

## 解题思路

### 思路 1：位运算

求解这道题之前，我们先来看看如何求解「一个数组中除了某个元素只出现一次以外，其余每个元素均出现两次。」即「[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)」问题。

我们可以对所有数不断进行异或操作，最终可得到单次出现的元素。

下面我们再来看这道题。

如果数组中有两个数字只出现一次，其余每个元素均出现两次。那么经过全部异或运算。我们可以得到只出现一次的两个数字的异或结果。

根据异或结果的性质，异或运算中如果某一位上为 $1$，则说明异或的两个数在该位上是不同的。根据这个性质，我们将数字分为两组：

1. 一组是和该位为 $0$ 的数字，
2. 一组是该位为 $1$ 的数字。

然后将这两组分别进行异或运算，就可以得到最终要求的两个数字。

### 思路 1：代码

```python
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        all_xor = 0
        for num in nums:
            all_xor ^= num
        # 获取所有异或中最低位的 1
        mask = 1
        while all_xor & mask == 0:
            mask <<= 1

        a_xor, b_xor = 0, 0
        for num in nums:
            if num & mask == 0:
                a_xor ^= num
            else:
                b_xor ^= num

        return a_xor, b_xor
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 中的元素个数。
- **空间复杂度**：$O(1)$。

# [0263. 丑数](https://leetcode.cn/problems/ugly-number/)

- 标签：数学
- 难度：简单

## 题目链接

- [0263. 丑数 - 力扣](https://leetcode.cn/problems/ugly-number/)

## 题目大意

给定一个整数 `n`。

要求：判断 `n` 是否为丑数。如果是，则返回 `True`，否则，返回 `False`。

- 丑数：只包含质因数 `2`、`3`、`5` 的正整数。

## 解题思路

- 如果 `n <= 0`，则 `n` 必然不是丑数，直接返回 `False`。
- 对 `n` 分别进行 `2`、`3`、`5` 的整除操作，直到 `n` 被除完，如果 `n` 最终为 `1`，则 `n` 是丑数，否则不是丑数。

## 代码

```python
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        factors = [2, 3, 5]
        for factor in factors:
            while n % factor == 0:
                n //= factor

        return n == 1
```

# [0264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

- 标签：哈希表、数学、动态规划、堆（优先队列）
- 难度：中等

## 题目链接

- [0264. 丑数 II - 力扣](https://leetcode.cn/problems/ugly-number-ii/)

## 题目大意

给定一个整数 `n`。

要求：找出并返回第 `n` 个丑数。

- 丑数：只包含质因数 `2`、`3`、`5` 的正整数。

## 解题思路

动态规划求解。

定义状态 `dp[i]` 表示第 `i` 个丑数。

状态转移方程为：`dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)` ，其中 `p2`、`p3`、`p5` 分别表示当前 `i` 中  `2`、`3`、`5` 的质因子数量。

## 代码

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [1 for _ in range(n)]
        p2, p3, p5 = 0, 0, 0
        for i in range(1, n):
            dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)
            if dp[i] == dp[p2] * 2:
                p2 += 1
            if dp[i] == dp[p3] * 3:
                p3 += 1
            if dp[i] == dp[p5] * 5:
                p5 += 1
        return dp[n - 1]
```

# [0268. 丢失的数字](https://leetcode.cn/problems/missing-number/)

- 标签：位运算、数组、哈希表、数学、二分查找、排序
- 难度：简单

## 题目链接

- [0268. 丢失的数字 - 力扣](https://leetcode.cn/problems/missing-number/)

## 题目大意

**描述**：给定一个包含 $[0, n]$ 中 $n$ 个数的数组 $nums$。

**要求**：找出 $[0, n]$ 这个范围内没有出现在数组中的那个数。

**说明**：

- $n == nums.length$
- $1 \le n \le 10^4$
- $0 \le nums[i] \le n$。
- $nums$ 中的所有数字都独一无二。

**示例**：

- 示例 1：

```python
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

- 示例 2：

```python
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

## 解题思路

$[0, n]$ 的范围有 $n + 1$ 个数（包含 $0$）。现在给了我们 $n$ 个数，要求找出其中缺失的那个数。

### 思路 1：哈希表

将 $nums$ 中所有元素插入到哈希表中，然后遍历 $[0, n]$，找到缺失的数字。

这里的哈希表也可以用长度为 $n + 1$ 的数组代替。

### 思路 1：代码

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        numSet = set(nums)

        for num in range(len(nums)+1):
            if num not in numSet:
                return num
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：数学计算

已知 $[0, n]$ 的求和公式为：$\sum_{i=0}^n i = \frac{n*(n+1)}{2}$，则用 $[0, n]$ 的和，减去数组中所有元素的和，就得到了缺失数字。

### 思路 2：代码

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        sum_nums = sum(nums)
        n = len(nums)
        return (n + 1) * n // 2 - sum_nums
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/)

- 标签：树、深度优先搜索、二叉搜索树、二分查找、二叉树
- 难度：简单

## 题目链接

- [0270. 最接近的二叉搜索树值 - 力扣](https://leetcode.cn/problems/closest-binary-search-tree-value/)

## 题目大意

**描述**：给定一个不为空的二叉搜索树的根节点，以及一个目标值 $target$。

**要求**：在二叉搜索树中找到最接近目标值 $target$ 的数值。

**说明**：

-  树中节点的数目在范围 $[1, 10^4]$ 内。
- $0 \le Node.val \le 10^9$。
- $-10^9 \le target \le 10^9$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)

```python
输入：root = [4,2,5,1,3], target = 3.714286
输出：4
```

- 示例 2：

```python
输入：root = [1], target = 4.428571
输出：1
```

## 解题思路

### 思路 1：二分查找算法

题目中最接近目标值 $target$ 的数值指的就是与 $target$ 相减绝对值最小的数值。

而且根据二叉搜索树的性质，我们可以利用二分搜索的方式，查找与 $target$ 相减绝对值最小的数值。具体做法为：

- 定义一个变量 $closest$ 表示与 $target$ 最接近的数值，初始赋值为根节点的值 $root.val$。
- 判断当前节点的值域 $closet$ 值哪个更接近 $target$，如果当前值更接近，则更新 $closest$。
- 如果 $target$ < 当前节点值，则从当前节点的左子树继续查找。
- 如果 $target$ ≥ 当前节点值，则从当前节点的右子树继续查找。

### 思路 1：代码

```python
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        closest = root.val
        while root:
            if abs(target - root.val) < abs(target - closest):
                closest = root.val
            if target < root.val:
                root = root.left
            else:
                root = root.right
        return closest
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$，其中 $n$ 为二叉搜索树的节点个数。
- **空间复杂度**：$O(1)$。

# [0278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [0278. 第一个错误的版本 - 力扣](https://leetcode.cn/problems/first-bad-version/)

## 题目大意

**描述**：给你一个整数 $n$，代表已经发布的版本号。还有一个用于检测版本是否出错的接口 `isBadVersion(version):` 。

**要求**：找出第一次出错的版本号 $bad$。

**说明**：

- 要求尽可能减少对 `isBadVersion(version):` 接口的调用。
- $1 \le bad \le n \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

- 示例 2：

```python
输入：n = 1, bad = 1
输出：1
```

## 解题思路

### 思路 1：二分查找

题目要求尽可能减少对 `isBadVersion(version):` 接口的调用，所以不能对每个版本都调用接口，而是应该将接口调用的次数降到最低。

可以注意到：如果检测某个版本不是错误版本时，则该版本之前的所有版本都不是错误版本。而当某个版本是错误版本时，则该版本之后的所有版本都是错误版本。我们可以利用这样的性质，在 $[1, n]$ 的区间内使用二分查找方法，从而在 $O(\log n)$ 时间复杂度内找到第一个出错误的版本。

### 思路 1：代码

```python
class Solution:
    def firstBadVersion(self, n):
        left = 1
        right = n
        while left < right:
            mid = (left + right) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [0279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

- 标签：广度优先搜索、数学、动态规划
- 难度：中等

## 题目链接

- [0279. 完全平方数 - 力扣](https://leetcode.cn/problems/perfect-squares/)

## 题目大意

**描述**：给定一个正整数 $n$。从中找到若干个完全平方数（比如 $1, 4, 9, 16 …$），使得它们的和等于 $n$。

**要求**：返回和为 $n$ 的完全平方数的最小数量。

**说明**：

- $1 \le n \le 10^4$。

**示例**：

- 示例 1：

```python
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

- 示例 2：

```python
输入：n = 13
输出：2
解释：13 = 4 + 9
```

## 解题思路

暴力枚举思路：对于小于 $n$ 的完全平方数，直接暴力枚举所有可能的组合，并且找到平方数个数最小的一个。

并且对于所有小于 $n$ 的完全平方数（$k = 1, 4, 9, 16, ...$），存在公式：$ans(n) = min(ans(n - k) + 1), k = 1, 4, 9, 16 ...$

即： **n 的完全平方数的最小数量 == n - k 的完全平方数的最小数量 + 1**。

我们可以使用递归解决这个问题。但是因为重复计算了中间解，会产生堆栈溢出。

那怎么解决重复计算问题和避免堆栈溢出？

我们可以转换一下思维。

1. 将 $n$ 作为根节点，构建一棵多叉数。
2. 从 $n$ 节点出发，如果一个小于 $n$ 的数刚好与 $n$ 相差一个平方数，则以该数为值构造一个节点，与 $n$ 相连。

那么求解和为 $n$ 的完全平方数的最小数量就变成了求解这棵树从根节点 $n$ 到节点 $0$ 的最短路径，或者说树的最小深度。

这个过程可以通过广度优先搜索来做。

### 思路 1：广度优先搜索

1. 定义 $visited$ 为标记访问节点的 set 集合变量，避免重复计算。定义 $queue$ 为存放节点的队列。使用 $count$ 表示为树的最小深度，也就是和为 $n$ 的完全平方数的最小数量。
2. 首先，我们将 $n$ 标记为已访问，即 `visited.add(n)`。并将其加入队列 $queue$ 中，即 `queue.append(n)`。
3. 令 $count$ 加 $1$，表示最小深度加 $1$。然后依次将队列中的节点值取出。
4. 对于取出的节点值 $value$，遍历可能出现的平方数（即遍历 $[1, \sqrt{value} + 1]$ 中的数）。
5. 每次从当前节点值减去一个平方数，并将减完的数加入队列。
   1. 如果此时的数等于 $0$，则满足题意，返回当前树的最小深度。
   2. 如果此时的数不等于 $0$，则将其加入队列，继续查找。

### 思路 1：代码

```python
class Solution:
    def numSquares(self, n: int) -> int:
        if n == 0:
            return 0
        
        visited = set()
        queue = collections.deque([])
        
        visited.add(n)
        queue.append(n)
        
        count = 0
        while queue:
            // 最少步数
            count += 1
            size = len(queue)
            for _ in range(size):
                value = queue.pop()
                for i in range(1, int(math.sqrt(value)) + 1):
                    x = value - i * i
                    if x == 0:
                        return count
                    if x not in visited:
                        queue.appendleft(x)
                        visited.add(x)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \sqrt{n})$。
- **空间复杂度**：$O(n)$。

### 思路 2：动态规划

我们可以将这道题转换为「完全背包问题」中恰好装满背包的方案数问题。

1. 将 $k = 1, 4, 9, 16, ...$  看做是 $k$ 种物品，每种物品都可以无限次使用。
2. 将 $n$ 看做是背包的装载上限。
3. 这道题就变成了，从 $k$ 种物品中选择一些物品，装入装载上限为 $n$ 的背包中，恰好装满背包最少需要多少件物品。

###### 1. 划分阶段

按照当前背包的载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：从完全平方数中挑选一些数，使其和恰好凑成 $w$ ，最少需要多少个完全平方数。

###### 3. 状态转移方程

$dp[w] = min \lbrace dp[w], dp[w - num] + 1$

###### 4. 初始条件

- 恰好凑成和为 $0$，最少需要 $0$ 个完全平方数。
- 默认情况下，在不使用完全平方数时，都不能恰好凑成和为 $w$ ，此时将状态值设置为一个极大值（比如 $n + 1$），表示无法凑成。

###### 5. 最终结果

根据我们之前定义的状态，$dp[w]$ 表示为：将物品装入装载上限为 $w$ 的背包中，恰好装满背包，最少需要多少件物品。 所以最终结果为 $dp[n]$。

1. 如果 $dp[n] \ne n + 1$，则说明：$dp[n]$ 为装入装载上限为 $n$ 的背包，恰好装满背包，最少需要的物品数量，则返回 $dp[n]$。
2. 如果 $dp[n] = n + 1$，则说明：无法恰好装满背包，则返回 $-1$。因为 $n$ 肯定能由 $n$ 个 $1$ 组成，所以这种情况并不会出现。

### 思路 2：代码

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [n + 1 for _ in range(n + 1)]
        dp[0] = 0

        for i in range(1, int(sqrt(n)) + 1):
            num = i * i
            for w in range(num, n + 1):
                dp[w] = min(dp[w], dp[w - num] + 1)

        if dp[n] != n + 1:
            return dp[n]
        return -1
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \sqrt{n})$。
- **空间复杂度**：$O(n)$。
# [0283. 移动零](https://leetcode.cn/problems/move-zeroes/)

- 标签：数组、双指针
- 难度：简单

## 题目链接

- [0283. 移动零 - 力扣](https://leetcode.cn/problems/move-zeroes/)

## 题目大意

**描述**：给定一个数组 $nums$。

**要求**：将所有 $0$ 移动到末尾，并保持原有的非 $0$ 数字的相对顺序。

**说明**：

- 只能在原数组上进行操作。
- $1 \le nums.length \le 10^4$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

- 示例 2：

```python
输入: nums = [0]
输出: [0]
```

## 解题思路

### 思路 1：冒泡排序（超时）

冒泡排序的思想，就是通过相邻元素的比较与交换，使得较大元素从前面移到后面。

我们可以借用冒泡排序的思想，将值为 $0$ 的元素移动到数组末尾。

因为数据规模为 $10^4$，而冒泡排序的时间复杂度为 $O(n^2)$。所以这种做法会导致超时。

### 思路 1：代码

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for i in range(len(nums)):
            for j in range(len(nums) - i - 1):
                if nums[j] == 0 and nums[j + 1] != 0:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：快慢指针

1. 使用两个指针 $slow$，$fast$。$slow$ 指向处理好的非 $0$ 数字数组的尾部，$fast$ 指针指向当前待处理元素。
2. 不断向右移动 $fast$ 指针，每次移动到非零数，则将左右指针对应的数交换，交换同时将 $slow$ 右移。
3. 此时，$slow$ 指针左侧均为处理好的非零数，而从 $slow$ 指针指向的位置开始， $fast$ 指针左边为止都为 $0$。

遍历结束之后，则所有 $0$ 都移动到了右侧，且保持了非零数的相对位置。

### 思路 2：代码

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        fast = 0
        while fast < len(nums):
            if nums[fast] != 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
            fast += 1
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0285. 二叉搜索树中的中序后继 - 力扣](https://leetcode.cn/problems/inorder-successor-in-bst/)

## 题目大意

给定一棵二叉搜索树的根节点 `root`。

要求：按中序遍历顺序将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

## 解题思路

可以分为两步：

1. 中序遍历二叉搜索树，将节点先存储到列表中。
2. 将列表中的节点构造成一棵递增顺序搜索树。

中序遍历直接按照 `左 -> 根 -> 右` 的顺序递归遍历，然后将遍历的节点存储到 `res` 中。

构造递增顺序搜索树，则用 `head` 保存头节点位置。遍历列表中的每个节点，将其左右指针先置空，再将其连接在上一个节点的右子节点上。

最后返回 `head.right` 即可。

## 代码

```python
class Solution:
    def inOrder(self, root, res):
        if not root:
            return
        self.inOrder(root.left, res)
        res.append(root)
        self.inOrder(root.right, res)

    def increasingBST(self, root: TreeNode) -> TreeNode:
        res = []
        self.inOrder(root, res)

        if not res:
            return
        head = TreeNode(-1)
        cur = head
        for node in res:
            node.left = node.right = None
            cur.right = node
            cur = cur.right
        return head.right
```

# [0286. 墙与门](https://leetcode.cn/problems/walls-and-gates/)

- 标签：广度优先搜索、数组、矩阵
- 难度：中等

## 题目链接

- [0286. 墙与门 - 力扣](https://leetcode.cn/problems/walls-and-gates/)

## 题目大意

给定一个 `m * n` 的二维网络 `rooms`。其中每个元素有三种初始值：

- `-1` 表示墙或者障碍物
- `0` 表示一扇门
- `INF` 表示为一个空的房间。这里用 $2^{31} = 2147483647$ 表示 `INF`。通往门的距离总是小于 $2^{31}$。

要求：给每个空房间填上该房间到最近的门的距离，如果无法到达门，则填 `INF`。

## 解题思路

从每个表示门开始，使用广度优先搜索去照门。因为广度优先搜索保证我们在搜索 `dist + 1` 距离的位置时，距离为 `dist` 的位置都已经搜索过了。所以每到达一个房间的时候一定是最短距离。

## 代码

```python
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        INF = 2147483647
        rows = len(rooms)
        if rows == 0:
            return
        cols = len(rooms[0])

        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        queue = []
        for i in range(rows):
            for j in range(cols):
                if rooms[i][j] == 0:
                    queue.append((i, j, 0))

        while queue:
            i, j, dist = queue.pop(0)
            for direction in directions:
                new_i = i + direction[0]
                new_j = j + direction[1]
                if 0 <= new_i < rows and 0 <= new_j < cols and rooms[new_i][new_j] == INF:
                    rooms[new_i][new_j] = dist + 1
                    queue.append((new_i, new_j, dist + 1))
```

# [0287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

- 标签：位运算、数组、双指针、二分查找
- 难度：中等

## 题目链接

- [0287. 寻找重复数 - 力扣](https://leetcode.cn/problems/find-the-duplicate-number/)

## 题目大意

**描述**：给定一个包含 $n + 1$ 个整数的数组 $nums$，里边包含的值都在 $1 \sim n$ 之间。可知至少存在一个重复的整数。

**要求**：假设 $nums$ 中只存在一个重复的整数，要求找出这个重复的数。

**说明**：

- $1 \le n \le 10^5$。
- $nums.length == n + 1$。
- $1 \le nums[i] \le n$。
- 要求使用空间复杂度为常数级 $O(1)$，时间复杂度小于 $O(n^2)$ 的解决方法。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,4,2,2]
输出：2
```

- 示例 2：

```python
输入：nums = [3,1,3,4,2]
输出：3
```

## 解题思路

### 思路 1：二分查找

利用二分查找的思想。

1. 使用两个指针 $left$，$right$。$left$ 指向 $1$，$right$ 指向 $n$。
2. 将区间 $[1, n]$ 分为 $[left, mid]$ 和 $[mid + 1, right]$。
3. 对于中间数 $mid$，统计 $nums$ 中小于等于 $mid$ 的数个数 $cnt$。
4. 如果 $cnt \le mid$，则重复数一定不会出现在左侧区间，那么从右侧区间开始搜索。
5. 如果 $cut > mid$，则重复数出现在左侧区间，则从左侧区间开始搜索。

### 思路 1：代码

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        left = 1
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1

            if cnt <= mid:
                left = mid + 1
            else:
                right = mid

        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

# [0288. 单词的唯一缩写](https://leetcode.cn/problems/unique-word-abbreviation/)

- 标签：设计、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [0288. 单词的唯一缩写 - 力扣](https://leetcode.cn/problems/unique-word-abbreviation/)

## 题目大意

单词缩写规则：<起始字母><中间字母><结尾字母>。如果单词长度不超过 2，则单词本身就是缩写。

举例：

- `dog --> d1g`：第一个字母`d`，最后一个字母 `g`，中间隔着 1 个字母。
- `internationalization --> i18n`：第一个字母 `i` ，最后一个字母 `n`，中间隔着 18 个字母。
- `it --> it`：单词只有两个字符，它就是它自身的缩写。

要求实现 ValidWordAbbr 类：

- `ValidWordAbbr(dictionary: List[str]):`使用单词字典初始化对象
- `def isUnique(self, word: str) -> bool:`
  - 如果字典 dictionary 中没有其他单词的缩写与该单词 word 的缩写相同，返回 True。
  - 如果字典 dictionary 中所有与该单词 word 的缩写相同的单词缩写都与 word 相同。

## 解题思路

将相同缩写的单词进行分类，利用哈希表进行存储。键值对格式为 缩写：该缩写对应的 word 列表。

然后初始化的时候，将 dictionary 里的单词按照缩写进行哈希表存储。

在判断的时候，先判断单词 word 的缩写是否能在哈希表中找到对应的映射关系。

- 如果 word 的缩写 abbr 没有在哈希表中，则返回 True。
- 如果 word 的缩写 abbr 在哈希表中：
  - 如果缩写 abbr 对应的字符串列表只有一个字符串，并且就是 word，则返回 True。Ï
  - 否则返回 False。
- 不满足上述要求也返回 False。

## 代码

```python
    def isUnique(self, word: str) -> bool:
        if len(word) <= 2:
            abbr = word
        else:
            abbr = word[0] + chr(len(word)-2) + word[-1]
        if abbr not in self.abbr_dict:
            return True
        if len(set(self.abbr_dict[abbr])) == 1 and word in set(self.abbr_dict[abbr]):
            return True
        return False
```

# [0289. 生命游戏](https://leetcode.cn/problems/game-of-life/)

- 标签：数组、矩阵、模拟
- 难度：中等

## 题目链接

- [0289. 生命游戏 - 力扣](https://leetcode.cn/problems/game-of-life/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的二维数组 $board$，每一个格子都可以看做是一个细胞。每个细胞都有一个初始状态：$1$ 代表活细胞，$0$ 代表死细胞。每个细胞与其相邻的八个位置（水平、垂直、对角线）细胞遵循以下生存规律：

- 如果活细胞周围八个位置的活细胞数少于 $2$ 个，则该位置活细胞死亡；
- 如果活细胞周围八个位置有 $2$ 个或 $3$ 个活细胞，则该位置活细胞仍然存活；
- 如果活细胞周围八个位置有超过 $3$ 个活细胞，则该位置活细胞死亡；
- 如果死细胞周围正好有 $3$ 个活细胞，则该位置死细胞复活。

二维数组代表的下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的的。其中细胞的出生和死亡是同时发生的。

现在给定 $m \times n$ 的二维数组 $board$ 的当前状态。

**要求**：返回下一个状态。

**说明**：

- $m == board.length$。
- $n == board[i].length$。
- $1 \le m, n \le 25$。
- $board[i][j]$ 为 $0$ 或 $1$。
- **进阶**：
  - 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
  - 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？


**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)

```python
输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)

```python
输入：board = [[1,1],[1,0]]
输出：[[1,1],[1,1]]
```

## 解题思路

### 思路 1：模拟

因为下一个状态隐含了过去细胞的状态，所以不能直接在原二维数组上直接进行修改。细胞的状态总共有四种情况：

- 死细胞 -> 死细胞，即 $0 \rightarrow 0$。
- 死细胞 -> 活细胞，即 $0 \rightarrow 1$。
- 活细胞 -> 活细胞，即 $1 \rightarrow 1$。
- 活细胞 -> 死细胞，即 $1 \rightarrow 0$。

死细胞 -> 死细胞，活细胞 -> 活细胞，不会对前后状态造成影响，所以主要考虑另外两种情况。我们把活细胞 -> 死细胞暂时标记为 $-1$，并且统计每个细胞周围活细胞数量时，使用绝对值统计，这样 $abs(-1)$ 也可以暂时标记为活细胞。然后把死细胞 -> 活细胞暂时标记为 $2$，这样判断的时候也不会统计上去。然后开始遍历。

- 遍历二维数组的每一个位置。并对该位置遍历周围八个位置，计算出八个位置上的活细胞数量。
  - 如果此位置是活细胞，并且周围活细胞少于 $2$ 个或超过 $3$ 个，则将其暂时标记为 $-1$，意为此细胞死亡。
  - 如果此位置是死细胞，并且周围有 $3$ 个活细胞，则将暂时标记为 $2$，意为此细胞复活。
- 遍历完之后，再次遍历一遍二维数组，如果该位置为 $-1$，将其赋值为 $0$，如果该位置为 $2$，将其赋值为 $1$。

### 思路 1：代码

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        directions = {(1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1)}

        rows = len(board)
        cols = len(board[0])

        for row in range(rows):
            for col in range(cols):
                lives = 0
                for direction in directions:
                    new_row = row + direction[0]
                    new_col = col + direction[1]

                    if 0 <= new_row < rows and 0 <= new_col < cols and abs(board[new_row][new_col]) == 1:
                        lives += 1
                if board[row][col] == 1 and (lives < 2 or lives > 3):
                    board[row][col] = -1
                if board[row][col] == 0 and lives == 3:
                    board[row][col] = 2

        for row in range(rows):
            for col in range(cols):
                if board[row][col] == -1:
                    board[row][col] = 0
                elif board[row][col] == 2:
                    board[row][col] = 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$、$n$ 分别为 $board$ 的行数和列数。
- **空间复杂度**：$O(m \times n)$。

# [0290. 单词规律](https://leetcode.cn/problems/word-pattern/)

- 标签：哈希表、字符串
- 难度：简单

## 题目链接

- [0290. 单词规律 - 力扣](https://leetcode.cn/problems/word-pattern/)

## 题目大意

给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否完全匹配相同的规律。

- 完全匹配相同的规律：pattern 的每个字母和字符串 str 中的每个非空单词之间存在这双向连接的对应规律。
- 比如：pattern = "abba", str = "dog cat cat dog"，其对应关系为：`a <=> dog，b <=> cat`

## 解题思路

这道题要求判断规律串中的字符与所给字符串中的非空单词，是否是一一对应的。即每个字符都能映射到对应的非空单词，每个非空单词也能映射为字符。

考虑使用两个哈希表，一个用来存储字符到非空单词的映射，另一个用来存储非空单词到字符的映射。

遍历 pattern 中的字符：

- 如果字符出现在第一个字典中，且字典中的值不等于对应的非空单词，则返回 False。
- 如果单词出现在第二个字典中，且字典中的值不等于对应的字符，则返回 False。

- 如果遍历完仍没发现不满足要求的情况，则返回 True。

## 代码

```python
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        pattern_dict = dict()
        word_dict = dict()
        words = s.split()

        if len(pattern) != len(words):
            return False

        for i in range(len(words)):
            p = pattern[i]
            word = words[i]
            if p in pattern_dict and pattern_dict[p] != word:
                return False
            if word in word_dict and word_dict[word] != p:
                return False
            pattern_dict[p] = word
            word_dict[word] = p
        return True
```

# [0292. Nim 游戏](https://leetcode.cn/problems/nim-game/)

- 标签：脑筋急转弯、数学、博弈
- 难度：简单

## 题目链接

- [0292. Nim 游戏 - 力扣](https://leetcode.cn/problems/nim-game/)

## 题目大意

两个人玩 Nim 游戏。游戏规则是这样的：

- 桌上有一堆石子，两个人轮流从石子堆中拿走 1~3 块石头。拿掉最后一块石头的人就是获胜者。

- 假如每个人都尽可能的想赢得比赛，所以每一轮都是最优解。

现在给定一个整数 n 代表石头数目。如果你作为先手，问最终能否赢得比赛。

## 解题思路

假设石子的数量为 1~3，那么我作为先手，肯定第一次就将所有的石子都拿完了，所以肯定能赢。

假设石子的数量为 4，那么我作为先手，无论第一次拿走 1、2、3 块石头，都不能拿完，而第二个人再拿的时候，会直接将剩下的石头一次性全拿走，所以肯定不会赢。

如果石子数量多于 4，那么我作为先手，为了赢，应该尽可能使得本轮拿走后的石子数为 4，这样对手拿完一次之后，自己肯定会获胜。

所以石子树为 5、6、7 块的时候，我可以通过分别拿走 1、2、3 块石头，使得剩下的石头数为 4，从而在下一轮获得胜利。

如果石子数为 8 块的时候，我无论怎么拿都不能使剩下石子为 4。而对方又会利用这个机会使得他拿走之后的石子数变为 4，从而使我失败。

所以，很显然：当 n 不是 4 的整数倍时，我一定赢得比赛。当 n 为 4 的整数倍时，我一定赢不了比赛。

## 代码

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
```

# [0295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

- 标签：设计、双指针、数据流、排序、堆（优先队列）
- 难度：困难

## 题目链接

- [0295. 数据流的中位数 - 力扣](https://leetcode.cn/problems/find-median-from-data-stream/)

## 题目大意

要求：设计一个支持一下两种操作的数组结构：

- `void addNum(int num)`：从数据流中添加一个整数到数据结构中。
- `double findMedian()`：返回目前所有元素的中位数。

## 解题思路

使用一个大顶堆 `queMax` 记录大于中位数的数，使用一个小顶堆 `queMin` 小于中位数的数。

- 当添加元素数量为偶数： `queMin` 和 `queMax` 中元素数量相同，则中位数为它们队头的平均值。
- 当添加元素数量为奇数：`queMin` 中的数比 `queMax` 多一个，此时中位数为 `queMin` 的队头。

为了满足上述条件，在进行 `addNum` 操作时，我们应当分情况处理：

- `num > max{queMin}`：此时 `num` 大于中位数，将该数添加到大顶堆 `queMax` 中。新的中位数将大于原来的中位数，所以可能需要将 `queMax` 中的最小数移动到 `queMin` 中。
- `num ≤ max{queMin}`：此时 `num` 小于中位数，将该数添加到小顶堆 `queMin` 中。新的中位数将小于等于原来的中位数，所以可能需要将 `queMin` 中最大数移动到 `queMax` 中。

## 代码

```python
import heapq

class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.queMin = list()
        self.queMax = list()


    def addNum(self, num: int) -> None:
        if not self.queMin or num < -self.queMin[0]:
            heapq.heappush(self.queMin, -num)
            if len(self.queMax) + 1 < len(self.queMin):
                heapq.heappush(self.queMax, -heapq.heappop(self.queMin))
        else:
            heapq.heappush(self.queMax, num)
            if len(self.queMax) > len(self.queMin):
                heapq.heappush(self.queMin, -heapq.heappop(self.queMax))


    def findMedian(self) -> float:
        if len(self.queMin) > len(self.queMax):
            return -self.queMin[0]
        return (-self.queMin[0] + self.queMax[0]) / 2
```

# [0297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、设计、字符串、二叉树
- 难度：困难

## 题目链接

- [0297. 二叉树的序列化与反序列化 - 力扣](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

## 题目大意

**要求**：设计一个算法，来实现二叉树的序列化与反序列化。

**说明**：

- 不限定序列化 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
- 树中结点数在范围 $[0, 10^4]$ 内。
- $-1000 \le Node.val \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```python
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

- 示例 2：

```python
输入：root = [1,2]
输出：[1,2]
```

## 解题思路

### 思路 1：深度优先搜索

#### 1. 序列化：将二叉树转为字符串数据表示

1. 按照前序顺序递归遍历二叉树，并将根节点跟左右子树的值链接起来（中间用 `,` 隔开）。

> 注意：如果遇到空节点，则将其标记为 `None`，这样在反序列化时才能唯一确定一棵二叉树。

#### 2. 反序列化：将字符串数据转为二叉树结构

1. 先将字符串按 `,` 分割成数组。然后递归处理每一个元素。
2. 从数组左侧取出一个元素。
   1. 如果当前元素为 `None`，则返回 `None`。
   2. 如果当前元素不为空，则新建一个二叉树节点作为根节点，保存值为当前元素值。并递归遍历左右子树，不断重复从数组中取出元素，进行判断。
3. 最后返回当前根节点。

### 思路 1：代码

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return 'None'
        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        def dfs(datalist):
            val = datalist.pop(0)
            if val == 'None':
                return None
            root = TreeNode(int(val))
            root.left = dfs(datalist)
            root.right = dfs(datalist)
            return root

        datalist = data.split(',')
        return dfs(datalist)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉树的节点数。
- **空间复杂度**：$O(n)$。

# [0300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

- 标签：数组、二分查找、动态规划
- 难度：中等

## 题目链接

- [0300. 最长递增子序列 - 力扣](https://leetcode.cn/problems/longest-increasing-subsequence/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：找到其中最长严格递增子序列的长度。

**说明**：

- **子序列**：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，$[3,6,2,7]$ 是数组 $[0,3,1,6,2,2,7]$ 的子序列。
- $1 \le nums.length \le 2500$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

- 示例 2：

```python
输入：nums = [0,1,0,3,2,3]
输出：4
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照子序列的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。

###### 3. 状态转移方程

一个较小的数后边如果出现一个较大的数，则会形成一个更长的递增子序列。

对于满足 $0 \le j < i$ 的数组元素 $nums[j]$ 和 $nums[i]$ 来说：

- 如果 $nums[j] < nums[i]$，则 $nums[i]$ 可以接在 $nums[j]$ 后面，此时以 $nums[i]$ 结尾的最长递增子序列长度会在「以 $nums[j]$ 结尾的最长递增子序列长度」的基础上加 $1$，即 $dp[i] = dp[j] + 1$。

- 如果 $nums[j] \le nums[i]$，则 $nums[i]$ 不可以接在 $nums[j]$ 后面，可以直接跳过。

综上，我们的状态转移方程为：$dp[i] = max(dp[i], dp[j] + 1), 0 \le j < i, nums[j] < nums[i]$。

###### 4. 初始条件

默认状态下，把数组中的每个元素都作为长度为 $1$ 的递增子序列。即 $dp[i] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。那为了计算出最大的最长递增子序列长度，则需要再遍历一遍 $dp$ 数组，求出最大值即为最终结果。

### 思路 1：动态规划代码

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [1 for _ in range(size)]

        for i in range(size):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
        return max(dp)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，最后求最大值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

# [0303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

- 标签：设计、数组、前缀和
- 难度：简单

## 题目链接

- [0303. 区域和检索 - 数组不可变 - 力扣](https://leetcode.cn/problems/range-sum-query-immutable/)

## 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：实现 `NumArray` 类，该类能处理区间为 `[left, right]` 之间的区间求和的多次查询。

`NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象。
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 总和 ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]`）。

**说明**：

- $1 \le nums.length \le 10^4$。
- $-10^5 \le nums[i] \le 10^5$。
- $0 \le left \le right < nums.length$。
- `sumRange` 方法调用次数不超过 $10^4$ 次。

**示例**：

- 示例 1：

```python
给定    nums = [-2, 0, 3, -5, 2, -1]

求和    sumRange(0, 2) -> 1
求和    sumRange(2, 5) -> -1
求和    sumRange(0, 5) -> -3
```

## 解题思路

### 思路 1：线段树

- 根据 `nums` 数组，构建一棵线段树。每个线段树的节点类存储当前区间的左右边界和该区间的和。

这样构建线段树的时间复杂度为 $O(\log n)$，单次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(\log n)$。

### 思路 1 线段树代码：

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
        
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
    
    
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    
    # 单点更新实现方法：将 nums[i] 更改为 val。节点的存储下标为 index，节点的区间为 [left, right]
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == right:
            self.tree[index].val = val              # 叶子节点，节点值修改为 val
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
        
    
    # 区间查询实现方法：在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)


class NumArray:

    def __init__(self, nums: List[int]):
        self.STree = SegmentTree(nums, lambda x, y: x + y)


    def sumRange(self, left: int, right: int) -> int:
        return self.STree.query_interval(left, right)
```
# [0304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

- 标签：设计、数组、矩阵、前缀和
- 难度：中等

## 题目链接

- [0304. 二维区域和检索 - 矩阵不可变 - 力扣](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

## 题目大意

给定一个二维矩阵 `matrix`。

要求：满足以下多个请求：

- ` def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:`计算以 `(row1, col1)` 为左上角、`(row2, col2)` 为右下角的子矩阵中各个元素的和。
- `def __init__(self, matrix: List[List[int]]):` 对二维矩阵 `matrix` 进行初始化操作。

## 解题思路

在进行初始化的时候做预处理，这样在多次查询时可以减少重复计算，也可以减少时间复杂度。

在进行初始化的时候，使用一个二维数组 `pre_sum` 记录下以 `(0, 0)` 为左上角，以当前 `(row, col)` 为右下角的子数组各个元素和，即 `pre_sum[row + 1][col + 1]`。

则在查询时，以 `(row1, col1)` 为左上角、`(row2, col2)` 为右下角的子矩阵中各个元素的和就等于以 `(0, 0)` 到 `(row2, col2)` 的大子矩阵减去左边 `(0, 0)` 到 `(row2, col1 - 1)`的子矩阵，再减去上边 `(0, 0)` 到 `(row1 - 1, col2)` 的子矩阵，再加上左上角 `(0, 0)` 到 `(row1 - 1, col1 - 1)` 的子矩阵（因为之前重复减了）。即 `pre_sum[row2 + 1][col2 + 1] - self.pre_sum[row2 + 1][col1] - self.pre_sum[row1][col2 + 1] + self.pre_sum[row1][col1]`。

## 代码

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        rows = len(matrix)
        cols = len(matrix[0])
        self.pre_sum = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]
        for row in range(rows):
            for col in range(cols):
                self.pre_sum[row + 1][col + 1] = self.pre_sum[row + 1][col] + self.pre_sum[row][col + 1] - self.pre_sum[row][col] + matrix[row][col]


    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.pre_sum[row2 + 1][col2 + 1] - self.pre_sum[row2 + 1][col1] - self.pre_sum[row1][col2 + 1] + self.pre_sum[row1][col1]
```

# [0307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

- 标签：设计、树状数组、线段树、数组
- 难度：中等

## 题目链接

- [0307. 区域和检索 - 数组可修改 - 力扣](https://leetcode.cn/problems/range-sum-query-mutable/)

## 题目大意

**描述**：给定一个数组 `nums`。

**要求**：

1. 完成两类查询：
   1. 要求将数组元素 `nums[index]` 的值更新为 `val`。
   2. 要求返回数组 `nums` 中区间 `[left, right]` 之间（包含 `left`、`right`）的 `nums` 元素的和。其中 $left \le right$。
2. 实现 `NumArray` 类：
   1. `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象。
   2. `void update(int index, int val)` 将 `nums[index]` 的值更新为 `val`。
   3. `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ 包含 ）的 `nums` 元素的和（即 `nums[left] + nums[left + 1], ..., nums[right]`）。

**说明**：

- $1 \le nums.length \le 3 * 10^4$。
- $-100 \le nums[i] \le 100$。
- $0 <= index < num.length$。
- $0 \le left \le right < nums.length$。
- 调用 `update` 和 `sumRange` 的方法次数不大于 $3 * 10^4$ 次。

**示例**：

- 示例 1：

```
给定    nums = [1, 3, 5]

求和    sumRange(0, 2) -> 9  
更新    update(1, 2)  
求和    sumRange(0, 2) -> 8  
```

## 解题思路

### 思路 1：线段树

根据 `nums` 数组，构建一棵线段树。每个线段树的节点类存储当前区间的左右边界和该区间的和。

这样构建线段树的时间复杂度为 $O(\log n)$，每次单点更新的时间复杂度为 $O(\log n)$，每次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(\log n)$。

### 思路 1 线段树代码：

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
        
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
    
    
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    
    # 单点更新实现方法：将 nums[i] 更改为 val。节点的存储下标为 index，节点的区间为 [left, right]
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == right:
            self.tree[index].val = val              # 叶子节点，节点值修改为 val
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
        
    
    # 区间查询实现方法：在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)

class NumArray:

    def __init__(self, nums: List[int]):
        self.STree = SegmentTree(nums, lambda x, y: x + y)


    def update(self, index: int, val: int) -> None:
        self.STree.update_point(index, val)


    def sumRange(self, left: int, right: int) -> int:
        return self.STree.query_interval(left, right)
```

# [0309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0309. 最佳买卖股票时机含冷冻期 - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## 题目大意

给定一个整数数组，其中第 `i` 个元素代表了第 `i` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票（即冷冻期为 `1` 天）。

## 解题思路

这道题是「[0122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)」的升级版。

冷冻期的意思是：如果昨天卖出了，那么今天不能买。在考虑的时候只要判断一下前一天是不是刚卖出。

对于每一天结束时的状态总共有以下几种：

- 买入状态：
  - 今日买入
  - 之前买入，之后一直持有无操作
- 卖出状态：
  - 今日买出，正处于冷冻期
  - 昨天卖出，今天结束后度过了冷冻期
  - 之前卖出，度过了冷冻期后无操作

在买入状态中，今日买入和之前买入的状态其实可以看做是股票的持有状态，可以将其合并为一种状态。

在卖出状态中，昨天卖出和之前卖出的状态其实可以看做是无股票并度过了冷冻期状态，可以将其合并为一种状态。

这样总结下来可以划分为三个状态：

- 股票的持有状态。
- 无股票，并且处于冷冻期状态。
- 无股票，并且不处于冷冻期状态。

所以我们可以定义状态 `dp[i][j]` ，表示为：第 `i` 天第 `j` 种情况（`0 <= j <= 2`）下，所获取的最大利润。

注意：这里第第 `j` 种情况，

接下来确定状态转移公式：

- 第 `0` 种状态（股票的持有状态）下可以有两种状态推出，取最大的那一种赋值：
  - 昨天就已经持有的：`dp[i][0] = dp[i - 1][0]`：
  - 今天刚买入的（则昨天不能持有股票也不能处于冷冻期，应来自于前天卖出状态）：`dp[i][0] = dp[i - 1][2] - prices[i]`
- 第 `1` 种状态（无股票，并且处于冷冻期状态）下可以有一种状态推出：
  - 今天卖出：`dp[i] = dp[i - 1][0] + prices[i]`
- 第 `2` 种状态（无股票，并且不处于冷冻期状态）下可以有两种状态推出，取最大的那一种赋值：
  - 昨天卖出：`dp[i] = dp[i - 1][1]`
  - 之前卖出：`dp[i] = dp[i - 1][2]`

下面确定初始化的边界值：

可以很明显看出第一天不做任何操作就是 `dp[0][0] = 0`，第一次买入就是 `dp[0][1] = -prices[i]`。

第一次卖出的话，可以视作为没有盈利（当天买卖，价格没有变化），即 `dp[0][2] = 0`。第二次买入的话，就是 `dp[0][3] = -prices[i]`。同理第二次卖出就是 `dp[0][4] = 0`。

在递推结束后，最大利润肯定是无操作、第一次卖出、第二次卖出这三种情况里边，且为最大值。我们在维护的时候维护的是最大值，则第一次卖出、第二次卖出所获得的利润肯定大于等于 0。而且，如果最优情况为一笔交易，那么在转移状态时，我们允许在一天内进行两次交易，则一笔交易的状态可以转移至两笔交易。所以最终答案为 `dp[size - 1][4]`。`size` 为股票天数。

## 代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size == 0:
            return 0
        dp = [[0 for _ in range(4)] for _ in range(size)]

        dp[0][0] = -prices[0]
        for i in range(1, size):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i])
            dp[i][1] = dp[i - 1][0] + prices[i]
            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2])
        return max(dp[size - 1][0], dp[size - 1][1], dp[size - 1][2])
```

# [0310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [0310. 最小高度树 - 力扣](https://leetcode.cn/problems/minimum-height-trees/)

## 题目大意

**描述**：有一棵包含 $n$ 个节点的树，节点编号为 $0 \sim n - 1$。给定一个数字 $n$ 和一个有 $n - 1$ 条无向边的 $edges$ 列表来表示这棵树。其中 $edges[i] = [ai, bi]$ 表示树中节点 $ai$ 和 $bi$ 之间存在一条无向边。

可以选择树中的任何一个节点作为根，当选择节点 $x$ 作为根节点时，设结果树的高度为 $h$。在所有可能的树种，具有最小高度的树（即 $min(h)$）被成为最小高度树。

**要求**：找到所有的最小高度树并按照任意顺序返回他们的根节点编号列表。

**说明**：

- **树的高度**：指根节点和叶子节点之间最长向下路径上边的数量。
- $1 \le n \le 2 * 10^4$。
- $edges.length == n - 1$。
- $0 \le ai, bi < n$。
- $ai \ne bi$。
- 所有 $(ai, bi)$ 互不相同。
- 给定的输入保证是一棵树，并且不会有重复的边。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)

```python
输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)

```python
输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
```

## 解题思路

### 思路 1：树形 DP + 二次遍历换根法

最容易想到的做法是：枚举 $n$ 个节点，以每个节点为根节点，然后进行深度优先搜索，求出每棵树的高度。最后求出所有树中的最小高度即为答案。但这种做法的时间复杂度为 $O(n^2)$，而 $n$ 的范围为 $[1, 2 * 10^4]$，这样做会导致超时，因此需要进行优化。

在上面的算法中，在一轮深度优先搜索中，除了可以得到整棵树的高度之外，在搜索过程中，其实还能得到以每个子节点为根节点的树的高度。如果我们能够利用这些子树的高度信息，快速得到以其他节点为根节点的树的高度，那么我们就能改进算法，以更小的时间复杂度解决这道题。这就是二次遍历与换根法的思想。

1. 第一次遍历：自底向上的计算出每个节点 $u$ 向下走（即由父节点 $u$ 向子节点 $v$ 走）的最长路径 $down1[u]$、次长路径 $down2[i]$，并记录向下走最长路径所经过的子节点 $p[u]$，方便第二次遍历时计算。
2. 第二次遍历：自顶向下的计算出每个节点 $v$ 向上走（即由子节点 $v$ 向父节点 $u$ 走）的最长路径 $up[v]$。需要注意判断 $u$ 向下走的最长路径是否经过了节点 $v$。
   1. 如果经过了节点 $v$，则向上走的最长路径，取决于「父节点 $u$ 向上走的最长路径」与「父节点 $u$ 向下走的次长路径」 的较大值，再加上 $1$。
   2. 如果没有经过节点 $v$，则向上走的最长路径，取决于「父节点 $u$ 向上走的最长路径」与「父节点 $u$ 向下走的最长路径」 的较大值，再加上 $1$。
3. 接下来，我们通过枚举 $n$​ 个节点向上走的最长路径与向下走的最长路径，从而找出所有树中的最小高度，并将所有最小高度树的根节点放入答案数组中并返回。

整个算法具体步骤如下：

1. 使用邻接表的形式存储树。
3. 定义第一个递归函数 `dfs(u, fa)` 用于计算每个节点向下走的最长路径 $down1[u]$、次长路径 $down2[u]$，并记录向下走的最长路径所经过的子节点 $p[u]$。
   1. 对当前节点的相邻节点进行遍历。
   2. 如果相邻节点是父节点，则跳过。
   3. 递归调用 `dfs(v, u)` 函数计算邻居节点的信息。
   4. 根据邻居节点的信息计算当前节点的高度，并更新当前节点向下走的最长路径 $down1[u]$、当前节点向下走的次长路径 $down2$、取得最长路径的子节点 $p[u]$。
4. 定义第二个递归函数 `reroot(u, fa)` 用于计算每个节点作为新的根节点时向上走的最长路径 $up[v]$。
   1. 对当前节点的相邻节点进行遍历。
   2. 如果相邻节点是父节点，则跳过。
   3. 根据当前节点 $u$ 的高度和相邻节点 $v$ 的信息更新 $up[v]$。同时需要判断节点 $u$ 向下走的最长路径是否经过了节点 $v$。
      1. 如果经过了节点 $v$，则向上走的最长路径，取决于「父节点 $u$ 向上走的最长路径」与「父节点 $u$ 向下走的次长路径」 的较大值，再加上 $1$，即：$up[v] = max(up[u], down2[u]) + 1$。
      2. 如果没有经过节点 $v$，则向上走的最长路径，取决于「父节点 $u$ 向上走的最长路径」与「父节点 $u$ 向下走的最长路径」 的较大值，再加上 $1$，即：$up[v] = max(up[u], down1[u]) + 1$。
   4. 递归调用 `reroot(v, u)` 函数计算邻居节点的信息。
5. 调用 `dfs(0, -1)` 函数计算每个节点的最长路径。
6. 调用 `reroot(0, -1)` 函数计算每个节点作为新的根节点时的最长路径。
7. 找到所有树中的最小高度。
8. 将所有最小高度的节点放入答案数组中并返回。

### 思路 1：代码

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
		
        # down1 用于记录向下走的最长路径 
        down1 = [0 for _ in range(n)]
        # down2 用于记录向下走的最长路径
        down2 = [0 for _ in range(n)]
        p = [0 for _ in range(n)]
        # 自底向上记录最长路径、次长路径
        def dfs(u, fa):
            for v in graph[u]:
                if v == fa:
                    continue
                # 自底向上统计信息
                dfs(v, u)                   
                height = down1[v] + 1
                if height >= down1[u]:
                    down2[u] = down1[u]
                    down1[u] = height
                    p[u] = v
                elif height > down2[u]:
                    down2[u] = height

        # 进行换根动态规划，自顶向下统计向上走的最长路径
        up = [0 for _ in range(n)]
        def reroot(u, fa):
            for v in graph[u]:
                if v == fa:
                    continue
                if p[u] == v:
                    up[v] = max(up[u], down2[u]) + 1
                else:
                    up[v] = max(up[u], down1[u]) + 1
                # 自顶向下统计信息
                reroot(v, u)                            

        dfs(0, -1)
        reroot(0, -1)

        # 找到所有树中的最小高度
        min_h = 1e9
        for i in range(n):
            min_h = min(min_h, max(down1[i], up[i]))

        # 将所有最小高度的节点放入答案数组中并返回
        res = []
        for i in range(n):
            if max(down1[i], up[i]) == min_h:
                res.append(i)

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[C++ 容易理解的换根动态规划解法 - 最小高度树](https://leetcode.cn/problems/minimum-height-trees/solution/c-huan-gen-by-vclip-sa84/)
- 【题解】[310. 最小高度树 - 最小高度树 - 力扣](https://leetcode.cn/problems/minimum-height-trees/solution/310-zui-xiao-gao-du-shu-by-vincent-40-teg8/)
- 【题解】[310. 最小高度树 - 最小高度树 - 力扣](https://leetcode.cn/problems/minimum-height-trees/solution/310-zui-xiao-gao-du-shu-by-vincent-40-teg8/)
# [0312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [0312. 戳气球 - 力扣](https://leetcode.cn/problems/burst-balloons/)

## 题目大意

**描述**：有 $n$ 个气球，编号为 $0 \sim n - 1$，每个气球上都有一个数字，这些数字存在数组 $nums$ 中。现在开始戳破气球。其中戳破第 $i$ 个气球，可以获得 $nums[i - 1] \times nums[i] \times nums[i + 1]$ 枚硬币，这里的 $i - 1$ 和 $i + 1$ 代表和 $i$ 相邻的两个气球的编号。如果 $i - 1$ 或 $i + 1$ 超出了数组的边界，那么就当它是一个数字为 $1$ 的气球。

**要求**：求出能获得硬币的最大数量。

**说明**：

- $n == nums.length$。
- $1 \le n \le 300$。
- $0 \le nums[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

- 示例 2：

```python
输入：nums = [1,5]
输出：10
解释：
nums = [1,5] --> [5] --> []
coins = 1*1*5 +  1*5*1 = 10
```

## 解题思路

### 思路 1：动态规划

根据题意，如果 $i - 1$ 或 $i + 1$ 超出了数组的边界，那么就当它是一个数字为 $1$ 的气球。我们可以预先在 $nums$ 的首尾位置，添加两个数字为 $1$ 的虚拟气球，这样变成了 $n + 2$ 个气球，气球对应编号也变为了 $0 \sim n + 1$。

对应问题也变成了：给定 $n + 2$ 个气球，每个气球上有 $1$ 个数字，代表气球上的硬币数量，当我们戳破气球 $nums[i]$ 时，就能得到对应 $nums[i - 1] \times nums[i] \times nums[i + 1]$ 枚硬币。现在要戳破 $0 \sim n + 1$ 之间的所有气球（不包括编号 $0$ 和编号 $n + 1$ 的气球），请问最多能获得多少枚硬币？

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：戳破所有气球 $i$ 与气球 $j$ 之间的气球（不包含气球 $i$ 和 气球 $j$），所能获取的最多硬币数。

###### 3. 状态转移方程

假设气球 $i$ 与气球 $j$ 之间最后一个被戳破的气球编号为 $k$。则 $dp[i][j]$ 取决于由 $k$ 作为分割点分割出的两个区间 $(i, k)$ 与 

$(k, j)$ 上所能获取的最多硬币数 + 戳破气球 $k$ 所能获得的硬币数，即状态转移方程为：

$dp[i][j] = max \lbrace dp[i][k] + dp[k][j] + nums[i] \times nums[k] \times nums[j] \rbrace, \quad i < k < j$

###### 4. 初始条件

- $dp[i][j]$ 表示的是开区间，则 $i < j - 1$。而当 $i \ge j - 1$ 时，所能获得的硬币数为 $0$，即 $dp[i][j] = 0, \quad i \ge j - 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：戳破所有气球 $i$ 与气球 $j$ 之间的气球（不包含气球 $i$ 和 气球 $j$），所能获取的最多硬币数。。所以最终结果为 $dp[0][n + 1]$。

### 思路 1：代码

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        size = len(nums)
        arr = [0 for _ in range(size + 2)]
        arr[0] = arr[size + 1] = 1
        for i in range(1, size + 1):
            arr[i] = nums[i - 1]
        
        dp = [[0 for _ in range(size + 2)] for _ in range(size + 2)]

        for l in range(3, size + 3):
            for i in range(0, size + 2):
                j = i + l - 1
                if j >= size + 2:
                    break
                for k in range(i + 1, j):
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[j] * arr[k])
        
        return dp[0][size + 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为气球数量。
- **空间复杂度**：$O(n^2)$。
# [0315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

- 标签：树状数组、线段树、数组、二分查找、分治、有序集合、归并排序
- 难度：困难

## 题目链接

- [0315. 计算右侧小于当前元素的个数 - 力扣](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 。

**要求**：返回一个新数组 $counts$ 。其中 $counts[i]$ 的值是 $nums[i]$ 右侧小于 $nums[i]$ 的元素的数量。

**说明**：

- $1 \le nums.length \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```

- 示例 2：

```python
输入：nums = [-1]
输出：[0]
```

## 解题思路

### 思路 1：归并排序

在使用归并排序对数组进行排序时，每当遇到 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i] \le right\underline{\hspace{0.5em}}nums[right\underline{\hspace{0.5em}}i]$ 时，意味着：在合并前，左子数组当前元素 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 右侧一定有 $left\underline{\hspace{0.5em}}i$ 个元素比 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 小。则我们可以在归并排序的同时，记录 $nums[i]$ 右侧小于 $nums[i]$ 的元素的数量。

1. 将元素值、对应下标、右侧小于 nums[i] 的元素的数量存入数组中。
2. 对其进行归并排序。
3. 当遇到 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i] \le right\underline{\hspace{0.5em}}nums[right\underline{\hspace{0.5em}}i]$ 时，记录 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 右侧比 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 小的元素数量，即：`left_nums[left_i][2] += right_i`。
4. 当合并时 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 仍有剩余时，说明 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 右侧有 $right\underline{\hspace{0.5em}}i$ 个小于 $left\underline{\hspace{0.5em}}nums[left\underline{\hspace{0.5em}}i]$ 的元素，记录下来，即：`left_nums[left_i][2] += right_i`。
5. 根据下标及右侧小于 $nums[i]$ 的元素的数量，组合出答案数组，并返回答案数组。

### 思路 1：代码

```python
class Solution:
    # 合并过程
    def merge(self, left_nums, right_nums):
        nums = []
        left_i, right_i = 0, 0
        while left_i < len(left_nums) and right_i < len(right_nums):
            # 将两个有序子数组中较小元素依次插入到结果数组中
            if left_nums[left_i] <= right_nums[right_i]:
                nums.append(left_nums[left_i])
                # left_nums[left_i] 右侧有 right_i 个比 left_nums[left_i] 小的
                left_nums[left_i][2] += right_i
                left_i += 1
            else:
                nums.append(right_nums[right_i])
                right_i += 1
        
        # 如果左子数组有剩余元素，则将其插入到结果数组中
        while left_i < len(left_nums):
            nums.append(left_nums[left_i])
            # left_nums[left_i] 右侧有 right_i 个比 left_nums[left_i] 小的
            left_nums[left_i][2] += right_i
            left_i += 1
        
        # 如果右子数组有剩余元素，则将其插入到结果数组中
        while right_i < len(right_nums):
            nums.append(right_nums[right_i])
            right_i += 1
        
        # 返回合并后的结果数组
        return nums

    # 分解过程
    def mergeSort(self, nums) :
        # 数组元素个数小于等于 1 时，直接返回原数组
        if len(nums) <= 1:
            return nums
        
        mid = len(nums) // 2                        # 将数组从中间位置分为左右两个数组
        left_nums = self.mergeSort(nums[0: mid])    # 递归将左子数组进行分解和排序
        right_nums =  self.mergeSort(nums[mid:])    # 递归将右子数组进行分解和排序
        return self.merge(left_nums, right_nums)    # 把当前数组组中有序子数组逐层向上，进行两两合并
        

    def countSmaller(self, nums: List[int]) -> List[int]:
        size = len(nums)

        # 将元素值、对应下标、右侧小于 nums[i] 的元素的数量存入数组中
        nums = [[num, i, 0] for i, num in enumerate(nums)]
        nums = self.mergeSort(nums)
        ans = [0 for _ in range(size)]

        for num in nums:
            ans[num[1]] = num[2]
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：树状数组

1. 首先对数组进行离散化处理。把原始数组中的数据映射到 $[0, len(nums) - 1]$ 这个区间。
2. 然后逆序顺序从数组 $nums$ 中遍历元素 $nums[i]$。
   1. 计算其离散化后的排名 $index$，查询比 $index$ 小的数有多少个。将其记录到答案数组的对应位置 $ans[i]$ 上。
   2. 然后在树状数组下标为 $index$ 的位置上，更新值为 $1$。
3. 遍历完所有元素，最后输出答案数组 $ans$ 即可。

### 思路 2：代码

```python
import bisect

class BinaryIndexTree:

    def __init__(self, n):
        self.size = n
        self.tree = [0 for _ in range(n + 1)]

    def lowbit(self, index):
        return index & (-index)

    def update(self, index, delta):
        while index <= self.size:
            self.tree[index] += delta
            index += self.lowbit(index)

    def query(self, index):
        res = 0
        while index > 0:
            res += self.tree[index]
            index -= self.lowbit(index)
        return res

class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        size = len(nums)
        if size == 0:
            return []
        if size == 1:
            return [0]

        # 离散化
        sort_nums = list(set(nums))
        sort_nums.sort()
        size_s = len(sort_nums)
        bit = BinaryIndexTree(size_s)

        ans = [0 for _ in range(size)]
        for i in range(size - 1, -1, -1):
            index = bisect.bisect_left(sort_nums, nums[i]) + 1
            ans[i] = bit.query(index - 1)
            bit.update(index, 1)

        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

# [0316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

- 标签：栈、贪心、字符串、单调栈
- 难度：中等

## 题目链接

- [0316. 去除重复字母 - 力扣](https://leetcode.cn/problems/remove-duplicate-letters/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：去除字符串中重复的字母，使得每个字母只出现一次。需要保证 **「返回结果的字典序最小（要求不能打乱其他字符的相对位置）」**。

**说明**：

- $1 \le s.length \le 10^4$。
- `s` 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "bcabc"
输出："abc"
```

- 示例 2：

```python
输入：s = "cbacdcbc"
输出："acdb"
```

## 解题思路

### 思路 1：哈希表 + 单调栈

针对题目的三个要求：去重、不能打乱其他字符顺序、字典序最小。我们来一一分析。

1. **去重**：可以通过 **「使用哈希表存储字母出现次数」** 的方式，将每个字母出现的次数统计起来，再遍历一遍，去除重复的字母。
2. **不能打乱其他字符顺序**：按顺序遍历，将非重复的字母存储到答案数组或者栈中，最后再拼接起来，就能保证不打乱其他字符顺序。
3. **字典序最小**：意味着字典序小的字母应该尽可能放在前面。
   1. 对于第 `i` 个字符 `s[i]` 而言，如果第 `0` ~ `i - 1` 之间的某个字符 `s[j]` 在 `s[i]` 之后不再出现了，那么 `s[j]` 必须放到 `s[i]` 之前。
   2. 而如果 `s[j]` 在之后还会出现，并且 `s[j]` 的字典序大于 `s[i]`，我们则可以先舍弃 `s[j]`，把 `s[i]` 尽可能的放到前面。后边再考虑使用 `s[j]` 所对应的字符。


要满足第 3 条需求，我们可以使用 **「单调栈」** 来解决。我们使用单调栈存储 `s[i]` 之前出现的非重复、并且字典序最小的字符序列。整个算法步骤如下：

1. 先遍历一遍字符串，用哈希表 `letter_counts` 统计出每个字母出现的次数。
2. 然后使用单调递减栈保存当前字符之前出现的非重复、并且字典序最小的字符序列。
3. 当遍历到 `s[i]` 时，如果 `s[i]` 没有在栈中出现过：
   1. 比较 `s[i]` 和栈顶元素 `stack[-1]` 的字典序。如果 `s[i]` 的字典序小于栈顶元素 `stack[-1]`，并且栈顶元素之后的出现次数大于 `0`，则将栈顶元素弹出。
   2. 然后继续判断 `s[i]` 和栈顶元素 `stack[-1]`，并且知道栈顶元素出现次数为 `0` 时停止弹出。此时将 `s[i]` 添加到单调栈中。
4. 从哈希表 `letter_counts` 中减去 `s[i]` 出现的次数，继续遍历。
5. 最后将单调栈中的字符依次拼接为答案字符串，并返回。

### 思路 1：代码

```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        letter_counts = dict()
        for ch in s:
            if ch in letter_counts:
                letter_counts[ch] += 1
            else:
                letter_counts[ch] = 1

        for ch in s:
            if ch not in stack:
                while stack and ch < stack[-1] and stack[-1] in letter_counts and letter_counts[stack[-1]] > 0:
                    stack.pop()
                stack.append(ch)
            letter_counts[ch] -= 1

        return ''.join(stack)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(|\sum|)$，其中 $\sum$ 为字符集合，$|\sum|$ 为字符种类个数。由于栈中字符不能重复，因此栈中最多有 $|\sum|$ 个字符。

## 参考资料

- 【题解】[去除重复数组 - 去除重复字母 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-shu-zu-by-lu-shi-zhe-sokp/)
# [0318. 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/)

- 标签：位运算、数组、字符串
- 难度：中等

## 题目链接

- [0318. 最大单词长度乘积 - 力扣](https://leetcode.cn/problems/maximum-product-of-word-lengths/)

## 题目大意

给定一个字符串数组 `words`。字符串中只包含英语的小写字母。

要求：计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。如果没有不包含相同字符的一对字符串，返回 0。

## 解题思路

这道题的核心难点是判断任意两个字符串之间是否包含相同字符。最直接的做法是先遍历第一个字符串的每个字符，再遍历第二个字符串查看是否有相同字符。但是这样做的话，时间复杂度过高。考虑怎么样可以优化一下。

题目中说字符串中只包含英语的小写字母，也就是 `26` 种字符。一个 `32` 位的 `int` 整数每一个二进制位都可以表示一种字符的有无，那么我们就可以通过一个整数来表示一个字符串中所拥有的字符种类。延伸一下，我们可以用一个整数数组来表示一个字符串数组中，每个字符串所拥有的字符种类。

接下来事情就简单了，两重循环遍历整数数组，遇到两个字符串不包含相同字符的情况，就计算一下他们长度的乘积，并维护一个乘积最大值。最后输出最大值即可。

## 代码

```python
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        size = len(words)
        arr = [0 for _ in range(size)]
        for i in range(size):
            word = words[i]
            len_word = len(word)
            for j in range(len_word):
                arr[i] |= 1 << (ord(word[j]) - ord('a'))
        ans = 0
        for i in range(size):
            for j in range(i + 1, size):
                if arr[i] & arr[j] == 0:
                    k = len(words[i]) * len(words[j])
                    ans = k if ans < k else ans
        return ans
```

# [0322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

- 标签：广度优先搜索、数组、动态规划
- 难度：中等

## 题目链接

- [0322. 零钱兑换 - 力扣](https://leetcode.cn/problems/coin-change/)

## 题目大意

**描述**：给定代表不同面额的硬币数组 $coins$ 和一个总金额 $amount$。

**要求**：求出凑成总金额所需的最少的硬币个数。如果无法凑出，则返回 $-1$。

**说明**：

- $1 \le coins.length \le 12$。
- $1 \le coins[i] \le 2^{31} - 1$。
- $0 \le amount \le 10^4$。

**示例**：

- 示例 1：

```python
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

- 示例 2：

```python
输入：coins = [2], amount = 3
输出：-1
```

## 解题思路

### 思路 1：广度优先搜索

我们可以从 $amount$ 开始，每次从 $coins$ 的硬币中选中 $1$ 枚硬币，并记录当前挑选硬币的次数。则最快减到 $0$ 的次数就是凑成总金额所需的最少的硬币个数。这道题就变成了从 $amount$ 减到 $0$ 的最短路径问题。我们可以用广度优先搜索的方法来做。

1. 定义 $visited$ 为标记已访问值的集合变量，$queue$ 为存放值的队列。
2. 将 $amount$ 状态标记为访问，并将其加入队列 $queue$。
3. 令当前步数加 $1$，然后将当前队列中的所有值依次出队，并遍历硬币数组：
   1. 如果当前值等于当前硬币值，则说明当前硬币刚好能凑成当前值，则直接返回当前次数。
   2. 如果当前值大于当前硬币值，并且当前值减去当前硬币值的差值没有出现在已访问集合 $visited$ 中，则将差值添加到队列和访问集合中。

4. 重复执行第 $3$ 步，直到队列为空。
5. 如果队列为空，也未能减到 $0$，则返回 $-1$。

### 思路 1：代码

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        
        visited = set([amount])
        queue = collections.deque([amount])

        step = 0
        while queue:
            step += 1
            size = len(queue)
            for _ in range(size):
                cur = queue.popleft()
                for coin in coins:
                    if cur == coin:
                        step += 1
                        return step
                    elif cur > coin and cur - coin not in visited:
                        queue.append(cur - coin)
                        visited.add(cur - coin)
            
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(amount \times size)$。其中 $amount$ 表示总金额，$size$ 表示硬币的种类数。
- **空间复杂度**：$O(amount)$。

### 思路 2：完全背包问题

这道题可以转换为：有 $n$ 种不同的硬币，$coins[i]$ 表示第 $i$ 种硬币的面额，每种硬币可以无限次使用。请问恰好凑成总金额为 $amount$ 的背包，最少需要多少硬币？

与普通完全背包问题不同的是，这里求解的是最少硬币数量。我们可以改变一下「状态定义」和「状态转移方程」。

###### 1. 划分阶段

按照当前背包的载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[c]$ 表示为：凑成总金额为 $c$ 的最少硬币数量。

###### 3. 状态转移方程

$dp[c] = \begin{cases} dp[c] & c < coins[i - 1] \cr min \lbrace dp[c], dp[c - coins[i - 1]]  + 1 \rbrace & c \ge coins[i - 1] \end{cases}$

1. 当 $c < coins[i - 1]$ 时：
   1. 不使用第 $i - 1$ 枚硬币，只使用前 $i - 1$ 枚硬币凑成金额 $w$ 的最少硬币数量，即 $dp[c]$。
2. 当 $c \ge coins[i - 1]$ 时，取下面两种情况中的较小值：
   1. 不使用第 $i - 1$ 枚硬币，只使用前 $i - 1$ 枚硬币凑成金额 $w$ 的最少硬币数量，即 $dp[c]$。
   2. 凑成金额 $c - coins[i - 1]$ 的最少硬币数量，再加上当前硬币的数量 $1$，即 $dp[c - coins[i - 1]]  + 1$。

###### 4. 初始条件

- 凑成总金额为 $0$ 的最少硬币数量为 $0$，即 $dp[0] = 0$。
- 默认情况下，在不使用硬币时，都不能恰好凑成总金额为 $w$ ，此时将状态值设置为一个极大值（比如 $n + 1$），表示无法凑成。

###### 5. 最终结果

根据我们之前定义的状态，$dp[c]$ 表示为：凑成总金额为 $c$ 的最少硬币数量。则最终结果为 $dp[amount]$。

1. 如果 $dp[amount] \ne amount + 1$，则说明： $dp[amount]$ 为凑成金额 $amount$ 的最少硬币数量，则返回 $dp[amount]$。
2. 如果 $dp[amount] = amount + 1$，则说明：无法凑成金额 $amount$，则返回 $-1$。

### 思路 2：代码

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        size = len(coins)
        dp = [(amount + 1) for _ in range(amount + 1)]
        dp[0] = 0

        # 枚举前 i 种物品
        for i in range(1, size + 1):
            # 正序枚举背包装载重量
            for c in range(coins[i - 1], amount + 1):
                dp[c] = min(dp[c], dp[c - coins[i - 1]] + 1)
        
        if dp[amount] != amount + 1:
            return dp[amount]
        return -1
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(amount \times size)$。其中 $amount$ 表示总金额，$size$ 表示硬币的种类数。
- **空间复杂度**：$O(amount)$。# [0323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0323. 无向图中连通分量的数目 - 力扣](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)

## 题目大意

**描述**：给定 `n` 个节点（编号从 `0` 到 `n - 1`）的图的无向边列表 `edges`，其中 `edges[i] = [u, v]` 表示节点 `u` 和节点 `v` 之间有一条无向边。

**要求**：计算该无向图中连通分量的数量。

**说明**：

- $1 \le n \le 2000$。
- $1 \le edges.length \le 5000$。
- $edges[i].length == 2$。
- $0 \le ai \le bi < n$。
- $ai != bi$。
- `edges` 中不会出现重复的边。

**示例**：

- 示例 1：

```python
输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]
 0          3
 |          |
 1 --- 2    4 
输出: 2
```

- 示例 2：

```python
输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]
 0           4
 |           |
 1 --- 2 --- 3
输出:  1
```

## 解题思路

先来看一下图论中相关的名次解释。

- **连通图**：在无向图中，如果可以从顶点 $v_i$ 到达 $v_j$，则称 $v_i$ 和 $v_j$ 连通。如果图中任意两个顶点之间都连通，则称该图为连通图。
- **无向图的连通分量**：如果该图为连通图，则连通分量为本身；否则将无向图中的极大连通子图称为连通分量，每个连通分量都是一个连通图。
- **无向图的连通分量个数**：无向图的极大连通子图的个数。

接下来我们来解决这道题。

### 思路 1：深度优先搜索

1. 使用 `visited` 数组标记遍历过的节点，使用 `count` 记录连通分量数量。
2. 从未遍历过的节点 `u` 出发，连通分量数量加 1。然后遍历与 `u` 节点构成无向边，且为遍历过的的节点 `v`。
3. 再从 `v` 出发继续深度遍历。
4. 直到遍历完与`u`  直接相关、间接相关的节点之后，再遍历另一个未遍历过的节点，继续上述操作。
5. 最后输出连通分量数目。

### 思路 1：代码

```python
class Solution:
    def dfs(self, visited, i, graph):
        visited[i] = True
        for j in graph[i]:
            if not visited[j]:
                self.dfs(visited, j, graph)

    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        count = 0
        visited = [False for _ in range(n)]
        graph = [[] for _ in range(n)]

        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)

        for i in range(n):
            if not visited[i]:
                count += 1
                self.dfs(visited, i, graph)
        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中$n$ 是顶点个数。
- **空间复杂度**：$O(n)$。

### 思路 2：广度优先搜索

1. 使用变量 `count` 记录连通分量个数。使用集合变量 `visited` 记录访问过的节点，使用邻接表 `graph` 记录图结构。
2. 从 `0` 开始，依次遍历 `n` 个节点。
3. 如果第 `i` 个节点未访问过：
   1. 将其添加到 `visited` 中。
   2. 并且连通分量个数累加，即 `count += 1`。
   3. 定义一个队列 `queue`，将第 `i` 个节点加入到队列中。
   4. 从队列中取出第一个节点，遍历与其链接的节点，并将未遍历过的节点加入到队列 `queue` 和 `visited` 中。
   5. 直到队列为空，则继续向后遍历。
4. 最后输出连通分量数目 `count`。

### 思路 2：代码

```python
import collections

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        count = 0
        visited = set()
        graph = [[] for _ in range(n)]

        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)

        for i in range(n):
            if i not in visited:
                visited.add(i)
                count += 1
                queue = collections.deque([i])
                while queue:
                    node_u = queue.popleft()
                    for node_v in graph[node_u]:
                        if node_v not in visited:
                            visited.add(node_v)
                            queue.append(node_v)
        return count
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。其中$n$ 是顶点个数。
- **空间复杂度**：$O(n)$。
# [0324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)

- 标签：数组、分治、快速选择、排序
- 难度：中等

## 题目链接

- [0324. 摆动排序 II - 力扣](https://leetcode.cn/problems/wiggle-sort-ii/)

## 题目大意

给你一个整数数组 `nums`。

要求：将它重新排列成 `nums[0] < nums[1] > nums[2] < nums[3] ...` 的顺序。可以假设所有输入数组都可以得到满足题目要求的结果。

注意：

- $1 \le nums.length \le 5 * 10^4$。
- $0 \le nums[i] \le 5000$。

## 解题思路

`num[i]` 的取值在 `[0, 5000]`。所以我们可以用桶排序算法将排序算法的时间复杂度降到 $O(n)$。然后按照下标的奇偶性遍历两次数组，第一次遍历将桶中的元素从末尾到头部依次放到对应奇数位置上。第二次遍历将桶中剩余元素从末尾到头部依次放到对应偶数位置上。

## 代码

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        buckets = [0 for _ in range(5010)]
        for num in nums:
            buckets[num] += 1

        size = len(nums)
        big = size - 2 if (size & 1) == 1 else size - 1
        small = size - 1 if (size & 1) == 1 else size - 2

        index = 5000
        for i in range(1, big + 1, 2):
            while buckets[index] == 0:
                index -= 1
            nums[i] = index
            buckets[index] -= 1
        for i in range(0, small + 1, 2):
            while buckets[index] == 0:
                index -= 1
            nums[i] = index
            buckets[index] -= 1
```

# [0326. 3 的幂](https://leetcode.cn/problems/power-of-three/)

- 标签：递归、数学
- 难度：简单

## 题目链接

- [0326. 3 的幂 - 力扣](https://leetcode.cn/problems/power-of-three/)

## 题目大意

给定一个整数 n，判断 n 是否是 3 的幂次方。$-2^{31} \le n \le 2^{31}-1$

## 解题思路

首先排除负数，因为 3 的幂次方不可能为负数。

因为 n 的最大值为 $2^{31}-1$。计算出在 n 的范围内，3 的幂次方最大为 $3^{19} = 1162261467$。

3 为质数，则 $3^{19}$ 的除数只有 $3^0, 3^1, …, 3^{19}$。所以若 n 为 3 的幂次方，则 n 肯定能被 $3^{19}$ 整除，直接判断即可。

## 代码

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        if (3 ** 19) % n == 0:
            return True
        return False
```

# [0328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

- 标签：链表
- 难度：中等

## 题目链接

- [0328. 奇偶链表 - 力扣](https://leetcode.cn/problems/odd-even-linked-list/)

## 题目大意

**描述**：给定一个单链表的头节点 `head`。

**要求**：将链表中的奇数位置上的节点排在前面，偶数位置上的节点排在后面，返回新的链表节点。

**说明**：

- 要求空间复杂度为 $O(1)$。
- $n$ 等于链表中的节点数。
- $0 \le n \le 10^4$。
- $-10^6 \le Node.val \le 10^6$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)

```python
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)

```python
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```

## 解题思路

### 思路 1：拆分后合并

1. 使用两个指针 `odd`、`even` 分别表示奇数节点链表和偶数节点链表。
2. 先将奇数位置上的节点和偶数位置上的节点分成两个链表，再将偶数节点的链表接到奇数链表末尾。
3. 过程中需要使用几个必要指针用于保留必要位置（比如原链表初始位置、偶数链表初始位置、当前遍历节点位置）。

### 思路 1：代码

```python
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next or not head.next.next:
            return head

        evenHead = head.next
        odd, even = head, evenHead
        isOdd = True

        curr = head.next.next

        while curr:
            if isOdd:
                odd.next = curr
                odd = curr
            else:
                even.next = curr
                even = curr
            isOdd = not isOdd
            curr = curr.next
        odd.next = evenHead
        even.next = None
        return head
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序、记忆化搜索、数组、动态规划、矩阵
- 难度：困难

## 题目链接

- [0329. 矩阵中的最长递增路径 - 力扣](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

## 题目大意

给定一个 `m * n` 大小的整数矩阵 `matrix`。要求：找出其中最长递增路径的长度。

对于每个单元格，可以往上、下、左、右四个方向移动，不能向对角线方向移动或移动到边界外。

## 解题思路

深度优先搜索。使用二维数组 `record` 存储遍历过的单元格最大路径长度，已经遍历过的单元格就不需要再次遍历了。

## 代码

```python
class Solution:
    max_len = 0
    directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        rows, cols = len(matrix), len(matrix[0])
        record = [[0 for _ in range(cols)] for _ in range(rows)]

        def dfs(i, j):
            record[i][j] = 1
            for direction in self.directions:
                new_i, new_j = i + direction[0], j + direction[1]
                if 0 <= new_i < rows and 0 <= new_j < cols and matrix[new_i][new_j] > matrix[i][j]:
                    if record[new_i][new_j] == 0:
                        dfs(new_i, new_j)
                    record[i][j] = max(record[i][j], record[new_i][new_j] + 1)
            self.max_len = max(self.max_len, record[i][j])

        for i in range(rows):
            for j in range(cols):
                if record[i][j] == 0:
                    dfs(i, j)
        return self.max_len
```

# [0334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

- 标签：贪心、数组
- 难度：中等

## 题目链接

- [0334. 递增的三元子序列 - 力扣](https://leetcode.cn/problems/increasing-triplet-subsequence/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：判断数组中是否存在长度为 3 的递增子序列。

**说明**：

- 要求算法时间复杂度为 $O(n)$、空间复杂度为 $O(1)$。
- **长度为 $3$ 的递增子序列**：存在这样的三元组下标 ($i$, $j$, $k$) 且满足 $i < j < k$ ，使得 $nums[i] < nums[j] < nums[k]$。
- $1 \le nums.length \le 5 \times 10^5$。
- $-2^{31} \le nums[i] \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意
```

- 示例 2：

```python
输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
```

## 解题思路

### 思路 1：快慢指针

常规方法是三重 `for` 循环遍历三个数，但是时间复杂度为 $O(n^3)$，肯定会超时的。

那么如何才能只进行一次遍历，就找到长度为 3 的递增子序列呢？

假设长度为 3 的递增子序列元素为 $a$、$b$、$c$，$a < b < c$。

先来考虑 $a$ 和 $b$。如果我们要使得一个数组  $i < j$，并且 $nums[i] < nums[j]$。那么应该使得 $a$ 尽可能的小，这样子我们下一个数字 $b$ 才可以尽可能地满足条件。

同样对于 $b$ 和 $c$，也应该使得 $b$ 尽可能的小，下一个数字 $c$ 才可以尽可能的满足条件。

所以，我们的目的是：在 $a < b$ 的前提下，保证 a 尽可能小。在 $b < c$ 的条件下，保证 $b$ 尽可能小。

我们可以使用两个数 $a$、$b$ 指向无穷大。遍历数组：

- 如果当前数字小于等于 $a$ ，则更新 `a = num`；
- 如果当前数字大于等于 $a$，则说明当前数满足 $num > a$，则判断：
  - 如果 $num \le b$，则更新 `b = num`；
  - 如果 $num > b$，则说明找到了长度为 3 的递增子序列，直接输出 $True$。
- 如果遍历完仍未找到，则输出 $False$。

### 思路 1：代码

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        a = float('inf')
        b = float('inf')
        for num in nums:
            if num <= a:
                a = num
            elif num <= b:
                b = num
            else:
                return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0336. 回文对](https://leetcode.cn/problems/palindrome-pairs/)

- 标签：字典树、数组、哈希表、字符串
- 难度：困难

## 题目链接

- [0336. 回文对 - 力扣](https://leetcode.cn/problems/palindrome-pairs/)

## 题目大意

给定一组互不相同的单词列表 `words`。

要求：找出所有不同的索引对 `(i, j)`，使得列表中的两个单词 `words[i] + words[j]` ，可拼接成回文串。

## 解题思路

如果字符串 `words[i] + words[j]` 能构成一个回文串，把 `words[i]` 分成 `words_left[i]` 和 `words_right[i]` 两部分。即 `words[i] + words[j] = words_left[i] + words_right[i] + words[j]`。则：

- `words_right[i]` 本身是回文串，`words_left[i]` 和 `words[j]` 互为逆序。

同理，如果 `words[j] + word[i]` 能构成一个回文串，把 `word[i]` 分成 `words_left[i]` 和 `words_right[i]` 两部分。即 `words[j] + word[i] = words[j] + words_left[i] + words_right[i]`。则：

- `words_left[i]` 本身是回文串，`words[j]` 和 `words_right[i]` 互为逆序。

从上面的表述可以得知，`words[j]` 可以通过拆分 `words[i]` 之后逆序得出。

我们使用两重循环遍历。一重循环遍历单词列表 `words` 中的每一个单词 `words[i]`，二重循环遍历每个单词的拆分位置 `j`。然后将每一个单词 `words[i]` 拆分成 `words[i][0:j+1]` 和 `words[i][j+1:]`。然后分别判断 `words[i][0:j+1]` 的逆序和 `words[i][j+1:]` 的逆序是否在单词列表中，如果在单词列表中，则将「`words[i]` 和 `words[i][0:j+1]` 对应的索引」或者 「`words[i]` 和 `words[i][j+1:]` 对应的索引」插入到答案数组中。

至于判断 `words[i][0:j+1]` 的逆序和 `words[i][j+1:]` 的逆序是否在单词列表中，以及获取 `words[i][0:j+1]` 的逆序和 `words[i][j+1:]` 的逆序所对应单词的索引下标可以通过构建字典树的方式获取。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.index = -1


    def insert(self, word: str, index: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.index = index

    def search(self, word: str) -> int:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return -1
            cur = cur.children[ch]

        if cur is not None and cur.isEnd:
            return cur.index
        return -1

class Solution:
    def isPalindrome(self, word: str) -> bool:
        left, right = 0, len(word) - 1
        while left < right:
            if word[left] != word[right]:
                return False
            left += 1
            right -= 1
        return True

    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        trie_tree = Trie()
        size = len(words)
        for i in range(size):
            word = words[i]
            trie_tree.insert(word, i)

        res = []
        for i in range(size):
            word = words[i]
            for j in range(len(word)):
                if self.isPalindrome(word[:j+1]):
                    temp = word[j+1:][::-1]
                    index = trie_tree.search(temp)
                    if index != i and index != -1:
                        res.append([index, i])
                        if temp == "":
                            res.append([i, index])
                if self.isPalindrome(word[j+1:]):
                    temp = word[:j+1][::-1]
                    index = trie_tree.search(temp)
                    if index != i and index != -1:
                        res.append([i, index])
        return res
```

# [0337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

- 标签：树、深度优先搜索、动态规划、二叉树
- 难度：中等

## 题目链接

- [0337. 打家劫舍 III - 力扣](https://leetcode.cn/problems/house-robber-iii/)

## 题目大意

小偷发现了一个新的可行窃的地区，这个地区的形状是一棵二叉树。这个地区只有一个入口，称为「根」。除了「根」之外，每栋房子只有一个「父」房子与之相连。如果两个直接相连的房子在同一天被打劫，房屋将自动报警。

现在给定这个代表地区房间的二叉树，每个节点值代表该房间所拥有的金额。要求计算在不触动警报的情况下，小偷一晚上能盗取的最高金额。

## 解题思路

树形动态规划问题。

对于当前节点 `cur`，不能选择子节点，也不能选择父节点。所以对于一棵子树来说，有两种情况：

- 选择了根节点
- 没有选择根节点

### 1. 选择根节点

如果选择了根节点，则不能再选择左右儿子节点，这种情况下的最大值为：当前节点 + 左子树不选择根节点 + 右子树不选择根节点。

### 2. 不选择根节点

如果不选择根节点，则可以选择左右儿子节点，共四种可能：

- 左子树选择根节点 + 右子树选择根节点
- 左子树选择根节点 + 右子树不选根节点
- 左子树不选根节点 + 右子树选择根节点
- 左子树不选根节点 + 右子树不选根节点

选择其中最大值。

上述描述中，当前节点的选择来自于子节点信息的选择，然后逐层向上，直到根节点。所以我们使用「后序遍历」的方式进行递归遍历。

## 代码

```python
class Solution:
    def dfs(self, root: TreeNode):
        if not root:
            return [0, 0]
        left = self.dfs(root.left)
        right = self.dfs(root.right)

        val_steal = root.val + left[1] + right[1]
        val_no_steal = max(left[0], left[1]) + max(right[0], right[1])
        return [val_steal, val_no_steal]
    def rob(self, root: TreeNode) -> int:
        res = self.dfs(root)
        return max(res[0], res[1])
```

# [0338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

- 标签：位运算、动态规划
- 难度：简单

## 题目链接

- [0338. 比特位计数 - 力扣](https://leetcode.cn/problems/counting-bits/)

## 题目大意

**描述**：给定一个整数 `n`。

**要求**：对于 `0 ≤ i ≤ n` 的每一个 `i`，计算其二进制表示中 `1` 的个数，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**说明**：

- $0 \le n \le 10^5$。
- 使用线性时间复杂度 $O(n)$ 解决此问题。
- 不使用任何内置函数解决此问题。

**示例**：

- 示例 1：

```python
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

## 解题思路

### 思路 1：动态规划

根据整数的二进制特点可以将整数分为两类：

- 奇数：其二进制表示中 $1$ 的个数一定比前面相邻的偶数多一个 $1$。
- 偶数：其二进制表示中 $1$ 的个数一定与该数除以 $2$ 之后的数一样多。

另外，边界 $0$ 的二进制表示中 $1$ 的个数为 $0$。

于是可以根据规律，从 $0$ 开始到 $n$ 进行递推求解。

###### 1. 划分阶段

按照整数 $n$ 进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：整数 $i$ 对应二进制表示中 $1$ 的个数。

###### 3. 状态转移方程

- 如果 $i$ 为奇数，则整数 $i$ 对应二进制表示中 $1$ 的个数等于整数 $i - 1$ 对应二进制表示中 $1$ 的个数加 $1$，即 $dp[i] = dp[i - 1] + 1$。
- 如果 $i$ 为偶数，则整数 $i$ 对应二进制表示中 $1$ 的个数等于整数 $i // 2$ 对应二进制表示中 $1$ 的个数，即 $dp[i] = dp[i // 2]$。

###### 4. 初始条件

整数 $0$ 对应二进制表示中 $1$ 的个数为 $0$。

###### 5. 最终结果

整个 $dp$ 数组即为最终结果，将其返回即可。

### 思路 1：动态规划代码

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0 for _ in range(n + 1)]
        for i in range(1, n + 1):
            if i % 2 == 1:
                dp[i] = dp[i - 1] + 1
            else:
                dp[i] = dp[i // 2]
        return dp
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一位数组保存状态，所以总的时间复杂度为 $O(n)$。

# [0340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0340. 至多包含 K 个不同字符的最长子串 - 力扣](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)

## 题目大意

给定一个字符串 `s`，

要求：返回至多包含 `k` 个不同字符的最长子串 `t` 的长度。

## 解题思路

用滑动窗口 `window_counts` 来记录各个字符个数，`window_counts` 为哈希表类型。用 `ans` 来维护至多包含 `k` 个不同字符的最长子串 `t` 的长度。

设定两个指针：`left`、`right`，分别指向滑动窗口的左右边界，保证窗口中不超过 `k` 种字符。

- 一开始，`left`、`right` 都指向 `0`。
- 将最右侧字符 `s[right]` 加入当前窗口 `window_counts` 中，记录该字符个数，向右移动 `right`。
- 如果该窗口中字符的种数多于 `k` 个，即 `len(window_counts) > k`，则不断右移 `left`，缩小滑动窗口长度，并更新窗口中对应字符的个数，直到 `len(window_counts) <= k`。
- 维护更新至多包含 `k` 个不同字符的最长子串 `t` 的长度。然后继续右移 `right`，直到 `right >= len(nums)` 结束。
- 输出答案 `ans`。

## 代码

```python
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        ans = 0
        window_counts = dict()
        left, right = 0, 0

        while right < len(s):
            if s[right] in window_counts:
                window_counts[s[right]] += 1
            else:
                window_counts[s[right]] = 1

            while(len(window_counts) > k):
                window_counts[s[left]] -= 1
                if window_counts[s[left]] == 0:
                    del window_counts[s[left]]
                left += 1
            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

# [0341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/)

- 标签：栈、树、深度优先搜索、设计、队列、迭代器
- 难度：中等

## 题目链接

- [0341. 扁平化嵌套列表迭代器 - 力扣](https://leetcode.cn/problems/flatten-nested-list-iterator/)

## 题目大意

给定一个嵌套的整数列表 `nestedList` 。列表中元素类型为 NestedInteger 类。每个元素（NestedInteger 对象）要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。

NestedInteger 类提供了三个方法：

- `isInteger()`，判断当前存储的对象是否为 int；
- `getInteger()` ，如果当前存储的元素是 int 型的，那么返回当前的结果 int，否则调用会失败；
- `getList()`，如果当前存储的元素是 `List<NestedInteger>` 型的，那么返回该 List，否则调用会失败。

要求：实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。

实现扁平迭代器类 NestedIterator：

- `NestedIterator(List<NestedInteger> nestedList)` 用嵌套列表 `nestedList` 初始化迭代器。
- `int next()` 返回嵌套列表的下一个整数。
- `boolean hasNext()` 如果仍然存在待迭代的整数，返回 `True`；否则，返回 `False`。

## 解题思路

初始化时不对元素进行预处理。而是将所有的 `NestedInteger` 逆序放到栈中，当需要展开的时候才进行展开。

## 代码

```python
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.stack = []
        size = len(nestedList)
        for i in range(size - 1, -1, -1):
            self.stack.append(nestedList[i])
        
    
    def next(self) -> int:
        cur = self.stack.pop()
        return cur.getInteger()
        
    
    def hasNext(self) -> bool:
        while self.stack:
            cur = self.stack[-1]
            if cur.isInteger():
                return True
            self.stack.pop()
            for i in range(len(cur.getList()) - 1, -1, -1):
                self.stack.append(cur.getList()[i])
        return False
```

# [0342. 4的幂](https://leetcode.cn/problems/power-of-four/)

- 标签：位运算、递归、数学
- 难度：简单

## 题目链接

- [0342. 4的幂 - 力扣](https://leetcode.cn/problems/power-of-four/)

## 题目大意

给定一个整数 $n$，判断 $n$ 是否是 $4$ 的幂次方，如果是的话，返回 True。不是的话，返回 False。

## 解题思路

通过循环可以直接做。但有更好的方法。

$n$ 如果是 $4$ 的幂次方，那么 $n$ 肯定是 $2$ 的幂次方，$2$ 的幂次方二进制表示只含有一个 $1$，可以通过 $n \text{ \& } (n - 1)$ 将 $n$ 的最后位置上 的 $1$ 置为 $0$，通过判断 $n$ 是否满足 $n \text { \& } (n - 1) == 0$ 来判断 $n$ 是否是 $2$ 的幂次方。

若根据上述判断，得出 $n$ 是 $2$ 的幂次方，则可以写为：$n = x^{2k}$ 或者 $n = x^{2k+1}$。如果 $n$ 是 $4$ 的幂次方，则 $n = 2^{k}$。

下面来看一下  $2^{2x}$、$2^{2x}+1$ 的情况：

- $(2^{2x} \mod 3) = (4^x \mod 3) = ((3+1)^x \mod 3) == 1$
- $(2^{2x+1} \mod 3) = ((2 \times 4^x) \mod 3) = ((2 \times (3+1)^x) \mod 3) == 2$

则如果 $n \mod 3 == 1$，则 $n$ 为 $4$ 的幂次方。

## 代码

```python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n-1)) == 0 and (n-1) % 3 == 0
```

# [0343. 整数拆分](https://leetcode.cn/problems/integer-break/)

- 标签：数学、动态规划
- 难度：中等

## 题目链接

- [0343. 整数拆分 - 力扣](https://leetcode.cn/problems/integer-break/)

## 题目大意

**描述**：给定一个正整数 $n$，将其拆分为 $k (k \ge 2)$ 个正整数的和，并使这些整数的乘积最大化。

**要求**：返回可以获得的最大乘积。

**说明**：

- $2 \le n \le 58$。

**示例**：

- 示例 1：

```python
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

- 示例 2：

```python
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照正整数进行划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。

###### 3. 状态转移方程

当 $i \ge 2$ 时，假设正整数 $i$ 拆分出的第 $1$ 个正整数是 $j(1 \le j < i)$，则有两种方法：

1. 将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 不再拆分为多个正整数，此时乘积为：$j \times (i - j)$。
2. 将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 继续拆分为多个正整数，此时乘积为：$j \times dp[i - j]$。

则 $dp[i]$ 取两者中的最大值。即：$dp[i] = max(j \times (i - j), j \times dp[i - j])$。

由于 $1 \le j < i$，需要遍历 $j$ 得到 $dp[i]$ 的最大值，则状态转移方程如下：

$dp[i] = max_{1 \le j < i}\lbrace max(j \times (i - j), j \times dp[i - j]) \rbrace$。

###### 4. 初始条件

- $0$ 和 $1$ 都不能被拆分，所以 $dp[0] = 0, dp[1] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。则最终结果为 $dp[n]$。

### 思路 1：代码

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        for i in range(2, n + 1):
            for j in range(i):
                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)
        return dp[n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n)$。

# [0344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [0344. 反转字符串 - 力扣](https://leetcode.cn/problems/reverse-string/)

## 题目大意

**描述**：给定一个字符数组 $s$。

**要求**：将其反转。

**说明**：

- 不能使用额外的数组空间，必须原地修改输入数组、使用 $O(1)$ 的额外空间解决问题。
- $1 \le s.length \le 10^5$。
- $s[i]$ 都是 ASCII 码表中的可打印字符。

**示例**：

- 示例 1：

```python
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

- 示例 2：

```python
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

## 解题思路

### 思路 1：对撞指针

1. 使用两个指针 $left$，$right$。$left$ 指向字符数组开始位置，$right$ 指向字符数组结束位置。
2. 交换 $s[left]$ 和 $s[right]$，将 $left$ 右移、$right$ 左移。
3. 如果遇到 $left == right$，跳出循环。

### 思路 1：代码

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [0345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [0345. 反转字符串中的元音字母 - 力扣](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：将字符串中的元音字母进行反转。

**说明**：

- 元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现不止一次。
- $1 \le s.length \le 3 \times 10^5$。
- $s$ 由可打印的 ASCII 字符组成。

**示例**：

- 示例 1：

```python
输入：s = "hello"
输出："holle"
```

- 示例 2：

```python
输入：s = "leetcode"
输出："leotcede"
```

## 解题思路

### 思路 1：对撞指针

1. 因为 Python 的字符串是不可变的，所以我们先将字符串转为数组。
2. 使用两个指针 $left$，$right$。$left$ 指向字符串开始位置，$right$ 指向字符串结束位置。
3. 然后 $left$ 依次从左到右移动查找元音字母，$right$ 依次从右到左查找元音字母。
4. 如果都找到了元音字母，则交换字符，然后继续进行查找。
5. 如果遇到 $left == right$ 时停止。
6. 最后返回对应的字符串即可。

### 思路 1：代码

```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
        left = 0
        right = len(s)-1
        s_list = list(s)
        while left < right:
            if s_list[left] not in vowels:
                left += 1
                continue
            if s_list[right] not in vowels:
                right -= 1
                continue
            s_list[left], s_list[right] = s_list[right], s_list[left]
            left += 1
            right -= 1
        return "".join(s_list)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(1)$。# [0346. 数据流中的移动平均值](https://leetcode.cn/problems/moving-average-from-data-stream/)

- 标签：设计、队列、数组、数据流
- 难度：简单

## 题目链接

- [0346. 数据流中的移动平均值 - 力扣](https://leetcode.cn/problems/moving-average-from-data-stream/)

## 题目大意

给定一个整数 `val` 和一个窗口大小 `size`。

要求：根据滑动窗口的大小，计算滑动窗口里所有数字的平均值。要实现 `MovingAverage` 类：

- `MovingAverage(int size)` 用窗口大小 `size` 初始化对象。
- `double next(int val)` 成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。

## 解题思路

使用队列保存滑动窗口的元素，并记录对应窗口大小和元素和。

在小于窗口大小的时候，直接向队列中添加元素，并记录元素和。

在等于窗口大小的时候，先将队列头部元素弹出，再添加元素，并记录元素和。

然后根据元素和和队列中元素个数计算出平均值。

## 代码

```python
class MovingAverage:

    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.queue = []
        self.size = size
        self.sum = 0


    def next(self, val: int) -> float:
        if len(self.queue) < self.size:
            self.queue.append(val)
        else:
            if self.queue:
                self.sum -= self.queue[0]
                self.queue.pop(0)
            self.queue.append(val)
        self.sum += val
        return self.sum / len(self.queue)
```

# [0347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

- 标签：数组、哈希表、分治、桶排序、计数、快速选择、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0347. 前 K 个高频元素 - 力扣](https://leetcode.cn/problems/top-k-frequent-elements/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $k$。

**要求**：返回出现频率前 $k$ 高的元素。可以按任意顺序返回答案。

**说明**：

- $1 \le nums.length \le 10^5$。
- $k$ 的取值范围是 $[1, \text{ 数组中不相同的元素的个数}]$。
- 题目数据保证答案唯一，换句话说，数组中前 $k$ 个高频元素的集合是唯一的。

**示例**：

- 示例 1：

```python
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

- 示例 2：

```python
输入: nums = [1], k = 1
输出: [1]
```

## 解题思路

### 思路 1：哈希表 + 优先队列

1. 使用哈希表记录下数组中各个元素的频数。
2. 然后将哈希表中的元素去重，转换为新数组。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
3. 使用二叉堆构建优先队列，优先级为元素频数。此时堆顶元素即为频数最高的元素。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
4. 将堆顶元素加入到答案数组中，进行出队操作。时间复杂度 $O(log{n})$。
   - 出队操作：交换堆顶元素与末尾元素，将末尾元素已移出堆。继续调整大顶堆。
5. 不断重复第 4 步，直到 $k$ 次结束。调整 $k$ 次的时间复杂度 $O(n \times \log n)$。

### 思路 1：代码

```python
class Heapq:
    # 堆调整方法：调整为大顶堆
    def heapAdjust(self, nums: [int], nums_dict, index: int, end: int):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子结点
            max_index = index
            if nums_dict[nums[left]] > nums_dict[nums[max_index]]:
                max_index = left
            if right <= end and nums_dict[nums[right]] > nums_dict[nums[max_index]]:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            nums[index], nums[max_index] = nums[max_index], nums[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1
    
    # 将数组构建为二叉堆
    def heapify(self, nums: [int], nums_dict):
        size = len(nums)
        # (size - 2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((size - 2) // 2, -1, -1):
            # 调用调整堆函数
            self.heapAdjust(nums, nums_dict, i, size - 1)
    
    # 入队操作
    def heappush(self, nums: list, nums_dict, value):
        nums.append(value)
        size = len(nums)
        i = size - 1
        # 寻找插入位置
        while (i - 1) // 2 >= 0:
            cur_root = (i - 1) // 2
            # value 小于当前根节点，则插入到当前位置
            if nums_dict[nums[cur_root]] > nums_dict[value]:
                break
            # 继续向上查找
            nums[i] = nums[cur_root]
            i = cur_root
        # 找到插入位置或者到达根位置，将其插入
        nums[i] = value
                
    # 出队操作
    def heappop(self, nums: list, nums_dict) -> int:
        size = len(nums)
        nums[0], nums[-1] = nums[-1], nums[0]
        # 得到最大值（堆顶元素）然后调整堆
        top = nums.pop()
        if size > 0:
            self.heapAdjust(nums, nums_dict, 0, size - 2)
            
        return top

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 统计元素频数
        nums_dict = dict()
        for num in nums:
            if num in nums_dict:
                nums_dict[num] += 1
            else:
                nums_dict[num] = 1

        # 使用 set 方法去重，得到新数组
        new_nums = list(set(nums))
        size = len(new_nums)

        heap = Heapq()
        queue = []
        for num in new_nums:
            heap.heappush(queue, nums_dict, num)
        
        res = []
        for i in range(k):
            res.append(heap.heappop(queue, nums_dict))
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。# [0349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

- 标签：数组、哈希表、双指针、二分查找、排序
- 难度：简单

## 题目链接

- [0349. 两个数组的交集 - 力扣](https://leetcode.cn/problems/intersection-of-two-arrays/)

## 题目大意

**描述**：给定两个数组 $nums1$ 和 $nums2$。

**要求**：返回两个数组的交集。重复元素只计算一次。

**说明**：

- $1 \le nums1.length, nums2.length \le 1000$。
- $0 \le nums1[i], nums2[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
```

- 示例 2：

```python
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

## 解题思路

### 思路 1：哈希表

1. 先遍历第一个数组，利用哈希表来存放第一个数组的元素，对应字典值设为 $1$。
2. 然后遍历第二个数组，如果哈希表中存在该元素，则将该元素加入到答案数组中，并且将该键值清空。

### 思路 1：代码

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        numDict = dict()
        nums = []
        for num in nums1:
            if num not in numDict:
                numDict[num] = 1
        for num in nums2:
            if num in numDict and numDict[num] != 0:
                numDict[num] -= 1
                nums.append(num)
        return nums
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：分离双指针

1. 对数组 $nums1$、$nums2$ 先排序。
2. 使用两个指针 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$。$left\underline{\hspace{0.5em}}1$ 指向第一个数组的第一个元素，即：$left\underline{\hspace{0.5em}}1 = 0$，$left\underline{\hspace{0.5em}}2$ 指向第二个数组的第一个元素，即：$left\underline{\hspace{0.5em}}2 = 0$。
3. 如果 $nums1[left_1]$ 等于 $nums2[left_2]$，则将其加入答案数组（注意去重），并将 $left\underline{\hspace{0.5em}}1$ 和 $left\underline{\hspace{0.5em}}2$ 右移。
4. 如果 $nums1[left_1]$ 小于 $nums2[left_2]$，则将 $left\underline{\hspace{0.5em}}1$ 右移。
5. 如果 $nums1[left_1]$ 大于 $nums2[left_2]$，则将 $left\underline{\hspace{0.5em}}2$ 右移。
6. 最后返回答案数组。

### 思路 2：代码

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()

        left_1 = 0
        left_2 = 0
        res = []
        while left_1 < len(nums1) and left_2 < len(nums2):
            if nums1[left_1] == nums2[left_2]:
                if nums1[left_1] not in res:
                    res.append(nums1[left_1])
                left_1 += 1
                left_2 += 1
            elif nums1[left_1] < nums2[left_2]:
                left_1 += 1
            elif nums1[left_1] > nums2[left_2]:
                left_2 += 1
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [0350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

- 标签：数组、哈希表
- 难度：简单

## 题目链接

- [0350. 两个数组的交集 II - 力扣](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

## 题目大意

**描述**：给定两个数组 $nums1$ 和 $nums2$。

**要求**：返回两个数组的交集。可以不考虑输出结果的顺序。

**说明**：

- 输出结果中，每个元素出现的次数，应该与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。
- $1 \le nums1.length, nums2.length \le 1000$。
- $0 \le nums1[i], nums2[i] \le 1000$。

**示例**：

```python
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]


输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

## 解题思路

### 思路 1：哈希表

1. 先遍历第一个数组，利用字典来存放第一个数组的元素出现次数。
2. 然后遍历第二个数组，如果字典中存在该元素，则将该元素加入到答案数组中，并减少字典中该元素出现的次数。
3. 遍历完之后，返回答案数组。

### 思路 1：代码

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        numDict = dict()
        nums = []
        for num in nums1:
            if num in numDict:
                numDict[num] += 1
            else:
                numDict[num] = 1
        for num in nums2:
            if num in numDict and numDict[num] != 0:
                numDict[num] -= 1
                nums.append(num)
        return nums
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。# [0351. 安卓系统手势解锁](https://leetcode.cn/problems/android-unlock-patterns/)

- 标签：动态规划、回溯
- 难度：中等

## 题目链接

- [0351. 安卓系统手势解锁 - 力扣](https://leetcode.cn/problems/android-unlock-patterns/)

## 题目大意

**描述**：安卓系统手势解锁的界面是一个编号为 $1 \sim 9$、大小为 $3 \times 3$ 的网格。用户可以设定一个「解锁模式」，按照一定顺序经过 $k$ 个点，构成一个「解锁手势」。现在给定两个整数，分别为 $m$ 和 $n$。

**要求**：计算出有多少种不同且有效的解锁模式数量，其中每种解锁模式至少需要经过 $m$ 个点，但是不超过 $n$ 个点。

**说明**：

- **有效的解锁模式**：
  - 解锁模式中所有点不能重复。
  - 如果解锁模式中两个点是按顺序经过的，那么这两个点之间的手势轨迹不能跨过其他任何未被经过的点。

- 一些有效和无效解锁模式示例：
  - ![](https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png)
  - 无效手势：$[4,1,3,6]$，连接点 $1$ 和点 $3$ 时经过了未被连接过的 $2$ 号点。
  - 无效手势：$[4,1,9,2]$，连接点 $1$ 和点 $9$ 时经过了未被连接过的 $5$ 号点。
  - 有效手势：$[2,4,1,3,6]$，连接点 $1$ 和点 $3$ 是有效的，因为虽然它经过了点 $2$，但是点 $2$ 在该手势中之前已经被连过了。
  - 有效手势：$[6,5,4,1,9,2]$，连接点 $1$ 和点 $9$ 是有效的，因为虽然它经过了按键 $5$，但是点 $5$ 在该手势中之前已经被连过了。

- $1 \le m, n \le 9$。
- 如果经过的点不同或者经过点的顺序不同，表示为不同的解锁模式。

**示例**：

- 示例 1：

```python
输入：m = 1, n = 1
输出：9
```

- 示例 2：

```python
输入：m = 1, n = 2
输出：65
```

## 解题思路

### 思路 1：状态压缩 + 记忆化搜索

因为手势解锁的界面是一个编号为 $1 \sim 9$、大小为 $3 \times 3$ 的网格，所以我们可以用一个 $9$ 位长度的二进制数 $state$ 来表示当前解锁模式中按键的选取情况。

因为解锁模式中两个点之间的手势轨迹不能跨过其他任何未被经过的点，所以我们可以预先使用一个哈希表 $graph$ 将手势轨迹跨过其他点的情况存储下来，便于判断当前手势轨迹是否有效。

接下来我们使用深度优先搜索方法，将所有有效的解锁模式统计出来，具体做法如下：

1. 定义一个全局变量 $ans$ 用于统计所有有效的解锁模式的方案数。
2. 定义一个深度优先搜索方法为 `def dfs(state, cur, step):`，表示当前键位选择情况为 $state$，从当前键位 $cur$ 出发，已经走了 $step$ 的有效解锁模式。
   1. 当 $step$ 在区间 $[m, n]$ 中时，统计有效解锁模式方案数，即：令 $ans$ 加 $1$。
   2. 当 $step$ 到达步数上限 $n$ 时，直接返回。
   3. 遍历下一步（第 $step + 1$ 步）可选择的键位 $k$，判断键位 $k$ 是否有效。
   4. 如果到达 $k$ 没有跨过其他键（$k$ 不在 $graph[cur]$ 中），或者到达 $k$ 跨过的键位是已经经过的键 ($state >> graph[cur][k] \text{ \& } 1 == 1$)，则继续调用 `dfs(state | (1 << k), k, step + 1)`，其中 `stete | (1 << k)` 表示下一步选择 $k$ 的状态。
3. 遍历开始位置 $1 \sim 9$，从 1 ~ 9 每个数字开始出发，调用 `dfs(1 << i, i, 1)`，进行所有有效的解锁模式的统计。
4. 最后输出 $ans$。

### 思路 1：代码

```python
class Solution:
    def numberOfPatterns(self, m: int, n: int) -> int:
        # 将手势轨迹跨过点的情况存入哈希表中
        graph = {
            1: {3: 2, 7: 4, 9: 5},
            2: {8: 5},
            3: {1: 2, 7: 5, 9: 6},
            4: {6: 5},
            5: {},
            6: {4: 5},
            7: {1: 4, 3: 5, 9: 8},
            8: {2: 5},
            9: {1: 5, 3: 6, 7: 8},
        }

        ans = 0

        def dfs(state, cur, step):
            nonlocal ans
            if m <= step <= n:
                ans += 1
            
            if step == n:
                return
            
            for k in range(1, 10):
                if state >> k & 1 != 0:
                    continue
                if k not in graph[cur] or state >> graph[cur][k] & 1:
                    dfs(state | (1 << k), k, step + 1)

        for i in range(1, 10):
            dfs(1 << i, i, 1)   # 从 1 ~ 9 每个数字开始出发

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n!)$。
- **空间复杂度**：$O(1)$。

## 参考资料

- 【题解】[LeetCode-351. 安卓系统手势解锁 - mkdocs_blog](https://github.com/zhanguohao/mkdocs_blog/blob/mkdocs_blog/docs/problem/leetcode/LeetCode-351.%20%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81.md)
# [0354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

- 标签：数组、二分查找、动态规划、排序
- 难度：困难

## 题目链接

- [0354. 俄罗斯套娃信封问题 - 力扣](https://leetcode.cn/problems/russian-doll-envelopes/)

## 题目大意

给定一个二维整数数组 envelopes 表示信封，其中 $envelopes[i] = [wi, hi]$，表示第 $i$ 个信封的宽度 $w_i$ 和高度 $h_i$。

当一个信封的宽度和高度比另一个信封大时，则小的信封可以放进大信封里，就像俄罗斯套娃一样。

现在要求：计算最多能有多少个信封组成一组「俄罗斯套娃」信封。

注意：不允许旋转信封（也就是说宽高不能互换）。

## 解题思路

如果最多有 k 个信封可以组成「俄罗斯套娃」信封。那么这 k 个信封按照宽高关系排序一定满足：

- $w_0 < w_1 < ... < w_{k-1}$
- $h_0 < h_1 < ... < h_{k-1}$

因为原二维数组是无序的，直接暴力搜素宽高升序序列并不容易。所以我们可以先固定一个维度，将其变为升序状态。再在另一个维度上进行选择。比如固定宽度为升序，则我们的问题就变为了：在高度这一维度下，求解数组的最长递增序列的长度。就变为了经典的「最长递增序列的长度问题」。即 [0300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)。

「最长递增序列的长度问题」的思路如下：

动态规划的状态 `dp[i]` 表示为：以第 i 个数字结尾的前 i 个元素中最长严格递增子序列的长度。

遍历前 i 个数字，`0 ≤ j ≤ i`：

- 当 `nums[j] < nums[i]` 时，`nums[i]` 可以接在 `nums[j]` 后面，此时以第 i 个数字结尾的最长严格递增子序列长度 + 1，即 `dp[i] = dp[j] + 1`。
- 当 `nums[j] ≥ nums[i]` 时，可以直接跳过。

则状态转移方程为：`dp[i] = max(dp[i], dp[j] + 1)`，`0 ≤ j ≤ i`，`nums[j] < nums[i]`。

最后再遍历一遍 dp 数组，求出最大值即可。

## 代码

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        if not envelopes:
            return 0
        size = len(envelopes)
        envelopes.sort(key=lambda x: (x[0], -x[1]))

        dp = [1 for _ in range(size)]

        for i in range(size):
            for j in range(i):
                if envelopes[j][1] < envelopes[i][1]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```

# [0357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/)

- 标签：数学、动态规划、回溯
- 难度：中等

## 题目链接

- [0357. 统计各位数字都不同的数字个数 - 力扣](https://leetcode.cn/problems/count-numbers-with-unique-digits/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：统计并返回区间 $[0, 10^n)$ 上各位数字都不相同的数字 $x$ 的个数。

**说明**：

- $0 \le n \le 8$。
- $0 \le x < 10^n$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。
```

- 示例 2：

```python
输入：n = 0
输出：1
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

题目求解区间 $[0, 10^n)$ 范围内各位数字都不相同的数字个数。则我们先将 $10^n - 1$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, state, isLimit, isNum):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True, False)` 开始递归。 `dfs(0, 0, True, False)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 初始没有使用数字（即前一位所选数字集合为 $0$）。
   3. 开始时受到数字 $n$ 对应最高位数位的约束。
   4. 开始时没有填写数字。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
   1. 如果 $isNum == True$，说明当前方案符合要求，则返回方案数 $1$。
   2. 如果 $isNum == False$，说明当前方案不符合要求，则返回方案数 $0$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
   1. 根据 $isNum$ 和 $isLimit$ 来决定填当前位数位所能选择的最小数字（$minX$）和所能选择的最大数字（$maxX$），
   2. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
   3. 如果之前没有选择 $d$，即 $d$ 不在之前选择的数字集合 $state$ 中，则方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)`。
      1. `state | (1 << d)` 表示之前选择的数字集合 $state$ 加上 $d$。
      2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位限制和 $pos$ 位限制。
      3. $isNum == True$ 表示 $pos$ 位选择了数字。
6. 最后的方案数为 `dfs(0, 0, True, False) + 1`，因为之前计算时没有考虑 $0$，所以最后统计方案数时要加 $1$。

### 思路 1：代码

```python
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        s = str(10 ** n - 1)

        @cache
        # pos: 第 pos 个数位
        # state: 之前选过的数字集合。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        # isNum: 表示 pos 前面的数位是否填了数字。如果为真，则当前位不可跳过；如果为假，则当前位可跳过。
        def dfs(pos, state, isLimit, isNum):
            if pos == len(s):
                # isNum 为 True，则表示当前方案符合要求
                return int(isNum)
            
            ans = 0
            if not isNum:
                # 如果 isNumb 为 False，则可以跳过当前数位
                ans = dfs(pos + 1, state, False, False)
            
            # 如果前一位没有填写数字，则最小可选择数字为 0，否则最少为 1（不能含有前导 0）。
            minX = 0 if isNum else 1
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                # d 不在选择的数字集合中，即之前没有选择过 d
                if (state >> d) & 1 == 0:
                    ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)
            return ans
    
        return dfs(0, 0, True, False) + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 10 \times 2^{10})$。
- **空间复杂度**：$O(n \times 2^{10})$。

# [0359. 日志速率限制器](https://leetcode.cn/problems/logger-rate-limiter/)

- 标签：设计、哈希表
- 难度：简单

## 题目链接

- [0359. 日志速率限制器 - 力扣](https://leetcode.cn/problems/logger-rate-limiter/)

## 题目大意

设计一个日志系统，可以流式接受消息和消息的时间戳。每条不重复的信息最多每 10 秒打印一次。即如果在时间 t 打印了 A 信息，则直到 t+10 的时间，才能再次打印这条信息。

要求实现 Logger 类：

- `def __init__(self):` 初始化 logger 对象
- `def shouldPrintMessage(self, timestamp: int, message: str) -> bool:`
  - 如果该条消息 message 在给定时间戳 timestamp 能够打印出来，则返回 True，否则返回 False。

## 解题思路

初始化一个哈希表，用来存储消息 message 最后一次打印的时间戳。

当新的消息到达是，先判断之前是否出现过相同的消息，如果未出现则可打印，存储时间戳，并返回 True。

如果出现过，且上一次相同的消息在 10 秒之前打印的，则该消息也可打印，更新时间戳，并返回 True。

如果上一次相同的消息是在 10 秒内打印的，则该信息不可打印，直接返回 False。

## 代码

```python
class Logger:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.msg_dict = dict()


    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message not in self.msg_dict:
            self.msg_dict[message] = timestamp
            return True
        if timestamp - self.msg_dict[message] >= 10:
            self.msg_dict[message] = timestamp
            return True
        else:
            return False
```

# [0360. 有序转化数组](https://leetcode.cn/problems/sort-transformed-array/)

- 标签：数组、数学、双指针、排序
- 难度：中等

## 题目链接

- [0360. 有序转化数组 - 力扣](https://leetcode.cn/problems/sort-transformed-array/)

## 题目大意

**描述**：给定一个已经排好的整数数组 $nums$ 和整数 $a$、$b$、$c$。

**要求**：对于数组中的每一个数 $x$，计算函数值 $f(x) = ax^2 + bx + c$，请将函数值产生的数组返回。

**说明**：

- 返回的这个数组必须按照升序排列，并且我们所期望的解法时间复杂度为 $O(n)$。
- $1 \le nums.length \le 200$。
- $-100 \le nums[i], a, b, c \le 100$。
- $nums$ 按照升序排列。

**示例**：

- 示例 1：

```python
输入: nums = [-4,-2,2,4], a = 1, b = 3, c = 5
输出: [3,9,15,33]
```

- 示例 2：

```python
输入: nums = [-4,-2,2,4], a = -1, b = 3, c = 5
输出: [-23,-5,1,7]
```

## 解题思路

### 思路 1： 数学 + 对撞指针

这是一道数学题。需要根据一元二次函数的性质来解决问题。因为返回的数组必须按照升序排列，并且期望的解法时间复杂度为 $O(n)$。这就不能先计算再排序了，而是要在线性时间复杂度内考虑问题。

我们先定义一个函数用来计算 $f(x)$。然后进行分情况讨论。

- 如果 $a == 0$，说明函数是一条直线。则根据 $b$ 值的正负来确定数组遍历顺序。
  - 如果 $b \ge 0$，说明这条直线是一条递增直线。则按照从头到尾的顺序依次计算函数值，并依次存入答案数组。
  - 如果 $b < 0$，说明这条直线是一条递减直线。则按照从尾到头的顺序依次计算函数值，并依次存入答案数组。
- 如果 $a > 0$，说明函数是一条开口向上的抛物线，最小值横坐标为 $diad = \frac{-b}{2.0 * a}$，离 diad 越远，函数值越大。则可以使用双指针从远到近，由大到小依次填入数组。具体步骤如下：
  - 使用双指针 $left$、$right$，令 $left$ 指向数组第一个元素位置，$right$ 指向数组最后一个元素位置。再定义 $index = len(nums) - 1$ 作为答案数组填入顺序的索引值。
  - 比较 $left - diad$ 与 $right - diad$ 的绝对值大小。大的就是目前距离 $diad$ 最远的那个。
    - 如果 $abs(nums[left] - diad)$ 更大，则将其填入答案数组对应位置，并令 $left += 1$。
    - 如果 $abs(nums[right] - diad)$ 更大，则将其填入答案数组对应位置，并令 $right -= 1$。
    - 令 $index -= 1$。
  - 直到 $left == right$，最后将 $nums[left]$ 填入答案数组对应位置。
- 如果 $a < 0$，说明函数是一条开口向下的抛物线，最大值横坐标为 $diad = \frac{-b}{2.0 * a}$，离 diad 越远，函数值越小。则可以使用双指针从远到近，由小到大一次填入数组。具体步骤如下：
  - 使用双指针 $left$、$right$，令 $left$ 指向数组第一个元素位置，$right$ 指向数组最后一个元素位置。再定义 $index = 0$ 作为答案数组填入顺序的索引值。
  - 比较 $left - diad$ 与 $right - diad$ 的绝对值大小。大的就是目前距离 $diad$ 最远的那个。
    - 如果 $abs(nums[left] - diad)$ 更大，则将其填入答案数组对应位置，并令 $left += 1$。
    - 如果 $abs(nums[right] - diad)$ 更大，则将其填入答案数组对应位置，并令 $right -= 1$。
    - 令 $index += 1$。
  - 直到 $left == right$，最后将 $nums[left]$ 填入答案数组对应位置。

### 思路 1：代码

```python
class Solution:
    def calFormula(self, x, a, b, c):
        return a * x * x + b * x + c

    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -> List[int]:
        size = len(nums)
        res = [0 for _ in range(size)]

        # 直线
        if a == 0:
            if b >= 0:
                index = 0
                for i in range(size):
                    res[index] = self.calFormula(nums[i], a, b, c)
                    index += 1
            else:
                index = 0
                for i in range(size - 1, -1, -1):
                    res[index] = self.calFormula(nums[i], a, b, c)
                    index += 1
        else:
            diad = -(b / (2.0 * a))
            left, right = 0, size - 1

            if a > 0:
                index = size - 1
                while left < right:
                    if abs(diad - nums[left]) > abs(diad - nums[right]):
                        res[index] = self.calFormula(nums[left], a, b, c)
                        left += 1
                    else:
                        res[index] = self.calFormula(nums[right], a, b, c)
                        right -= 1
                    index -= 1
                res[index] = self.calFormula(nums[left], a, b, c)
            else:
                diad = -(b / (2.0 * a))
                left, right = 0, size - 1
                index = 0
                while left < right:
                    if abs(diad - nums[left]) > abs(diad - nums[right]):
                        res[index] = self.calFormula(nums[left], a, b, c)
                        left += 1
                    else:
                        res[index] = self.calFormula(nums[right], a, b, c)
                        right -= 1
                    index += 1
                res[index] = self.calFormula(nums[left], a, b, c)
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$，不考虑最终返回值的空间占用。

# [0367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

- 标签：数学、二分查找
- 难度：简单

## 题目链接

- [0367. 有效的完全平方数 - 力扣](https://leetcode.cn/problems/valid-perfect-square/)

## 题目大意

**描述**：给定一个正整数 $num$。

**要求**：判断 num 是不是完全平方数。

**说明**：

- 要求不能使用内置的库函数，如 `sqrt`。
- $1 \le num \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：num = 16
输出：True
解释：返回 true，因为 4 * 4 = 16 且 4 是一个整数。
```

- 示例 2：

```python
输入：num = 14
输出：False
解释：返回 false，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

## 解题思路

### 思路 1：二分查找

如果 $num$ 是完全平方数，则 $num = x \times x$，$x$ 为整数。问题就变为了对于正整数 $num$，是否能找到一个整数 $x$，使得 $x \times x = num$。

而对于 $x$，我们可以通过二分查找算法快速找到。

### 思路 1：代码

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left = 0
        right = num
        while left < right:
            mid = left + (right - left) // 2
            if mid * mid > num:
                right = mid - 1
            elif mid * mid < num:
                left = mid + 1
            else:
                left = mid
                break
        return left * left == num
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$，其中 $n$ 为正整数 $num$ 的最大值。
- **空间复杂度**：$O(1)$。

# [0370. 区间加法](https://leetcode.cn/problems/range-addition/)

- 标签：数组、前缀和
- 难度：中等

## 题目链接

- [0370. 区间加法 - 力扣](https://leetcode.cn/problems/range-addition/)

## 题目大意

**描述**：给定一个数组的长度 `length` ，初始情况下数组中所有数字均为 `0`。再给定 `k` 个更新操作。其中每个操作是一个三元组 `[startIndex, endIndex, inc]`，表示将子数组 `nums[startIndex ... endIndex]` （包括 `startIndex`、`endIndex`）上所有元素增加 `inc`。

**要求**：返回 `k` 次操作后的数组。

**示例**：

- 示例 1：

```
给定 length = 5，即 nums = [0, 0, 0, 0, 0]

操作 [1, 3, 2] -> [0, 2, 2, 2, 0]
操作 [2, 4, 3] -> [0, 2, 5, 5, 3]
操作 [0, 2, -2] -> [-2, 0, 3, 5, 3]
```

## 解题思路

### 思路 1：线段树

- 初始化一个长度为 `length`，值全为 `0` 的 `nums` 数组。
- 然后根据 `nums` 数组构建一棵线段树。每个线段树的节点类存储当前区间的左右边界和该区间的和。并且线段树使用延迟标记。
- 然后遍历三元组操作，进行区间累加运算。
- 最后从线段树中查询数组所有元素，返回该数组即可。

这样构建线段树的时间复杂度为 $O(\log n)$，单次区间更新的时间复杂度为 $O(\log n)$，单次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(\log n)$。

### 思路 1：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = None                        # 区间和问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
    
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间更新接口：将区间为 [q_left, q_right] 上的所有元素值加上 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
        
        
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 单点更新实现方法：将 nums[i] 更改为 val，节点的存储下标为 index
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == right:
            self.tree[index].val = val              # 叶子节点，节点值修改为 val
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖        
            if self.tree[index].lazy_tag is not None:
                self.tree[index].lazy_tag += val    # 将当前节点的延迟标记增加 val
            else:
                self.tree[index].lazy_tag = val     # 将当前节点的延迟标记增加 val
            interval_size = (right - left + 1)      # 当前节点所在区间大小
            self.tree[index].val += val * interval_size  # 当前节点所在区间每个元素值增加 val
            return
        
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return
    
        self.__pushdown(index)                      # 向下更新节点的区间值
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if q_left <= mid:                           # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, left_index)
        if q_right > mid:                           # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(index)
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)

    # 向下更新实现方法：更新下标为 index 的节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, index):
        lazy_tag = self.tree[index].lazy_tag
        if lazy_tag is None: 
            return
        
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        
        if self.tree[left_index].lazy_tag is not None:
            self.tree[left_index].lazy_tag += lazy_tag  # 更新左子节点懒惰标记
        else:
            self.tree[left_index].lazy_tag = lazy_tag
        left_size = (self.tree[left_index].right - self.tree[left_index].left + 1)
        self.tree[left_index].val += lazy_tag * left_size   # 左子节点每个元素值增加 lazy_tag
        
        if self.tree[right_index].lazy_tag is not None:
            self.tree[right_index].lazy_tag += lazy_tag # 更新右子节点懒惰标记
        else:
            self.tree[right_index].lazy_tag = lazy_tag
        right_size = (self.tree[right_index].right - self.tree[right_index].left + 1)
        self.tree[right_index].val += lazy_tag * right_size # 右子节点每个元素值增加 lazy_tag
        
        self.tree[index].lazy_tag = None            # 更新当前节点的懒惰标记

class Solution:
    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        nums = [0 for _ in range(length)]
        self.ST = SegmentTree(nums, lambda x, y: x + y)
        for update in updates:
            self.ST.update_interval(update[0], update[1], update[2])

        return self.ST.get_nums()
```

# [0371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)

- 标签：位运算、数学
- 难度：中等

## 题目链接

- [0371. 两整数之和 - 力扣](https://leetcode.cn/problems/sum-of-two-integers/)

## 题目大意

**描述**：给定两个整数 $a$ 和 $b$。

**要求**：不使用运算符 `+` 和 `-` ，计算两整数 $a$ 和 $b$ 的和。

**说明**：

- $-1000 \le a, b \le 1000$。

**示例**：

- 示例 1：

```python
输入：a = 1, b = 2
输出：3
```

- 示例 2：

```python
输入：a = 2, b = 3
输出：5
```

## 解题思路

### 思路 1：位运算

需要用到位运算的一些知识。

- 异或运算 `a ^ b`：可以获得 $a + b$ 无进位的加法结果。
- 与运算 `a & b`：对应位置为 $1$，说明 $a$、$b$ 该位置上原来都为 $1$，则需要进位。
- 左移运算 `a << 1`：将 $a$ 对应二进制数左移 $1$ 位。

这样，通过 `a ^ b` 运算，我们可以得到相加后无进位结果，再根据 `(a & b) << 1`，计算进位后结果。

进行 `a ^ b` 和 `(a & b) << 1` 操作之后判断进位是否为 $0$，若不为 $0$，则继续上一步操作，直到进位为 $0$。

> 注意：
>
> Python 的整数类型是无限长整数类型，负数不确定符号位是第几位。所以我们可以将输入的数字手动转为 $32$ 位无符号整数。
>
> 通过 `a &= 0xFFFFFFFF` 即可将 $a$ 转为 $32$ 位无符号整数。最后通过对 $a$ 的范围判断，将其结果映射为有符号整数。

### 思路 1：代码

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        MAX_INT = 0x7FFFFFFF
        MASK = 0xFFFFFFFF
        a &= MASK
        b &= MASK
        while b:
            carry = ((a & b) << 1) & MASK
            a ^= b
            b = carry
        if a <= MAX_INT:
            return a
        else:
            return ~(a ^ MASK)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log k)$，其中 $k$ 为 $int$ 所能表达的最大整数。
- **空间复杂度**：$O(1)$。

# [0374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

- 标签：二分查找、交互
- 难度：简单

## 题目链接

- [0374. 猜数字大小 - 力扣](https://leetcode.cn/problems/guess-number-higher-or-lower/)

## 题目大意

**描述**：猜数字游戏。给定一个整数 $n$ 和一个接口 `def guess(num: int) -> int:`，题目会从 $1 \sim n$ 中随机选取一个数 $x$。我们只能通过调用接口来判断自己猜测的数是否正确。

**要求**：要求返回题目选取的数字 $x$。

**说明**：

- `def guess(num: int) -> int:` 返回值：
  - $-1$：我选出的数字比你猜的数字小，即 $pick < num$；
  - $1$：我选出的数字比你猜的数字大 $pick > num$；
  - $0$：我选出的数字和你猜的数字一样。恭喜！你猜对了！$pick == num$。

**示例**：

- 示例 1：

```python
输入：n = 10, pick = 6
输出：6
```

- 示例 2：

```python
输入：n = 1, pick = 1
输出：1
```

## 解题思路

### 思路 1：二分查找

利用两个指针 $left$、$right$。$left$ 指向数字 $1$，$right$ 指向数字 $n$。每次从中间开始调用接口猜测是否正确。

- 如果猜测的数比选中的数大，则将 $right$ 向左移，令 `right = mid - 1`，继续从中间调用接口猜测；
- 如果猜测的数比选中的数小，则将 $left$ 向右移，令 `left = mid + 1`，继续从中间调用的接口猜测；
- 如果猜测正确，则直接返回该数。

### 思路 1：二分查找代码

```python
class Solution:
    def guessNumber(self, n: int) -> int:
        left = 1
        right = n
        while left <= right:
            mid = left + (right - left) // 2
            ans = guess(mid)
            if ans == 1:
                left = mid + 1
            elif ans == -1:
                right = mid - 1
            else:
                return mid
        return 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。
# [0375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

- 标签：数学、动态规划、博弈
- 难度：中等

## 题目链接

- [0375. 猜数字大小 II - 力扣](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

## 题目大意

**描述**：现在两个人来玩一个猜数游戏，游戏规则如下：

1. 对方从 $1 \sim n$ 中选择一个数字。
2. 我们来猜对方选了哪个数字。
3. 如果我们猜到了正确数字，就会赢得游戏。
4. 如果我们猜错了，那么对方就会告诉我们，所选的数字比我们猜的数字更大或者更小，并且需要我们继续猜数。
5. 每当我们猜了数字 $x$ 并且猜错了的时候，我们需要支付金额为 $x$ 的现金。如果我们花光了钱，就会输掉游戏。

现在给定一个特定数字 $n$。

**要求**：返回能够确保我们获胜的最小现金数（不管对方选择哪个数字）。

**说明**：

- $1 \le n \le 200$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/09/10/graph.png)

```python
输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10]。你先猜测数字为 7 。
  - 如果这是我选中的数字，你的总费用为 $0。否则，你需要支付 $7。
  - 如果我的数字更大，则下一步需要猜测的数字范围是 [8, 10] 。你可以猜测数字为 9。
    - 如果这是我选中的数字，你的总费用为 $7。否则，你需要支付 $9。
    - 如果我的数字更大，那么这个数字一定是 10。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16。
    - 如果我的数字更小，那么这个数字一定是 8。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16。
  - 如果我的数字更小，则下一步需要猜测的数字范围是 [1, 6]。你可以猜测数字为 3。
    - 如果这是我选中的数字，你的总费用为 $7。否则，你需要支付 $3。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [4, 6]。你可以猜测数字为 5。
      - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5。
      - 如果我的数字更大，那么这个数字一定是 6。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15。
      - 如果我的数字更小，那么这个数字一定是 4。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1, 2]。你可以猜测数字为 1。
      - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10。否则，你需要支付 $1。
      - 如果我的数字更大，那么这个数字一定是 2。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11。
在最糟糕的情况下，你需要支付 $16。因此，你只需要 $16 就可以确保自己赢得游戏。
```

- 示例 2：

```python
输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
  - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
  - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1。
```

## 解题思路

### 思路 1：动态规划

直觉上这道题应该通过二分查找来求解，但实际上并不能通过二分查找来求解。

因为我们可以通过二分查找方法，能够找到猜中的最小次数，但这个猜中的最小次数所对应的支付金额，并不是最小现金数。

也就是说，通过二分查找的策略，并不能找到确保我们获胜的最小现金数。所以我们需要转换思路。

我们可以用递归的方式来思考。

对于 $1 \sim n$ 中每一个数 $x$：

1. 如果 $x$ 恰好是正确数字，则获胜，付出的现金数为 $0$。
2. 如果 $x$ 不是正确数字，则付出现金数为 $x$，同时我们得知，正确数字比 $x$ 更大还是更小。
   1. 如果正确数字比 $x$ 更小，我们只需要求出 $1 \sim x - 1$ 中能够获胜的最小现金数，再加上 $x$ 就是确保我们获胜的最小现金数。
   2. 如果正确数字比 $x$ 更大，我们只需要求出 $x + 1 \sim n$ 中能够获胜的最小现金数，再加上 $x$ 就是确保我们获胜的最小现金数。
   3. 因为正确数字可能比 $x$ 更小，也可能比 $x$ 更大。在考虑最坏情况下也能获胜，我们需要准备的最小现金应该为两种情况下的最小代价的最大值，再加上 $x$ 本身。

我们可以通过枚举 $x$，并求出所有情况下的最小值，即为确保我们获胜的最小现金数。

我们可以定义一个方法 $f(1)(n)$ 来表示 $1 \sim n$ 中能够获胜的最小现金数，则可以得到递推公式：$f(1)(n) = min_{x = 1}^{x = n} \lbrace max \lbrace f(1)(x - 1), f(x + 1)(n) \rbrace + x \rbrace)$。

将递推公式应用到 $i \sim j$ 中，可得：$f(i)(j) = min_{x = i}^{x = j} \lbrace max \lbrace f(i)(x - 1), f(x + 1)(j) \rbrace + x \rbrace)$

接下来我们就可以通过动态规划的方式解决这道题了。

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：数字 $i \sim j$ 中能够确保我们获胜的最小现金数。

###### 3. 状态转移方程

$dp[i][j] = min_{x = i}^{x = j} \lbrace max \lbrace dp[i][x - 1], dp[x + 1][j] \rbrace + x \rbrace)$

###### 4. 初始条件

- 默认数字 $i \sim j$ 中能够确保我们获胜的最小现金数为无穷大。
- 当区间长度为 $1$ 时，区间中只有 $1$ 个数，肯定为正确数字，则付出最小现金数为 $0$，即 $dp[i][i] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：数字 $i \sim j$ 中能够确保我们获胜的最小现金数。所以最终结果为 $dp[1][n]$。

### 思路 1：代码

```python
class Solution:
    def getMoneyAmount(self, n: int) -> int:
        dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]
        for l in range(2, n + 1):
            for i in range(1, n + 1):
                j = i + l - 1
                if j > n:
                    break
                dp[i][j] = float('inf')
                for k in range(i, j):
                    dp[i][j] = min(dp[i][j], max(dp[i][k - 1] + k, dp[k + 1][j] + k))

        return dp[1][n]

```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n^2)$。

# [0376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [0376. 摆动序列 - 力扣](https://leetcode.cn/problems/wiggle-subsequence/)

## 题目大意

如果一个数组序列中，连续项之间的差值是严格的在正数、负数之间交替，则称该数组序列为「摆动序列」。第一个差值可能为正数，也可能为负数。只有一个元素或者还有两个不等元素的数组序列也可以看做是摆动序列。

- 例如：`[1, 7, 4, 9, 2, 5]` 是摆动序列 ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列。第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

现在给定一个整数数组 nums，返回 nums 中作为「摆动序列」的「最长子序列长度」。

## 解题思路

我们先通过一个例子来说明如何求摆动数组最长子序列的长度。

下图是 `nums = [1,17,5,10,13,15,10,5,16,8]` 的图示。

![](http://qcdn.itcharge.cn/images/20210805131834.png)

根据题意可知，摆动数组中连续项的差值是正负交替的，直观表现就像是一条高低起伏的山脉，或者像一把锯齿。

观察图像可知，貌似当我们不断交错的选择山脉的「波峰」和「波谷」作为子序列的元素，就会使摆动数组的子序列尽可能的长。例如下图选择 `[1, 17, 5, 15, 5, 16, 8]`。

![](http://qcdn.itcharge.cn/images/20210805131848.png)

可是为什么选择「峰」「谷」就能使摆动数组的子序列尽可能的长？为什么我们不选择「中间元素」呢？

其实也可以选择「中间元素」，**因为一路从波谷爬坡到波峰再到波谷，和从波谷爬坡到半山腰再回到波谷所形成的摆动数组最长子序列的长度是一样的。**

只不过如果选择中间元素，这个中间元素两侧必有波峰和波谷，我们假设选择的序列出现顺序为：「谷 -> 中间元素 -> 谷」，则「谷」和「谷」中间的「峰」必定没有出现在选择的序列中，我们必然可以将选择的「中间元素」替换为「峰」。

同理，「峰 -> 中间元素 -> 峰」中选择的「中间元素」必然也可以替换为「谷」。

所以既然中可以替换，所以我们干脆直接选择「峰」「谷」就可以满足最长子序列的长度。

所以题目就变为了：统计序列中「峰」「谷」的数量。

记录下前一对连续项的差值、当前对连续项的差值，并判断是否是互为正负的。

- 如果互为正负，则为「峰」或「谷」，记录下个数，并更新前一对连续项的差值。
- 如果符号相同，则继续向后判断。

## 代码

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        size = len(nums)
        cur_diff = 0
        pre_diff = 0
        res = 1
        for i in range(size - 1):
            cur_diff = nums[i + 1] - nums[i]
            if (cur_diff > 0 and pre_diff <= 0) or (pre_diff >= 0 and cur_diff < 0):
                res += 1
                pre_diff = cur_diff
        return res
```

# [0377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0377. 组合总和 Ⅳ - 力扣](https://leetcode.cn/problems/combination-sum-iv/)

## 题目大意

**描述**：给定一个由不同整数组成的数组 $nums$ 和一个目标整数 $target$。

**要求**：从 $nums$ 中找出并返回总和为 $target$ 的元素组合个数。

**说明**：

- 题目数据保证答案符合 32 位整数范围。
- $1 \le nums.length \le 200$。
- $1 \le nums[i] \le 1000$。
- $nums$ 中的所有元素互不相同。
- $1 \le target \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

- 示例 2：

```python
输入：nums = [9], target = 3
输出：0
```

## 解题思路

### 思路 1：动态规划

「完全背包问题求方案数」的变形。本题与「完全背包问题求方案数」不同点在于：方案中不同的物品顺序代表不同方案。

比如「完全背包问题求方案数」中，凑成总和为 $4$ 的方案 $[1, 3]$  算 $1$ 种方案，但是在本题中 $[1, 3]$、$[3, 1]$ 算 $2$ 种方案数。

我们需要在考虑某一总和 $w$ 时，需要将 $nums$ 中所有元素都考虑到。对应到循环关系时，即将总和 $w$ 的遍历放到外侧循环，将 $nums$ 数组元素的遍历放到内侧循环，即：

```python
for w in range(target + 1):
    for i in range(1, len(nums) + 1):
        xxxx
```

###### 1. 划分阶段

按照总和进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：凑成总和 $w$ 的组合数。

###### 3. 状态转移方程

凑成总和为 $w$ 的组合数 = 「不使用当前 $nums[i - 1]$，只使用之前整数凑成和为 $w$ 的组合数」+「使用当前 $nums[i - 1]$ 凑成和为 $w - nums[i - 1]$ 的方案数」。即状态转移方程为：$dp[w] = dp[w] + dp[w - nums[i - 1]]$。

###### 4. 初始条件

- 凑成总和 $0$ 的组合数为 $1$，即 $dp[0] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[w]$ 表示为：凑成总和 $w$ 的组合数。 所以最终结果为 $dp[target]$。

### 思路 1：代码

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        size = len(nums)
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1

        for w in range(target + 1):
            for i in range(1, size + 1):
                if w >= nums[i - 1]:
                    dp[w] = dp[w] + dp[w - nums[i - 1]]
            
        return dp[target]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times target)$，其中 $n$ 为数组 $nums$ 的元素个数，$target$ 为目标整数。
- **空间复杂度**：$O(target)$。

# [0378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

- 标签：数组、二分查找、矩阵、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0378. 有序矩阵中第 K 小的元素 - 力扣](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

## 题目大意

给定一个 `n * n` 矩阵 `matrix`，其中每行和每列元素均按升序排序。

要求：找到矩阵中第 `k` 小的元素。

注意：它是排序后的第 `k` 小元素，而不是第 `k` 个 不同的元素。

## 解题思路

已知二维矩阵 `matrix` 每行每列是按照升序排序的。那么二维矩阵的下界就是左上角元素 `matrix[0][0]`，上界就是右下角元素 `matrix[rows - 1][cols - 1]`。那么我们可以使用二分查找的方法在上界、下界之间搜索所有值，找到第 `k` 小的元素。

我们可以通过判断矩阵中比 `mid` 小的元素个数是否等于 `k` 来确定是否找到第 `k` 小的元素。

- 如果比 `mid` 小的元素个数大于等于 `k`，说明最终答案 `ans` 小于等于 `mid`。
- 如果比 `mid` 小的元素个数小于 `k`，说明最终答案 `ans` 大于 `k`。

## 代码

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        rows, cols = len(matrix), len(matrix[0])
        left, right = matrix[0][0], matrix[rows - 1][cols - 1] + 1
        while left < right:
            mid = left + (right - left) // 2
            if self.counterKthSmallest(mid, matrix) >= k:
                right = mid
            else:
                left = mid + 1
        return left

    def counterKthSmallest(self, mid, matrix):
        rows, cols = len(matrix), len(matrix[0])
        count = 0
        j = cols - 1
        for i in range(rows):
            while j >= 0 and mid < matrix[i][j]:
                j -= 1
            count += j + 1
        return count
```

# [0380. 常数时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

- 标签：设计、数组、哈希表、数学、随机化
- 难度：中等

## 题目链接

- [0380. 常数时间插入、删除和获取随机元素 - 力扣](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

## 题目大意

设计一个数据结构 ，支持时间复杂度为 O(1) 的以下操作：

- insert(val)：当元素 val 不存在时，向集合中插入该项。
- remove(val)：元素 val 存在时，从集合中移除该项。
- getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。

## 解题思路

普通动态数组进行访问操作，需要线性时间查找解决。我们可以利用哈希表记录下每个元素的下标，这样在访问时可以做到常数时间内访问元素了。对应的插入、删除、后去随机元素需要做相应的变化。

- 插入操作：将元素直接插入到数组尾部，并用哈希表记录插入元素的下标位置。
- 删除操作：使用哈希表找到待删除元素所在位置，将其与数组末尾位置元素相互交换，更新哈希表中交换后元素的下标值，并将末尾元素删除。
- 获取随机元素：使用` random.choice` 获取。

## 代码

```python
import random

class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dict = dict()
        self.list = list()


    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.dict:
            idx = self.dict[val]
            last = self.list[-1]
            self.list[idx] = last
            self.dict[last] = idx
            self.list.pop()
            self.dict.pop(val)
            return True
        return False


    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return random.choice(self.list)
```

# [0383. 赎金信](https://leetcode.cn/problems/ransom-note/)

- 标签：哈希表、字符串、计数
- 难度：简单

## 题目链接

- [0383. 赎金信 - 力扣](https://leetcode.cn/problems/ransom-note/)

## 题目大意

**描述**：为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。

给定一个赎金信字符串 $ransomNote$ 和一个杂志字符串 $magazine$。

**要求**：判断 $ransomNote$ 能不能由 $magazines$ 里面的字符构成。如果可以构成，返回 `True`；否则返回 `False`。

**说明**：

- $magazine$ 中的每个字符只能在 $ransomNote$ 中使用一次。
- $1 \le ransomNote.length, magazine.length \le 10^5$。
- $ransomNote$ 和 $magazine$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：ransomNote = "a", magazine = "b"
输出：False
```

- 示例 2：

```python
输入：ransomNote = "aa", magazine = "ab"
输出：False
```

## 解题思路

### 思路 1：哈希表

暴力做法是双重循环遍历字符串 $ransomNote$ 和 $magazines$。我们可以用哈希表来减少算法的时间复杂度。具体做法如下：

- 先用哈希表存储 $magazines$ 中各个字符的个数（哈希表可用字典或数组实现）。
- 再遍历字符串 $ransomNote$ 中每个字符，对于每个字符：
  - 如果在哈希表中个数为 $0$，直接返回 `False`。
  - 如果在哈希表中个数不为 $0$，将其个数减 $1$。
- 遍历到最后，则说明 $ransomNote$ 能由 $magazines$ 里面的字符构成。返回 `True`。

### 思路 1：代码

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        magazine_counts = [0 for _ in range(26)]

        for ch in magazine:
            num = ord(ch) - ord('a')
            magazine_counts[num] += 1

        for ch in ransomNote:
            num = ord(ch) - ord('a')
            if magazine_counts[num] == 0:
                return False
            else:
                magazine_counts[num] -= 1

        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$，其中 $m$ 是字符串 $ransomNote$ 的长度，$n$ 是字符串 $magazines$ 的长度。
- **空间复杂度**：$O(|S|)$，其中 $S$ 是字符集，本题中 $|S| = 26$。

# [0384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/)

- 标签：数组、数学、随机化
- 难度：中等

## 题目链接

- [0384. 打乱数组 - 力扣](https://leetcode.cn/problems/shuffle-an-array/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是等可能的。

实现 `Solution class`:

- `Solution(int[] nums)` 使用整数数组 $nums$ 初始化对象。
- `int[] reset()` 重设数组到它的初始状态并返回。
- `int[] shuffle()` 返回数组随机打乱后的结果。

**说明**：

- $1 \le nums.length \le 50$。
- $-10^6 \le nums[i] \le 10^6$。
- $nums$ 中的所有元素都是 唯一的。
- 最多可以调用 $10^4$ 次 `reset` 和 `shuffle`。

**示例**：

- 示例 1：

```python
输入：
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
输出：
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

解释：
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
```

## 解题思路

### 思路 1：洗牌算法

题目要求在打乱顺序后，数组的所有排列应该是等可能的。对于长度为 $n$ 的数组，我们可以把问题转换为：分别在 $n$ 个位置上，选择填入某个数的概率是相同。具体选择方法如下：

- 对于第 $0$ 个位置，我们从 $0 \sim n - 1$ 总共 $n$ 个数中随机选择一个数，将该数与第 $0$ 个位置上的数进行交换。则每个数被选到的概率为 $\frac{1}{n}$。
- 对于第 $1$ 个位置，我们从剩下 $n - 1$ 个数中随机选择一个数，将该数与第 $1$ 个位置上的数进行交换。则每个数被选到的概率为 $\frac{n - 1}{n} \times \frac{1}{n - 1} = \frac{1}{n}$ （第一次没选到并且第二次被选中）。
- 对于第 $2$ 个位置，我们从剩下 $n - 2$ 个数中随机选择一个数，将该数与第 $2$ 个位置上的数进行交换。则每个数被选到的概率为 $\frac{n - 1}{n} \times \frac{n - 2}{n - 1} \times \frac{1}{n - 2} = \frac{1}{n}$ （第一次没选到、第二次没选到，并且第三次被选中）。
- 依次类推，对于每个位置上，每个数被选中的概率都是 $\frac{1}{n}$。

### 思路 1：洗牌算法代码

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums


    def reset(self) -> List[int]:
        return self.nums


    def shuffle(self) -> List[int]:
        self.shuffle_nums = self.nums.copy()
        for i in range(len(self.shuffle_nums)):
            swap_index = random.randrange(i, len(self.shuffle_nums))
            self.shuffle_nums[i], self.shuffle_nums[swap_index] = self.shuffle_nums[swap_index], self.shuffle_nums[i]
        return self.shuffle_nums
```

## 参考资料

- 【题解】[「Python/Java/JavaScript/Go」 洗牌算法 - 打乱数组 - 力扣](https://leetcode.cn/problems/shuffle-an-array/solution/pythonjavajavascriptgo-xi-pai-suan-fa-by-k7i2/)# [0386. 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)

- 标签：深度优先搜索、字典树
- 难度：中等

## 题目链接

- [0386. 字典序排数 - 力扣](https://leetcode.cn/problems/lexicographical-numbers/)

## 题目大意

给定一个整数 `n`。

要求：按字典序返回范围 `[1, n]` 的所有整数。并且要求时间复杂度为 `O(n)`，空间复杂度为 `o(1)`。

## 解题思路

按照字典序进行深度优先搜索。实质上算是构造一棵字典树，然后将 `[1, n]` 中的数插入到字典树中，并将遍历结果存储到列表中。

## 代码

```python
class Solution:
    def dfs(self, cur, n, res):
        if cur > n:
            return
        res.append(cur)
        for i in range(10):
            num = 10 * cur + i
            if num > n:
                return
            self.dfs(num, n, res)

    def lexicalOrder(self, n: int) -> List[int]:
        res = []
        for i in range(1, 10):
            self.dfs(i, n, res)
        return res
```

# [0387. 字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string/)

- 标签：队列、哈希表、字符串、计数
- 难度：简单

## 题目链接

- [0387. 字符串中的第一个唯一字符 - 力扣](https://leetcode.cn/problems/first-unique-character-in-a-string/)

## 题目大意

给定一个只包含小写字母的字符串 `s`。

要求：找到第一个不重复的字符，并返回它的索引。

## 解题思路

遍历字符串，使用哈希表存储字符串中每个字符的出现次数。然后第二次遍历时，找出只出现一次的字符。

## 代码

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        strDict = dict()
        for i in range(len(s)):
            if s[i] in strDict:
                strDict[s[i]] += 1
            else:
                strDict[s[i]] = 1

        for i in range(len(s)):
            if s[i] in strDict and strDict[s[i]] == 1:
                return i
        return -1
```

- 思路 2 代码：
# [0389. 找不同](https://leetcode.cn/problems/find-the-difference/)

- 标签：位运算、哈希表、字符串、排序
- 难度：简单

## 题目链接

- [0389. 找不同 - 力扣](https://leetcode.cn/problems/find-the-difference/)

## 题目大意

给定两个只包含小写字母的字符串 s、t。字符串 t 是由 s 进行随机重拍之后，再在随机位置添加一个字母得到的。要求：找出字符串 t 中被添加的字母。

## 解题思路

字符串 t 比字符串 s 多了一个随机字母。可以使用哈希表存储一下字符串 s 中各个字符的数量，再遍历一遍字符串 t 中的字符，从哈希表中减去对应数量的字符，最后剩的那一个字符就是多余的字符。

## 代码

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        s_dict = dict()
        for ch in s:
            if ch in s_dict:
                s_dict[ch] += 1
            else:
                s_dict[ch] = 1

        for ch in t:
            if ch in s_dict and s_dict[ch] != 0:
                s_dict[ch] -= 1
            else:
                return ch
```

# [0391. 完美矩形](https://leetcode.cn/problems/perfect-rectangle/)

- 标签：数组、扫描线
- 难度：困难

## 题目链接

- [0391. 完美矩形 - 力扣](https://leetcode.cn/problems/perfect-rectangle/)

## 题目大意

**描述**：给定一个数组 `rectangles`，其中 `rectangles[i] = [xi, yi, ai, bi]` 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 `(xi, yi)`，右上顶点是 `(ai, bi)`。

**要求**：如果所有矩形一起精确覆盖了某个矩形区域，则返回 `True`；否则，返回 `False`。

**说明**：

- $1 \le rectangles.length \le 2 * 10^4$。
- $rectangles[i].length == 4$。
- $-10^5 \le xi, yi, ai, bi \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg)

```python
输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
输出：True
解释：5 个矩形一起可以精确地覆盖一个矩形区域。 
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg)

```python
输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
输出：false
解释：两个矩形之间有间隔，无法覆盖成一个矩形。
```

- 示例 3：

![](https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg)

```python
输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
输出：False
解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。
```


## 解题思路

### 思路 1：线段树

首先我们要先判断所有小矩形的面积和是否等于外接矩形区域的面积。如果不相等，则说明出现了重叠或者空缺，明显不符合题意。

在两者面积相等的情况下，还可能会发生重叠的情况。接下来我们要思考如何判断重叠。

- 第一种思路：暴力枚举所有矩形对，两两进行比较，判断是否出现了重叠。这样的时间复杂度是 $O(n^2)$，容易超时。
- 第二种思路：
  - 如果所有小矩形可以精确覆盖某个矩形区域，那这些小矩形一定是相互挨着的，也就是说相邻两个矩形的边会重合在一起。比如说 矩形 `A` 下边刚好是 `B` 的上边，或者是 `B` 的上边的一部分。
  - 我们可以固定一个坐标轴，比如说固定 `y` 轴，然后只看水平方向上所有矩形的边。然后我们就会发现，满足题意要求的矩形区域中，纵坐标为 `y` 的平行线上，「所有上边纵坐标为 `y` 的矩形上边区间」与「所有下边纵坐标为 `y` 的矩形下边区间」是完全一样，或者说重合在一起的（除了矩形矩形最上边和最下边只有一条，不会重合之外）。
  - 这样我们就可以用扫描线的思路，建立一个线段树。然后先固定纵坐标 `y`，将「所有上边纵坐标为 `y` 的矩形上边区间」对应的区间值减 `1`，再将「所有下边纵坐标为 `y` 的矩形下边区间」对应的区间值加 `1`。然后查询整个线代树区间值，如果区间值超过 `1`，则说明发生了重叠，不符合题目要求。如果扫描完所有的纵坐标，没有发生重叠，则说明符合题意要求。
  - 因为横坐标的范围为 $[-10^5,10^5]$，但是最多只有 $2 * 10^4$ 个横坐标，所以我们可以先对所有坐标做一下离散化处理，再根据离散化之后的横坐标建立线段树。

具体步骤如下：

1. 通过遍历所有小矩形，计算出所有小矩形的面积和为 `area`。同时计算出矩形区域四个顶点位置，并根据四个顶点计算出矩形区域的面积为 `total_area`。如果所有小矩形面积不等于矩形区域的面积，则直接返回 `False`。
2. 再次遍历所有小矩形，将所有坐标点进行离散化处理，将其编号存入两个哈希表 `x_dict`、`y_dict`。
3. 使用哈希表 `top_dict`、`bottom_dict` 分别存储每个矩阵的上下两条边。将上下两条边的横坐标 `x1`、`x2`。分别存入到 `top_dict[y_dict[y2]]`、`top_dict[y_dict[y2]]` 中。
4. 建立区间长度为横坐标个数的线段树 `STree`。
5. 遍历所有的纵坐标，对于纵坐标 `i`：
   1. 先遍历当前纵坐标下矩阵的上边数组，即 `top_dict[i]`，取出边的横坐标 `x1`、`x2`。令区间 `[x1, x2 - 1]` 上的值减 `1`。
   2. 再遍历当前纵坐标下矩阵的下边数组，即 `bottom_dict[i]`，取出边的横坐标 `x1`、`x2`。令区间 `[x1, x2 - 1]` 上的值加 `1`。
   3. 如果上下边覆盖完之后，被覆盖次数超过了 `1`，则说明出现了重叠，直接返回 `Fasle`。
6. 如果遍历完所有的纵坐标，没有发现重叠，则返回 `True`。

### 思路 1：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = None                        # 区间和问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
            
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
        
    # 区间更新接口：将区间为 [q_left, q_right] 上的所有元素值加上 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
    
    
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖        
            if self.tree[index].lazy_tag is not None:
                self.tree[index].lazy_tag += val    # 将当前节点的延迟标记增加 val
            else:
                self.tree[index].lazy_tag = val     # 将当前节点的延迟标记增加 val
            self.tree[index].val += val             # 当前节点所在区间每个元素值增加 val
            return
    
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return
    
        self.__pushdown(index)                      # 向下更新节点的区间值
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if q_left <= mid:                           # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, left_index)
        if q_right > mid:                           # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, right_index)
    
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(index)
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
    
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)
        
    # 向下更新实现方法：更新下标为 index 的节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, index):
        lazy_tag = self.tree[index].lazy_tag
        if lazy_tag is None: 
            return
        
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        
        if self.tree[left_index].lazy_tag is not None:
            self.tree[left_index].lazy_tag += lazy_tag  # 更新左子节点懒惰标记
        else:
            self.tree[left_index].lazy_tag = lazy_tag
        self.tree[left_index].val += lazy_tag
        
        if self.tree[right_index].lazy_tag is not None:
            self.tree[right_index].lazy_tag += lazy_tag # 更新右子节点懒惰标记
        else:
            self.tree[right_index].lazy_tag = lazy_tag
        self.tree[right_index].val += lazy_tag 
        self.tree[index].lazy_tag = None            # 更新当前节点的懒惰标记
        
        
class Solution:
    def isRectangleCover(self, rectangles) -> bool:
        left, right, bottom, top  = math.inf, -math.inf, math.inf, -math.inf
        area = 0
        x_set, y_set = set(), set()
        
        for rectangle in rectangles:
            x1, y1, x2, y2 = rectangle
            left, right = min(left, x1), max(right, x2)
            bottom, top  = min(bottom, y1), max(top, y2)
            area += (y2 - y1) * (x2 - x1)
            x_set.add(x1)
            x_set.add(x2)
            y_set.add(y1)
            y_set.add(y2)
            
        total_area = (top - bottom) * (right - left)
        
        # 判断所有小矩形面积是否等于所有矩形顶点构成最大矩形面积，不等于则直接返回 False
        if area != total_area:
            return False
        
        # 离散化处理所有点的横坐标、纵坐标
        x_dict, y_dict = dict(), dict()
        
        idx = 0
        for x in sorted(list(x_set)):
            x_dict[x] = idx
            idx += 1
            
        idy = 0
        for y in sorted(list(y_set)):
            y_dict[y] = idy
            idy += 1
            
        # 使用哈希表 top_dict、bottom_dict 分别存储每个矩阵的上下两条边。
        bottom_dict, top_dict = collections.defaultdict(list), collections.defaultdict(list)
        for i in range(len(rectangles)):
            x1, y1, x2, y2 = rectangles[i] 
            bottom_dict[y_dict[y1]].append([x_dict[x1], x_dict[x2]])
            top_dict[y_dict[y2]].append([x_dict[x1], x_dict[x2]])
            
        # 建立线段树
        self.STree = SegmentTree([0 for _ in range(len(x_set))], lambda x, y: max(x, y))
        
        for i in range(idy):
            for x1, x2 in top_dict[i]:
                self.STree.update_interval(x1, x2 - 1, -1)
            for x1, x2 in bottom_dict[i]:
                self.STree.update_interval(x1, x2 - 1, 1)
            cnt = self.STree.query_interval(0, len(x_set) - 1)
            if cnt  > 1:
                return False
        return True
```

## 参考资料

- 【题解】[线段树+扫描线 - 完美矩形 - 力扣](https://leetcode.cn/problems/perfect-rectangle/solution/xian-duan-shu-sao-miao-xian-by-lucifer10-raw5/)# [0392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

- 标签：双指针、字符串、动态规划
- 难度：简单

## 题目链接

- [0392. 判断子序列 - 力扣](https://leetcode.cn/problems/is-subsequence/)

## 题目大意

**描述**：给定字符串 $s$ 和 $t$。

**要求**：判断 $s$ 是否为 $t$ 的子序列。

**说明**：

- $0 \le s.length \le 100$。
- $0 \le t.length \le 10^4$。
- 两个字符串都只由小写字符组成。

**示例**：

- 示例 1：

```python
输入：s = "abc", t = "ahbgdc"
输出：True
```

- 示例 2：

```python
输入：s = "axc", t = "ahbgdc"
输出：False
```

## 解题思路

### 思路 1：双指针

使用两个指针 $i$、$j$ 分别指向字符串 $s$ 和 $t$，然后对两个字符串进行遍历。

- 遇到 $s[i] == t[j]$ 的情况，则 $i$ 向右移。
- 不断右移 $j$。
- 如果超过 $s$ 或 $t$ 的长度则跳出。
- 最后判断指针 $i$ 是否指向了 $s$ 的末尾，即：判断 $i$ 是否等于 $s$ 的长度。如果等于，则说明 $s$ 是 $t$ 的子序列，如果不等于，则不是。

### 思路 1：代码

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        size_s = len(s)
        size_t = len(t)
        i, j = 0, 0
        while i < size_s and j < size_t:
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == size_s
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$、$m$ 分别为字符串 $s$、$t$ 的长度。
- **空间复杂度**：$O(1)$。

# [0394. 字符串解码](https://leetcode.cn/problems/decode-string/)

- 标签：栈、递归、字符串
- 难度：中等

## 题目链接

- [0394. 字符串解码 - 力扣](https://leetcode.cn/problems/decode-string/)

## 题目大意

**描述**：给定一个经过编码的字符串 `s`。

**要求**：返回 `s` 经过解码之后的字符串。

**说明**：

- 编码规则：`k[encoded_string]`。`encoded_string` 为字符串，`k` 为整数。表示字符串 `encoded_string` 重复 `k` 次。
- $1 \le s.length \le 30$。
- `s` 由小写英文字母、数字和方括号 `[]` 组成。
- `s` 保证是一个有效的输入。
- `s` 中所有整数的取值范围为 $[1, 300]$。

**示例**：

- 示例 1：

```python
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

- 示例 2：

```python
输入：s = "3[a2[c]]"
输出："accaccacc"
```

## 解题思路

### 思路 1：栈

1. 使用两个栈 `stack1`、`stack2`。`stack1` 用来保存左括号前已经解码的字符串，`stack2` 用来存储左括号前的数字。
2. 用 `res` 存储待解码的字符串、`num` 存储当前数字。
3. 遍历字符串。
   1. 如果遇到数字，则累加数字到 `num`。
   2. 如果遇到左括号，将当前待解码字符串入栈 `stack1`，当前数字入栈 `stack2`，然后将 `res`、`nums` 清空。
   3. 如果遇到右括号，则从 `stack1` 的取出待解码字符串 `res`，从 `stack2` 中取出当前数字 `num`，将其解码拼合成字符串赋值给 `res`。
   4. 如果遇到其他情况（遇到字母），则将当前字母加入 `res` 中。
4. 遍历完输出解码之后的字符串 `res`。

### 思路 1：代码

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack1 = []
        stack2 = []
        num = 0
        res = ""
        for ch in s:
            if ch.isdigit():
                num = num * 10 + int(ch)
            elif ch == '[':
                stack1.append(res)
                stack2.append(num)
                res = ""
                num = 0
            elif ch == ']':
                cur_res = stack1.pop()
                cur_num = stack2.pop()
                res = cur_res + res * cur_num
            else:
                res += ch
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

- 标签：哈希表、字符串、分治、滑动窗口
- 难度：中等

## 题目链接

- [0395. 至少有 K 个重复字符的最长子串 - 力扣](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

## 题目大意

给定一个字符串 `s` 和一个整数 `k`。

要求：找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

注意：`s` 仅由小写英文字母构成。

## 解题思路

这道题看起来很像是常规滑动窗口套路的问题，但是用普通滑动窗口思路无法解决问题。

如果窗口需要保证「各种字符出现次数都大于等于 `k`」这一性质。那么当向右移动 `right`，扩大窗口时，如果 `s[right]` 是第一次出现的元素，窗口内的字符种类数量必然会增加，此时缩小 `s[left]` 也不一定满足窗口内「各种字符出现次数都大于等于 `k`」这一性质。那么我们就无法通过这种方式来进行滑动窗口。

但是我们可以通过固定字符种类数的方式进行滑动窗口。因为给定字符串 `s` 仅有小写字母构成，则最长子串中的字符种类数目，最少为 `1` 种，最多为 `26` 种。我们通过枚举最长子串中可能出现的字符种类数目，从而固定窗口中出现的字符种类数目 `i （1 <= i <= 26）`，再进行滑动数组。窗口内需要保证出现的字符种类数目等于 `i`。向右移动 `right`，扩大窗口时，记录窗口内各种类字符数量。当窗口内出现字符数量大于 `i` 时，则不断右移 `right`，保证窗口内出现字符种类等于 `i`。同时，记录窗口内出现次数小于 `k` 的字符数量，当窗口中出现次数小于 `k` 的字符数量为 `0` 时，就可以记录答案，并维护答案最大值了。

整个算法的具体步骤如下：

- 使用 `ans` 记录满足要求的最长子串长度。

- 枚举最长子串中的字符种类数目 `i`，最小为 `1` 种，最大为 `26` 种。对于给定字符种类数目 `i`：
  - 使用两个指针 `left`、`right` 指向滑动窗口的左右边界。
  - 使用 `window_count` 变量来统计窗口内字符种类数目，保证窗口中的字符种类数目 `window_count` 不多于 `i`。
  - 使用 `letter_map` 哈希表记录窗口中各个字符出现的数目。使用 `less_k_count` 记录窗口内出现次数小于 `k` 次的字符数量。
  - 向右移动 `right`，将最右侧字符 `s[right]` 加入当前窗口，用 `letter_map` 记录该字符个数。
  - 如果该字符第一次出现，即 `letter_map[s[right]] == 1`，则窗口内字符种类数目 + 1，即 `window_count += 1`。同时窗口内小于 `k` 次的字符数量 + 1（等到 `letter_map[s[right]] >= k` 时再减去），即 `less_k_count += 1`。
  - 如果该字符已经出现过 `k` 次，即 `letter_map[s[right]] == k`，则窗口内小于 `k` 次的字符数量 -1，即 `less_k_count -= 1`。
  - 当窗口内字符种类数目 `window_count` 大于给定字符种类数目 `i` 时，即 `window_count > i`，则不断右移 `left`，缩小滑动窗口长度，直到 `window_count == i`。
  - 如果此时窗口内字符种类数目 `window_count` 等于给定字符种类 `i` 并且小于 `k` 次的字符数量为 `0`，即 `window_count == i and less_k_count == 0` 时，维护更新答案为 `ans = max(right - left + 1, ans)`。
- 最后输出答案 `ans`。

## 代码

```python
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        ans = 0
        for i in range(1, 27):
            left, right = 0, 0
            window_count = 0
            less_k_count = 0
            letter_map = dict()
            while right < len(s):
                if s[right] in letter_map:
                    letter_map[s[right]] += 1
                else:
                    letter_map[s[right]] = 1

                if letter_map[s[right]] == 1:
                    window_count += 1
                    less_k_count += 1
                if letter_map[s[right]] == k:
                    less_k_count -= 1

                while window_count > i:
                    letter_map[s[left]] -= 1
                    if letter_map[s[left]] == 0:
                        window_count -= 1
                        less_k_count -= 1
                    if letter_map[s[left]] == k - 1:
                        less_k_count += 1
                    left += 1

                if window_count == i and less_k_count == 0:
                    ans = max(right - left + 1, ans)
                right += 1
        return ans
```

# [0399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

- 标签：深度优先搜索、广度优先搜索、并查集、图、数组、最短路
- 难度：中等

## 题目链接

- [0399. 除法求值 - 力扣](https://leetcode.cn/problems/evaluate-division/)

## 题目大意

**描述**：给定一个变量对数组 $equations$ 和一个实数数组 $values$ 作为已知条件，其中 $equations[i] = [Ai, Bi]$  和 $values[i]$ 共同表示 `Ai / Bi = values[i]`。每个 $Ai$ 或 $Bi$ 是一个表示单个变量的字符串。

再给定一个表示多个问题的数组 $queries$，其中 $queries[j] = [Cj, Dj]$ 表示第 $j$ 个问题，要求：根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

**要求**：返回所有问题的答案。如果某个答案无法确定，则用 $-1.0$ 代替，如果问题中出现了给定的已知条件中没有出现的表示变量的字符串，则也用 $-1.0$ 代替这个答案。

**说明**：

- 未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。
- $1 \le equations.length \le 20$。
- $equations[i].length == 2$。
- $1 \le Ai.length, Bi.length \le 5$。
- $values.length == equations.length$。
- $0.0 < values[i] \le 20.0$。
- $1 \le queries.length \le 20$。
- $queries[i].length == 2$。
- $1 \le Cj.length, Dj.length \le 5$。
- $Ai, Bi, Cj, Dj$ 由小写英文字母与数字组成。

**示例**：

- 示例 1：

```python
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

- 示例 2：

```python
输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
```

## 解题思路

### 思路 1：并查集

在「[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations)」的基础上增加了倍数关系。在「[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations)」中我们处理传递关系使用了并查集，这道题也是一样，不过在使用并查集的同时还要维护倍数关系。

举例说明：

- `a / b = 2.0`：说明 $a == 2b$，$a$ 和 $b$ 在同一个集合。
- `b / c = 3.0`：说明 $b == 3c$，$b$  和 $c$  在同一个集合。

根据上述两式可得：$a$、$b$、$c$ 都在一个集合中，且 $a == 2b == 6c$。

我们可以将同一集合中的变量倍数关系都转换为与根节点变量的倍数关系，比如上述例子中都转变为与 $a$ 的倍数关系。

具体操作如下：

- 定义并查集结构，并在并查集中定义一个表示倍数关系的 $multiples$ 数组。
- 遍历 $equations$ 数组、$values$ 数组，将每个变量按顺序编号，并使用 `union` 将其并入相同集合。
- 遍历 $queries$ 数组，判断两个变量是否在并查集中，并且是否在同一集合。如果找到对应关系，则将计算后的倍数关系存入答案数组，否则则将 $-1$ 存入答案数组。
- 最终输出答案数组。

并查集中维护倍数相关方法说明：

- `find` 方法： 
  - 递推寻找根节点，并将倍数累乘，然后进行路径压缩，并且更新当前节点的倍数关系。
- `union` 方法：
  - 如果两个节点属于同一集合，则直接返回。
  - 如果两个节点不属于同一个集合，合并之前当前节点的倍数关系更新，然后再进行更新。
- `is_connected` 方法：
  - 如果两个节点不属于同一集合，返回 $-1$。
  - 如果两个节点属于同一集合，则返回倍数关系。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.multiples = [1 for _ in range(n)]

    def find(self, x):
        multiple = 1.0
        origin = x
        while x != self.parent[x]:
            multiple *= self.multiples[x]
            x = self.parent[x]
        self.parent[origin] = x
        self.multiples[origin] = multiple
        return x

    def union(self, x, y, multiple):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        self.parent[root_x] = root_y
        self.multiples[root_x] = multiple * self.multiples[y] / self.multiples[x]
        return

    def is_connected(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            return -1.0

        return self.multiples[x] / self.multiples[y]

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        equations_size = len(equations)
        hash_map = dict()
        union_find = UnionFind(2 * equations_size)

        id = 0
        for i in range(equations_size):
            equation = equations[i]
            var1, var2 = equation[0], equation[1]
            if var1 not in hash_map:
                hash_map[var1] = id
                id += 1
            if var2 not in hash_map:
                hash_map[var2] = id
                id += 1
            union_find.union(hash_map[var1], hash_map[var2], values[i])

        queries_size = len(queries)
        res = []
        for i in range(queries_size):
            query = queries[i]
            var1, var2 = query[0], query[1]
            if var1 not in hash_map or var2 not in hash_map:
                res.append(-1.0)
            else:
                id1 = hash_map[var1]
                id2 = hash_map[var2]
                res.append(union_find.is_connected(id1, id2))

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O((m + n) \times \alpha(m + n))$，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(m + n)$。

# [0400. 第 N 位数字](https://leetcode.cn/problems/nth-digit/)

- 标签：数学、二分查找
- 难度：中等

## 题目链接

- [0400. 第 N 位数字 - 力扣](https://leetcode.cn/problems/nth-digit/)

## 题目大意

**描述**：给你一个整数 $n$。

**要求**：在无限的整数序列 $[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]$ 中找出并返回第 $n$ 位上的数字。

**说明**：

- $1 \le n \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：n = 3
输出：3
```

- 示例 2：

```python
输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。
```

## 解题思路

### 思路 1：找规律

数字以 $0123456789101112131415…$ 的格式序列化到一个字符序列中。在这个序列中，第 $5$ 位（从下标 $0$ 开始计数）是 $5$，第 $13$ 位是 $1$，第 $19$ 位是 $4$，等等。

根据题意中的字符串，找数学规律：

- $1$ 位数字有 $9$ 个，共 $9$ 位：$123456789$。
- $2$ 位数字有 $90$ 个，共 $2 \times 90$ 位：$10111213...9899$。
- $3$ 位数字有 $900$ 个，共 $3 \times 900$ 位：$100...999$。
- $4$ 位数字有 $9000$ 个，共 $4 \times 9000$ 位： $1000...9999$。
- $……$

则我们可以按照以下步骤解决这道题：

1. 我们可以先找到第 $n$ 位所在整数 $number$ 所对应的位数 $digit$。
2. 同时找到该位数 $digit$ 的起始整数 $start$。
3. 再计算出 $n$ 所在整数 $number$。$number$ 等于从起始数字 $start$ 开始的第 $\lfloor \frac{n - 1}{digit} \rfloor$ 个数字。即 `number = start + (n - 1) // digit`。
4. 然后确定 $n$ 对应的是数字 $number$ 中的哪一位。即 $digit\underline{\hspace{0.5em}}idx = (n - 1) \mod digit$。
5. 最后返回结果。

### 思路 1：代码

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        digit = 1
        start = 1
        base = 9
        while n > base:
            n -= base
            digit += 1
            start *= 10
            base = start * digit * 9

        number = start + (n - 1) // digit
        digit_idx = (n - 1) % digit
        return int(str(number)[digit_idx])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：二分查找

假设第 $n$ 位数字所在的整数是 $digit$ 位数，我们可以定义一个方法 $totalDigits(x)$ 用于计算所有位数不超过 $x$ 的整数的所有位数和。

根据题意我们可知，所有位数不超过 $digit - 1$ 的整数的所有位数和一定小于 $n$，并且所有不超过 $digit$ 的整数的所有位数和一定大于等于 $n$。

因为所有位数不超过 $x$ 的整数的所有位数和 $totalDigits(x)$  是关于 $x$ 单调递增的，所以我们可以使用二分查找的方式，确定第 $n$ 位数字所在的整数的位数 $digit$。

$n$ 的最大值为 $2^{31} - 1$，约为 $2 \times 10^9$。而 $9$ 位数字有 $9 \times 10^8$ 个，共 $9 \times 9 \times 10^8 = 8.1 \times 10^9 > 2 \times 10 ^ 9$，所以第 $n$ 位所在整数的位数 $digit$ 最多为 $9$ 位，最小为 $1$ 位。即 $digit$ 的取值范围为 $[1, 9]$。

我们使用二分查找算法得到 $digit$ 之后，还可以计算出不超过 $digit - 1$ 的整数的所有位数和 $pre\underline{\hspace{0.5em}}digits = totalDigits(digit - 1)$，则第 $n$ 位数字所在整数在所有 $digit$ 位数中的下标是 $idx = n - pre\underline{\hspace{0.5em}}digits - 1$。

得到下标 $idx$ 后，可以计算出 $n$ 所在整数 $number$。$number$ 等于从起始数字 $10^{digit - 1}$ 开始的第 $\lfloor \frac{idx}{digit} \rfloor$ 个数字。即 `number = 10 ** (digit - 1) + idx // digit`。

该整数 $number$ 中第 $idx \mod digit$ 即为第 $n$ 位上的数字，将其作为答案返回即可。

### 思路 2：代码

```python
class Solution:
    def totalDigits(self, x):
        digits = 0
        digit, cnt = 1, 9
        while digit <= x:
            digits += digit * cnt
            digit += 1
            cnt *= 10
        return digits

    def findNthDigit(self, n: int) -> int:
        left, right = 1, 9
        while left < right:
            mid = left + (right - left) // 2
            if self.totalDigits(mid) < n:
                left = mid + 1
            else:
                right = mid

        digit = left
        pre_digits = self.totalDigits(digit - 1)
        idx = n - pre_digits - 1
        number = 10 ** (digit - 1) + idx // digit
        digit_idx = idx % digit
    
        return int(str(number)[digit_idx])
```

### 思路 2：复杂度分析

- **时间复杂度**：$\log n \times \log \log n$，位数上限 $D$ 为 $\log n$，二分查找的时间复杂度为 $\log D$，每次执行的时间复杂度为 $D$，总的时间复杂度为 $D \times \log D = O(\log n \times \log \log n)$。
- **空间复杂度**：$O(1)$。

## 参考资料

- 【题解】[400. 第 N 位数字 - 清晰易懂的找规律解法(击败100%, 几乎双百)](https://leetcode.cn/problems/nth-digit/solutions/1129463/geekplayers-leetcode-ac-qing-xi-yi-dong-uasjy/)
- 【题解】[400. 第 N 位数字 - 方法一：二分查找](https://leetcode.cn/problems/nth-digit/solutions/1128000/di-n-wei-shu-zi-by-leetcode-solution-mdl2/)
# [0403. 青蛙过河](https://leetcode.cn/problems/frog-jump/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [0403. 青蛙过河 - 力扣](https://leetcode.cn/problems/frog-jump/)

## 题目大意

**描述**：一只青蛙要过河，这条河被等分为若干个单元格，每一个单元格内可能放油一块石子（也可能没有）。青蛙只能跳到有石子的单元格内，不能跳到没有石子的单元格内。

现在给定一个严格按照升序排序的数组 $stones$，其中 $stones[i]$ 代表第 $i$ 块石子所在的单元格序号。默认第 $0$ 块石子序号为 $0$（即 $stones[0] == 0$）。

开始时，青蛙默认站在序号为 $0$ 石子上（即 $stones[0]$），并且假定它第 $1$ 步只能跳跃 $1$ 个单位（即只能从序号为 $0$ 的单元格跳到序号为 $1$ 的单元格）。

如果青蛙在上一步向前跳跃了 $k$ 个单位，则下一步只能向前跳跃 $k - 1$、$k$ 或者 $k + 1$ 个单位。

**要求**：判断青蛙能否成功过河（即能否在最后一步跳到最后一块石子上）。如果能，则返回 `True`；否则，则返回 `False`。

**说明**：

- $2 \le stones.length \le 2000$。
- $0 \le stones[i] \le 2^{31} - 1$。
- $stones[0] == 0$。
- $stones$ 按严格升序排列。

**示例**：

- 示例 1：

```python
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
```

## 解题思路

### 思路 1：动态规划

题目中说：如果青蛙在上一步向前跳跃了 $k$ 个单位，则下一步只能向前跳跃 $k - 1$、$k$ 或者 $k + 1$ 个单位。则下一步的状态可以由 $3$ 种状态转移而来。

- 上一步所在石子到下一步所在石头的距离为 $k - 1$。
- 上一步所在石子到下一步所在石头的距离为 $k$。
- 上一步所在石子到下一步所在石头的距离为 $k + 1$。

则我们可以通过石子块数，跳跃距离来进行阶段划分和定义状态，以及推导状态转移方程。

###### 1. 划分阶段

按照石子块数进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][k]$ 表示为：青蛙能否以长度为 $k$ 的距离，到达第 $i$ 块石子。

###### 3. 状态转移方程

1. 外层循环遍历每一块石子 $i$，对于每一块石子 $i$，使用内层循环遍历石子 $i$ 之前所有的石子 $j$。
2. 并计算出上一步所在石子 $j$  到当前所在石子 $i$ 之间的距离为 $k$。
3. 如果上一步所在石子 $j$ 通过上上一步以长度为 $k - 1$、$k$ 或者 $k + 1$ 的距离到达石子 $j$，那么当前步所在石子也可以通过 $k$ 的距离到达石子 $i$。即通过检查 $dp[j][k - 1]$、$dp[j][k]$、$dp[j][k + 1]$ 中是否至少有一个为真，即可判断 $dp[i][k]$ 是否为真。
   - 即：$dp[i][k] = dp[j][k - 1] \text{ or } dp[j][k] or dp[j][k + 1] $。

###### 4. 初始条件

刚开始青蛙站在序号为 $0$ 石子上（即 $stones[0]$），肯定能以长度为 $0$ 的距离，到达第 $0$ 块石子，即 $dp[0][0] = True$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][k]$ 表示为：青蛙能否以长度为 $k$ 的距离，到达第 $i$ 块石子。则如果 $dp[size - 1][k]$ 为真，则说明青蛙能成功过河（即能在最后一步跳到最后一块石子上）；否则则说明青蛙不能成功过河。

### 思路 1：动态规划代码

```python
class Solution:
    def canCross(self, stones: List[int]) -> bool:
        size = len(stones)

        stone_dict = dict()
        for i in range(size):
            stone_dict[stones[i]] = i

        dp = [[False for _ in range(size + 1)] for _ in range(size)]
        dp[0][0] = True

        for i in range(1, size):
            for j in range(i):
                k = stones[i] - stones[j]
                if k <= 0 or k > j + 1:
                    continue
                
                dp[i][k] = dp[j][k - 1] or dp[j][k] or dp[j][k + 1]

                if dp[size - 1][k]:
                    return True

        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，所以总的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。

## 参考资料

- 【题解】[【403. 青蛙过河】理解理解动态规划与dfs - 青蛙过河 - 力扣](https://leetcode.cn/problems/frog-jump/solution/403-qing-wa-guo-he-li-jie-li-jie-dong-ta-oyt9/)# [0404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0404. 左叶子之和 - 力扣](https://leetcode.cn/problems/sum-of-left-leaves/)

## 题目大意

给定一个二叉树，计算所有左叶子之和。

## 解题思路

深度优先搜索递归遍历二叉树，若当前节点不为空，且左孩子节点不为空，且左孩子节点的左右孩子节点都为空，则该节点的左孩子节点为左叶子节点。将其值累加起来，即为答案。

## 代码

```python
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.ans = 0
        def dfs(node):
            if not node:
                return None
            if node.left and not node.left.left and not node.left.right:
                self.ans += node.left.val
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return self.ans
```

# [0405. 数字转换为十六进制数](https://leetcode.cn/problems/convert-a-number-to-hexadecimal/)

- 标签：位运算、数学
- 难度：简单

## 题目链接

- [0405. 数字转换为十六进制数 - 力扣](https://leetcode.cn/problems/convert-a-number-to-hexadecimal/)

## 题目大意

**描述**：给定一个整数 $num$。

**要求**：编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用「补码运算」方法。

**说明**：

- 十六进制中所有字母（$a \sim f$）都必须是小写。
- 十六进制字符串中不能包含多余的前导零。如果要转化的数为 $0$，那么以单个字符 $0$ 来表示。
- 对于其他情况，十六进制字符串中的第一个字符将不会是 $0$ 字符。 
- 给定的数确保在 $32$ 位有符号整数范围内。
- 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

**示例**：

- 示例 1：

```python
输入:
26

输出:
"1a"
```

- 示例 2：

```python
输入:
-1

输出:
"ffffffff"
```

## 解题思路

### 思路 1：模拟

主要是对不同情况的处理。

- 当 $num$ 为 0 时，直接返回 $0$。
- 当 $num$ 为负数时，对负数进行「补码运算」，转换为对应的十进制正数（将其绝对值与 $2^{32} - 1$ 异或再加 1），然后执行和 $nums$ 为正数一样的操作。
- 当 $num$ 为正数时，将其对 $16$ 取余，并转为对应的十六进制字符，并按位拼接到字符串中，再将 $num$ 除以 $16$，继续对 $16$ 取余，直到 $num$ 变为为 0。
- 最后将拼接好的字符串逆序返回就是答案。

### 思路 1：代码

```python
class Solution:
    def toHex(self, num: int) -> str:
        res = ''
        if num == 0:
            return '0'
        
        if num < 0:
            num = (abs(num) ^ (2 ** 32 - 1)) + 1
        
        while num:
            digit = num % 16
            if digit >= 10:
                digit = chr(ord('a') + digit - 10)
            else:
                digit = str(digit)
            res += digit
            num >>= 4
        return res[::-1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(C)$，其中 $C$ 为构造的十六进制数的长度。
- **空间复杂度**：$O(C)$。

# [0406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

- 标签：贪心、树状数组、线段树、数组、排序
- 难度：中等

## 题目链接

- [0406. 根据身高重建队列 - 力扣](https://leetcode.cn/problems/queue-reconstruction-by-height/)

## 题目大意

n 个人打乱顺序排成一排，给定一个数组 people 表示队列中人的属性（顺序是打乱的）。其中 $people[i] = [h_i, k_i]$ 表示第 i 个人的身高为 $h_i$，前面正好有 $k_i$ 个身高大于或等于 $h_i$ 的人。

现在重新构造并返回输入数组 people 所表示的队列 queue。其中 $queue[j] = [h_j, k_j]$ 是队列中第 j 个人的信息，表示为身高为 $h_j$，前面正好有 $k_j$ 个身高大于或等于 $h_j$​ 的人。

## 解题思路

这道题目有两个维度，身高 $h_j$ 和满足条件的数量 $k_j$。进行排序的时候如果同时考虑两个维度条件，就有点复杂了。我们可以考虑固定一个维度，先排好序，再考虑另一个维度的要求。

我们可以先确定身高维度。将数组按身高从高到低进行排序，身高相同的则按照 k 值升序排列。这样排序之后可以确定目前对于第 j 个人来说，前面的 j - 1 个人肯定比他都高。

然后建立一个包含 n 个位置的空队列 queue，按照上边排好的顺序遍历，依次将其插入到第 $k_j$​ 位置上。最后返回新的队列。

## 代码

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        queue = []
        people.sort(key = lambda x: (-x[0], x[1]))
        for p in people:
            queue.insert(p[1], p)
        return queue
```

# [0409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/)

- 标签：贪心、哈希表、字符串
- 难度：简单

## 题目链接

- [0409. 最长回文串 - 力扣](https://leetcode.cn/problems/longest-palindrome/)

## 题目大意

给定一个包含大写字母和小写字母的字符串 `s`。

要求：找到通过这些字母构造成的最长的回文串。

注意：

- 在构造过程中，请注意区分大小写。比如 `Aa` 不能当做一个回文字符串。
- 假设字符串的长度不会超过 `1010`。

## 解题思路

这道题目是通过给定字母构造回文串，并找到最长的回文串长度。那就要先看看回文串的特点。在回文串中，最多只有一个字母出现过奇数次，其余字符都出现过偶数次。且相同字母是中心对称的。

则我们可以用哈希表统计字符出现次数。对于每个字符，使用尽可能多的偶数次字符作为回文串的两侧，并记录下使用的字符个数，记录到答案中。再使用一个 `flag` 标记下是否有奇数次的字符，如果有的话，最终答案再加 1。最后输出答案。

## 代码

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        word_dict = dict()
        for ch in s:
            if ch in word_dict:
                word_dict[ch] += 1
            else:
                word_dict[ch] = 1

        ans = 0
        flag = False
        for value in word_dict.values():
            ans += value // 2 * 2
            if value % 2 == 1:
                flag = True

        if flag:
            ans += 1

        return ans
```

# [0410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

- 标签：贪心、数组、二分查找、动态规划、前缀和
- 难度：困难

## 题目链接

- [0410. 分割数组的最大值 - 力扣](https://leetcode.cn/problems/split-array-largest-sum/)

## 题目大意

**描述**：给定一个非负整数数组 $nums$ 和一个整数 $k$，将数组分成 $m$ 个非空的连续子数组。

**要求**：使 $m$ 个子数组各自和的最大值最小，并求出子数组各自和的最大值。

**说明**：

- $1 \le nums.length \le 1000$。
- $0 \le nums[i] \le 10^6$。
- $1 \le k \le min(50, nums.length)$。

**示例**：

- 示例 1：

```python
输入：nums = [7,2,5,10,8], k = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

- 示例 2：

```python
输入：nums = [1,2,3,4,5], k = 2
输出：9
```

## 解题思路

### 思路 1：二分查找算法

先来理解清楚题意。题目的目的是使得 $m$ 个连续子数组各自和的最大值最小。意思是将数组按顺序分成 $m$ 个子数组，然后计算每个子数组的和，然后找出 $m$ 个和中的最大值，要求使这个最大值尽可能小。最后输出这个尽可能小的和最大值。

可以用二分查找来找这个子数组和的最大值，我们用 $ans$ 来表示这个值。$ans$ 最小为数组 $nums$ 所有元素的最大值，最大为数组 $nums$ 所有元素的和。即 $ans$ 范围是 $[max(nums), sum(nums)]$。

所以就确定了二分查找的两个指针位置。$left$ 指向 $max(nums)$，$right$ 指向 $sum(nums)$。然后取中间值 $mid$，计算当子数组和的最大值为 mid 时，所需要分割的子数组最少个数。

- 如果需要分割的子数组最少个数大于 $m$ 个，则说明子数组和的最大值取小了，不满足条件，应该继续调大，将 $left$ 右移，从右区间继续查找。
- 如果需要分割的子数组最少个数小于或等于 $m$ 个，则说明子数组和的最大值满足条件，并且还可以继续调小，将 $right$ 左移，从左区间继续查找，看是否有更小的数组和满足条件。
- 最终，返回符合条件的最小值即可。

### 思路 1：代码

```python
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def get_count(x):
            total = 0
            count = 1
            for num in nums:
                if total + num > x:
                    count += 1
                    total = num
                else:
                    total += num
            return count

        left = max(nums)
        right = sum(nums)
        while left < right:
            mid = left + (right - left) // 2
            if get_count(mid) > m:
                left = mid + 1
            else:
                right = mid
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log (\sum nums))$，其中 $n$ 为数组中的元素个数。
- **空间复杂度**：$O(1)$。

# [0412. Fizz Buzz](https://leetcode.cn/problems/fizz-buzz/)

- 标签：数学、字符串、模拟
- 难度：简单

## 题目链接

- [0412. Fizz Buzz - 力扣](https://leetcode.cn/problems/fizz-buzz/)

## 题目大意

给定一个整数 n，按照规则，输出 1~n 的字符串表示。

规则：

- 如果 i 是 3 的倍数，输出 "Fizz"；
- 如果 i 是 5 的倍数，输出 "Buzz"；
- 如果 i 是 3 和 5 的倍数，则输出 "FizzBuzz"。

## 解题思路

简单题，按照题目规则输出即可。

## 代码

```python
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        ans = []
        for i in range(1,n+1):
            if i % 15 == 0:
                ans.append("FizzBuzz")
            elif i % 3 == 0:
                ans.append("Fizz")
            elif i % 5 == 0:
                ans.append("Buzz")
            else:
                ans.append(str(i))
        return ans
```

# [0415. 字符串相加](https://leetcode.cn/problems/add-strings/)

- 标签：数学、字符串、模拟
- 难度：简单

## 题目链接

- [0415. 字符串相加 - 力扣](https://leetcode.cn/problems/add-strings/)

## 题目大意

**描述**：给定两个字符串形式的非负整数 `num1` 和`num2`。

**要求**：计算它们的和，并同样以字符串形式返回。

**说明**：

- $1 \le num1.length, num2.length \le 10^4$。
- $num1$ 和 $num2$ 都只包含数字 $0 \sim 9$。
- $num1$ 和 $num2$ 都不包含任何前导零。
- 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。

**示例**：

- 示例 1：

```python
输入：num1 = "11", num2 = "123"
输出："134"
```

- 示例 2：

```python
输入：num1 = "456", num2 = "77"
输出："533"
```

## 解题思路

### 思路 1：双指针

需要用字符串的形式来模拟大数加法。

加法的计算方式是：从个位数开始，由低位到高位，按位相加，如果相加之后超过 `10`，就需要向前进位。

模拟加法的做法是：

1. 用一个数组存储按位相加后的结果，每一位对应一位数。
2. 然后分别使用一个指针变量，对两个数 `num1`、`num2` 字符串进行反向遍历，将相加后的各个位置上的结果保存在数组中，这样计算完成之后就得到了一个按位反向的结果。
3. 最后返回结果的时候将数组反向转为字符串即可。

注意需要考虑 `num1`、`num2` 不等长的情况，让短的那个字符串对应位置按 $0$ 计算即可。

### 思路 1：代码

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # num1 位数
        digit1 = len(num1) - 1
        # num2 位数
        digit2 = len(num2) - 1

        # 进位
        carry = 0
        # sum 存储反向结果
        sum = []
        # 逆序相加
        while carry > 0 or digit1 >= 0 or digit2 >= 0:
            # 获取对应位数上的数字
            num1_d = int(num1[digit1]) if digit1 >= 0 else 0
            num2_d = int(num2[digit2]) if digit2 >= 0 else 0
            digit1 -= 1
            digit2 -= 1
            # 计算结果，存储，进位
            num = num1_d+num2_d+carry
            sum.append('%d'%(num%10))
            carry = num // 10
        # 返回计算结果
        return "".join(sum[::-1])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(max(m + n))$。其中 $m$ 是字符串 $num1$ 的长度，$n$ 是字符串 $num2$ 的长度。
- **空间复杂度**：$O(max(m + n))$。# [0416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0416. 分割等和子集 - 力扣](https://leetcode.cn/problems/partition-equal-subset-sum/)

## 题目大意

**描述**：给定一个只包含正整数的非空数组 $nums$。

**要求**：判断是否可以将这个数组分成两个子集，使得两个子集的元素和相等。

**说明**：

- $1 \le nums.length \le 200$。
- $1 \le nums[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11]。
```

- 示例 2：

```python
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

## 解题思路

### 思路 1：动态规划

这道题换一种说法就是：从数组中选择一些元素组成一个子集，使子集的元素和恰好等于整个数组元素和的一半。

这样的话，这道题就可以转变为「0-1 背包问题」。

1. 把整个数组中的元素和记为 $sum$，把元素和的一半 $target = \frac{sum}{2}$ 看做是「0-1 背包问题」中的背包容量。
2. 把数组中的元素 $nums[i]$ 看做是「0-1 背包问题」中的物品。
3. 第 $i$ 件物品的重量为 $nums[i]$，价值也为 $nums[i]$。
4. 因为物品的重量和价值相等，如果能装满载重上限为 $target$ 的背包，那么得到的最大价值也应该是 $target$。

这样问题就转变为：给定一个数组 $nums$ 代表物品，数组元素和的一半 $target = \frac{sum}{2}$ 代表背包的载重上限。其中第 $i$ 件物品的重量为 $nums[i]$，价值为 $nums[i]$，每件物品有且只有 $1$ 件。请问在总重量不超过背包装载重量上限的情况下，能否将背包装满从而得到最大价值？

###### 1. 划分阶段

当前背包的载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：从数组 $nums$ 中选择一些元素，放入最多能装元素和为 $w$ 的背包中，得到的元素和最大为多少。

###### 3. 状态转移方程

$dp[w] = \begin{cases} dp[w] & w < nums[i - 1] \cr max \lbrace dp[w], \quad dp[w - nums[i - 1]] + nums[i - 1] \rbrace & w \ge nums[i - 1] \end{cases}$

###### 4. 初始条件

- 无论背包载重上限为多少，只要不选择物品，可以获得的最大价值一定是 $0$，即 $dp[w] = 0, 0 \le w \le W$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[target]$ 表示为：从数组 $nums$ 中选择一些元素，放入最多能装元素和为 $target = \frac{sum}{2}$ 的背包中，得到的元素和最大值。 

所以最后判断一下 $dp[target]$ 是否等于 $target$。如果 $dp[target] == target$，则说明集合中的子集刚好能够凑成总和 $target$，此时返回 `True`；否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    # 思路 2：动态规划 + 滚动数组优化
    def zeroOnePackMethod2(self, weight: [int], value: [int], W: int):
        size = len(weight)
        dp = [0 for _ in range(W + 1)]
        
        # 枚举前 i 种物品
        for i in range(1, size + 1):
            # 逆序枚举背包装载重量（避免状态值错误）
            for w in range(W, weight[i - 1] - 1, -1):
                # dp[w] 取「前 i - 1 件物品装入载重为 w 的背包中的最大价值」与「前 i - 1 件物品装入载重为 w - weight[i - 1] 的背包中，再装入第 i - 1 物品所得的最大价值」两者中的最大值
                dp[w] = max(dp[w], dp[w - weight[i - 1]] + value[i - 1])
                
        return dp[W]

    def canPartition(self, nums: List[int]) -> bool:
        sum_nums = sum(nums)
        if sum_nums & 1:
            return False

        target = sum_nums // 2
        return self.zeroOnePackMethod2(nums, nums, target) == target
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times target)$，其中 $n$ 为数组 $nums$ 的元素个数，$target$ 是整个数组元素和的一半。
- **空间复杂度**：$O(target)$。

# [0417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

- 标签：深度优先搜索、广度优先搜索、数组、矩阵
- 难度：中等

## 题目链接

- [0417. 太平洋大西洋水流问题 - 力扣](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

## 题目大意

**描述**：给定一个 `m * n` 大小的二维非负整数矩阵 `heights` 来表示一片大陆上各个单元格的高度。`heights[i][j]` 表示第 `i` 行第 `j` 列所代表的陆地高度。这个二维矩阵所代表的陆地被太平洋和大西洋所包围着。左上角是「太平洋」，右下角是「大西洋」。规定水流只能按照上、下、左、右四个方向流动，且只能从高处流到低处，或者在同等高度上流动。

**要求**：找出代表陆地的二维矩阵中，水流既可以从该处流动到太平洋，又可以流动到大西洋的所有坐标。以二维数组 `res` 的形式返回，其中 `res[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 既可流向太平洋也可流向大西洋。

**说明**：

- $m == heights.length$。
- $n == heights[r].length$。
- $1 \le m, n \le 200$。
- $0 \le heights[r][c] \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```python
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

- 示例 2：

```python
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

## 解题思路

### 思路 1：深度优先搜索

雨水由高处流向低处，如果我们根据雨水的流向搜索，来判断是否能从某一位置流向太平洋和大西洋不太容易。我们可以换个思路。

1. 分别从太平洋和大西洋（就是矩形边缘）出发，逆流而上，找出水流逆流能达到的地方，可以用两个二维数组 `pacific`、`atlantic` 分别记录太平洋和大西洋能到达的位置。
2. 然后再对二维数组进行一次遍历，找出两者交集的位置，就是雨水既可流向太平洋也可流向大西洋的位置，将其加入答案数组 `res` 中。
3. 最后返回答案数组 `res`。

### 思路 1：代码

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        rows, cols = len(heights), len(heights[0])
        pacific = [[False for _ in range(cols)] for _ in range(rows)]
        atlantic = [[False for _ in range(cols)] for _ in range(rows)]

        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def dfs(i, j, visited):
            visited[i][j] = True
            for direct in directs:
                new_i = i + direct[0]
                new_j = j + direct[1]
                if new_i < 0 or new_i >= rows or new_j < 0 or new_j >= cols:
                    continue
                if heights[new_i][new_j] >= heights[i][j] and not visited[new_i][new_j]:
                    dfs(new_i, new_j, visited)

        for j in range(cols):
            dfs(0, j, pacific)
            dfs(rows - 1, j, atlantic)

        for i in range(rows):
            dfs(i, 0, pacific)
            dfs(i, cols - 1, atlantic)

        res = []
        for i in range(rows):
            for j in range(cols):
                if pacific[i][j] and atlantic[i][j]:
                    res.append([i, j])
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(m \times n)$。# [0421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

- 标签：位运算、字典树、数组、哈希表
- 难度：中等

## 题目链接

- [0421. 数组中两个数的最大异或值 - 力扣](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

## 题目大意

给定一个整数数组 `nums`。

要求：返回 `num[i] XOR nums[j]` 的最大运算结果。其中 `0 ≤ i ≤ j < n`。

## 解题思路

最直接的想法暴力求解。两层循环计算两两之间的异或结果，记录并更新最大异或结果。

更好的做法可以减少一重循环。首先，要取得异或结果的最大值，那么从二进制的高位到低位，尽可能的让每一位异或结果都为 `1`。

将数组中所有数字的二进制形式从高位到低位依次存入字典树中。然后是利用异或运算交换律：如果 `a ^ b = max` 成立，那么 `a ^ max = b` 与 `b ^ max = a` 均成立。这样当我们知道 `a` 和 `max` 时，可以通过交换律求出 `b`。`a` 是我们遍历的每一个数，`max` 是我们想要尝试的最大值，从 `111111...` 开始，从高位到低位依次填 `1`。

对于 `a` 和 `max`，如果我们所求的 `b` 也在字典树中，则表示 `max` 是可以通过 `a` 和 `b` 得到的，那么 `max` 就是所求最大的异或。如果 `b` 不在字典树中，则减小 `max` 值继续判断，或者继续查询下一个 `a`。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, num: int, max_bit: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for i in range(max_bit, -1, -1):
            bit = num >> i & 1
            if bit not in cur.children:
                cur.children[bit] = Trie()
            cur = cur.children[bit]
        cur.isEnd = True

    def search(self, num: int, max_bit: int) -> int:
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = 0
        for i in range(max_bit, -1, -1):
            bit = num >> i & 1
            if 1 - bit not in cur.children:
                res = res * 2
                cur = cur.children[bit]
            else:
                res = res * 2 + 1
                cur = cur.children[1 - bit]
        return res

class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        trie_tree = Trie()
        max_bit = len(format(max(nums), 'b')) - 1
        ans = 0
        for num in nums:
            trie_tree.insert(num, max_bit)
            ans = max(ans, trie_tree.search(num, max_bit))
            
        return ans
```



# [0424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0424. 替换后的最长重复字符 - 力扣](https://leetcode.cn/problems/longest-repeating-character-replacement/)

## 题目大意

**描述**：给定一个仅由大写英文字母组成的字符串 $s$，以及一个整数 $k$。可以将任意位置上的字符替换成另外的大写字母，最多可替换 $k$ 次。

**要求**：在进行上述操作后，找到包含重复字母的最长子串长度。

**说明**：

- $1 \le s.length \le 10^5$。
- $s$ 仅由大写英文字母组成。
- $0 \le k \le s.length$。

**示例**：

- 示例 1：

```python
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

- 示例 2：

```python
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
```

## 解题思路

先来考虑暴力求法。枚举字符串 s 的所有子串，对于每一个子串：

- 统计子串中出现次数最多的字符，替换除它以外的字符 k 次。
- 维护最长子串的长度。

但是这种暴力求法中，枚举子串的时间复杂度为 $O(n^2)$，统计出现次数最多的字符和替换字符时间复杂度为 $0(n)$，且两者属于平行处理，总体下来的时间复杂度为 $O(n^3)$。这样做会超时。

### 思路 1：滑动窗口

1. 使用 counts 数组来统计字母频数。使用 left、right 双指针分别指向滑动窗口的首尾位置，使用 max_count 来维护最长子串的长度。
2. 不断右移 right 指针，增加滑动窗口的长度。
3. 对于当前滑动窗口的子串，如果当前窗口的间距 > 当前出现最大次数的字符的次数 + k 时，意味着替换 k 次仍不能使当前窗口中的字符全变为相同字符，则此时应该将左边界右移，同时将原先左边界的字符频次减少。

### 思路 1：代码

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        max_count = 0
        left, right = 0, 0
        counts = [0 for _ in range(26)]
        while right < len(s):
            num_right = ord(s[right]) - ord('A')
            counts[num_right] += 1
            max_count = max(max_count, counts[num_right])
            right += 1
            if right - left > max_count + k:
                num_left = ord(s[left]) - ord('A')
                counts[num_left] -= 1
                left += 1

        return right - left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串的长度。
- **空间复杂度**：$O(|\sum|)$，其中 $\sum$ 是字符集，本题中 $| \sum | = 26$。

# [0425. 单词方块](https://leetcode.cn/problems/word-squares/)

- 标签：字典树、数组、字符串、回溯
- 难度：困难

## 题目链接

- [0425. 单词方块 - 力扣](https://leetcode.cn/problems/word-squares/)

## 题目大意

给定一个单词集合 `words`（没有重复）。

要求：找出其中所有的单词方块 。

- 单词方块：指从第 `k` 行和第 `k` 列 `(0 ≤ k < max(行数, 列数))` 来看都是相同的字符串。

例如，单词序列 ["ball","area","lead","lady"] 形成了一个单词方块，因为每个单词从水平方向看和从竖直方向看都是相同的。

```
b a l l
a r e a
l e a d
l a d y
```

## 解题思路

根据单词方块的第一个单词，可以推出下一个单词的前缀。

比如第一个单词是 `ball`，那么单词方块的长度是 `4 * 4`，则下一个单词（第二个单词）的前缀为 `a`。这样我们就又找到了一个以 `a` 为前缀且长度为 `4` 的单词，即 `area`，此时就变成了 `[ball, area]`。

那么下一个单词（第三个单词）的前缀为 `le`。这样我们就又找到了一个以 `le` 为前缀且长度为 `4` 的单词，即 `lead`。此时就变成了 `[ball, area, lead]`。

以此类推，就可以得到整个单词方块。

并且我们可以使用字典树（前缀树）来存储单词，并且通过回溯得到所有的解。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str):
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = []
        for ch in word:
            if ch not in cur.children:
                return res
            cur = cur.children[ch]
        cur.dfs(word, res)
        return res

    def dfs(self, word, res):
        cur = self
        if cur and cur.isEnd:
            res.append(word)
            return
        for ch in cur.children:
            node = cur.children[ch]
            node.dfs(word + ch, res)


class Solution:

    def backtrace(self, index, size, path, res, trie_tree):
        if index == size:
            res.append(path[:])
            return
        next_prefix = ""  # 下一行的前缀
        for i in range(index):
            next_prefix += path[i][index]

        next_words_with_prefix = trie_tree.search(next_prefix)
        for word in next_words_with_prefix:
            path.append(word)
            self.backtrace(index + 1, size, path, res, trie_tree)
            path.pop(-1)


    def wordSquares(self, words: List[str]) -> List[List[str]]:
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)
        size = len(words[0])
        res = []
        path = []
        for word in words:
            path.append(word)
            self.backtrace(1, size, path, res, trie_tree)
            path.pop(-1)
        return res
```

# [0426. 将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)

- 标签：栈、树、深度优先搜索、二叉搜索树、链表、二叉树、双向链表
- 难度：中等

## 题目链接

- [0426. 将二叉搜索树转化为排序的双向链表 - 力扣](https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：将这棵二叉树转换为一个已排序的双向循环链表。要求不能创建新的节点，只能调整树中节点指针的指向。

## 解题思路

通过中序递归遍历可以将二叉树升序排列输出。这道题需要在中序遍历的同时，将节点的左右指向进行改变。使用 `head`、`tail` 存放双向链表的头尾节点，然后从根节点开始，进行中序递归遍历。

具体做法如下：

- 如果当前节点为空，直接返回。
- 如果当前节点不为空：
  - 递归遍历左子树。
  - 如果尾节点不为空，则将尾节点与当前节点进行连接。
  - 如果尾节点为空，则初始化头节点。
  - 将当前节点标记为尾节点。
  - 递归遍历右子树。
- 最后将头节点和尾节点进行连接。

## 代码

```python
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(node: 'Node'):
            if not node:
                return

            dfs(node.left)
            if self.tail:
                self.tail.right = node
                node.left = self.tail
            else:
                self.head = node
            self.tail = node
            dfs(node.right)

        if not root:
            return None

        self.head, self.tail = None, None
        dfs(root)
        self.head.left = self.tail
        self.tail.right = self.head
        return self.head
```

# [0428. 序列化和反序列化 N 叉树](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、字符串
- 难度：困难

## 题目链接

- [0428. 序列化和反序列化 N 叉树 - 力扣](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/)

## 题目大意

要求：设计一个序列化和反序列化 N 叉树的算法。序列化 / 反序列化算法的算法实现没有限制。你只需要保证 N 叉树可以被序列化为一个字符串并且该字符串可以被反序列化成原树结构即可。

- 序列化是指将一个数据结构转化为位序列的过程，因此可以将其存储在文件中或内存缓冲区中，以便稍后在相同或不同的计算机环境中恢复结构。
- N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。

## 解题思路

- 序列化：通过深度优先搜索的方式，递归遍历节点，以 `root.val`、`len(root.children)`、`root.children` 的顺序生成序列化结果，并用 `-` 链接，返回结果字符串。
- 反序列化：先将字符串按 `-` 分割成数组。然后按照 `root.val`、`len(root.children)`、`root.children` 的顺序解码，并建立对应节点。最后返回根节点。



## 代码

```python
class Codec:
    def serialize(self, root: 'Node') -> str:
        """Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        """
        if not root:
            return 'None'

        data = str(root.val) + '-' + str(len(root.children))
        for child in root.children:
            data += '-' + self.serialize(child)
        return data
        
    
    def deserialize(self, data: str) -> 'Node':
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        """
        datalist = data.split('-')
        return self.dfs(datalist)

    def dfs(self, datalist):
        val = datalist.pop(0)
        if val == 'None':
            return None
        root = Node(int(val))
        root.children = []

        size = int(datalist.pop(0))
        for _ in range(size):
            root.children.append(self.dfs(datalist))
        return root
```

# [0429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

- 标签：树、广度优先搜索
- 难度：中等

## 题目链接

- [0429. N 叉树的层序遍历 - 力扣](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

## 题目大意

给定一个 N 叉树的根节点 `root`。

要求：返回其节点值的层序遍历（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔。

## 解题思路

和二叉树的层序遍历类似。广度优先搜索每次取出第 `i` 层上所有元素。具体步骤如下：

- 根节点入队。
- 当队列不为空时，求出当前队列长度 $size$。
  - 依次从队列中取出这 $size$ 个元素，并将元素值存入当前层级列表 `level` 中。
  - 将该层所有节点的所有孩子节点入队，遍历完之后将这层节点数组加入答案数组中，然后继续迭代。
- 当队列为空时，结束。

## 代码

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        ans = []
        if not root:
            return ans

        queue = [root]
        
        while queue:
            level = []
            size = len(queue)
            for _ in range(size):
                cur = queue.pop(0)
                level.append(cur.val)
                for child in cur.children:
                    queue.append(child)
            ans.append(level)

        return ans
```

# [0430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/)

- 标签：深度优先搜索、链表、双向链表
- 难度：中等

## 题目链接

- [0430. 扁平化多级双向链表 - 力扣](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/)

## 题目大意

给定一个带子链表指针 child 的双向链表，将 child 的子链表进行扁平化处理，使所有节点出现在单级双向链表中。

扁平化处理如下：

```
原链表：
1---2---3---4---5---6--NULL
        |
        7---8---9---10--NULL
            |
            11--12--NULL
扁平化之后：
1---2---3---7---8---11---12---9---10---4---5---6--NULL
```



## 解题思路

递归处理多层链表的扁平化。遍历链表，找到 child 非空的节点， 将其子链表链接到当前节点的 next 位置（自身扁平化处理）。然后继续向后遍历，不断找到 child 节点，并进行链接。直到处理到尾部位置。

## 代码

```python
class Solution:
    def dfs(self, node: 'Node'):
        # 找到链表的尾节点或 child 链表不为空的节点
        while node.next and not node.child:
            node = node.next
        tail = None
        if node.child:
            # 如果 child 链表不为空，将 child 链表扁平化
            tail = self.dfs(node.child)

            # 将扁平化的 child 链表链接在该节点之后
            temp = node.next
            node.next = node.child
            node.next.prev = node
            node.child = None
            tail.next = temp
            if temp:
                temp.prev = tail
            # 链接之后，从 child 链表的尾节点继续向后处理链表
            return self.dfs(tail)
        # child 链表为空，则该节点是尾节点，直接返回
        return node
    def flatten(self, head: 'Node') -> 'Node':
        if not head:
            return head
        self.dfs(head)
        return head
```

# [0435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

- 标签：贪心、数组、动态规划、排序
- 难度：中等

## 题目链接

- [0435. 无重叠区间 - 力扣](https://leetcode.cn/problems/non-overlapping-intervals/)

## 题目大意

**描述**：给定一个区间的集合 `intervals`，其中 `intervals[i] = [starti, endi]`。从集合中移除部分区间，使得剩下的区间互不重叠。

**要求**：返回需要移除区间的最小数量。

**说明**：

- $1 \le intervals.length \le 10^5$。
- $intervals[i].length == 2$。
- $-5 * 10^4 \le starti < endi \le 5 * 10^4$。

**示例**：

- 示例 1：

```python
输入：intervals = [[1,2],[2,3],[3,4],[1,3]]
输出：1
解释：移除 [1,3] 后，剩下的区间没有重叠。
```

- 示例 2：

```python
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

## 解题思路

### 思路 1：贪心算法

这道题我们可以转换一下思路。原题要求保证移除区间最少，使得剩下的区间互不重叠。换个角度就是：「如何使得剩下互不重叠区间的数目最多」。那么答案就变为了：「总区间个数 - 不重叠区间的最多个数」。我们的问题也变成了求所有区间中不重叠区间的最多个数。

从贪心算法的角度来考虑，我们应该将区间按照结束时间排序。每次选择结束时间最早的区间，然后再在剩下的时间内选出最多的区间。

我们用贪心三部曲来解决这道题。

1. **转换问题**：将原问题转变为，当选择结束时间最早的区间之后，再在剩下的时间内选出最多的区间（子问题）。
2. **贪心选择性质**：每次选择时，选择结束时间最早的区间。这样选出来的区间一定是原问题最优解的区间之一。
3. **最优子结构性质**：在上面的贪心策略下，贪心选择当前时间最早的区间 + 剩下的时间内选出最多区间的子问题最优解，就是全局最优解。也就是说在贪心选择的方案下，能够使所有区间中不重叠区间的个数最多。

使用贪心算法的代码解决步骤描述如下：

1. 将区间集合按照结束坐标升序排列，然后维护两个变量，一个是当前不重叠区间的结束时间 `end_pos`，另一个是不重叠区间的个数 `count`。初始情况下，结束坐标 `end_pos` 为第一个区间的结束坐标，`count` 为 `1`。
2. 依次遍历每段区间。对于每段区间：`intervals[i]`：
   1. 如果 `end_pos <= intervals[i][0]`，即 `end_pos` 小于等于区间起始位置，则说明出现了不重叠区间，令不重叠区间数 `count` 加 `1`，`end_pos` 更新为新区间的结束位置。
3. 最终返回「总区间个数 - 不重叠区间的最多个数」即 `len(intervals) - count` 作为答案。

### 思路 1：代码

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        intervals.sort(key=lambda x: x[1])
        end_pos = intervals[0][1]
        count = 1
        for i in range(1, len(intervals)):
            if end_pos <= intervals[i][0]:
                count += 1
                end_pos = intervals[i][1]

        return len(intervals) - count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 是区间的数量。
- **空间复杂度**：$O(\log n)$。
# [0437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0437. 路径总和 III - 力扣](https://leetcode.cn/problems/path-sum-iii/)

## 题目大意

给定一个二叉树的根节点 `root`，和一个整数 `sum`。

要求：求出该二叉树里节点值之和等于 `sum` 的路径的数目。

- 路径：不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

## 解题思路

直观想法是：

以每一个节点 `node` 为起始节点，向下检测延伸的路径。递归遍历每一个节点所有可能的路径，然后将这些路径数目加起来即为答案。

但是这样会存在许多重复计算。我们可以定义节点的前缀和来减少重复计算。

- 节点的前缀和：从根节点到当前节点路径上所有节点的和。

有了节点的前缀和，我们就可以通过前缀和来计算两节点之间的路劲和。即：`则两节点之间的路径和 = 两节点之间的前缀和之差`。

为了计算符合要求的路径数量，我们用哈希表存储「前缀和的节点数量」。哈希表以「当前节点的前缀和」为键，以「该前缀和的节点数量」为值。这样就能通过哈希表直接计算出符合要求的路径数量，从而累加到答案上。

整个算法的具体步骤如下：

- 通过先序遍历方式递归遍历二叉树，计算每一个节点的前缀和 `cur_sum`。
- 从哈希表中取出 `cur_sum - sum` 的路径数量（也就是表示存在从前缀和为 `cur_sum - sum` 所对应的节点到前缀和为 `cur_sum` 所对应的节点的路径个数）累加到答案 `res` 中。
- 然后以「当前节点的前缀和」为键，以「该前缀和的节点数量」为值，存入哈希表中。
- 递归遍历二叉树，并累加答案值。
- 恢复哈希表「当前前缀和的节点数量」，返回答案。

## 代码

```python
class Solution:
    prefixsum_count = dict()

    def dfs(self, root, prefixsum_count, target_sum, cur_sum):
        if not root:
            return 0
        res = 0
        cur_sum += root.val
        res += prefixsum_count.get(cur_sum - target_sum, 0)
        prefixsum_count[cur_sum] = prefixsum_count.get(cur_sum, 0) + 1

        res += self.dfs(root.left, prefixsum_count, target_sum, cur_sum)
        res += self.dfs(root.right, prefixsum_count, target_sum, cur_sum)

        prefixsum_count[cur_sum] -= 1
        return res

    def pathSum(self, root: TreeNode, sum: int) -> int:
        if not root:
            return 0
        prefixsum_count = dict()
        prefixsum_count[0] = 1
        return self.dfs(root, prefixsum_count, sum, 0)
```

# [0438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0438. 找到字符串中所有字母异位词 - 力扣](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

## 题目大意

**描述**：给定两个字符串 $s$ 和 $p$。

**要求**：找到 $s$ 中所有 $p$ 的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**说明**：

- **异位词**：指由相同字母重排列形成的字符串（包括相同的字符串）。
- $1 <= s.length, p.length <= 3 * 10^4$。
- $s$ 和 $p$ 仅包含小写字母。

**示例**：

- 示例 1：

```python
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

- 示例 2：

```python
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

## 解题思路

### 思路 1：滑动窗口

维护一个固定长度为 $len(p)$ 的滑动窗口。于是问题的难点变为了如何判断 $s$ 的子串和 $p$ 是异位词。可以使用两个字典来分别存储 $s$ 的子串中各个字符个数和 $p$ 中各个字符个数。如果两个字典对应的键值全相等，则说明 $s$ 的子串和 $p$ 是异位词。但是这样每一次比较的操作时间复杂度是 $O(n)$，我们可以通过在滑动数组中逐字符比较的方式来减少两个字典之间相互比较的复杂度，并用 $valid$ 记录经过验证的字符个数。整个算法步骤如下：

- 使用哈希表 $need$ 记录 $p$ 中各个字符出现次数。使用字典 $window$ 记录 $s$ 的子串中各个字符出现的次数。使用数组 $res$ 记录答案。使用 $valid$ 记录 $s$ 的子串中经过验证的字符个数。使用 $window\underline{\hspace{0.5em}}size$ 表示窗口大小，值为 $len(p)$。使用两个指针 $left$、$right$。分别指向滑动窗口的左右边界。
- 一开始，$left$、$right$ 都指向 $0$。
- 如果 $s[right]$ 出现在 $need$ 中，将最右侧字符 $s[right]$ 加入当前窗口 $window$ 中，记录该字符个数。并验证该字符是否和 $need$ 中个对应字符个数相等。如果相等则验证的字符个数加 $1$，即 `valid += 1`。
- 如果该窗口字符长度大于等于 $window\underline{\hspace{0.5em}}size$ 个，即 $right - left + 1 \ge window\underline{\hspace{0.5em}}size$。则不断右移 $left$，缩小滑动窗口长度。
  - 如果验证字符个数 $valid$ 等于窗口长度 $window\underline{\hspace{0.5em}}size$，则 $s[left, right + 1]$ 为 $p$ 的异位词，所以将 $left$ 加入到答案数组中。
  - 如果$s[left]$ 在 $need$ 中，则更新窗口中对应字符的个数，同时维护 $valid$ 值。
- 右移 $right$，直到 $right \ge len(nums)$ 结束。
- 输出答案数组 $res$。

### 思路 1：代码

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        need = collections.defaultdict(int)
        for ch in p:
            need[ch] += 1

        window = collections.defaultdict(int)
        window_size = len(p)
        res = []
        left, right = 0, 0
        valid = 0
        while right < len(s):
            if s[right] in need:
                window[s[right]] += 1
                if window[s[right]] == need[s[right]]:
                    valid += 1

            if right - left + 1 >= window_size:
                if valid == len(need):
                    res.append(left)
                if s[left] in need:
                    if window[s[left]] == need[s[left]]:
                        valid -= 1
                    window[s[left]] -= 1
                left += 1
            right += 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m + |\sum|)$，其中 $n$、$m$ 分别为字符串 $s$、$p$ 的长度，$\sum$ 为字符集，本题中 $|\sum| = 26$。
- **空间复杂度**：$|\sum|$。

# [0443. 压缩字符串](https://leetcode.cn/problems/string-compression/)

- 标签：双指针、字符串
- 难度：中等

## 题目链接

- [0443. 压缩字符串 - 力扣](https://leetcode.cn/problems/string-compression/)

## 题目大意

**描述**：给定一个字符数组 $chars$。请使用下述算法压缩：

从一个空字符串 $s$ 开始。对于 $chars$ 中的每组连续重复字符：

- 如果这一组长度为 $1$，则将字符追加到 $s$ 中。
- 如果这一组长度超过 $1$，则需要向 $s$ 追加字符，后跟这一组的长度。

压缩后得到的字符串 $s$ 不应该直接返回 ，需要转储到字符数组 $chars$ 中。需要注意的是，如果组长度为 $10$ 或 $10$ 以上，则在 $chars$ 数组中会被拆分为多个字符。

**要求**：在修改完输入数组后，返回该数组的新长度。

**说明**：

- $1 \le chars.length \le 2000$。
- $chars[i]$ 可以是小写英文字母、大写英文字母、数字或符号。
- 必须设计并实现一个只使用常量额外空间的算法来解决此问题。

**示例**：

- 示例 1：

```python
输入：chars = ["a","a","b","b","c","c","c"]
输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
解释："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
```

- 示例 2：

```python
输入：chars = ["a"]
输出：返回 1 ，输入数组的前 1 个字符应该是：["a"]
解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。
```

## 解题思路

### 思路 1：快慢指针

题目要求原地修改字符串数组。我们可以使用快慢指针来解决原地修改问题，具体解决方法如下：

- 定义两个快慢指针 $slow$，$fast$。其中 $slow$ 指向压缩后的当前字符位置，$fast$ 指向压缩前的当前字符位置。
- 记录下当前待压缩字符的起始位置 $fast\underline{\hspace{0.5em}}start = start$，然后过滤掉连续相同的字符。
- 将待压缩字符的起始位置的字符存入压缩后的当前字符位置，即  $chars[slow] = chars[fast\underline{\hspace{0.5em}}start]$，并向右移动压缩后的当前字符位置，即 $slow += 1$。
- 判断一下待压缩字符的数目是否大于 $1$：
  - 如果数量为 $1$，则不用记录该数量。
  - 如果数量大于 $1$（即 $fast - fast\underline{\hspace{0.5em}}start > 0$），则我们需要将对应数量存入压缩后的当前字符位置。这时候还需要判断一下数量是否大于等于 $10$。
    - 如果数量大于等于 $10$，则需要先将数字从个位到高位转为字符，存入压缩后的当前字符位置（此时数字为反，比如原数字是 $321$，则此时存入后为 $123$）。因为数字为反，所以我们需要将对应位置上的子字符串进行反转。
    - 如果数量小于 $10$，则直接将数字存入压缩后的当前字符位置，无需取反。
- 判断完之后向右移动压缩前的当前字符位置 $fast$，然后继续压缩字符串，直到全部压缩完，则返回压缩后的当前字符位置 $slow$ 即为答案。

### 思路 1：代码

```python
class Solution:
    
    def compress(self, chars: List[str]) -> int:
        def reverse(left, right):
            while left < right:
                chars[left], chars[right] = chars[right], chars[left]
                left += 1
                right -= 1

        slow, fast = 0, 0
        while fast < len(chars):
            fast_start = fast
            while fast + 1 < len(chars) and chars[fast + 1] == chars[fast]:
                fast += 1
            
            chars[slow] = chars[fast_start]
            slow += 1

            if fast - fast_start > 0:
                cnt = fast - fast_start + 1
                slow_start = slow
                while cnt != 0:
                    chars[slow] = str(cnt % 10)
                    slow += 1
                    cnt = cnt // 10
                reverse(slow_start, slow - 1)
            
            fast += 1
        return slow
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(1)$。
# [0445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

- 标签：栈、链表、数学
- 难度：中等

## 题目链接

- [0445. 两数相加 II - 力扣](https://leetcode.cn/problems/add-two-numbers-ii/)

## 题目大意

给定两个非空链表的头节点 `l1` 和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。每个节点只储存一位数字。除了数字 `0` 之外，这两个链表代表的数字都不会以 `0` 开头。

要求：将这两个数相加会返回一个新的链表。

## 解题思路

链表中最高位位于链表开始位置，最低位位于链表结束位置。这与我们做加法的数位顺序是相反的。为了将链表逆序，从而从低位开始处理数位，我们可以借用两个栈：将链表中所有数字分别压入两个栈中，再依次取出相加。

同时，在相加的时候，还要考虑进位问题。具体步骤如下：

- 将链表 `l1` 中所有节点值压入 `stack1` 栈中，再将链表 `l2` 中所有节点值压入 `stack2` 栈中。
- 使用 `res` 存储新的结果链表，一开始指向 `None`，`carry` 记录进位。
- 如果 `stack1` 或 `stack2` 不为空，或着进位 `carry` 不为 `0`，则：
  - 从 `stack1` 中取出栈顶元素 `num1`，如果 `stack1` 为空，则 `num1 = 0`。
  - 从 `stack2` 中取出栈顶元素 `num2`，如果 `stack2` 为空，则 `num2 = 0`。
  - 计算相加结果，并计算进位。
  - 建立新节点，存储进位后余下的值，并令其指向 `res`。
  - `res` 指向新节点，继续判断。
- 如果 `stack1`、`stack2` 都为空，并且进位 `carry` 为 `0`，则输出 `res`。

## 代码

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        stack1, stack2 = [], []
        while l1:
            stack1.append(l1.val)
            l1 = l1.next
        while l2:
            stack2.append(l2.val)
            l2 = l2.next

        res = None
        carry = 0
        while stack1 or stack2 or carry != 0:
            num1 = stack1.pop() if stack1 else 0
            num2 = stack2.pop() if stack2 else 0
            cur_sum = num1 + num2 + carry
            carry = cur_sum // 10
            cur_sum %= 10
            cur_node = ListNode(cur_sum)
            cur_node.next = res
            res = cur_node
        return res
```

# [0447. 回旋镖的数量](https://leetcode.cn/problems/number-of-boomerangs/)

- 标签：数组、哈希表、数学
- 难度：中等

## 题目链接

- [0447. 回旋镖的数量 - 力扣](https://leetcode.cn/problems/number-of-boomerangs/)

## 题目大意

给定平面上点坐标的数组 points，其中 $points[i] = [x_i, y_i]$。判断 points 中是否存在三个点 i，j，k，满足 i 和 j 之间的距离等于 i 和 k 之间的距离，即 $dist[i, j] = dist[i, k]$。找出满足上述关系的答案数量。

## 解题思路

使用哈希表记录每两个点之间的距离。然后使用两重循环遍历坐标数组，对于每两个点 i、点 j，计算两个点之间的距离，并将距离存进哈希表中。再从哈希表中选取距离相同的关系中依次选出两个，作为三个点之间的距离关系 $dist[i, j] =dist[i, k]$，因为还需考虑顺序，所以共有 $value * (value-1)$ 种情况。累加到答案中。

## 代码

```python
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        ans = 0
        for point_i in points:
            dis_dict = dict()
            for point_j in points:
                if point_i != point_j:
                    dx = point_i[0] - point_j[0]
                    dy = point_i[1] - point_j[1]
                    dis = dx * dx + dy * dy
                    if dis in dis_dict:
                        dis_dict[dis] += 1
                    else:
                        dis_dict[dis] = 1
            for value in dis_dict.values():
                ans += value*(value-1)
        return ans
```

# [0450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

- 标签：树、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0450. 删除二叉搜索树中的节点 - 力扣](https://leetcode.cn/problems/delete-node-in-a-bst/)

## 题目大意

**描述**：给定一个二叉搜索树的根节点 `root`，以及一个值 `key`。

**要求**：从二叉搜索树中删除 key 对应的节点。并保证删除后的树仍是二叉搜索树。要求算法时间复杂度为 $0(h)$，$h$ 为树的高度。最后返回二叉搜索树的根节点。

**说明**：

- 节点数的范围 $[0, 10^4]$。
- $-10^5 \le Node.val \le 10^5$。
- 节点值唯一。
- `root` 是合法的二叉搜索树。
- $-10^5 \le key \le 10^5$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```python
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如上图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

- 示例 2：

```python
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

## 解题思路

### 思路 1：递归

删除分两个步骤：查找和删除。查找通过递归查找，删除的话需要考虑情况。

1.  从根节点 `root` 开始，递归遍历搜索二叉树。
   1. 如果当前节点节点为空，返回当前节点。
   2. 如果当前节点值大于 `key`，则去左子树中搜索并删除，此时 `root.left` 也要跟着递归更新，递归完成后返回当前节点。
   3. 如果当前节点值小于 `key`，则去右子树中搜索并删除，此时 `root.right` 也要跟着递归更新，递归完成后返回当前节点。
   4. 如果当前节点值等于 `key`，则该节点就是待删除节点。
      1. 如果当前节点的左子树为空，则删除该节点之后，则右子树代替当前节点位置，返回右子树。
      2. 如果当前节点的右子树为空，则删除该节点之后，则左子树代替当前节点位置，返回左子树。
      3. 如果当前节点的左右子树都有，则将左子树转移到右子树最左侧的叶子节点位置上，然后右子树代替当前节点位置。返回右子树。

### 思路 1：代码

```python
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return root

        if root.val > key:
            root.left = self.deleteNode(root.left, key)
            return root
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
            return root
        else:
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                curr = root.right
                while curr.left:
                    curr = curr.left
                curr.left = root.left
                return root.right
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉搜索树的节点数。
- **空间复杂度**：$O(n)$。
# [0451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/)

- 标签：哈希表、字符串、桶排序、计数、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0451. 根据字符出现频率排序 - 力扣](https://leetcode.cn/problems/sort-characters-by-frequency/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：将字符串 `s` 里的字符按照出现的频率降序排列。如果有多个答案，返回其中任何一个。

**说明**：

- $1 \le s.length \le 5 * 10^5$。
- `s` 由大小写英文字母和数字组成。

**示例**：

- 示例 1：

```python
输入: s = "tree"
输出: "eert"
解释: 'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

- 示例 2：

```python
输入: s = "cccaaa"
输出: "cccaaa"
解释: 'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

## 解题思路

### 思路 1：优先队列

1. 使用哈希表 `s_dict` 统计字符频率。
2. 然后遍历哈希表 `s_dict`，将字符以及字符频数存入优先队列中。
3. 将优先队列中频数最高的元素依次加入答案数组中。
4. 最后拼接答案数组为字符串，将其返回。

### 思路 1：代码

```python
import heapq

class Solution:
    def frequencySort(self, s: str) -> str:
        # 统计元素频数
        s_dict = dict()
        for ch in s:
            if ch in s_dict:
                s_dict[ch] += 1
            else:
                s_dict[ch] = 1
        
        priority_queue = []
        for ch in s_dict:
            heapq.heappush(priority_queue, (-s_dict[ch], ch))
        
        res = []
        while priority_queue:
            ch = heapq.heappop(priority_queue)[-1]
            times = s_dict[ch]
            while times:
                res.append(ch)
                times -= 1
        return ''.join(res)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n  + k \times log_2k)$。其中 $n$ 为字符串 $s$ 的长度，$k$ 是字符串中不同字符的个数。
- **空间复杂度**：$O(n + k)$。

# [0452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

- 标签：贪心、数组、排序
- 难度：中等

## 题目链接

- [0452. 用最少数量的箭引爆气球 - 力扣](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

## 题目大意

**描述**：在一个坐标系中有许多球形的气球。对于每个气球，给定气球在 x 轴上的开始坐标和结束坐标 $(x_{start}, x_{end})$。

同时，在 $x$ 轴的任意位置都能垂直发出弓箭，假设弓箭发出的坐标就是 x。那么如果有气球满足 $x_{start} \le x \le x_{end}$，则该气球就会被引爆，且弓箭可以无限前进，可以将满足上述要求的气球全部引爆。

现在给定一个数组 `points`，其中 $points[i] = [x_{start}, x_{end}]$ 代表每个气球的开始坐标和结束坐标。

**要求**：返回能引爆所有气球的最小弓箭数。

**说明**：

- $1 \le points.length \le 10^5$。
- $points[i].length == 2$。
- $-2^{31} \le x_{start} < x_{end} \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用 2 支箭来爆破:
- 在x = 6 处射出箭，击破气球 [2,8] 和 [1,6]。
- 在x = 11 处发射箭，击破气球 [10,16] 和 [7,12]。
```

- 示例 2：

```python
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要 4 支箭。
```

## 解题思路

### 思路 1：贪心算法

弓箭的起始位置和结束位置可以看做是一段区间，直观上来看，为了使用最少的弓箭数，可以尽量射中区间重叠最多的地方。

所以问题变为了：**如何寻找区间重叠最多的地方，也就是区间交集最多的地方。**

我们将 `points` 按结束坐标升序排序（为什么按照结束坐标排序后边说）。

然后维护两个变量：一个是当前弓箭的坐标 `arrow_pos`、另一个是弓箭的数目 `count`。

为了尽可能的穿过更多的区间，所以每一支弓箭都应该尽可能的从区间的结束位置穿过，这样才能覆盖更多的区间。

初始情况下，第一支弓箭的坐标为第一个区间的结束位置，然后弓箭数为 $1$。然后依次遍历每段区间。

如果遇到弓箭坐标小于区间起始位置的情况，说明该弓箭不能引爆该区间对应的气球，需要用新的弓箭来射，所以弓箭数加 $1$，弓箭坐标也需要更新为新区间的结束位置。

最终返回弓箭数目。

再来看为什么将 `points` 按结束坐标升序排序而不是按照开始坐标升序排序？

其实也可以，但是按开始坐标排序不如按结束坐标排序简单。

按开始坐标升序排序需要考虑一种情况：有交集关系的区间中，有的区间结束位置比较早。比如 `[0, 6]、[1, 2] [4, 5]`，按照开始坐标升序排序的话，就像下图一样：

```
[0..................6]
   [1..2]    
             [4..5]
```

第一箭的位置需要进行迭代判断，取区间 `[0, 6]、[1, 2]` 中结束位置最小的位置，即 `arrow_pos = min(points[i][1], arrow_pos)`，然后再判断接下来的区间是否能够引爆。

而按照结束坐标排序的话，箭的位置一开始就确定了，不需要再改变和判断箭的位置，直接判断区间即可。

### 思路 1：代码

1. 按照结束位置升序排序

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort(key=lambda x: x[1])
        arrow_pos = points[0][1]
        count = 1
        for i in range(1, len(points)):
            if arrow_pos < points[i][0]:
                count += 1
                arrow_pos = points[i][1]
        return count
```

2. 按照开始位置升序排序

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort(key=lambda x: x[0])
        arrow_pos = points[0][1]
        count = 1
        for i in range(1, len(points)):
            if arrow_pos < points[i][0]:
                count += 1
                arrow_pos = points[i][1]
            else:
                arrow_pos = min(points[i][1], arrow_pos)
        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$， 其中 $n$ 是数组 `points` 的长度。
- **空间复杂度**：$O(\log n)$。

# [0454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

- 标签：数组、哈希表
- 难度：中等

## 题目链接

- [0454. 四数相加 II - 力扣](https://leetcode.cn/problems/4sum-ii/)

## 题目大意

**描述**：给定四个整数数组 $nums1$、$nums2$、$nums3$、$nums4$。

**要求**：计算有多少不同的 $(i, j, k, l)$ 满足以下条件。

1. $0 \le i, j, k, l < n$。
2. $nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0$。

**说明**：

- $n == nums1.length$。
- $n == nums2.length$。
- $n == nums3.length$。
- $n == nums4.length$。
- $1 \le n \le 200$。
- $-2^{28} \le nums1[i], nums2[i], nums3[i], nums4[i] \le 2^{28}$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

- 示例 2：

```python
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

## 解题思路

### 思路 1：哈希表

直接暴力搜索的时间复杂度是 $O(n^4)$。我们可以降低一下复杂度。

将四个数组分为两组。$nums1$ 和 $nums2$ 分为一组，$nums3$ 和 $nums4$ 分为一组。

已知 $nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0$，可以得到 $nums1[i] + nums2[j] = -(nums3[k] + nums4[l])$

建立一个哈希表。两重循环遍历数组 $nums1$、$nums2$，先将 $nums[i] + nums[j]$ 的和个数记录到哈希表中，然后再用两重循环遍历数组 $nums3$、$nums4$。如果 $-(nums3[k] + nums4[l])$ 的结果出现在哈希表中，则将结果数累加到答案中。最终输出累加之后的答案。

### 思路 1：代码

```python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        nums_dict = dict()
        for num1 in nums1:
            for num2 in nums2:
                sum = num1 + num2
                if sum in nums_dict:
                    nums_dict[sum] += 1
                else:
                    nums_dict[sum] = 1
        count = 0
        for num3 in nums3:
            for num4 in nums4:
                sum = num3 + num4
                if -sum in nums_dict:
                    count += nums_dict[-sum]

        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组的元素个数。
- **空间复杂度**：$O(n^2)$。

# [0455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

- 标签：贪心、数组、双指针、排序
- 难度：简单

## 题目链接

- [0455. 分发饼干 - 力扣](https://leetcode.cn/problems/assign-cookies/)

## 题目大意

**描述**：一位很棒的家长为孩子们分发饼干。对于每个孩子 `i`，都有一个胃口值 `g[i]`，即每个小孩希望得到饼干的最小尺寸值。对于每块饼干 `j`，都有一个尺寸值 `s[j]`。只有当 `s[j] > g[i]` 时，我们才能将饼干 `j` 分配给孩子 `i`。每个孩子最多只能给一块饼干。

现在给定代表所有孩子胃口值的数组 `g` 和代表所有饼干尺寸的数组 `j`。

**要求**：尽可能满足越多数量的孩子，并求出这个最大数值。

**说明**：

- $1 \le g.length \le 3 * 10^4$。
- $0 \le s.length \le 3 * 10^4$。
- $1 \le g[i], s[j] \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：g = [1,2,3], s = [1,1]
输出：1
解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以应该输出 1。
```

- 示例 2：

```python
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1, 2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2。
```

## 解题思路

### 思路 1：贪心算法

为了尽可能的满⾜更多的⼩孩，而且一块饼干不能掰成两半，所以我们应该尽量让胃口小的孩子吃小块饼干，这样胃口大的孩子才有大块饼干吃。

所以，从贪心算法的角度来考虑，我们应该按照孩子的胃口从小到大对数组 `g` 进行排序，然后按照饼干的尺寸大小从小到大对数组 `s` 进行排序，并且对于每个孩子，应该选择满足这个孩子的胃口且尺寸最小的饼干。

下面我们使用贪心算法三步走的方法解决这道题。

1. **转换问题**：将原问题转变为，当胃口最小的孩子选择完满足这个孩子的胃口且尺寸最小的饼干之后，再解决剩下孩子的选择问题（子问题）。
2. **贪心选择性质**：对于当前孩子，用尺寸尽可能小的饼干满足这个孩子的胃口。
3. **最优子结构性质**：在上面的贪心策略下，当前孩子的贪心选择 + 剩下孩子的子问题最优解，就是全局最优解。也就是说在贪心选择的方案下，能够使得满足胃口的孩子数量达到最大。

使用贪心算法的代码解决步骤描述如下：

1. 对数组 `g`、`s` 进行从小到大排序，使用变量 `index_g` 和 `index_s` 分别指向 `g`、`s` 初始位置，使用变量 `res` 保存结果，初始化为 `0`。
2. 对比每个元素 `g[index_g]` 和 `s[index_s]`：
   1. 如果 `g[index_g] <= s[index_s]`，说明当前饼干满足当前孩子胃口，则答案数量加 `1`，并且向右移动 `index_g` 和 `index_s`。
   2. 如果 `g[index_g] > s[index_s]`，说明当前饼干无法满足当前孩子胃口，则向右移动 `index_s`，判断下一块饼干是否可以满足当前孩子胃口。
3. 遍历完输出答案 `res`。

### 思路 1：代码

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        index_g, index_s = 0, 0
        res = 0
        while index_g < len(g) and index_s < len(s):
            if g[index_g] <= s[index_s]:
                res += 1
                index_g += 1
                index_s += 1
            else:
                index_s += 1   

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times \log m + n \times \log n)$，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。
- **空间复杂度**：$O(\log m + \log n)$。
# [0459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

- 标签：字符串、字符串匹配
- 难度：简单

## 题目链接

- [0459. 重复的子字符串 - 力扣](https://leetcode.cn/problems/repeated-substring-pattern/)

## 题目大意

**描述**：给定一个非空的字符串 `s`。

**要求**：检查该字符串 `s` 是否可以通过由它的一个子串重复多次构成。

**说明**：

- $1 \le s.length \le 10^4$。
- `s` 由小写英文字母组成

**示例**：

- 示例 1：

```python
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

- 示例 2：

```python
输入: s = "aba"
输出: false
```

## 解题思路

### 思路 1：KMP 算法

这道题我们可以使用 KMP 算法的 `next` 数组来解决。我们知道 `next[j]` 表示的含义是：**记录下标 `j` 之前（包括 `j`）的模式串 `p` 中，最长相等前后缀的长度。**

而如果整个模式串 `p` 的最长相等前后缀长度不为 `0`，即 `next[len(p) - 1] != 0` ，则说明整个模式串 `p` 中有最长相同的前后缀，假设 `next[len(p) - 1] == k`，则说明 `p[0: k] == p[m - k: m]`。比如字符串 `"abcabcabc"`，最长相同前后缀为 `"abcabc" = "abcabc"`。

- 如果最长相等的前后缀是重叠的，比如之前的例子 `"abcabcabc"`。
  - 如果我们去除字符串中相同的前后缀的重叠部分，剩下两头前后缀部分（这两部分是相同的）。然后再去除剩余的后缀部分，只保留剩余的前缀部分。比如字符串 `"abcabcabc"` 去除重叠部分和剩余的后缀部分之后就是 `"abc"`。实际上这个部分就是字符串去除整个后缀部分的剩余部分。
  - 如果整个字符串可以通过子串重复构成的话，那么这部分就是最小周期的子串。
  - 我们只需要判断整个子串的长度是否是剩余部分长度的整数倍即可。也就是判断 `len(p) % (len(p) - next[size - 1]) == 0` 是否成立，如果成立，则字符串 `s` 可由 `s[0: len(p) - next[size - 1]]` 构成的子串重复构成，返回 `True`。否则返回 `False`。
- 如果最长相等的前后缀是不重叠的，那我们可将重叠部分视为长度为 `0` 的空串，则剩余的部分其实就是去除后缀部分的剩余部分，上述结论依旧成立。 

### 思路 1：代码

```python
class Solution:
    def generateNext(self, p: str):
        m = len(p)
        next = [0 for _ in range(m)]

        left = 0
        for right in range(1, m):
            while left > 0 and p[left] != p[right]:
                left = next[left - 1]
            if p[left] == p[right]:
                left += 1
            next[right] = left

        return next

    def repeatedSubstringPattern(self, s: str) -> bool:
        size = len(s)
        if size == 0:
            return False
        next = self.generateNext(s)
        if next[size - 1] != 0 and size % (size - next[size - 1]) == 0:
            return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m)$，其中模式串 $p$ 的长度为 $m$。
- **空间复杂度**：$O(m)$。

# [0461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

- 标签：位运算
- 难度：简单

## 题目链接

- [0461. 汉明距离 - 力扣](https://leetcode.cn/problems/hamming-distance/)

## 题目大意

给定两个整数 x 和 y，计算他们之间的汉明距离。

- 汉明距离：两个数字对应二进制位上不同的位置的数目

## 解题思路

先对两个数进行异或运算（相同位置上，值相同，结果为 0，值不同，结果为 1），用于记录 x 和 y 不同位置上的异同情况。

然后再按位统计异或结果中 1 的位数。

这里统计 1 的位数可以逐位移动，检查每一位是否为 1。

也可以借助  $n \text{ \& } (n - 1)$  运算。这个运算刚好可以将 n 的二进制中最低位的 1 变为 0。

## 代码

1. 逐位移动
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        xor = x ^ y
        distance = 0
        while xor:
            if xor & 1:
                distance += 1
            xor >>= 1
        return distance
```

2. $n \text{ \& } (n - 1)$  运算
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        xor = x ^ y
        distance = 0
        while xor:
            distance += 1
            xor = xor & (xor - 1)
        return distance
```

# [0463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

- 标签：深度优先搜索、广度优先搜索、数组、矩阵
- 难度：简单

## 题目链接

- [0463. 岛屿的周长 - 力扣](https://leetcode.cn/problems/island-perimeter/)

## 题目大意

**描述**：给定一个 `row * col` 大小的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地，`grid[i][j] = 0` 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（多个表示陆地的格子相连组成）。

岛屿内部中没有「湖」（指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。

**要求**：计算这个岛屿的周长。

**说明**：

- $row == grid.length$。
- $col == grid[i].length$。
- $1 <= row, col <= 100$。
- $grid[i][j]$ 为 $0$ 或 $1$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)

```python
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
```

- 示例 2：

```python
输入：grid = [[1]]
输出：4
```

## 解题思路

### 思路 1：广度优先搜索

1. 使用整形变量 `count` 存储周长，使用队列 `queue` 用于进行广度优先搜索。
2. 遍历一遍二维数组 `grid`，对 `grid[row][col] == 1` 的区域进行广度优先搜索。
3. 先将起始点 `(row, col)` 加入队列。
4. 如果队列不为空，则取出队头坐标 `(row, col)`。先将 `(row, col)` 标记为 `2`，避免重复统计。
5. 然后遍历上、下、左、右四个方向的相邻区域，如果遇到边界或者水域，则周长加 1。
6. 如果相邻区域 `grid[new_row][new_col] == 1`，则将其赋值为 `2`，并将坐标加入队列。
7. 继续执行 4 ~ 6 步，直到队列为空时返回 `count`。

### 思路 1：代码

```python
class Solution:
    def bfs(self, grid, rows, cols, row, col):
        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        queue = collections.deque([(row, col)])

        count = 0
        while queue:
            row, col = queue.popleft()
            # 避免重复统计
            grid[row][col] = 2
            for direct in directs:
                new_row = row + direct[0]
                new_col = col + direct[1]
                # 遇到边界或者水域，则周长加 1
                if new_row < 0 or new_row >= rows or new_col < 0 or new_col >= cols or grid[new_row][new_col] == 0:
                    count += 1
                # 相邻区域为陆地，则将其标记为 2，加入队列
                elif grid[new_row][new_col] == 1:
                    grid[new_row][new_col] = 2
                    queue.append((new_row, new_col))
                # 相邻区域为 2 的情况不做处理
        return count

    def islandPerimeter(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 1:
                    return self.bfs(grid, rows, cols, row, col)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(n \times m)$。

## 参考资料

- 【题解】[Golang BFS 实现，性能比dfs要高 - 岛屿的周长 - 力扣](https://leetcode.cn/problems/island-perimeter/solution/golang-bfs-shi-xian-xing-neng-bi-dfsyao-nln2g/) 
# [0464. 我能赢吗](https://leetcode.cn/problems/can-i-win/)

- 标签：位运算、记忆化搜索、数学、动态规划、状态压缩、博弈
- 难度：中等

## 题目链接

- [0464. 我能赢吗 - 力扣](https://leetcode.cn/problems/can-i-win/)

## 题目大意

**描述**：给定两个整数，$maxChoosableInteger$ 表示可以选择的最大整数，$desiredTotal$ 表示累计和。现在开始玩一个游戏，两个玩家轮流从 $1 \sim maxChoosableInteger$ 中不重复的抽取一个整数，直到累积整数和大于等于 $desiredTotal$ 时，这个人就赢得比赛。假设两位玩家玩游戏时都表现最佳。

**要求**：判断先出手的玩家是否能够稳赢，如果能稳赢，则返回 `True`，否则返回 `False`。

**说明**：

- $1 \le maxChoosableInteger \le 20$。
- $0 \le desiredTotal \le 300$。

**示例**：

- 示例 1：

```python
输入：maxChoosableInteger = 10, desiredTotal = 11
输出：False
解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```

- 示例 2：

```python
输入：maxChoosableInteger = 10, desiredTotal = 0
输出：True
```

## 解题思路

### 思路 1：状态压缩 + 记忆化搜索

$maxChoosableInteger$ 的区间范围是 $[1, 20]$，数据量不是很大，我们可以使用状态压缩来判断当前轮次中数字的选取情况。

题目假设两位玩家玩游戏时都表现最佳，则每个人都会尽力去赢，在每轮次中，每个人都会分析此次选择后，对后续轮次的影响，判断自己是必赢还是必输。

1. 如果当前轮次选择某个数之后，自己一定会赢时，才会选择这个数。
2. 如果当前轮次无论选择哪个数，自己一定会输时，那无论选择哪个数其实都已经无所谓了。

这样我们可以定义一个递归函数 `dfs(state, curTotal)`，用于判断处于状态 $state$，并且当前累计和为 $curTotal$ 时，自己是否一定会赢。如果自己一定会赢，返回 `True`，否则返回 `False`。递归函数内容如下：

1. 从 $1 \sim maxChoosableInteger$ 中选择一个之前没有选过的数 $k$。
2. 如果选择的数 $k$ 加上当前的整数和 $curTotal$ 之后大于等于 $desiredTotal$，则自己一定会赢。
3. 如果选择的数 $k$ 之后，对方必输（即递归调用 `dfs(state | (1 << (k - 1)), curTotal + k)`  为 `Flase` 时），则自己一定会赢。
4. 如果无论选择哪个数，自己都赢不了，则自己必输，返回 `False`。

这样，我们从 $state = 0, curTotal = 0$ 开始调用递归方法 `dfs(state, curTotal)`，即可判断先出手的玩家是否能够稳赢。

接下来，我们还需要考虑一些边界条件。

1. 当 $maxChoosableInteger$ 直接大于等于 $desiredTotal$，则先手玩家无论选什么，直接就赢了，这种情况下，我们直接返回 `True`。
2. 当 $1 \sim maxChoosableInteger$ 中所有数加起来都小于 $desiredTotal$，则先手玩家无论怎么选，都无法稳赢，题目要求我们判断先出手的玩家是否能够稳赢，既然先手无法稳赢，我们直接返回 `False`。

### 思路 1：代码

```python
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        @cache
        def dfs(state, curTotal):
            for k in range(1, maxChoosableInteger + 1):             # 从 1 ~ maxChoosableInteger 中选择一个数
                if state >> (k - 1) & 1 != 0:                       # 如果之前选过该数则跳过
                    continue
                if curTotal + k >= desiredTotal:                    # 如果选择了 k，累积整数和大于等于 desiredTotal，则该玩家一定赢
                    return True
                if not dfs(state | (1 << (k - 1)), curTotal + k):   # 如果当前选择了 k 之后，对手一定输，则当前玩家一定赢
                    return True
            return False                                            # 以上都赢不了的话，当前玩家一定输

        # maxChoosableInteger 直接大于等于 desiredTotal，则先手玩家一定赢
        if maxChoosableInteger >= desiredTotal:
            return True
            
        # 1 ~ maxChoosableInteger 所有数加起来都不够 desiredTotal，则先手玩家一定输
        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:
            return False
        return dfs(0, 0)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为 $maxChoosableInteger$。
- **空间复杂度**：$O(2^n)$。
# [0467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0467. 环绕字符串中唯一的子字符串 - 力扣](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

## 题目大意

把字符串 `s` 看作是 `abcdefghijklmnopqrstuvwxyz` 的无限环绕字符串，所以 `s` 看起来是这样的：`...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....`。 

给定一个字符串 `p`。

要求：你需要的是找出 `s` 中有多少个唯一的 `p` 的非空子串，尤其是当你的输入是字符串 `p` ，你需要输出字符串 `s` 中 `p` 的不同的非空子串的数目。 

注意: `p` 仅由小写的英文字母组成，`p` 的大小可能超过 `10000`。

## 解题思路

字符串 `s` 是个 `a` ~ `z` 无限循环的字符串，题目要求计算字符串 `s` 和字符串 `p` 中有多少个相等的非空子串。发现以该字符结尾的连续子串的长度，就等于以该字符结尾的相等子串的个数。所以我们可以按以下步骤求解：

- 记录以每个字符结尾的字符串最长长度。
- 将其累加起来就是最终答案。

## 代码

```python
class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        dp = collections.defaultdict(int)
        dp[p[0]] = 1
        max_len = 1
        for i in range(1, len(p)):
            if (ord(p[i]) - ord(p[i - 1])) % 26 == 1:
                max_len += 1
            else:
                max_len = 1
            dp[p[i]] = max(dp[p[i]], max_len)

        ans = 0
        for key, value in dp.items():
            ans += value
        return ans
```

# [0468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/)

- 标签：字符串
- 难度：中等

## 题目链接

- [0468. 验证IP地址 - 力扣](https://leetcode.cn/problems/validate-ip-address/)

## 题目大意

**描述**：给定一个字符串 `queryIP`。

**要求**：如果是有效的 IPv4 地址，返回 `"IPv4"`；如果是有效的 IPv6 地址，返回 `"IPv6"`；如果不是上述类型的 IP 地址，返回 `"Neither"`。

**说明**：

- **有效的 IPv4 地址**：格式为 `"x1.x2.x3.x4"` 形式的 IP 地址。 其中：
  -  $0 \le xi \le 255$。
  - $xi$ 不能包含前导零。

- 例如: `"192.168.1.1"` 、 `"192.168.1.0"` 为有效 IPv4 地址，`"192.168.01.1"` 为无效 IPv4 地址，`"192.168.1.00"` 、 `"192.168@1.1"` 为无效 IPv4 地址。
- **有效的 IPv6 地址**： 格式为`"x1:x2:x3:x4:x5:x6:x7:x8"` 的 IP 地址，其中:
  - $1 \le xi.length \le 4$。
  - $xi$ 是一个十六进制字符串，可以包含数字、小写英文字母（`'a'` 到 `'f'`）和大写英文字母（`'A'` 到 `'F'`）。
  - 在 $xi$ 中允许前导零。
- 例如：`"2001:0db8:85a3:0000:0000:8a2e:0370:7334"` 和 `"2001:db8:85a3:0:0:8A2E:0370:7334"` 是有效的 IPv6 地址，而 `"2001:0db8:85a3::8A2E:037j:7334"` 和 `"02001:0db8:85a3:0000:0000:8a2e:0370:7334"` 是无效的 IPv6 地址。
- `queryIP` 仅由英文字母，数字，字符 `'.'` 和 `':'` 组成。

**示例**：

- 示例 1：

```python
输入：queryIP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"
```

- 示例 2：

```python
输入：queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
输出："IPv6"
解释：有效的 IPv6 地址，返回 "IPv6"
```

## 解题思路

### 思路 1：模拟

根据题意以及有效的 IPV4 地址规则、有效的 IPv6 地址规则，我们可以分两步来做：第一步，验证是否为有效的 IPV4 地址。第二步，验证是否为有效的 IPv6 地址。

#### 1. 验证是否为有效的 IPv4 地址

1. 将字符串按照 `'.'` 进行分割，将不同分段存入数组 `path` 中。
2. 如果分段数组 `path` 长度等于 $4$，则说明该字符串为 IPv4 地址，接下里验证是否为有效的 IPv4 地址。
3. 遍历分段数组 `path`，去验证每个分段 `sub`。
   1. 如果当前分段 `sub` 为空，或者不是纯数字，则返回 `"Neither"`。
   2. 如果当前分段 `sub` 有前导 $0$，并且长度不为 $1$，则返回 `"Neither"`。
   3. 如果当前分段 `sub` 对应的值不在 $0 \sim 255$ 范围内，则返回 `"Neither"`。
4. 遍历完分段数组 `path`，扔未发现问题，则该字符串为有效的 IPv4 地址，返回 `IPv4`。

#### 2. 验证是否为有效的 IPv6 地址

1. 将字符串按照 `':'` 进行分割，将不同分段存入数组 `path` 中。
2. 如果分段数组 `path` 长度等于 $8$，则说明该字符串为 IPv6 地址，接下里验证是否为有效的 IPv6 地址。
3. 定义一个代表十六进制不同字符的字符串 `valid = "0123456789abcdefABCDEF"`，用于验证分段的每一位是否为 $16$ 进制数。
4. 遍历分段数组 `path`，去验证每个分段 `sub`。
   1. 如果当前分段 `sub` 为空，则返回 `"Neither"`。
   2. 如果当前分段 `sub` 长度超过 $4$，则返回 `"Neither"`。
   3. 如果当前分段 `sub` 对应的每一位的值不在 `valid` 内，则返回 `"Neither"`。
5. 遍历完分段数组 `path`，扔未发现问题，则该字符串为有效的 IPv6 地址，返回 `IPv6`。

如果通过上面两步验证，该字符串既不是有效的 IPv4 地址，也不是有效的 IPv6 地址，则返回 `"Neither"`。

### 思路 1：代码

```python
class Solution:
    def validIPAddress(self, queryIP: str) -> str:
        path = queryIP.split('.')
        if len(path) == 4:
            for sub in path:
                if not sub or not sub.isdecimal():
                    return "Neither"
                if sub[0] == '0' and len(sub) != 1:
                    return "Neither"
                if int(sub) > 255:
                    return "Neither"
            return "IPv4"

        path = queryIP.split(':')
        if len(path) == 8:
            valid = "0123456789abcdefABCDEF"
            for sub in path:
                if not sub:
                    return "Neither"
                if len(sub) > 4:
                    return "Neither"
                for digit in sub:
                    if digit not in valid:
                        return "Neither"
            return "IPv6"

        return "Neither"
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 `queryIP` 的长度。
- **空间复杂度**：$O(n)$。
# [0473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)

- 标签：位运算、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目链接

- [0473. 火柴拼正方形 - 力扣](https://leetcode.cn/problems/matchsticks-to-square/)

## 题目大意

**描述**：给定一个表示火柴长度的数组 $matchsticks$，其中 $matchsticks[i]$ 表示第 $i$ 根火柴的长度。

**要求**：找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以将火柴连接起来，并且每根火柴都要用到。如果能拼成正方形，则返回 `True`，否则返回 `False`。

**说明**：

- $1 \le matchsticks.length \le 15$。
- $1 \le matchsticks[i] \le 10^8$。

**示例**：

- 示例 1：

```python
输入: matchsticks = [1,1,2,2,2]
输出: True
解释: 能拼成一个边长为 2 的正方形，每边两根火柴。
```

- 示例 2：

```python
输入: matchsticks = [3,3,3,3,4]
输出: False
解释: 不能用所有火柴拼成一个正方形。
```

## 解题思路

### 思路 1：回溯算法

1. 先排除数组为空和火柴总长度不是 $4$ 的倍数的情况，直接返回 `False`。
2. 然后将火柴按照从大到小排序。用数组 $sums$ 记录四个边长分组情况。
3. 将火柴分为 $4$ 组，把每一根火柴依次向 $4$ 条边上放。
4. 直到放置最后一根，判断能否构成正方形，若能构成正方形，则返回 `True`，否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def dfs(self, index, sums, matchsticks, size, side_len):
        if index == size:
            return True

        for i in range(4):
            # 如果两条边的情况相等，只需要计算一次，没必要多次重复计算
            if i > 0 and sums[i] == sums[i - 1]:
                continue
            sums[i] += matchsticks[index]
            if sums[i] <= side_len and self.dfs(index + 1, sums, matchsticks, size, side_len):
                return True
            sums[i] -= matchsticks[index]
                
        return False

    def makesquare(self, matchsticks: List[int]) -> bool:
        if not matchsticks:
            return False
        size = len(matchsticks)
        sum_len = sum(matchsticks)
        if sum_len % 4 != 0:
            return False

        side_len = sum_len // 4
        matchsticks.sort(reverse=True)

        sums = [0 for _ in range(4)]
        return self.dfs(0, sums, matchsticks, size, side_len)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(4^n)$。$n$ 是火柴的数目。
- **空间复杂度**：$O(n)$。递归栈的空间复杂度为 $O(n)$。

# [0474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

- 标签：数组、字符串、动态规划
- 难度：中等

## 题目链接

- [0474. 一和零 - 力扣](https://leetcode.cn/problems/ones-and-zeroes/)

## 题目大意

**描述**：给定一个二进制字符串数组 $strs$，以及两个整数 $m$ 和 $n$。

**要求**：找出并返回 $strs$ 的最大子集的大小，该子集中最多有 $m$ 个 $0$ 和 $n$ 个 $1$。

**说明**：

- 如果 $x$ 的所有元素也是 $y$ 的元素，集合 $x$ 是集合 $y$ 的子集。
- $1 \le strs.length \le 600$。
- $1 \le strs[i].length \le 100$。
- $strs[i]$ 仅由 `'0'` 和 `'1'` 组成。
- $1 \le m, n \le 100$。

**示例**：

- 示例 1：

```python
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3。
```

- 示例 2：

```python
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2。
```

## 解题思路

### 思路 1：动态规划

这道题可以转换为「二维 0-1 背包问题」来做。

把 $0$ 的个数和 $1$ 的个数视作一个二维背包的容量。每一个字符串都当做是一件物品，其成本为字符串中 $1$ 的数量和 $0$ 的数量，每个字符串的价值为 $1$。

###### 1. 划分阶段

按照物品的序号、当前背包的载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：最多有 $i$ 个 $0$ 和 $j$ 个 $1$ 的字符串 $strs$ 的最大子集的大小。

###### 3. 状态转移方程

填满最多由 $i$ 个 $0$ 和 $j$ 个 $1$ 构成的二维背包的最多物品数为下面两种情况中的最大值：

- 使用之前字符串填满容量为 $i - zero\underline{\hspace{0.5em}}num$、$j - one\underline{\hspace{0.5em}}num$ 的背包的物品数 + 当前字符串价值
- 选择之前字符串填满容量为 $i$、$j$ 的物品数。

则状态转移方程为：$dp[i][j] = max(dp[i][j], dp[i - zero\underline{\hspace{0.5em}}num][j - one\underline{\hspace{0.5em}}num] + 1)$。

###### 4. 初始条件

- 无论有多少个 $0$，多少个 $1$，只要不选 $0$，也不选 $1$，则最大子集的大小为 $0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：最多有 $i$ 个 $0$ 和 $j$ 个 $1$ 的字符串 $strs$ 的最大子集的大小。所以最终结果为 $dp[m][n]$。

### 思路 1：代码

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        
        for str in strs:
            one_num = 0
            zero_num = 0
            for ch in str:
                if ch == '0':
                    zero_num += 1
                else:
                    one_num += 1
            for i in range(m, zero_num - 1, -1):
                for j in range(n, one_num - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zero_num][j - one_num] + 1)

        return dp[m][n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(l \times m \times n)$，其中 $l$ 为字符串 $strs$ 的长度。
- **空间复杂度**：$O(m \times n)$。

# [0480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)

- 标签：数组、哈希表、滑动窗口、堆（优先队列）
- 难度：困难

## 题目链接

- [0480. 滑动窗口中位数 - 力扣](https://leetcode.cn/problems/sliding-window-median/)

## 题目大意

**描述**：给定一个数组 $nums$，有一个长度为 $k$ 的窗口从最左端滑动到最右端。窗口中有 $k$ 个数，每次窗口向右移动 $1$ 位。

**要求**：找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

**说明**：

- **中位数**：有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
- 例如：
  - $[2,3,4]$，中位数是 $3$
  - $[2,3]$，中位数是 $(2 + 3) / 2 = 2.5$。
- 你可以假设 $k$ 始终有效，即：$k$ 始终小于等于输入的非空数组的元素个数。
- 与真实值误差在 $10 ^ {-5}$ 以内的答案将被视作正确答案。

**示例**：

- 示例 1：

```python
给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。
```

## 解题思路

### 思路 1：小顶堆 + 大顶堆

题目要求动态维护长度为 $k$ 的窗口中元素的中位数。如果对窗口元素进行排序，时间复杂度一般是 $O(k \times \log k)$。如果对每个区间都进行排序，那时间复杂度就更大了，肯定会超时。

我们需要借助一个内部有序的数据结构，来降低取窗口中位数的时间复杂度。Python 可以借助 `heapq` 构建大顶堆和小顶堆。通过 $k$ 的奇偶性和堆顶元素来获取中位数。

接下来还要考虑几个问题：初始化问题、取中位数问题、窗口滑动中元素的添加删除操作。接下来一一解决。

初始化问题：

我们将所有大于中位数的元素放到 $heap\underline{\hspace{0.5em}}max$（小顶堆）中，并且元素个数向上取整。然后再将所有小于等于中位数的元素放到 $heap\underline{\hspace{0.5em}}min$（大顶堆）中，并且元素个数向下取整。这样当 $k$ 为奇数时，$heap\underline{\hspace{0.5em}}max$ 比 $heap\underline{\hspace{0.5em}}min$ 多一个元素，中位数就是 $heap\underline{\hspace{0.5em}}max$ 堆顶元素。当 $k$ 为偶数时，$heap\underline{\hspace{0.5em}}max$ 和 $heap\underline{\hspace{0.5em}}min$ 中的元素个数相同，中位数就是 $heap\underline{\hspace{0.5em}}min$ 堆顶元素和 $heap\underline{\hspace{0.5em}}max$ 堆顶元素的平均数。这个过程操作如下：

- 先将数组中前 $k$ 个元素放到 $heap\underline{\hspace{0.5em}}max$ 中。
- 再从 $heap\underline{\hspace{0.5em}}max$ 中取出 $k // 2$ 个堆顶元素放到 $heap\underline{\hspace{0.5em}}min$ 中。

取中位数问题（上边提到过）：

- 当 $k$ 为奇数时，中位数就是 $heap\underline{\hspace{0.5em}}max$ 堆顶元素。当 $k$ 为偶数时，中位数就是 $heap\underline{\hspace{0.5em}}max$ 堆顶元素和 $heap\underline{\hspace{0.5em}}min$ 堆顶元素的平均数。

窗口滑动过程中元素的添加和删除问题：

- 删除：每次滑动将窗口左侧元素删除。由于 `heapq` 没有提供删除中间特定元素相对应的方法。所以我们使用「延迟删除」的方式先把待删除的元素标记上，等到待删除的元素出现在堆顶时，再将其移除。我们使用 $removes$ （哈希表）来记录待删除元素个数。
  - 将窗口左侧元素删除的操作为：`removes[nums[left]] += 1`。
- 添加：每次滑动在窗口右侧添加元素。需要根据上一步删除的结果来判断需要添加到哪一个堆上。我们用 $banlance$ 记录 $heap\underline{\hspace{0.5em}}max$ 和 $heap\underline{\hspace{0.5em}}min$ 元素个数的差值。
  - 如果窗口左边界 $nums[left]$小于等于 $heap\underline{\hspace{0.5em}}max$ 堆顶元素 ，则说明上一步删除的元素在 $heap\underline{\hspace{0.5em}}min$ 上，则让 `banlance -= 1`。
  - 如果窗口左边界 $nums[left]$ 大于 $heap\underline{\hspace{0.5em}}max$ 堆顶元素，则说明上一步删除的元素在 $heap\underline{\hspace{0.5em}}max$ 上，则上 `banlance += 1`。
  - 如果窗口右边界 $nums[right]$ 小于等于 $heap\underline{\hspace{0.5em}}max$ 堆顶元素，则说明待添加元素需要添加到 $heap\underline{\hspace{0.5em}}min$ 上，则让 `banlance += 1`。
  - 如果窗口右边界 $nums[right]$ 大于 $heap\underline{\hspace{0.5em}}max$ 堆顶元素，则说明待添加元素需要添加到 $heap\underline{\hspace{0.5em}}max$ 上，则让 `banlance -= 1`。
- 经过上述操作，$banlance$ 的取值为 $0$、$-2$、$2$ 中的一种。需要经过调整使得 $banlance == 0$。
  - 如果 $banlance == 0$，已经平衡，不需要再做操作。
  - 如果 $banlance == -2$，则说明 $heap\underline{\hspace{0.5em}}min$ 比 $heap\underline{\hspace{0.5em}}max$ 的元素多了两个。则从 $heap\underline{\hspace{0.5em}}min$ 中取出堆顶元素添加到 $heap\underline{\hspace{0.5em}}max$ 中。 
  - 如果 $banlance == 2$，则说明 $heap\underline{\hspace{0.5em}}max$ 比 $heap\underline{\hspace{0.5em}}min$ 的元素多了两个。则从 $heap\underline{\hspace{0.5em}}max$ 中取出堆顶元素添加到 $heap\underline{\hspace{0.5em}}min$ 中。
- 调整完之后，分别检查 $heap\underline{\hspace{0.5em}}max$ 和 $heap\underline{\hspace{0.5em}}min$ 的堆顶元素。
  - 如果 $heap\underline{\hspace{0.5em}}max$ 堆顶元素恰好为待删除元素，即 $removes[-heap\underline{\hspace{0.5em}}max[0]] > 0$，则弹出 $heap\underline{\hspace{0.5em}}max$ 堆顶元素。
  - 如果 $heap\underline{\hspace{0.5em}}min$ 堆顶元素恰好为待删除元素，即 $removes[heap\underline{\hspace{0.5em}}min[0]] > 0$，则弹出 $heap\underline{\hspace{0.5em}}min$ 堆顶元素。
- 最后取中位数放入答案数组中，然后继续滑动窗口。

### 思路 1：代码

```python
import collections
import heapq

class Solution:
    def median(self, heap_max, heap_min, k):
        if k % 2 == 1:
            return -heap_max[0]
        else:
            return (-heap_max[0] + heap_min[0]) / 2

    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        heap_max, heap_min = [], []
        removes = collections.Counter()

        for i in range(k):
            heapq.heappush(heap_max, -nums[i])
        for i in range(k // 2):
            heapq.heappush(heap_min, -heapq.heappop(heap_max))

        res = [self.median(heap_max, heap_min, k)]

        for i in range(k, len(nums)):
            banlance = 0
            left, right = i - k, i
            removes[nums[left]] += 1
            if heap_max and nums[left] <= -heap_max[0]:
                banlance -= 1
            else:
                banlance += 1

            if heap_max and nums[right] <= -heap_max[0]:
                heapq.heappush(heap_max, -nums[i])
                banlance += 1
            else:
                banlance -= 1
                heapq.heappush(heap_min, nums[i])

            if banlance == -2:
                heapq.heappush(heap_max, -heapq.heappop(heap_min))
            if banlance == 2:
                heapq.heappush(heap_min, -heapq.heappop(heap_max))

            while heap_max and removes[-heap_max[0]] > 0:
                removes[-heapq.heappop(heap_max)] -= 1
            while heap_min and removes[heap_min[0]] > 0:
                removes[heapq.heappop(heap_min)] -= 1
            res.append(self.median(heap_max, heap_min, k))

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[《风 险 对 冲》：双堆对顶，大堆小堆同时维护，44ms - 滑动窗口中位数 - 力扣](https://leetcode.cn/problems/sliding-window-median/solution/feng-xian-dui-chong-shuang-dui-dui-ding-hq1dt/)
# [0485. 最大连续 1 的个数](https://leetcode.cn/problems/max-consecutive-ones/)

- 标签：数组
- 难度：简单

## 题目链接

- [0485. 最大连续 1 的个数 - 力扣](https://leetcode.cn/problems/max-consecutive-ones/)

## 题目大意

**描述**：给定一个二进制数组 $nums$， 数组中只包含 $0$ 和 $1$。

**要求**：计算其中最大连续 $1$ 的个数。

**说明**：

- $1 \le nums.length \le 10^5$。
- $nums[i]$ 不是 $0$ 就是 $1$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
```

- 示例 2：

```python
输入：nums = [1,0,1,1,0,1]
输出：2
```

## 解题思路

### 思路 1：一次遍历

1. 使用两个变量 $cnt$ 和 $ans$。$cnt$ 用于存储当前连续 $1$ 的个数，$ans$ 用于存储最大连续 $1$ 的个数。
2. 然后进行一次遍历，统计当前连续 $1$ 的个数，并更新最大的连续 $1$ 个数。
3. 最后返回 $ans$ 作为答案。

### 思路 1：代码

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        ans = 0
        cnt = 0
        for num in nums:
            if num == 1:
                cnt += 1
                ans = max(ans, cnt)
            else:
                cnt = 0
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/)

- 标签：递归、数组、数学、动态规划、博弈
- 难度：中等

## 题目链接

- [0486. 预测赢家 - 力扣](https://leetcode.cn/problems/predict-the-winner/)

## 题目大意

**描述**：给定搞一个整数数组 $nums$。玩家 $1$ 和玩家 $2$ 基于这个数组设计了一个游戏。

玩家 $1$ 和玩家 $2$ 轮流进行自己的回合，玩家 $1$ 先手。

开始时，两个玩家的初始分值都是 $0$。每一回合，玩家从数组的任意一端取一个数字（即 $nums[0]$ 或 $nums[nums.length - 1]$），取到的数字将会从数组中移除（数组长度减 $1$）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。

**要求**：如果玩家 $1$ 能成为赢家，则返回 `True`。否则返回 `False`。如果两个玩家得分相等，同样认为玩家 $1$ 是游戏的赢家，也返回 `True`。假设每个玩家的玩法都会使他的分数最大化。

**说明**：

- $1 \le nums.length \le 20$。
- $0 \le nums[i] \le 10^7$。

**示例**：

- 示例 1：

```python
输入：nums = [1,5,2]
输出：False
解释：一开始，玩家 1 可以从 1 和 2 中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False。
```

- 示例 2：

```python
输入：nums = [1,5,233,7]
输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：玩家 $1$ 与玩家 $2$ 在 $nums[i]...nums[j]$ 之间互相选取，玩家 $1$ 比玩家 $2$ 多的最大分数。

###### 3. 状态转移方程

根据状态的定义，只有在 $i \le j$ 时才有意义，所以当 $i > j$ 时，$dp[i][j] = 0$。

1. 当 $i == j$ 时，当前玩家只能拿取 $nums[i]$，因此对于所有 $0 \le i < nums.length$，都有：$dp[i][i] = nums[i]$。
2. 当 $i < j$ 时，当前玩家可以选择 $nums[i]$ 或 $nums[j]$，并是自己的分数最大化，然后换另一位玩家从剩下部分选取数字。则转移方程为：$dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])$。

###### 4. 初始条件

- 当 $i > j$ 时，$dp[i][j] = 0$。
- 当 $i == j$ 时，$dp[i][j] = nums[i]$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：玩家 $1$ 与玩家 $2$ 在 $nums[i]...nums[j]$ 之间互相选取，玩家 $1$ 比玩家 $2$ 多的最大分数。则如果玩家 $1$ 想要赢，则  $dp[0][size - 1]$ 必须大于等于 $0$。所以最终结果为 $dp[0][size - 1] >= 0$。

### 思路 1：代码

```python
class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        size = len(nums)
        dp = [[0 for _ in range(size)] for _ in range(size)]

        for l in range(1, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                if l == 1:
                    dp[i][j] = nums[i]
                else:
                    dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
        return dp[0][size - 1] >= 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n^2)$。

# [0487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)

- 标签：数组、动态规划、滑动窗口
- 难度：中等

## 题目链接

- [0487. 最大连续1的个数 II - 力扣](https://leetcode.cn/problems/max-consecutive-ones-ii/)

## 题目大意

**描述**：给定一个二进制数组 $nums$，可以最多将 $1$ 个 $0$ 翻转为 $1$。

**要求**：如果最多可以翻转一个 $0$，则返回数组中连续 $1$ 的最大个数。

**说明**：

- 1 <= nums.length <= 105
  nums[i] 不是 0 就是 1.

**示例**：

- 示例 1：

```python
输入：nums = [1,0,1,1,0]
输出：4
解释：翻转第一个 0 可以得到最长的连续 1。当翻转以后，最大连续 1 的个数为 4。
```

- 示例 2：

```python
输入：nums = [1,0,1,1,0,1]
输出：4
```

## 解题思路

### 思路 1：滑动窗口

暴力做法是尝试将每个位置的 $0$ 分别变为 $1$，然后统计最大连续 $1$ 的个数。但这样复杂度就太高了。

我们可以使用滑动窗口来解决问题。保证滑动窗口内最多有 $1$ 个 $0$。具体做法如下：

设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证滑动窗口内最多有 $1$ 个 $0$。使用 $zero\underline{\hspace{0.5em}}count$ 统计窗口内 $1$ 的个数。使用 $ans$ 记录答案。

- 一开始，$left$、$right$ 都指向 $0$。
- 如果 $nums[right] == 0$，则窗口内 $1$ 的个数加 $1$。
- 如果该窗口中 $1$ 的个数多于 $1$ 个，即 $zero\underline{\hspace{0.5em}}count > 1$，则不断右移 $left$，缩小滑动窗口长度，并更新窗口中 $1$ 的个数，直到 $zero\underline{\hspace{0.5em}}count \le 1$。
- 维护更新最大连续 $1$ 的个数。然后右移 $right$，直到 $right \ge len(nums)$ 结束。
- 输出最大连续 $1$ 的个数。

### 思路 1：代码

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        left, right = 0, 0
        ans = 0
        zero_count = 0

        while right < len(nums):
            if nums[right] == 0:
                zero_count += 1
            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。

# [0491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

- 标签：位运算、数组、哈希表、回溯
- 难度：中等

## 题目链接

- [0491. 递增子序列 - 力扣](https://leetcode.cn/problems/increasing-subsequences/)

## 题目大意

给定一个整数数组 `nums`，找出并返回该数组的所有递增子序列，递增子序列的长度至少为 2。

## 解题思路

可以利用回溯算法求解。

建立两个数组 res、path。res 用于存放所有递增子序列，path 用于存放当前的递增子序列。

定义回溯方法，从 `start_index = 0` 的位置开始遍历。

- 如果当前子序列的长度大于等于 2，则将当前递增子序列添加到 res 数组中（注意：不用返回，因为还要继续向下查找）
- 对数组 `[start_index, len(nums) - 1]` 范围内的元素进行取值，判断当前元素是否在本层出现过。如果出现过则跳出循环。
  - 将 `nums[i]` 标记为使用过。
  - 将 `nums[i]` 加入到当前 path 中。
  - 继续从 `i + 1` 开发遍历下一节点。
  - 进行回退操作。
- 最终返回 res 数组。

## 代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, nums: List[int], start_index):
        if len(self.path) > 1:
            self.res.append(self.path[:])

        num_set = set()
        for i in range(start_index, len(nums)):
            if self.path and nums[i] < self.path[-1] or nums[i] in num_set:
                continue

            num_set.add(nums[i])
            self.path.append(nums[i])
            self.backtrack(nums, i + 1)
            self.path.pop()

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        self.backtrack(nums, 0)
        return self.res
```

# [0494. 目标和](https://leetcode.cn/problems/target-sum/)

- 标签：数组、动态规划、回溯
- 难度：中等

## 题目链接

- [0494. 目标和 - 力扣](https://leetcode.cn/problems/target-sum/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $target$。数组长度不超过 $20$。向数组中每个整数前加 `+` 或 `-`。然后串联起来构造成一个表达式。

**要求**：返回通过上述方法构造的、运算结果等于 $target$ 的不同表达式数目。

**说明**：

- $1 \le nums.length \le 20$。
- $0 \le nums[i] \le 1000$。
- $0 \le sum(nums[i]) \le 1000$。
- $-1000 \le target \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

- 示例 2：

```python
输入：nums = [1], target = 1
输出：1
```

## 解题思路

### 思路 1：深度优先搜索（超时）

使用深度优先搜索对每位数字进行 `+` 或者 `-`，具体步骤如下：

1. 定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 `dfs(0, 0)`。
2. 下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。
3. 如果当前位置 $i$ 到达最后一个位置 $size$：
   1. 如果和 $cur\underline{\hspace{0.5em}}sum$ 等于目标和 $target$，则返回方案数 $1$。
   2. 如果和 $cur\underline{\hspace{0.5em}}sum$ 不等于目标和 $target$，则返回方案数 $0$。
4. 递归搜索 $i + 1$ 位置，和为 $cur\underline{\hspace{0.5em}}sum  -  nums[i]$ 的方案数。
5. 递归搜索 $i + 1$ 位置，和为 $cur\underline{\hspace{0.5em}}sum  +  nums[i]$ 的方案数。
6. 将 4 ~ 5 两个方案数加起来就是当前位置 $i$、和为 $cur\underline{\hspace{0.5em}}sum$ 的方案数，返回该方案数。
7. 最终方案数为 `dfs(0, 0)`，将其作为答案返回即可。

### 思路 1：代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        size = len(nums)

        def dfs(i, cur_sum):
            if i == size:
                if cur_sum == target:
                    return 1
                else:
                    return 0
            ans = dfs(i + 1, cur_sum - nums[i]) + dfs(i + 1, cur_sum + nums[i])
            return ans
        
        return dfs(0, 0)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。递归调用的栈空间深度不超过 $n$。

### 思路 2：记忆化搜索

在思路 1 中我们单独使用深度优先搜索对每位数字进行 `+` 或者 `-` 的方法超时了。所以我们考虑使用记忆化搜索的方式，避免进行重复搜索。

这里我们使用哈希表 $$table$$ 记录遍历过的位置 $i$ 及所得到的的当前和 $cur\underline{\hspace{0.5em}}sum$ 下的方案数，来避免重复搜索。具体步骤如下：

1. 定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 `dfs(0, 0)`。
2. 下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。
3. 如果当前位置 $i$ 遍历完所有位置：
   1. 如果和 $cur\underline{\hspace{0.5em}}sum$ 等于目标和 $target$，则返回方案数 $1$。
   2. 如果和 $cur\underline{\hspace{0.5em}}sum$ 不等于目标和 $target$，则返回方案数 $0$。
4. 如果当前位置 $i$、和为 $cur\underline{\hspace{0.5em}}sum$  之前记录过（即使用 $table$ 记录过对应方案数），则返回该方案数。
5. 如果当前位置 $i$、和为 $cur\underline{\hspace{0.5em}}sum$  之前没有记录过，则：
   1. 递归搜索 $i + 1$ 位置，和为 $cur\underline{\hspace{0.5em}}sum  -  nums[i]$ 的方案数。
   2. 递归搜索 $i + 1$ 位置，和为 $cur\underline{\hspace{0.5em}}sum  +  nums[i]$ 的方案数。
   3. 将上述两个方案数加起来就是当前位置 $i$、和为 $cur\underline{\hspace{0.5em}}sum$ 的方案数，将其记录到哈希表 $table$ 中，并返回该方案数。
6. 最终方案数为 `dfs(0, 0)`，将其作为答案返回即可。

### 思路 2：代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        size = len(nums)
        table = dict()

        def dfs(i, cur_sum):
            if i == size:
                if cur_sum == target:
                    return 1
                else:
                    return 0
                    
            if (i, cur_sum) in table:
                return table[(i, cur_sum)]
            
            cnt = dfs(i + 1, cur_sum - nums[i]) + dfs(i + 1, cur_sum + nums[i])
            table[(i, cur_sum)] = cnt
            return cnt

        return dfs(0, 0)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。递归调用的栈空间深度不超过 $n$。

### 思路 3：动态规划

假设数组中所有元素和为 $sum$，数组中所有符号为 `+` 的元素为 $sum\underline{\hspace{0.5em}}x$，符号为 `-` 的元素和为 $sum\underline{\hspace{0.5em}}y$。则 $target = sum\underline{\hspace{0.5em}}x - sum\underline{\hspace{0.5em}}y$。

而 $sum\underline{\hspace{0.5em}}x + sum\underline{\hspace{0.5em}}y = sum$。根据两个式子可以求出 $2 \times sum\underline{\hspace{0.5em}}x = target + sum$，即 $sum\underline{\hspace{0.5em}}x = (target + sum) / 2$。

那么这道题就变成了，如何在数组中找到一个集合，使集合中元素和为 $(target + sum) / 2$。这就变为了「0-1 背包问题」中求装满背包的方案数问题。

###### 1. 定义状态

定义状态 $dp[i]$ 表示为：填满容量为 $i$ 的背包，有 $dp[i]$ 种方法。

###### 2. 状态转移方程

填满容量为 $i$ 的背包的方法数来源于：

1. 不使用当前 $num$：只使用之前元素填满容量为 $i$ 的背包的方法数。
2. 使用当前 $num$：填满容量 $i - num$ 的包的方法数，再填入 $num$ 的方法数。

则动态规划的状态转移方程为：$dp[i] = dp[i] + dp[i - num]$。

###### 3. 初始化

初始状态下，默认填满容量为 $0$ 的背包有 $1$ 种办法（什么也不装）。即 $dp[i] = 1$。

###### 4. 最终结果

根据状态定义，最后输出 $dp[sise]$（即填满容量为 $size$ 的背包，有 $dp[size]$ 种方法）即可，其中 $size$ 为数组 $nums$ 的长度。

### 思路 3：代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sum_nums = sum(nums)
        if abs(target) > abs(sum_nums) or (target + sum_nums) % 2 == 1:
            return 0
        size = (target + sum_nums) // 2
        dp = [0 for _ in range(size + 1)]
        dp[0] = 1
        for num in nums:
            for i in range(size, num - 1, -1):
                dp[i] = dp[i] + dp[i - num]
        return dp[size]
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。
# [0496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

- 标签：栈、数组、哈希表、单调栈
- 难度：简单

## 题目链接

- [0496. 下一个更大元素 I - 力扣](https://leetcode.cn/problems/next-greater-element-i/)

## 题目大意

**描述**：给定两个没有重复元素的数组 `nums1` 和 `nums2` ，其中 `nums1` 是 `nums2` 的子集。

**要求**：找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。

**说明**：

- `nums1` 中数字 `x` 的下一个更大元素是指： `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素。如果不存在，对应位置输出 `-1`。
- $1 \le nums1.length \le nums2.length \le 1000$。
- $0 \le nums1[i], nums2[i] \le 10^4$。
- $nums1$ 和 $nums2$ 中所有整数互不相同。
- $nums1$ 中的所有整数同样出现在 $nums2$ 中。

**示例**：

- 示例 1：

```python
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

- 示例 2：

```python
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```

## 解题思路

最直接的思路是根据题意直接暴力求解。遍历 `nums1` 中的每一个元素。对于 `nums1` 的每一个元素 `nums1[i]`，再遍历一遍 `nums2`，查找 `nums2` 中对应位置右边第一个比 `nums1[i]` 大的元素。这种解法的时间复杂度是 $O(n^2)$。

另一种思路是单调栈。

### 思路 1：单调栈

因为 `nums1` 是 `nums2` 的子集，所以我们可以先遍历一遍 `nums2`，并构造单调递增栈，求出 `nums2` 中每个元素右侧下一个更大的元素。然后将其存储到哈希表中。然后再遍历一遍 `nums1`，从哈希表中取出对应结果，存放到答案数组中。这种解法的时间复杂度是 $O(n)$。具体做法如下：

1. 使用数组 `res` 存放答案。使用 `stack` 表示单调递增栈。使用哈希表 `num_map` 用于存储 `nums2` 中下一个比当前元素大的数值，映射关系为 `当前元素值：下一个比当前元素大的数值`。

2. 遍历数组 `nums2`，对于当前元素：
   1. 如果当前元素值较小，则直接让当前元素值入栈。
   2. 如果当前元素值较大，则一直出栈，直到当前元素值小于栈顶元素。
      1. 出栈时，第一个大于栈顶元素值的元素，就是当前元素。则将其映射到 `num_map` 中。
3. 遍历完数组 `nums2`，建立好所有元素下一个更大元素的映射关系之后，再遍历数组 `nums1`。
4. 从 `num_map` 中取出对应的值，将其加入到答案数组中。
5. 最终输出答案数组 `res`。

### 思路 1：代码

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        stack = []
        num_map = dict()
        for num in nums2:
            while stack and num > stack[-1]:
                num_map[stack[-1]] = num
                stack.pop()
            stack.append(num)

        for num in nums1:
            res.append(num_map.get(num, -1))
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

- 标签：数组、矩阵、模拟
- 难度：中等

## 题目链接

- [0498. 对角线遍历 - 力扣](https://leetcode.cn/problems/diagonal-traverse/)

## 题目大意

**描述**：给定一个大小为 $m \times n$ 的矩阵 $mat$ 。

**要求**：以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

**说明**：

- $m == mat.length$。
- $n == mat[i].length$。
- $1 \le m, n \le 10^4$。
- $1 \le m \times n \le 10^4$。
- $-10^5 \le mat[i][j] \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

```python
输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,4,7,5,3,6,8,9]
```

- 示例 2：

```python
输入：mat = [[1,2],[3,4]]
输出：[1,2,3,4]
```

## 解题思路

### 思路 1：找规律 + 考虑边界问题

这道题的关键是「找规律」和「考虑边界问题」。

找规律：

1. 当「行号 + 列号」为偶数时，遍历方向为从左下到右上。可以记为右上方向 $(-1, +1)$，即行号减 $1$，列号加 $1$。
2. 当「行号 + 列号」为奇数时，遍历方向为从右上到左下。可以记为左下方向 $(+1, -1)$，即行号加 $1$，列号减 $1$。

边界情况：

1. 向右上方向移动时：
   1. 如果在最后一列，则向下方移动，即 `x += 1`。
   2. 如果在第一行，则向右方移动，即 `y += 1`。
   3. 其余情况想右上方向移动，即 `x -= 1`、`y += 1`。
2. 向左下方向移动时：
   1. 如果在最后一行，则向右方移动，即 `y += 1`。
   2. 如果在第一列，则向下方移动，即 `x += 1`。
   3. 其余情况向左下方向移动，即 `x += 1`、`y -= 1`。

### 思路 1：代码

```python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        rows = len(mat)
        cols = len(mat[0])
        count = rows * cols
        x, y = 0, 0
        ans = []

        for i in range(count):
            ans.append(mat[x][y])

            if (x + y) % 2 == 0:
                # 最后一列
                if y == cols - 1:
                    x += 1
                # 第一行
                elif x == 0:
                    y += 1
                # 右上方向
                else:
                    x -= 1
                    y += 1
            else:
                # 最后一行
                if x == rows - 1:
                    y += 1
                # 第一列
                elif y == 0:
                    x += 1
                # 左下方向
                else:
                    x += 1
                    y -= 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$、$n$ 分别为二维矩阵的行数、列数。
- **空间复杂度**：$O(m \times n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(m \times n)$。不算上则空间复杂度为 $O(1)$。

## 参考资料

- 【题解】[「498. 对角线遍历」最简单易懂! - 对角线遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/diagonal-traverse/solution/498-dui-jiao-xian-bian-li-zui-jian-dan-y-ibu3/)

# [0501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [0501. 二叉搜索树中的众数 - 力扣](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

## 题目大意

给定一个有相同值的二叉搜索树（BST），要求找出 BST 中所有众数（出现频率最高的元素）。

二叉搜索树定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

## 解题思路

中序递归遍历二叉搜索树所得到的结果是一个有序数组，所以问题就变为了如何统计有序数组的众数。

定义几个变量。`count` 用来统计当前元素值对应的节点个数，`max_count` 用来元素出现次数最多的次数。数组 `res` 用来存储所有众数结果（因为众数可能不止一个）。

因为中序递归遍历二叉树，比较的元素肯定是相邻节点，所以需要再使用一个变量 `pre` 来指向前一节点。下面就开始愉快的递归了。

- 如果当前节点为空，直接返回。
- 递归遍历左子树。
- 比较当前节点和前一节点：
  - 如果前一节点为空，则当前元素频率赋值为 1。
  - 如果前一节点值与当前节点值相同，则当前元素频率 + 1。
  - 如果前一节点值与当前节点值不同，则重新计算当前元素频率，将当前元素频率赋值为 1。
- 判断当前元素频率和最高频率关系：
  - 如果当前元素频率和最高频率值相等，则将对应元素值加入 res 数组。
  - 如果当前元素频率大于最高频率值，则更新最高频率值，并清空原 res 数组，将当前元素加入 res 数组。
- 递归遍历右子树。

最终得到的 res 数组即为所求的众数。

## 代码

```python
class Solution:
    res = []
    count = 0
    max_count = 0
    pre = None
    def search(self, cur: TreeNode):
        if not cur:
            return
        self.search(cur.left)
        if not self.pre:
            self.count = 1
        elif self.pre.val == cur.val:
            self.count += 1
        else:
            self.count = 1

        self.pre = cur

        if self.count == self.max_count:
            self.res.append(cur.val)
        elif self.count > self.max_count:
            self.max_count = self.count
            self.res.clear()
            self.res.append(cur.val)

        self.search(cur.right)
        return

    def findMode(self, root: TreeNode) -> List[int]:
        self.count = 0
        self.max_count = 0
        self.res.clear()
        self.pre = None
        self.search(root)
        return self.res
```

# [0503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

- 标签：栈、数组、单调栈
- 难度：中等

## 题目链接

- [0503. 下一个更大元素 II - 力扣](https://leetcode.cn/problems/next-greater-element-ii/)

## 题目大意

给定一个循环数组 `nums`（最后一个元素的下一个元素是数组的第一个元素）。

要求：输出每个元素的下一个更大元素。如果不存在，则输出 `-1`。

- 数字 `x` 的下一个更大的元素：按数组遍历顺序，这个数字之后的第一个比它更大的数。这意味着你应该循环地搜索它的下一个更大的数。

## 解题思路

第一种思路是根据题意直接暴力求解。遍历 `nums` 中的每一个元素。对于 `nums` 的每一个元素 `nums[i]`，查找 `nums[i]` 右边第一个比 `nums1[i]` 大的元素。这种解法的时间复杂度是 $O(n^2)$。

第二种思路是使用单调递增栈。遍历数组 `nums`，构造单调递增栈，求出 `nums` 中每个元素右侧下一个更大的元素。然后将其存储到答案数组中。这种解法的时间复杂度是 $O(n)$。

而循环数组的求解方法可以将 `nums` 复制一份到末尾，生成长度为 `len(nums) * 2` 的数组，或者通过取模运算将下标映射到 `0` ~ `len(nums) * 2 - 1` 之间。

具体做法如下：

- 使用数组 `res` 存放答案，初始值都赋值为 `-1`。使用变量 `stack` 表示单调递增栈。
- 遍历数组 `nums`，对于当前元素：
  - 如果当前元素值小于栈顶元素，则说明当前元素「下一个更大元素」与栈顶元素的「下一个更大元素」相同。应该直接让当前元素的下标入栈。
  - 如果当前元素值大于栈顶元素，则说明当前元素是之前元素的「下一个更大元素」，则不断将栈顶元素出栈。直到当前元素值小于栈顶元素值。
    - 出栈时，出栈元素的「下一个更大元素」是当前元素。则将当前元素值存入到答案数组 `res` 中出栈元素所对应的位置中。
- 最终输出答案数组 `res`。

## 代码

```python
size = len(nums)
        res = [-1 for _ in range(size)]
        stack = []
        for i in range(size * 2):
            while stack and nums[i % size] > nums[stack[-1]]:
                index = stack.pop()
                res[index] = nums[i % size]
            stack.append(i % size)

        return res
```

# [0504. 七进制数](https://leetcode.cn/problems/base-7/)

- 标签：数学
- 难度：简单

## 题目链接

- [0504. 七进制数 - 力扣](https://leetcode.cn/problems/base-7/)

## 题目大意

**描述**：给定一个整数 $num$。

**要求**：将其转换为 $7$ 进制数，并以字符串形式输出。

**说明**：

- $-10^7 \le num \le 10^7$。

**示例**：

- 示例 1：

```python
输入: num = 100
输出: "202"
```

- 示例 2：

```python
输入: num = -7
输出: "-10"
```

## 解题思路

### 思路 1：模拟

1. $num$ 不断对 $7$ 取余整除。
2. 然后将取到的余数进行拼接成字符串即可。

### 思路 1：代码

```python
class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return "0"
        if num < 0:
            return "-" + self.convertToBase7(-num)
        ans = ""
        while num:
            ans = str(num % 7) + ans
            num //= 7
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log |n|)$。
- **空间复杂度**：$O(\log |n|)$。

# [0506. 相对名次](https://leetcode.cn/problems/relative-ranks/)

- 标签：数组、排序、堆（优先队列）
- 难度：简单

## 题目链接

- [0506. 相对名次 - 力扣](https://leetcode.cn/problems/relative-ranks/)

## 题目大意

**描述**：给定一个长度为 $n$ 的数组 $score$。其中 $score[i]$ 表示第 $i$ 名运动员在比赛中的成绩。所有成绩互不相同。

**要求**：找出他们的相对名次，并授予前三名对应的奖牌。前三名运动员将会被分别授予「金牌（`"Gold Medal"`）」，「银牌（`"Silver Medal"`）」和「铜牌（`"Bronze Medal"`）」。

**说明**：

- $n == score.length$。
- $1 \le n \le 10^4$。
- $0 \le score[i] \le 10^6$。
- $score$ 中的所有值互不相同。

**示例**：

- 示例 1：

```python
输入：score = [5,4,3,2,1]
输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
```

- 示例 2：

```python
输入：score = [10,3,8,9,4]
输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
```

## 解题思路

### 思路 1：排序

1. 先对数组 $score$ 进行排序。
2. 再将对应前三个位置上的元素替换成对应的字符串：`"Gold Medal"`, `"Silver Medal"`, `"Bronze Medal"`。

### 思路 1：代码

```python
class Solution:
    def shellSort(self, arr):
        size = len(arr)
        gap = size // 2

        while gap > 0:
            for i in range(gap, size):
                temp = arr[i]
                j = i
                while j >= gap and arr[j - gap] < temp:
                    arr[j] = arr[j - gap]
                    j -= gap
                arr[j] = temp
            gap = gap // 2
        return arr

    def findRelativeRanks(self, score: List[int]) -> List[str]:
        nums = score.copy()
        nums = self.shellSort(nums)
        score_map = dict()
        for i in range(len(nums)):
            score_map[nums[i]] = i + 1

        res = []
        for i in range(len(score)):
            if score[i] == nums[0]:
                res.append("Gold Medal")
            elif score[i] == nums[1]:
                res.append("Silver Medal")
            elif score[i] == nums[2]:
                res.append("Bronze Medal")
            else:
                res.append(str(score_map[score[i]]))
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。因为采用了时间复杂度为 $O(n \times \log n)$ 的希尔排序。
- **空间复杂度**：$O(n)$。
# [0509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

- 标签：递归、记忆化搜索、数学、动态规划
- 难度：简单

## 题目链接

- [0509. 斐波那契数 - 力扣](https://leetcode.cn/problems/fibonacci-number/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：计算第 $n$ 个斐波那契数。

**说明**：

- 斐波那契数列的定义如下：
  - $f(0) = 0, f(1) = 1$。
  - $f(n) = f(n - 1) + f(n - 2)$，其中 $n > 1$。
- $0 \le n \le 30$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

- 示例 2：

```python
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

## 解题思路

### 思路 1：递归算法

根据我们的递推三步走策略，写出对应的递归代码。

1. 写出递推公式：$f(n) = f(n - 1) + f(n - 2)$。
2. 明确终止条件：$f(0) = 0, f(1) = 1$。
3. 翻译为递归代码：
   1. 定义递归函数：`fib(self, n)` 表示输入参数为问题的规模 $n$，返回结果为第 $n$ 个斐波那契数。
   2. 书写递归主体：`return self.fib(n - 1) + self.fib(n - 2)`。
   3. 明确递归终止条件：
      1. `if n == 0: return 0`
      2. `if n == 1: return 1`

### 思路 1：代码

```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return self.fib(n - 1) + self.fib(n - 2)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O((\frac{1 + \sqrt{5}}{2})^n)$。具体证明方法参考 [递归求斐波那契数列的时间复杂度，不要被网上的答案误导了 - 知乎](https://zhuanlan.zhihu.com/p/256344121)。
- **空间复杂度**：$O(n)$。每次递归的空间复杂度是 $O(1)$， 调用栈的深度为 $n$，所以总的空间复杂度就是 $O(n)$。

### 思路 2：动态规划算法

###### 1. 划分阶段

我们可以按照整数顺序进行阶段划分，将其划分为整数 $0 \sim n$。

###### 2. 定义状态

定义状态 $dp[i]$ 为：第 $i$ 个斐波那契数。

###### 3. 状态转移方程

根据题目中所给的斐波那契数列的定义 $f(n) = f(n - 1) + f(n - 2)$，则直接得出状态转移方程为 $dp[i] = dp[i - 1] + dp[i - 2]$。

###### 4. 初始条件

根据题目中所给的初始条件 $f(0) = 0, f(1) = 1$ 确定动态规划的初始条件，即 $dp[0] = 0, dp[1] = 1$。

###### 5. 最终结果

根据状态定义，最终结果为 $dp[n]$，即第 $n$ 个斐波那契数为 $dp[n]$。

### 思路 2：代码

```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n

        dp = [0 for _ in range(n + 1)]
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 2] + dp[i - 1]

        return dp[n]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。因为 $dp[i]$ 的状态只依赖于 $dp[i - 1]$ 和 $dp[i - 2]$，所以可以使用 $3$ 个变量来分别表示 $dp[i]$、$dp[i - 1]$、$dp[i - 2]$，从而将空间复杂度优化到 $O(1)$。
# [0513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0513. 找树左下角的值 - 力扣](https://leetcode.cn/problems/find-bottom-left-tree-value/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：找出该二叉树 「最底层」的「最左边」节点的值。

**说明**：

- 假设二叉树中至少有一个节点。
- 二叉树的节点个数的范围是 $[1,10^4]$。
- $-2^{31} \le Node.val \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：[1,2,3,4,null,5,6,null,null,7]
输出：7
```

![](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

## 解题思路

### 思路 1：层序遍历

这个问题可以拆分为两个问题：

1. 如何找到「最底层」。
2. 在「最底层」如何找到最左边的节点。

第一个问题，我们可以通过层序遍历直接确定最底层节点。而第二个问题可以通过改变层序遍历的左右节点访问顺序从而找到「最底层」的「最左边节点」。具体方法如下：

1. 对二叉树进行层序遍历。每层元素先访问右节点，再访问左节点。
2. 当遍历到最后一个元素时，此时最后一个元素就是「最底层」的「最左边」节点，即左下角的节点，将该节点的值返回即可。

### 思路 1：层序遍历代码

```python
import collections
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return -1
        queue = collections.deque()
        queue.append(root)
        while queue:
            cur = queue.popleft()
            if cur.right:
                queue.append(cur.right)
            if cur.left:
                queue.append(cur.left)
        return cur.val
```

# [0515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0515. 在每个树行中找最大值 - 力扣](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：找出二叉树中每一层的最大值。

## 解题思路

利用队列进行层序遍历，并记录下每一层的最大值，将其存入答案数组中。

## 代码

```python

```

# [0516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0516. 最长回文子序列 - 力扣](https://leetcode.cn/problems/longest-palindromic-subsequence/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：找出其中最长的回文子序列，并返回该序列的长度。

**说明**：

- **子序列**：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
- $1 \le s.length \le 1000$。
- $s$ 仅由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb"。
```

- 示例 2：

```python
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb"。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：字符串 $s$ 在区间 $[i, j]$ 范围内的最长回文子序列长度。

###### 3. 状态转移方程

我们对区间 $[i, j]$ 边界位置上的字符 $s[i]$ 与 $s[j]$ 进行分类讨论：

1. 如果 $s[i] = s[j]$，则 $dp[i][j]$ 为区间 $[i + 1, j - 1]$ 范围内最长回文子序列长度 + $2$，即 $dp[i][j] = dp[i + 1][j - 1] + 2$。
2. 如果 $s[i] \ne s[j]$，则 $dp[i][j]$ 取决于以下两种情况，取其最大的一种：
	1. 加入 $s[i]$ 所能组成的最长回文子序列长度，即：$dp[i][j] = dp[i][j - 1]$。
	2. 加入 $s[j]$ 所能组成的最长回文子序列长度，即：$dp[i][j] = dp[i - 1][j]$。

则状态转移方程为：

$dp[i][j] = \begin{cases} max \lbrace dp[i + 1][j - 1] + 2 \rbrace & s[i] = s[j]  \cr max \lbrace dp[i][j - 1], dp[i - 1][j] \rbrace & s[i] \ne s[j] \end{cases}$

###### 4. 初始条件

- 单个字符的最长回文序列是 $1$，即 $dp[i][i] = 1$。

###### 5. 最终结果

由于 $dp[i][j]$ 依赖于 $dp[i + 1][j - 1]$、$dp[i + 1][j]$、$dp[i][j - 1]$，所以我们应该按照从下到上、从左到右的顺序进行遍历。

根据我们之前定义的状态，$dp[i][j]$ 表示为：字符串 $s$ 在区间 $[i, j]$ 范围内的最长回文子序列长度。所以最终结果为 $dp[0][size - 1]$。

### 思路 1：代码

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        size = len(s)
        dp = [[0 for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = 1

        for i in range(size - 1, -1, -1):
            for j in range(i + 1, size):
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

        return dp[0][size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n^2)$。

# [0518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [0518. 零钱兑换 II - 力扣](https://leetcode.cn/problems/coin-change-ii/)

## 题目大意

**描述**：给定一个整数数组 $coins$ 表示不同面额的硬币，另给一个整数 $amount$ 表示总金额。

**要求**：计算并返回可以凑成总金额的硬币方案数。如果无法凑出总金额，则返回 $0$。

**说明**：

- 每一种面额的硬币枚数为无限个。
- $1 \le coins.length \le 300$。
- $1 \le coins[i] \le 5000$。
- $coins$ 中的所有值互不相同。
- $0 \le amount \le 5000$。

**示例**：

- 示例 1：

```python
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

- 示例 2：

```python
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3。
```

## 解题思路

### 思路 1：动态规划

这道题可以转换为：有 $n$ 种不同的硬币，$coins[i]$ 表示第 $i$ 种硬币的面额，每种硬币可以无限次使用。请问凑成总金额为 $amount$ 的背包，一共有多少种方案？

这就变成了完全背包问题。「[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)」中计算的是凑成总金额的最少硬币个数，而这道题计算的是凑成总金额的方案数。

###### 1. 划分阶段

按照当前背包的载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：凑成总金额为 $i$ 的方案总数。

###### 3. 状态转移方程

凑成总金额为 $i$ 的方案数 = 「不使用当前 $coin$，只使用之前硬币凑成金额 $i$ 的方案数」+「使用当前 $coin$ 凑成金额 $i - coin$ 的方案数」。即状态转移方程为：$dp[i] = dp[i] + dp[i - coin]$。

###### 4. 初始条件

- 凑成总金额为 $0$ 的方案数为 $1$，即 $dp[0] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：凑成总金额为 $i$ 的方案总数。 所以最终结果为 $dp[amount]$。

### 思路 1：代码

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:

        dp = [0 for _ in range(amount + 1)]
        dp[0] = 1
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i - coin]

        return dp[amount]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times amount)$，其中 $n$ 为数组 $coins$ 的元素个数，$amount$ 为总金额。
- **空间复杂度**：$O(amount)$。

# [0525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

- 标签：数组、哈希表、前缀和
- 难度：中等

## 题目链接

- [0525. 连续数组 - 力扣](https://leetcode.cn/problems/contiguous-array/)

## 题目大意

给定一个二进制数组 `nums`。

要求：找到含有相同数量 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

## 解题思路

「`0` 和 `1` 数量相同」等价于「`1` 的数量减去 `0` 的数量等于 `0`」。

我们可以使用一个变量 `pre_diff` 来记录下前 `i` 个数中，`1` 的数量比 `0` 的数量多多少个。我们把这个 `pre_diff`叫做「`1` 和 `0` 数量差」，也可以理解为变种的前缀和。

然后我们再用一个哈希表 `pre_dic` 来记录「`1` 和 `0` 数量差」第一次出现的下标。

那么，如果我们在遍历的时候，发现 `pre_diff` 相同的数量差已经在之前出现过了，则说明：这两段之间相减的 `1` 和 `0` 数量差为 `0`。

什么意思呢？

比如说：`j < i`，前 `j` 个数中第一次出现 `pre_diff == 2` ，然后前 `i` 个数中个第二次又出现了 `pre_diff == 2`。那么这两段形成的子数组 `nums[j + 1: i]` 中 `1` 比 `0` 多 `0` 个，则 `0` 和 `1` 数量相同的子数组长度为 `i - j`。

而第二次之所以又出现 `pre_diff == 2` ，是因为前半段子数组 `nums[0: j]`  贡献了相同的差值。

接下来还有一个小问题，如何计算「`1` 和 `0` 数量差」？

我们可以把数组中的 `1` 记为贡献 `+1`，`0` 记为贡献 `-1`。然后使用一个变量 `count`，只要出现 `1` 就让 `count` 加上 `1`，意思是又多出了 `1` 个 `1`。只要出现 `0`，将让 `count` 减去 `1`，意思是 `0` 和之前累积的 `1` 个 `1` 相互抵消掉了。这样遍历完数组，也就计算出了对应的「`1` 和 `0` 数量差」。

整个思路的具体做法如下：

- 创建一个哈希表，键值对关系为「`1` 和 `0` 的数量差：最早出现的下标 `i`」。
- 使用变量 `pre_diff` 来计算「`1` 和 `0` 数量差」，使用变量 `count` 来记录 `0` 和 `1` 数量相同的连续子数组的最长长度，然后遍历整个数组。
- 如果 `nums[i] == 1`，则让 `pre_diff += 1`；如果 `nums[i] == 0`，则让 `pre_diff -= 1`。
- 如果在哈希表中发现了相同的 `pre_diff`，则计算相应的子数组长度，与 `count` 进行比较并更新 `count` 值。
- 如果在哈希表中没有发现相同的 `pre_diff`，则在哈希表中记录下第一次出现 `pre_diff` 的下标 `i`。
- 最后遍历完输出 `count`。

> 注意：初始化哈希表为：`pre_dic = {0: -1}`，意思为空数组时，默认「`1` 和 `0` 数量差」为 `0`，且第一次出现的下标为 `-1`。
>
> 之所以这样做，是因为在遍历过程中可能会直接出现 `pre_diff == 0` 的情况，这种情况下说明 `nums[0: i]` 中 `0` 和 `1` 数量相同，如果像上边这样初始化后，就可以直接计算出此时子数组长度为 `i - (-1) = i + 1`。

## 代码

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        pre_dic = {0: -1}
        count = 0
        pre_sum = 0
        for i in range(len(nums)):
            if nums[i]:
                pre_sum += 1
            else:
                pre_sum -= 1
            if pre_sum in pre_dic:
                count = max(count, i - pre_dic[pre_sum])
            else:
                pre_dic[pre_sum] = i
        return count
```

# [0526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/)

- 标签：位运算、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目链接

- [0526. 优美的排列 - 力扣](https://leetcode.cn/problems/beautiful-arrangement/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回可以构造的「优美的排列」的数量。

**说明**：

- **优美的排列**：假设有 $1 \sim n$ 的 $n$ 个整数。如果用这些整数构造一个数组 $perm$（下标从 $1$ 开始），使得数组第 $i$ 位元素 $perm[i]$ 满足下面两个条件之一，则该数组就是一个「优美的排列」：
  - $perm[i]$ 能够被 $i$ 整除；
  - $i$ 能够被 $perm[i]$ 整除。

- $1 \le n \le 15$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：2
解释：
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
```

- 示例 2：

```python
输入：n = 1
输出：1
```

## 解题思路

### 思路 1：回溯算法

这道题可以看做是「[0046. 全排列](https://leetcode.cn/problems/permutations/)」的升级版。

1. 通过回溯算法我们可以将数组的所有排列情况列举出来。
2. 因为只有满足第 $i$ 位元素能被 $i$ 整除，或者满足 $i$ 能整除第 $i$ 位元素的条件下才符合要求，所以我们可以进行剪枝操作，不再考虑不满足要求的情况。
3. 最后回溯完输出方案数。

### 思路 1：代码

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        ans = 0
        visited = set()

        def backtracking(index):
            nonlocal ans
            if index == n + 1:
                ans += 1
                return

            for i in range(1, n + 1):
                if i in visited:
                    continue
                if i % index == 0 or index % i == 0:
                    visited.add(i)
                    backtracking(index + 1)
                    visited.remove(i)

        backtracking(1)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n!)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n)$，递归栈空间大小为 $O(n)$。

### 思路 2：状态压缩 DP

因为 $n$ 最大只有 $15$，所以我们可以考虑使用「状态压缩」。

「状态压缩」指的是使用一个 $n$ 位的二进制数来表示排列中数的选取情况。

举个例子：

1. $n = 4, state = (1001)_2$，表示选择了数字 $1, 4$，剩余数字 $2$ 和 $3$ 未被选择。
2. $n = 6, state = (011010)_2$，表示选择了数字 $2, 4, 5$，剩余数字 $1, 3, 6$ 未被选择。

这样我们就可以使用 $n$ 位的二进制数 $state$ 来表示当前排列中数的选取情况。

如果我们需要检查值为 $k$ 的数字是否被选择时，可以通过判断 $(state \text{ >} \text{> } (k - 1)) \text{ \& } 1$ 是否为 $1$ 来确定。

如果为 $1$，则表示值为 $k$ 的数字被选择了，如果为 $0$，则表示值为 $k$ 的数字没有被选择。

###### 1. 划分阶段

按照排列的数字个数、数字集合的选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][state]$ 表示为：考虑前 $i$ 个数，且当数字集合的选择情况为 $state$ 时的方案数。

###### 3. 状态转移方程

假设 $dp[i][state]$ 中第 $i$ 个位置所选数字为 $k$，则：$state$ 中第 $k$ 位为 $1$，且 $k \mod i == 0$ 或者 $i \mod k == 0$。

那么 $dp[i][state]$ 肯定是由考虑前 $i - 1$ 个位置，且 $state$ 第 $k$ 位为 $0$ 的状态而来，即：$dp[i - 1][state \& (\neg(1 \text{ <}\text{< } (k - 1)))]$。

所以状态转移方程为：$dp[i][state] = \sum_{k = 1}^n dp[i - 1][state \text{ \& } (\neg(1 \text{ <} \text{< } (k - 1)))]$。

###### 4. 初始条件

- 不考虑任何数（$i = 0, state = 0$）的情况下，方案数为 $1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][state]$ 表示为：考虑前 $i$ 个数，且当数字集合的选择情况为 $state$ 时的方案数。所以最终结果为 $dp[i][states -  1]$，其中 $states = 1 \text{ <} \text{< } n$。

### 思路 2：代码

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        states = 1 << n
        dp = [[0 for _ in range(states)] for _ in range(n + 1)]
        dp[0][0] = 1

        for i in range(1, n + 1):                   # 枚举第 i 个位置
            for state in range(states):             # 枚举所有状态
                one_num = bin(state).count("1")     # 计算当前状态中选择了多少个数字（即统计 1 的个数）
                if one_num != i:                    # 只有 i 与选择数字个数相同时才能计算
                    continue
                for k in range(1, n + 1):           # 枚举第 i 个位置（最后 1 位）上所选的数字
                    if state >> (k - 1) & 1 == 0:   # 只有 state 第 k 个位置上为 1 才表示选了该数字
                        continue
                    if k % i == 0 or i % k == 0:    # 只有满足整除关系才符合要求
                        # dp[i][state] 由前 i - 1 个位置，且 state 第 k 位为 0 的状态而来
                        dp[i][state] += dp[i - 1][state & (~(1 << (k - 1)))]

        return dp[i][states - 1]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2 \times 2^n)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n \times 2^n)$。

### 思路 3：状态压缩 DP + 优化

通过二维的「状态压缩 DP」可以看出，当我们在考虑第 $i$ 个位置时，其选择数字个数也应该为 $i$。

而我们可以根据 $state$ 中 $1$ 的个数来判断当前选择的数字个数，这样我们就可以减少用于枚举第 $i$ 个位置的循环，改用统计 $state$ 中 $1$ 的个数来判断前选择的数字个数或者说当前正在考虑的元素位置。

而这样，我们还可以进一步优化状态的定义，将二维的状态优化为一维的状态。具体做法如下：

###### 1. 划分阶段

按照数字集合的选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[state]$ 表示为：当数字集合的选择情况为 $state$ 时的方案数。

###### 3. 状态转移方程

对于状态 $state$，先统计出 $state$ 中选择的数字个数（即统计二进制中 $1$ 的个数）$one\underline{\hspace{0.5em}}num$。

则 $dp[state]$ 表示选择了前 $one\underline{\hspace{0.5em}}num$ 个数字，且选择情况为 $state$ 时的方案数。

$dp[state]$ 的状态肯定是由前 $one\underline{\hspace{0.5em}}num - 1$ 个数字，且 $state$ 第 $k$ 位为 $0$ 的状态而来对应状态转移而来，即：$dp[state \oplus (1 << (k - 1))]$。

所以状态转移方程为：$dp[state] = \sum_{k = 1}^n dp[state \oplus (1 << (k - 1))]$

###### 4. 初始条件

- 不考虑任何数的情况下，方案数为 $1$，即：$dp[0] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当数字集合选择状态为 $state$ 时的方案数。所以最终结果为 $dp[states -  1]$，其中 $states = 1 << n$。

### 思路 3：代码

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        states = 1 << n
        dp = [0 for _ in range(states)]
        dp[0] = 1

        for state in range(states):                         # 枚举所有状态
            one_num = bin(state).count("1")                 # 计算当前状态中选择了多少个数字（即统计 1 的个数）
            for k in range(1, n + 1):                       # 枚举最后 1 位上所选的数字
                if state >> (k - 1) & 1 == 0:               # 只有 state 第 k 个位置上为 1 才表示选了该数字
                    continue
                if one_num % k == 0 or k % one_num == 0:    # 只有满足整除关系才符合要求
                    # dp[state] 由前 one_num - 1 个位置，且 state 第 k 位为 0 的状态而来
                    dp[state] += dp[state ^ (1 << (k - 1))]

        return dp[states - 1]
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(2^n)$。

## 参考资料

- 【题解】[【宫水三叶】详解两种状态压缩 DP 思路 - 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/solution/gong-shui-san-xie-xiang-jie-liang-chong-vgsia/)
# [0530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

- 标签：树、深度优先搜索、广度优先搜索、二叉搜索树、二叉树
- 难度：

## 题目链接

- [0530. 二叉搜索树的最小绝对差 - 力扣](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

## 题目大意

**描述**：给定一个二叉搜索树的根节点 $root$。

**要求**：返回树中任意两不同节点值之间的最小差值。

**说明**：

- **差值**：是一个正数，其数值等于两值之差的绝对值。
- 树中节点的数目范围是 $[2, 10^4]$。
- $0 \le Node.val \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

```python
输入：root = [4,2,6,1,3]
输出：1
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

```python
输入：root = [1,0,48,null,null,12,49]
输出：1
```

## 解题思路

### 思路 1：中序遍历

先来看二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

题目要求二叉搜索树上任意两节点的差的绝对值的最小值。

二叉树的中序遍历顺序是：左 -> 根 -> 右，二叉搜索树的中序遍历最终得到就是一个升序数组。而升序数组中绝对值差的最小值就是比较相邻两节点差值的绝对值，找出其中最小值。

那么我们就可以先对二叉搜索树进行中序遍历，并保存中序遍历的结果。然后再比较相邻节点差值的最小值，从而找出最小值。

### 思路 1：代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)

        inorder(root)
        return res

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        inorder = self.inorderTraversal(root)
        ans = float('inf')
        for i in range(1, len(inorder)):
            ans = min(ans, abs(inorder[i - 1] - inorder[i]))

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉搜索树中的节点数量。
- **空间复杂度**：$O(n)$。

# [0538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0538. 把二叉搜索树转换为累加树 - 力扣](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

## 题目大意

给定一棵二叉搜索树（BST）的根节点，且二叉搜索树的节点值各不相同。要求将其转化为「累加树」，使其每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

## 解题思路

题目要求将每个节点的值修改为原来的节点值加上大于它的节点值之和。已知二叉搜索树的中序遍历可以得到一个升序数组。

题目就可以变为：修改升序数组中每个节点值为末尾元素累加和。由于末尾元素累加和的求和过程和遍历顺序相反，所以我们可以考虑换种思路。

二叉搜索树的中序遍历顺序为：左 -> 根 -> 右，从而可以得到一个升序数组，那么我们将左右反着遍历，即顺序为：右 -> 根 -> 左，就可以得到一个降序数组，这样就可以在遍历的同时求前缀和。

当然我们在计算前缀和的时候，需要用到前一个节点的值，所以需要用变量 `pre` 存储前一节点的值。

## 代码

```python
class Solution:
    pre = 0
    def createBinaryTree(self, root: TreeNode):
        if not root:
            return
        self.createBinaryTree(root.right)
        root.val += self.pre
        self.pre = root.val
        self.createBinaryTree(root.left)

    def convertBST(self, root: TreeNode) -> TreeNode:
        self.pre = 0
        self.createBinaryTree(root)
        return root
```

# [0539. 最小时间差](https://leetcode.cn/problems/minimum-time-difference/)

- 标签：数组、数学、字符串、排序
- 难度：中等

## 题目链接

- [0539. 最小时间差 - 力扣](https://leetcode.cn/problems/minimum-time-difference/)

## 题目大意

给定一个 24 小时制形式（小时:分钟 "HH:MM"）的时间列表 `timePoints`。

要求：找出列表中任意两个时间的最小时间差并以分钟数表示。

## 解题思路

- 遍历时间列表 `timePoints`，将每个时间转换为以分钟计算的整数形式，比如时间 `14:20`，将其转换为 `14 * 60 + 20 = 860`，存放到新的时间列表 `times` 中。
- 为了处理最早时间、最晚时间之间的时间间隔，我们将 `times` 中最小时间添加到列表末尾一起进行排序。
- 然后将新的时间列表 `times` 按照升序排列。
- 遍历排好序的事件列表 `times` ，找出相邻两个时间的最小间隔值即可。

## 代码

```python
class Solution:
    def changeTime(self, timePoint: str):
        hours, minutes = timePoint.split(':')
        return int(hours) * 60 + int(minutes)

    def findMinDifference(self, timePoints: List[str]) -> int:
        if not timePoints or len(timePoints) > 24 * 60:
            return 0

        times = sorted(self.changeTime(time) for time in timePoints)
        times.append(times[0] + 24 * 60)
        res = times[-1]
        for i in range(1, len(times)):
            res = min(res, times[i] - times[i - 1])
        return res
```

# [0542. 01 矩阵](https://leetcode.cn/problems/01-matrix/)

- 标签：广度优先搜索、数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [0542. 01 矩阵 - 力扣](https://leetcode.cn/problems/01-matrix/)

## 题目大意

**描述**：给定一个 $m * n$ 大小的、由 `0` 和 `1` 组成的矩阵 $mat$。

**要求**：输出一个大小相同的矩阵 $res$，其中 $res[i][j]$ 表示对应位置元素（即 $mat[i][j]$）到最近的 $0$ 的距离。

**说明**：

- 两个相邻元素间的距离为 $1$。
- $m == mat.length$。
- $n == mat[i].length$。
- $1 \le m, n \le 10^4$。
- $1 \le m * n \le 10^4$。
- $mat[i][j] === 0$ 或者 $mat[i][j] == 1$。
- $mat$ 中至少有一个 $0$。

**示例**：

- 示例 1：

![](https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png)

```python
输入：mat = [[0,0,0],[0,1,0],[0,0,0]]
输出：[[0,0,0],[0,1,0],[0,0,0]]
```

- 示例 2：

![](https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png)

```python
输入：mat = [[0,0,0],[0,1,0],[1,1,1]]
输出：[[0,0,0],[0,1,0],[1,2,1]]
```

## 解题思路

### 思路 1：广度优先搜索

题目要求的是每个 `1` 到 `0`的最短曼哈顿距离。

比较暴力的做法是，从每个 `1` 开始进行广度优先搜索，每一步累积距离，当搜索到第一个 `0`，就是离这个 `1`  最近的 `0`，我们更新对应 `1` 位置上的答案距离。然后从下一个 `1` 开始进行广度优先搜索。

这样做每次进行广度优先搜索的时间复杂度为 $O(m \times n)$。对于 $m \times n$ 个节点来说，每个节点可能都要进行一次广度优先搜索，总的时间复杂度为 $O(m^2 \times n^2)$。时间复杂度太高了。

我们可以换个角度：求每个 `0` 到 `1` 的最短曼哈顿距离（和求每个 `1` 到 `0` 是等价的）。

我们将所有值为 `0` 的元素位置保存到队列中，然后对所有值为 `0` 的元素开始进行广度优先搜索，每搜一步距离加 `1`，当每次搜索到 `1` 时，就可以得到 `0` 到这个 `1` 的最短距离，也就是当前离这个 `1` 最近的 `0` 的距离。

这样对于所有节点来说，总共需要进行一次广度优先搜索就可以了，时间复杂度为 $O(m \times n)$。

具体步骤如下：

1. 使用一个集合变量 `visited` 存储所有值为 `0` 的元素坐标。使用队列变量 `queue` 存储所有值为 `0` 的元素坐标。使用二维数组 `res` 存储对应位置元素（即 $mat[i][j]$）到最近的 $0$ 的距离。
2. 我们从所有为如果队列 `queue` 不为空，则从队列中依次取出值为 `0` 的元素坐标，遍历其上、下、左、右位置。
3. 如果相邻区域未被访问过（说明遇到了值为 `1` 的元素），则更新相邻位置的距离值，并把相邻位置坐标加入队列 `queue` 和访问集合 `visited` 中。
4. 继续执行 2  ~ 3 步，直到队列为空时，返回 `res`。

### 思路 1：代码

```python
import collections

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        rows, cols = len(mat), len(mat[0])
        res = [[0 for _ in range(cols)] for _ in range(rows)]
        visited = set()

        for i in range(rows):
            for j in range(cols):
                if mat[i][j] == 0:
                    visited.add((i, j))
        
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        queue = collections.deque(visited)

        while queue:
            i, j = queue.popleft()
            for direction in directions:
                new_i = i + direction[0]
                new_j = j + direction[1]
                if 0 <= new_i < rows and 0 <= new_j < cols and (new_i, new_j) not in visited:
                    res[new_i][new_j] = res[i][j] + 1
                    queue.append((new_i, new_j))
                    visited.add((new_i, new_j))
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。
- **空间复杂度**：$O(m \times n)$。

# [0543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

- 标签：树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0543. 二叉树的直径 - 力扣](https://leetcode.cn/problems/diameter-of-binary-tree/)

## 题目大意

**描述**：给一个二叉树的根节点 $root$。

**要求**：计算该二叉树的直径长度。

**说明**：

- **二叉树的直径长度**：二叉树中任意两个节点路径长度中的最大值。
- 两节点之间的路径长度是以它们之间边的数目表示。
- 这条路径可能穿过也可能不穿过根节点。

**示例**：

- 示例 1：

```python
给定二叉树：
          1
         / \
        2   3
       / \     
      4   5    
输出：3
解释：该二叉树的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

这道题重点是理解直径长度的定义。「二叉树的直径长度」的定义为：二叉树中任意两个节点路径长度中的最大值。并且这条路径可能穿过也可能不穿过根节点。

对于根为 $root$ 的二叉树来说，其直径长度并不简单等于「左子树高度」加上「右子树高度」。

根据路径是否穿过根节点，我们可以将二叉树分为两种：

1. 直径长度所对应的路径穿过根节点。
2. 直径长度所对应的路径不穿过根节点。

我们来看下图中的两个例子。

![](https://qcdn.itcharge.cn/images/20230427111005.png)

如图所示，左侧这棵二叉树就是一棵常见的平衡二叉树，其直径长度所对应的路径是穿过根节点的（$D\rightarrow B \rightarrow A \rightarrow C$）。这种情况下：$\text{二叉树的直径} = \text{左子树高度} + \text{右子树高度}$。

而右侧这棵特殊的二叉树，其直径长度所对应的路径是没有穿过根节点的（$F \rightarrow D \rightarrow B \rightarrow E \rightarrow G$）。这种情况下：$\text{二叉树的直径} = \text{所有子树中最大直径长度}$。

也就是说根为 $root$ 的二叉树的直径长度可能来自于  $\text{左子树高度} + \text{右子树高度}$，也可能来自于 $\text{子树中的最大直径}$，即 $\text{二叉树的直径} = max(\text{左子树高度} + \text{右子树高度}, \quad \text{所有子树中最大直径长度})$。

那么现在问题就变成为如何求「子树的高度」和「子树中的最大直径」。

1. 子树的高度：我们可以利用深度优先搜索方法，递归遍历左右子树，并分别返回左右子树的高度。
2. 子树中的最大直径：我们可以在递归求解子树高度的时候维护一个 $ans$ 变量，用于记录所有 $\text{左子树高度} + \text{右子树高度}$ 中的最大值。

最终 $ans$ 就是我们所求的该二叉树的最大直径，将其返回即可。

### 思路 1：代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.ans = 0

    def dfs(self, node):
        if not node:
            return 0
        left_height = self.dfs(node.left)                     # 左子树高度
        right_height = self.dfs(node.right)                   # 右子树高度
        self.ans = max(self.ans, left_height + right_height)  # 维护所有路径中的最大直径
        return max(left_height, right_height) + 1             # 返回该节点的高度 = 左右子树最大高度 + 1

    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.dfs(root)
        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。

# [0546. 移除盒子](https://leetcode.cn/problems/remove-boxes/)

- 标签：记忆化搜索、数组、动态规划
- 难度：困难

## 题目链接

- [0546. 移除盒子 - 力扣](https://leetcode.cn/problems/remove-boxes/)

## 题目大意

**描述**：给定一个代表不同颜色盒子的正数数组 $boxes$，盒子的颜色由不同正数组成，其中 $boxes[i]$ 表示第 $i$ 个盒子的颜色。

我们将经过若干轮操作去去掉盒子，直到所有盒子都去掉为止。每一轮我们可以移除具有相同颜色的连续 $k$ 个盒子（$k \ge 1$），这样一轮之后，我们将获得 $k \times k$ 个积分。

**要求**：返回我们能获得的最大积分和。

**说明**：

- $1 \le boxes.length \le 100$。
- $1 \le boxes[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
```

- 示例 2：

```python
输入：boxes = [1,1,1]
输出：9
```

## 解题思路

### 思路 1：动态规划

对于每个盒子，

如果使用二维状态 $dp[i][j]$ 表示为：移除区间 $[i, j]$ 之间的盒子，所能够得到的最大积分和。但实际上，移除区间 $[i, j]$ 之间盒子，所能得到的最大积分和，并不只依赖于子区间，也依赖于之前移除其他区间对当前区间的影响。比如当前区间的某个值和其他区间的相同值连起来可以获得更高的额分数。

因此，我们需要再二维状态的基础上，增加更多维数的状态。

对于当前区间 $[i, j]$，我们需要凑一些尽可能长的同色盒子一起消除，从而获得更高的分数。我们不妨每次都选择消除区间 $[i, j]$ 中最后一个盒子 $boxes[j]$，并且记录 $boxes[j]$ 之后与 $boxes[j]$ 颜色相同的盒子数量。

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j][k]$ 表示为：移除区间 $[i, j]$ 之间的盒子，并且区间右侧有 $k$ 个与 $boxes[j]$ 颜色相同的盒子，所能够得到的最大积分和。

###### 3. 状态转移方程

- 当区间长度为 $1$ 时，当前区间只有一个盒子，区间末尾有 $k$ 个与 $boxes[j]$ 颜色相同的盒子，所能够得到的最大积分为 $(k + 1) \times (k + 1)$。
- 当区间长度大于 $1$ 时，对于区间末尾的 $k$ 个与 $boxes[j]$ 颜色相同的盒子，有两种处理方式：
  - 将末尾的盒子移除，所能够得到的最大积分为：移除末尾盒子之前能够获得的最大积分和，再加上本轮移除末尾盒子能够获得的积分和，即：$dp[i][j - 1][0] + (k + 1) \times (k + 1)$。
  - 在区间中找到一个位置 $t$，使得第 $t$ 个盒子与第 $j$ 个盒子颜色相同，先将区间 $[t + 1, j - 1]$ 的盒子消除，然后继续凑同色盒子，即：$dp[t + 1][j - 1][0] + dp[i][t][k + 1]$。

###### 4. 初始条件

- 区间长度为 $1$ 时，当前区间只有一个盒子，区间末尾有 $k$ 个与 $boxes[j]$ 颜色相同的盒子，所能够得到的最大积分为 $(k + 1) \times (k + 1)$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j][k]$ 表示为：移除区间 $[i, j]$ 之间的盒子，并且区间右侧有 $k$ 个与 $boxes[j]$ 颜色相同的盒子，所能够得到的最大积分和。所以最终结果为 $dp[0][size - 1][0]$。

### 思路 1：代码

```python
class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        size = len(boxes)

        dp = [[[0 for _ in range(size)] for _ in range(size)] for _ in range(size)]
        for l in range(1, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break

                for k in range(size - j):
                    if l == 1:
                        dp[i][j][k] = max(dp[i][j][k], (k + 1) * (k + 1))
                    else:
                        dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][0] + (k + 1) * (k + 1))
                    for t in range(i, j):
                        if boxes[t] == boxes[j]:
                            dp[i][j][k] = max(dp[i][j][k], dp[t + 1][j - 1][0] + dp[i][t][k + 1])

        return dp[0][size - 1][0]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^4)$，其中 $n$ 为数组 $boxes$ 的元素个数。
- **空间复杂度**：$O(n^3)$。

# [0547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0547. 省份数量 - 力扣](https://leetcode.cn/problems/number-of-provinces/)

## 题目大意

**描述**：有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

「省份」是由一组直接或间接链接的城市组成，组内不含有其他没有相连的城市。

现在给定一个 `n * n` 的矩阵 `isConnected` 表示城市的链接关系。其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，`isConnected[i][j] = 0` 表示第 `i` 个城市和第 `j` 个城市没有相连。

**要求**：根据给定的城市关系，返回「省份」的数量。

**说明**：

- $1 \le n \le 200$。
- $n == isConnected.length$。
- $n == isConnected[i].length$。
- $isConnected[i][j]$ 为 $1$ 或 $0$。
- $isConnected[i][i] == 1$。
- $isConnected[i][j] == isConnected[j][i]$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)

```python
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)

```python
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
```

## 解题思路

### 思路 1：并查集

1. 遍历矩阵 `isConnected`。如果 `isConnected[i][j] == 1`，将 `i` 节点和 `j` 节点相连。
2. 然后判断每个城市节点的根节点，然后统计不重复的根节点有多少个，即为「省份」的数量。

### 思路 1：代码

```python
class UnionFind:
    def __init__(self, n):                          # 初始化
        self.fa = [i for i in range(n)]             # 每个元素的集合编号初始化为数组 fa 的下标索引
    
    def find(self, x):                              # 查找元素根节点的集合编号内部实现方法
        while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
            self.fa[x] = self.fa[self.fa[x]]        # 隔代压缩优化
            x = self.fa[x]
        return x                                    # 返回元素根节点的集合编号

    def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:                        # x 和 y 的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
            return False
        self.fa[root_x] = root_y                    # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
        return True

    def is_connected(self, x, y):                   # 查询操作：判断 x 和 y 是否同属于一个集合
        return self.find(x) == self.find(y)

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        size = len(isConnected)
        union_find = UnionFind(size)
        for i in range(size):
            for j in range(i + 1, size):
                if isConnected[i][j] == 1:
                    union_find.union(i, j)

        res = set()
        for i in range(size):
            res.add(union_find.find(i))
        return len(res)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times \alpha(n))$。其中 $n$ 是城市的数量，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n)$。# [0557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [0557. 反转字符串中的单词 III - 力扣](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：将字符串中每个单词的字符顺序进行反装，同时仍保留空格和单词的初始顺序。

**说明**：

- $1 \le s.length \le 5 * 10^4$。
- `s` 包含可打印的 ASCII 字符。
- `s` 不包含任何开头或结尾空格。
- `s` 里至少有一个词。
- `s` 中的所有单词都用一个空格隔开。

**示例**：

- 示例 1：

```python
输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

- 示例 2：

```python
输入： s = "God Ding"
输出："doG gniD"
```

## 解题思路

### 思路 1：使用额外空间

因为 Python 的字符串是不可变的，所以在原字符串空间上进行切换顺序操作肯定是不可行的了。但我们可以利用切片方法。

1. 将字符串按空格进行分割，分割成一个个的单词。
2. 再将每个单词进行反转。
3. 最后将每个单词连接起来。

### 思路 1：代码

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(word[::-1] for word in s.split(" "))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。# [0560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

- 标签：数组、哈希表、前缀和
- 难度：中等

## 题目链接

- [0560. 和为 K 的子数组 - 力扣](https://leetcode.cn/problems/subarray-sum-equals-k/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $k$。

**要求**：找到该数组中和为 $k$ 的连续子数组的个数。

**说明**：

- $1 \le nums.length \le 2 \times 10^4$。
- $-1000 \le nums[i] \le 1000$。
  $-10^7 \le k \le 10^7$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,1], k = 2
输出：2
```

- 示例 2：

```python
输入：nums = [1,2,3], k = 3
输出：2
```

## 解题思路

### 思路 1：枚举算法（超时）

先考虑暴力做法，外层两重循环，遍历所有连续子数组，然后最内层再计算一下子数组的和。部分代码如下：

```python
for i in range(len(nums)):
    for j in range(i + 1):
        sum = countSum(i, j)
```

这样下来时间复杂度就是 $O(n^3)$ 了。下一步是想办法降低时间复杂度。

对于以 $i$ 开头，以 $j$ 结尾（$i \le j$）的子数组 $nums[i]…nums[j]$ 来说，我们可以通过顺序遍历 $j$，逆序遍历 $i$ 的方式（或者前缀和的方式），从而在 $O(n^2)$ 的时间复杂度内计算出子数组的和，同时使用变量 $cnt$ 统计出和为 $k$ 的子数组个数。

但这样提交上去超时了。

### 思路 1：代码

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cnt = 0
        for j in range(len(nums)):
            sum = 0
            for i in range(j, -1, -1):
                sum += nums[i]
                if sum == k:
                    cnt += 1
        
        return cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：前缀和 + 哈希表

先用一重循环遍历数组，计算出数组 $nums$ 中前 $j$ 个元素的和（前缀和），保存到一维数组 $pre\underline{\hspace{0.5em}}sum$ 中，那么对于任意 $nums[i]…nums[j]$ 的子数组的和为 $pre\underline{\hspace{0.5em}}sum[j] - pre\underline{\hspace{0.5em}}sum[i - 1]$。这样计算子数组和的时间复杂度降为了 $O(1)$。总体时间复杂度为 $O(n^2)$。

但是还是超时了。。

由于我们只关心和为 $k$ 出现的次数，不关心具体的解，可以使用哈希表来加速运算。

$pre\underline{\hspace{0.5em}}sum[i]$ 的定义是前 $i$ 个元素和，则 $pre\underline{\hspace{0.5em}}sum[i]$ 可以由 $pre\underline{\hspace{0.5em}}sum[i - 1]$ 递推而来，即：$pre\underline{\hspace{0.5em}}sum[i] = pre\underline{\hspace{0.5em}}sum[i - 1] + num[i]$。 $[i..j]$ 子数组和为 $k$ 可以转换为：$pre\underline{\hspace{0.5em}}sum[j] - pre\underline{\hspace{0.5em}}sum[i - 1] == k$。

综合一下，可得：$pre\underline{\hspace{0.5em}}sum[i - 1] == pre\underline{\hspace{0.5em}}sum[j] - k $。

所以，当我们考虑以 $j$ 结尾和为 $k$ 的连续子数组个数时，只需要统计有多少个前缀和为 $pre\underline{\hspace{0.5em}}sum[j] - k$ （即 $pre\underline{\hspace{0.5em}}sum[i - 1]$）的个数即可。具体做法如下：

- 使用 $pre\underline{\hspace{0.5em}}sum$ 变量记录前缀和（代表 $pre\underline{\hspace{0.5em}}sum[j]$）。
- 使用哈希表 $pre\underline{\hspace{0.5em}}dic$ 记录 $pre\underline{\hspace{0.5em}}sum[j]$ 出现的次数。键值对为 $pre\underline{\hspace{0.5em}}sum[j] : pre\underline{\hspace{0.5em}}sum\underline{\hspace{0.5em}}count$。
- 从左到右遍历数组，计算当前前缀和 $pre\underline{\hspace{0.5em}}sum$。
- 如果 $pre\underline{\hspace{0.5em}}sum - k$ 在哈希表中，则答案个数累加上 $pre\underline{\hspace{0.5em}}dic[pre\underline{\hspace{0.5em}}sum - k]$。
- 如果 $pre\underline{\hspace{0.5em}}sum$ 在哈希表中，则前缀和个数累加 $1$，即 $pre\underline{\hspace{0.5em}}dic[pre\underline{\hspace{0.5em}}sum] += 1$。
- 最后输出答案个数。

### 思路 2：代码

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        pre_dic = {0: 1}
        pre_sum = 0
        count = 0
        for num in nums:
            pre_sum += num
            if pre_sum - k in pre_dic:
                count += pre_dic[pre_sum - k]
            if pre_sum in pre_dic:
                pre_dic[pre_sum] += 1
            else:
                pre_dic[pre_sum] = 1
        return count
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0561. 数组拆分](https://leetcode.cn/problems/array-partition/)

- 标签：贪心、数组、计数排序、排序
- 难度：简单

## 题目链接

- [0561. 数组拆分 - 力扣](https://leetcode.cn/problems/array-partition/)

## 题目大意

**描述**：给定一个长度为 $2 \times n$ 的整数数组 $nums$。

**要求**：将数组中的数拆分成 $n$ 对，每对数求最小值，求 $n$ 对数最小值的最大总和是多少。

**说明**：

- $1 \le n \le 10^4$。
- $nums.length == 2 * n$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```
- 示例 2：

```python
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

## 解题思路

### 思路 1：计数排序

因为 $nums[i]$ 的范围为 $[-10^4, 10^4]$，范围不是很大，所以我们可以使用计数排序算法先将数组 $nums$ 进行排序。

要想每对数最小值的总和最大，就得使每对数的最小值尽可能大。只有让较大的数与较大的数一起组合，较小的数与较小的数一起结合，才能才能使总和最大。所以，排序完之后将相邻两个元素的最小值进行相加，即得到结果。

###  思路 1：代码

```python
class Solution:
    def countingSort(self, nums: [int]) -> [int]:
        # 计算待排序数组中最大值元素 nums_max 和最小值元素 nums_min
        nums_min, nums_max = min(nums), max(nums)
        # 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1
        size = nums_max - nums_min + 1
        counts = [0 for _ in range(size)]
        
        # 统计值为 num 的元素出现的次数
        for num in nums:
            counts[num - nums_min] += 1
        
        # 生成累积计数数组
        for i in range(1, size):
            counts[i] += counts[i - 1]

        # 反向填充目标数组
        res = [0 for _ in range(len(nums))]
        for i in range(len(nums) - 1, -1, -1):
            num = nums[i]
            # 根据累积计数数组，将 num 放在数组对应位置
            res[counts[num - nums_min] - 1] = num
            # 将 num 的对应放置位置减 1，从而得到下个元素 num 的放置位置
            counts[nums[i] - nums_min] -= 1

        return res

    def arrayPairSum(self, nums: List[int]) -> int:
        nums = self.countingSort(nums)
        return sum(nums[::2])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + k)$，其中 $k$ 代表数组 $nums$ 的值域。
- **空间复杂度**：$O(k)$。

### 思路 2：排序

要想每对数最小值的总和最大，就得使每对数的最小值尽可能大。只有让较大的数与较大的数一起组合，较小的数与较小的数一起结合，才能才能使总和最大。

1. 对 $nums$ 进行排序。
2. 将相邻两个元素的最小值进行相加，即得到结果。

### 思路 1：代码

```python
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

# [0567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

- 标签：哈希表、双指针、字符串、滑动窗口
- 难度：中等

## 题目链接

- [0567. 字符串的排列 - 力扣](https://leetcode.cn/problems/permutation-in-string/)

## 题目大意

**描述**：给定两个字符串 $s1$ 和 $s2$ 。

**要求**：判断 $s2$ 是否包含 $s1$ 的排列。如果包含，返回 $True$；否则，返回 $False$。

**说明**：

- $1 \le s1.length, s2.length \le 10^4$。
- $s1$ 和 $s2$ 仅包含小写字母。

**示例**：

- 示例 1：

```python
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

- 示例 2：

```python
输入：s1= "ab" s2 = "eidboaoo"
输出：False
```

## 解题思路

### 思路 1：滑动窗口

题目要求判断 $s2$ 是否包含 $s1$ 的排列，则 $s2$ 的子串长度等于 $s1$ 的长度。我们可以维护一个长度为字符串 $s1$ 长度的固定长度的滑动窗口。

先统计出字符串  $s1$ 中各个字符的数量，我们用 $s1\underline{\hspace{0.5em}}count$ 来表示。这个过程可以用字典、数组来实现，也可以直接用 `collections.Counter()` 实现。再统计 $s2$ 对应窗口内的字符数量 $window\underline{\hspace{0.5em}}count$，然后不断向右滑动，然后进行比较。如果对应字符数量相同，则返回 $True$，否则继续滑动。直到末尾时，返回 $False$。整个解题步骤具体如下：

1. $s1\underline{\hspace{0.5em}}count$ 用来统计 $s1$ 中各个字符数量。$window\underline{\hspace{0.5em}}count$ 用来维护窗口中 $s2$ 对应子串的各个字符数量。$window\underline{\hspace{0.5em}}size$ 表示固定窗口的长度，值为 $len(s1)$。
2. 先统计出 $s1$ 中各个字符数量。
3. $left$ 、$right$ 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
4. 向右移动 $right$，先将 $len(s1)$ 个元素填入窗口中。
5. 当窗口元素个数为 $window\underline{\hspace{0.5em}}size$ 时，即：$right - left + 1 \ge window\underline{\hspace{0.5em}}size$ 时，判断窗口内各个字符数量 $window\underline{\hspace{0.5em}}count$ 是否等于 $s1 $ 中各个字符数量 $s1\underline{\hspace{0.5em}}count$。
   1. 如果等于，直接返回 $True$。
   2. 如果不等于，则向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $window\underline{\hspace{0.5em}}size$。
6. 重复 $4 \sim 5$ 步，直到 $right$ 到达数组末尾。返回 $False$。

### 思路 1：代码

```python
import collections

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        left, right = 0, 0
        s1_count = collections.Counter(s1)
        window_count = collections.Counter()
        window_size = len(s1)

        while right < len(s2):
            window_count[s2[right]] += 1

            if right - left + 1 >= window_size:
                if window_count == s1_count:
                    return True
                window_count[s2[left]] -= 1
                if window_count[s2[left]] == 0:
                    del window_count[s2[left]]
                left += 1
            right += 1
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m + |\sum|)$，其中 $n$、$m$ 分别是字符串 $s1$、$s2$ 的长度，$\sum$ 是字符集，本题中 $|\sum| = 26$。
- **空间复杂度**：$O(|\sum|)$。

# [0575. 分糖果](https://leetcode.cn/problems/distribute-candies/)

- 标签：数组、哈希表
- 难度：简单

## 题目链接

- [0575. 分糖果 - 力扣](https://leetcode.cn/problems/distribute-candies/)

## 题目大意

给定一个偶数长度为 `n` 的数组，其中不同的数字代表不同种类的糖果，每一个数字代表一个糖果。

要求：将这些糖果按种类平均分为一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

## 解题思路

`n` 个糖果分为两个人，每个人最多只能得到 `n // 2` 个糖果。假设糖果种数为 `m`。则如果糖果种类数大于糖果总数的一半，即 `m > n // 2`，则返回糖果数量的一半就好，也就说糖果总数一半的糖果都可以是不同种类的糖果。妹妹能获得最多 `n // 2` 种糖果。而如果让给种类数小于等于糖果总数的一半，即 `m <= n // 2`，则返回种类数，也就是说妹妹可以最多获得 `m` 种糖果。

综合这两种情况，其最终结果就是 `ans = min(m, n // 2)`。

计算糖果种类可以用 set 集合来做。

## 代码

```python
class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        candy_set = set(candyType)
        return min(len(candyType) // 2, len(candy_set))
```

# [0576. 出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)

- 标签：动态规划
- 难度：中等

## 题目链接

- [0576. 出界的路径数 - 力扣](https://leetcode.cn/problems/out-of-boundary-paths/)

## 题目大意

**描述**：有一个大小为 $m \times n$ 的网络和一个球。球的起始位置为 $(startRow, startColumn)$。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。最多可以移动 $maxMove$ 次球。

现在给定五个整数 $m$、$n$、$maxMove$、$startRow$ 以及 $startColumn$。

**要求**：找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 $10^9 + 7$ 取余后的结果。

**说明**：

- $1 \le m, n \le 50$。
- $0 \le maxMove \le 50$。
- $0 \le startRow < m$。
- $0 \le startColumn < n$。

**示例**：

- 示例 1：

```python
输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
输出：6
```

![](https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png)

## 解题思路

### 思路 1：记忆化搜索

1. 问题的状态定义为：从位置 $(i, j)$ 出发，最多使用 $moveCount$ 步，可以将球移出边界的路径数量。
2. 定义一个 $m \times n \times (maxMove + 1)$ 的三维数组 $memo$ 用于记录已经计算过的路径数量。
3. 定义递归函数 $dfs(i, j, moveCount)$ 用于计算路径数量。
   1. 如果 $(i, j)$ 已经出界，则说明找到了一条路径，返回方案数为 $1$。
   2. 如果没有移动次数了，则返回方案数为 $0$。
   3. 定义方案数 $ans$，遍历四个方向，递归计算四个方向的方案数，累积到 $ans$ 中，并进行取余。
   4. 返回方案数 $ans$。
4. 调用递归函数 $dfs(startRow, startColumn, maxMove)$，并将其返回值作为答案进行返回。

### 思路 1：代码

```python
class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        mod = 10 ** 9 + 7

        memo = [[[-1 for _ in range(maxMove + 1)] for _ in range(n)] for _ in range(m)]

        def dfs(i, j, moveCount):
            if i < 0 or i >= m or j < 0 or j >= n:
                return 1
            
            if moveCount == 0:
                return 0

            if memo[i][j][moveCount] != -1:
                return memo[i][j][moveCount]

            ans = 0
            for direction in directions:
                new_i = i + direction[0]
                new_j = j + direction[1]
                ans += dfs(new_i, new_j, moveCount - 1)
                ans %= mod

            memo[i][j][moveCount] = ans
            return ans

        return dfs(startRow, startColumn, maxMove)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n \times maxMove)$。
- **空间复杂度**：$O(m \times n \times maxMove)$。

### 思路 2：动态规划

我们需要统计从 $(startRow, startColumn)$ 位置出发，最多移动 $maxMove$ 次能够穿过边界的所有路径数量。则我们可以根据位置和移动步数来划分阶段和定义状态。

###### 1. 划分阶段

按照位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j][k]$ 表示为：从位置 $(i, j)$ 最多移动 $k$ 次最终穿过边界的所有路径数量。

###### 3. 状态转移方程

因为球可以在上下左右四个方向上进行移动，所以对于位置 $(i, j)$，最多移动 $k$ 次最终穿过边界的所有路径数量取决于周围四个方向上最多经过 $k - 1$ 次穿过对应位置上的所有路径数量和。

即：$dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i + 1][j][k - 1] + dp[i][j - 1][k - 1] + dp[i][j + 1][k - 1]$。

###### 4. 初始条件

如果位置 $[i, j]$ 已经处于边缘，只差一步就穿过边界。则此时位置 $(i, j)$ 最多移动 $k$ 次最终穿过边界的所有路径数量取决于有相邻多少个方向是边界。也可以通过对上面 $(i - 1, j)$、$(i + 1, j)$、$(i, j - 1)$、$(i, j + 1)$ 是否已经穿过边界进行判断（每一个方向穿过一次，就累积一次），来计算路径数目。然后将其作为初始条件。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j][k]$ 表示为：从位置 $(i, j)$ 最多移动 $k$ 次最终穿过边界的所有路径数量。则最终答案为 $dp[startRow][startColumn][maxMove]$。

### 思路 2：动态规划代码

```python
class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        mod = 10 ** 9 + 7
        
        dp = [[[0 for _ in range(maxMove + 1)] for _ in range(n)] for _ in range(m)]
        for i in r
        for k in range(1, maxMove + 1):
            for i in range(m):
                for j in range(n):
                    for direction in directions:
                        new_i = i + direction[0]
                        new_j = j + direction[1]
                        if 0 <= new_i < m and 0 <= new_j < n:
                            dp[i][j][k] = (dp[i][j][k] + dp[new_i][new_j][k - 1]) % mod
                        else:
                            dp[i][j][k] = (dp[i][j][k] + 1) % mod
        
        return dp[startRow][startColumn][maxMove]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(m \times n \times maxMove)$。三重循环遍历的时间复杂度为 $O(m \times n \times maxMove)$。
- **空间复杂度**：$O(m \times n \times maxMove)$。使用了三维数组保存状态，所以总体空间复杂度为 $O(m \times n \times maxMove)$。
# [0583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0583. 两个字符串的删除操作 - 力扣](https://leetcode.cn/problems/delete-operation-for-two-strings/)

## 题目大意

给定两个单词 `word1` 和 `word2`，找到使得 `word1` 和 `word2` 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

## 解题思路

动态规划求解。

先定义状态 `dp[i][j]` 为以 `i - 1` 为结尾的字符串 `word1` 和以 `j - 1` 字结尾的字符串 `word2` 想要达到相等，所需要删除元素的最少次数。

然后确定状态转移方程。

- 如果 `word1[i - 1] == word2[j - 1]`，`dp[i][j]` 取源于以 `i - 2` 结尾结尾的字符串 `word1` 和以 `j - 1` 结尾的字符串 `word2`，即 `dp[i][j] = dp[i - 1][j - 1]`。
- 如果 `word1[i - 1] != word2[j - 1]`，`dp[i][j]` 取源于以下三种情况中的最小情况：
  - 删除 `word1[i - 1]`，最少操作次数为：`dp[i - 1][j] + 1`。
  - 删除 `word2[j - 1]`，最少操作次数为：`dp[i][j - 1] + 1`。
  - 同时删除 `word1[i - 1]`、`word2[j - 1]`，最少操作次数为 `dp[i - 1][j - 1] + 2`。

然后确定一下边界条件。

- 当 `word1` 为空字符串，以 `j - 1` 结尾的字符串 `word2` 要删除 `j` 个字符才能和 `word1` 相同，即 `dp[0][j] = j`。
- 当 `word2` 为空字符串，以 `i - 1` 结尾的字符串 `word1` 要删除 `i` 个字符才能和 `word2` 相同，即 `dp[i][0] = i`。

最后递推求解，最终输出 `dp[size1][size2]` 为答案。

## 代码

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        size1 = len(word1)
        size2 = len(word2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]

        for i in range(size1 + 1):
            dp[i][0] = i
        for j in range(size2 + 1):
            dp[0][j] = j

        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1)

        return dp[size1][size2]
```

# [0589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

- 标签：栈、树、深度优先搜索
- 难度：简单

## 题目链接

- [0589. N 叉树的前序遍历 - 力扣](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

## 题目大意

给定一棵 N 叉树的根节点 `root`。

要求：返回其节点值的前序遍历。

进阶：使用迭代法完成。

## 解题思路

递归法很好写。迭代法需要借助于栈。

- 用栈保存根节点 `root`。然后遍历栈。
- 循环判断栈是否为空。
- 如果栈不为空，取出栈顶节点，将节点值加入答案数组。
- 逆序遍历栈顶节点的子节点，将其依次放入栈中（逆序保证取出顺序为正）。
- 然后继续第 2 ~ 4 步，直到栈为空。

最后输出答案数组。

## 代码

```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        res = []
        stack = []
        if not root:
            return res
        stack.append(root)
        while stack:
            node = stack.pop()
            res.append(node.val)
            for i in range(len(node.children) - 1, -1, -1):
                if node.children[i]:
                    stack.append(node.children[i])
        return res
```

# [0590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

- 标签：栈、树、深度优先搜索
- 难度：简单

## 题目链接

- [0590. N 叉树的后序遍历 - 力扣](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

## 题目大意

给定一个 N 叉树的根节点 `root`。

要求：返回其节点值的后序遍历。

## 解题思路

N 叉树的后序遍历顺序为：子节点顺序递归遍历 -> 根节点。

一个取巧的方法是先按照：根节点 -> 子节点逆序递归遍历 的顺序将遍历顺序存储到答案数组。

然后再将其进行翻转就变为了后序遍历顺序。具体操作如下：

- 用栈保存根节点 `root`。然后遍历栈。
- 循环判断栈是否为空。
- 如果栈不为空，取出栈顶节点，将节点值加入答案数组。
- 顺序遍历栈顶节点的子节点，将其依次放入栈中（顺序遍历保证取出顺序为逆序）。
- 然后继续第 2 ~ 4 步，直到栈为空。

最后将答案数组逆序返回。

## 代码

```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        res = []
        stack = []
        if not root:
            return res

        stack.append(root)
        while stack:
            node = stack.pop()
            res.append(node.val)
            for child in node.children:
                stack.append(child)

        return res[::-1]
```

# [0599. 两个列表的最小索引总和](https://leetcode.cn/problems/minimum-index-sum-of-two-lists/)

- 标签：数组、哈希表、字符串
- 难度：简单

## 题目链接

- [0599. 两个列表的最小索引总和 - 力扣](https://leetcode.cn/problems/minimum-index-sum-of-two-lists/)

## 题目大意

Andy 和 Doris 都有一个表示最喜欢餐厅的列表 list1、list2，每个餐厅的名字用字符串表示。

找出他们共同喜爱的餐厅，要求两个餐厅在列表中的索引和最小，如果答案不唯一，则输出所有答案。

## 解题思路

遍历 list1，建立一个哈希表 list1_dict，以 list1[i] : i 键值对的方式，将 list1 的下标存储起来。

然后遍历 list2，判断 list2[i] 是否在哈希表中，如果在，则根据 i + list1_dict[i] 和 min_sum 的比较，判断是否需要更新最小索引和。如果 i + list1_dict[i] < min_sum，则更新最小索引和，并清空答案数据，添加新的答案。如果 i + list1_dict[i] == min_sum，则更新最小索引和，并添加答案。

## 代码

```python
class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        list1_dict = dict()
        len1 = len(list1)
        len2 = len(list2)
        for i in range(len1):
            list1_dict[list1[i]] = i

        min_sum = len1 + len2
        res = []
        for i in range(len2):
            if list2[i] in list1_dict:
                sum = i + list1_dict[list2[i]]
                if sum < min_sum:
                    res = [list2[i]]
                    min_sum = sum
                elif sum == min_sum:
                    res.append(list2[i])
        return res
```

# [0600. 不含连续1的非负整数](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/)

- 标签：动态规划
- 难度：困难

## 题目链接

- [0600. 不含连续1的非负整数 - 力扣](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/)

## 题目大意

**描述**：给定一个正整数 $n$。

**要求**：统计在 $[0, n]$ 范围的非负整数中，有多少个整数的二进制表示中不存在连续的 $1$。

**说明**：

- $1 \le n \le 10^9$。

**示例**：

- 示例 1：

```python
输入: n = 5
输出: 5
解释: 
下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。
```

- 示例 2：

```python
输入: n = 1
输出: 2
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, pre, isLimit):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。其中：

1. $pos$ 表示当前枚举的数位位置。
2. $pre$ 表示前一位是否为 $1$，用于过滤连续 $1$ 的不合法方案。
3. $isLimit$ 表示前一位数位是否等于上界，用于限制本次搜索的数位范围。

接下来按照如下步骤进行递归。

1. 从 `dfs(0, False, True)` 开始递归。 `dfs(0, False, True)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 开始时前一位不为 $1$。
   3. 开始时受到数字 $n$ 对应最高位数位的约束。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，当前为合法方案，此时：直接返回方案数 $1$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 因为不需要考虑前导 $0$，所以当前所能选择的最小数字 $minX$ 为 $0$。
5. 根据 $isLimit$ 来决定填当前位数位所能选择的最大数字（$maxX$）。
6. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
7. 如果前一位为 $1$ 并且当前为 $d$ 也为 $1$，则说明当前方案出现了连续的 $1$，则跳过。
8. 方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, d == 1, isLimit and d == maxX)`。
   1. `d == 1` 表示下一位 $pos - 1$ 的前一位 $pos$ 是否为 $1$。
   2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位限制和 $pos$ 位限制。
9. 最后的方案数为 `dfs(0, False, True)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def findIntegers(self, n: int) -> int:
        # 将 n 的二进制转换为字符串 s
        s = str(bin(n))[2:]
        
        @cache
        # pos: 第 pos 个数位
        # pre: 第 pos - 1 位是否为 1
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        def dfs(pos, pre, isLimit):
            if pos == len(s):
                return 1
            
            ans = 0
            # 不需要考虑前导 0，则最小可选择数字为 0
            minX = 0
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 1。
            maxX = int(s[pos]) if isLimit else 1
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                if pre and d == 1:
                    continue
                ans += dfs(pos + 1, d == 1, isLimit and d == maxX)

            return ans
    
        return dfs(0, False, True)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。
# [0611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

- 标签：贪心、数组、双指针、二分查找、排序
- 难度：中等

## 题目链接

- [0611. 有效三角形的个数 - 力扣](https://leetcode.cn/problems/valid-triangle-number/)

## 题目大意

**描述**：给定一个包含非负整数的数组 $nums$，其中 $nums[i]$ 表示第 $i$ 条边的边长。

**要求**：统计数组中可以组成三角形三条边的三元组个数。

**说明**：

- $1 \le nums.length \le 1000$。
- $0 \le nums[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

- 示例 2：

```python
输入: nums = [4,2,3,4]
输出: 4
```

## 解题思路

### 思路 1：对撞指针

构成三角形的条件为：任意两边和大于第三边，或者任意两边差小于第三边。只要满足这两个条件之一就可以构成三角形。以任意两边和大于第三边为例，如果用 $a$、$b$、$c$ 来表示的话，应该同时满足 $a + b > c$、$a + c > b$、$b + c > a$。如果我们将三条边升序排序，假设 $a \le b \le c$，则如果满足 $a + b > c$，则 $a + c > b$ 和 $b + c > a$ 一定成立。

所以我们可以先对 $nums$ 进行排序。然后固定最大边 $i$，利用对撞指针 $left$、$right$ 查找较小的两条边。然后判断是否构成三角形并统计三元组个数。

为了避免重复计算和漏解，要严格保证三条边的序号关系为：$left < right < i$。具体做法如下：

- 对数组从小到大排序，使用 $ans$ 记录三元组个数。
- 从 $i = 2$ 开始遍历数组的每一条边，$i$ 作为最大边。
- 使用双指针 $left$、$right$。$left$ 指向 $0$，$right$ 指向 $i - 1$。
  - 如果 $nums[left] + nums[right] \le nums[i]$，说明第一条边太短了，可以增加第一条边长度，所以将 $left$ 右移，即 `left += 1`。
  - 如果 $nums[left] + nums[right] > nums[i]$，说明可以构成三角形，并且第二条边固定为 $right$ 边的话，第一条边可以在 $[left, right - 1]$ 中任意选择。所以三元组个数要加上 $right - left$。即 `ans += (right - left)`。
- 直到 $left == right$ 跳出循环，输出三元组个数 $ans$。

### 思路 1：代码

```python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        size = len(nums)
        ans = 0

        for i in range(2, size):
            left = 0
            right = i - 1
            while left < right:
                if nums[left] + nums[right] <= nums[i]:
                    left += 1
                else:
                    ans += (right - left)
                    right -= 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组中的元素个数。
- **空间复杂度**：$O(\log n)$，排序需要 $\log n$ 的栈空间。

# [0616. 给字符串添加加粗标签](https://leetcode.cn/problems/add-bold-tag-in-string/)

- 标签：字典树、数组、哈希表、字符串、字符串匹配
- 难度：中等

## 题目链接

- [0616. 给字符串添加加粗标签 - 力扣](https://leetcode.cn/problems/add-bold-tag-in-string/)

## 题目大意

给定一个字符串 `s` 和一个字符串列表 `words`。

要求：如果 `s` 的子串在字符串列表 `words` 中出现过，则在该子串前后添加加粗闭合标签 `<b>` 和 `</b>`。如果两个子串有重叠部分，则将它们一起用一对闭合标签包围起来。同理，如果两个子字符串连续被加粗，那么你也需要把它们合起来用一对加粗标签包围。最后返回添加加粗标签后的字符串 `s`。

## 解题思路

构建字典树，将字符串列表 `words` 中所有字符串添加到字典树中。

然后遍历字符串 `s`，从每一个位置开始查询字典树。在第一个符合要求的单词前面添加 `<b>`。在连续符合要求的单词中的最后一个单词后面添加 `</b>`。

最后返回添加加粗标签后的字符串 `s`。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd


class Solution:
    def addBoldTag(self, s: str, words: List[str]) -> str:
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        size = len(s)
        bold_left, bold_right = -1, -1
        ans = ""
        for i in range(size):
            cur = trie_tree
            if s[i] in cur.children:
                bold_left = i
                while bold_left < size and s[bold_left] in cur.children:
                    cur = cur.children[s[bold_left]]
                    bold_left += 1
                    if cur.isEnd:
                        if bold_right == -1:
                            ans += "<b>"
                        bold_right = max(bold_left, bold_right)
            if i == bold_right:
                ans += "</b>"
                bold_right = -1
            ans += s[i]
        if bold_right >= 0:
            ans += "</b>"
        return ans
```

# [0617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0617. 合并二叉树 - 力扣](https://leetcode.cn/problems/merge-two-binary-trees/)

## 题目大意

给定两个二叉树，将两个二叉树合并成一个新的二叉树。合并规则如下：

- 如果两个二叉树对应节点重叠，则将两个节点的值相加并作为新的二叉树节点。
- 如果两个二叉树对应节点其中一个为空，另一个不为空，则将不为空的节点左心新的二叉树节点。

最终返回新的二叉树的根节点。

## 解题思路

利用前序遍历二叉树，并按照规则递归建立二叉树。将其对应节点值相加或者取其中不为空的节点做为新节点。

## 代码

```python
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1:
            return root2
        if not root2:
            return root1

        merged = TreeNode(root1.val + root2.val)
        merged.left = self.mergeTrees(root1.left, root2.left)
        merged.right = self.mergeTrees(root1.right, root2.right)
        return merged

```

# [0621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

- 标签：贪心、数组、哈希表、计数、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0621. 任务调度器 - 力扣](https://leetcode.cn/problems/task-scheduler/)

## 题目大意

给定一个字符数组 tasks 表示 CPU 需要执行的任务列表。tasks 中每个字母表示一种不同种类的任务。任务可以按任意顺序执行，并且每个任务执行时间为 1 个单位时间。在任何一个单位时间，CPU 可以完成一个任务，或者也可以处于待命状态。

但是两个相同种类的任务之间需要 n 个单位时间的冷却时间，所以不能在连续的 n 个单位时间内执行相同的任务。

要求计算出完成 tasks 中所有任务所需要的「最短时间」。

## 解题思路

因为相同种类的任务之间最少需要 n 个单位时间间隔，所以为了最短时间，应该优先考虑任务出现此次最多的任务。

先找出出现次数最多的任务，然后中间间隔的单位来安排别的任务，或者处于待命状态。

然后将第二出现次数最多的任务，按照 n 个时间间隔安排起来。如果第二出现次数最多的任务跟第一出现次数最多的任务出现次数相同，则最短时间就会加一。

最后我们会发现：最短时间跟出现次数最多的任务正相关。

假设出现次数最多的任务为 "A"。与 "A" 出现次数相同的任务数为 count。则：

- `最短时间 = （A 出现次数 - 1）* （n + 1）+ count`。

最后还应该比较一下总的任务个数跟计算出的最短时间答案。如果最短时间比总的任务个数还少，说明间隔中放不下所有的任务，会有任务「溢出」。则应该将多余任务插入间隔中，则答案应为总的任务个数。

## 代码

```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        # 记录每个任务出现的次数
        tasks_counts = [0 for _ in range(26)]
        for i in range(len(tasks)):
            num = ord(tasks[i]) - ord('A')
            tasks_counts[num] += 1
        max_task_count = max(tasks_counts)
        # 统计多少个出现最多次的任务
        count = 0
        for task_count in tasks_counts:
            if task_count == max_task_count:
               count += 1

        # 如果结果比任务数量少，则返回总任务数
        return max((max_task_count - 1) * (n + 1) + count, len(tasks))
```

# [0622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

- 标签：设计、队列、数组、链表
- 难度：中等

## 题目链接

- [0622. 设计循环队列 - 力扣](https://leetcode.cn/problems/design-circular-queue/)

## 题目大意

**要求**：设计实现一个循环队列，支持以下操作：

- `MyCircularQueue(k)`: 构造器，设置队列长度为 `k`。
- `Front`: 从队首获取元素。如果队列为空，返回 `-1`。
- `Rear`: 获取队尾元素。如果队列为空，返回 `-1`。
- `enQueue(value)`: 向循环队列插入一个元素。如果成功插入则返回真。
- `deQueue()`: 从循环队列中删除一个元素。如果成功删除则返回真。
- `isEmpty()`: 检查循环队列是否为空。
- `isFull()`: 检查循环队列是否已满。

**说明**：

- 所有的值都在 `0` 至 `1000` 的范围内。
- 操作数将在 `1` 至 `1000` 的范围内。
- 请不要使用内置的队列库。

**示例**：

- 示例 1：

```python
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

## 解题思路

这道题可以使用数组，也可以使用链表来实现循环队列。

### 思路 1：使用数组模拟

建立一个容量为 `k + 1` 的数组 `queue`。并保存队头指针 `front`、队尾指针 `rear`，队列容量 `capacity` 为 `k + 1`（这里之所以用了 `k + 1` 的容量，是为了判断空和满，需要空出一个）。

然后实现循环队列的各个接口：

1. `MyCircularQueue(k)`: 
   1. 将数组 `queue` 初始化大小为 `k + 1` 的数组。
   2. `front`、`rear` 初始化为 `0`。
2. `Front`: 
   1. 先检测队列是否为空。如果队列为空，返回 `-1`。
   2. 如果不为空，则返回队头元素。
3. `Rear`: 
   1. 先检测队列是否为空。如果队列为空，返回 `-1`。
   2. 如果不为空，则返回队尾元素。
4. `enQueue(value)`: 
   1. 如果队列已满，则无法插入，返回 `False`。
   2. 如果队列未满，则将队尾指针 `rear` 向右循环移动一位，并进行插入操作。然后返回 `True`。
5. `deQueue()`: 
   1. 如果队列为空，则无法删除，返回 `False`。
   2. 如果队列不空，则将队头指针 `front` 指向元素赋值为 `None`，并将 `front` 向右循环移动一位。然后返回 `True`。
6. `isEmpty()`: 如果 `rear` 等于 `front`，则说明队列为空，返回 `True`。否则，队列不为空，返回 `False`。
7. `isFull()`: 如果 `(rear + 1) % capacity` 等于 `front`，则说明队列已满，返回 `True`。否则，队列未满，返回 `False`。

### 思路 1：代码

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.capacity = k + 1
        self.queue = [0 for _ in range(k + 1)]
        self.front = 0
        self.rear = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = value
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[(self.front + 1)  % self.capacity]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.rear]

    def isEmpty(self) -> bool:
        return self.front == self.rear

    def isFull(self) -> bool:
        return (self.rear + 1) % self.capacity == self.front
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。初始化和每项操作的时间复杂度均为 $O(1)$。
- **空间复杂度**：$O(k)$。其中 $k$ 为给定队列的元素数目。

# [0633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)

- 标签：数学、双指针、二分查找
- 难度：中等

## 题目链接

- [0633. 平方数之和 - 力扣](https://leetcode.cn/problems/sum-of-square-numbers/)

## 题目大意

给定一个非负整数 c，判断是否存在两个整数 a 和 b，使得 $a^2 + b^2 = c$，如果存在则返回 True，不存在返回 False。

## 解题思路

最直接的办法就是枚举 a、b 所有可能。这样遍历下来的时间复杂度为 $O(c^2)$。但是没必要进行二重遍历。可以只遍历 a，然后去判断 $\sqrt{c - b^2}$ 是否为整数，并且 a 只需遍历到 $\sqrt{c}$ 即可，时间复杂度为 $O(\sqrt{c})$。

另一种方法是双指针。定义两个指针 left，right 分别指向 0 和 $\sqrt{c}$。判断 $left^2 + right^2$ 与 c 之间的关系。

- 如果 $a^2 + b^2 == c$，则返回 True。
- 如果 $a^2 + b^2 < c$，则将 a 值加一，继续查找。
- 如果 $a^2 + b^2 > c$，则将 b 值减一，继续查找。
- 当 $a == b$ 时，结束查找。如果此时仍没有找到满足 $a^2 + b^2 == c$ 的 a、b 值，则返回 False。

## 代码

```python
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        a, b = 0, int(c ** 0.5)
        while a <= b:
            sum = a*a + b*b
            if sum == c:
                return True
            elif sum < c:
                a += 1
            else:
                b -= 1
        return False
```

# [0639. 解码方法 II](https://leetcode.cn/problems/decode-ways-ii/)

- 标签：字符串、动态规划
- 难度：困难

## 题目链接

- [0639. 解码方法 II - 力扣](https://leetcode.cn/problems/decode-ways-ii/)

## 题目大意

**描述**：给定一个包含数字和字符 `'*'` 的字符串 $s$。该字符串已经按照下面的映射关系进行了编码：

- `A` 映射为 $1$。
- `B` 映射为 $2$。
- ...
- `Z` 映射为 $26$。

除了上述映射方法，字符串 $s$ 中可能包含字符 `'*'`，可以表示 $1$ ~ $9$ 的任一数字（不包括 $0$）。例如字符串 `"1*"` 可以表示为 `"11"`、`"12"`、…、`"18"`、`"19"` 中的任何一个编码。

基于上述映射的方法，现在对字符串 `s` 进行「解码」。即从数字到字母进行反向映射。比如 `"11106"` 可以映射为：

- `"AAJF"`，将消息分组为 $(1 1 10 6)$。
- `"KJF"`，将消息分组为 $(11 10 6)$。

**要求**：计算出共有多少种可能的解码方案。

**说明**：

- $1 \le s.length \le 100$。
- $s$ 只包含数字，并且可能包含前导零。
- 题目数据保证答案肯定是一个 $32$ 位的整数。

```python
输入：s = "*"
输出：9
解释：这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。因此，"*" 总共有 9 种解码方法。
```

## 解题思路

### 思路 1：动态规划

这道题是「[91. 解码方法 - 力扣](https://leetcode.cn/problems/decode-ways/)」的升级版，其思路是相似的，只不过本题的状态转移方程的条件和公式不太容易想全。

###### 1. 划分阶段

按照字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：字符串 $s$ 前 $i$ 个字符构成的字符串可能构成的翻译方案数。

###### 3. 状态转移方程

$dp[i]$ 的来源有两种情况：

1. 使用了一个字符，对 $s[i]$ 进行翻译：
   1. 如果 `s[i] == '*'`，则 `s[i]` 可以视作区间 `[1, 9]` 上的任意一个数字，可以被翻译为 `A` ~ `I`。此时当前位置上的方案数为 `9`，即 `dp[i] = dp[i - 1] * 9`。
   2. 如果 `s[i] == '0'`，则无法被翻译，此时当前位置上的方案数为 `0`，即 `dp[i] = dp[i - 1] * 0`。
   3. 如果是其他情况（即 `s[i]` 是区间 `[1, 9]` 上某一个数字），可以被翻译为 `A` ~ `I` 对应位置上的某个字母。此时当前位置上的方案数为 `1`，即 `dp[i] = dp[i - 1] * 1`。

2. 使用了两个字符，对 `s[i - 1]` 和 `s[i]` 进行翻译：
   1. 如果 `s[i - 1] == '*'` 并且 `s[i] == '*'`，则 `s[i]` 可以视作区间 `[11, 19]` 或者 `[21, 26]` 上的任意一个数字。此时当前位置上的方案数为 `15`，即 `dp[i] = dp[i - 2] * 15`。
   2. 如果 `s[i - 1] == '*'` 并且 `s[i] != '*'`，则：
      1. 如果 `s[i]` 在区间 `[1, 6]` 内，`s[i - 1]` 可以选择 `1` 或 `2`。此时当前位置上的方案数为 `2`，即 `dp[i] = dp[i - 2] * 2`。
      2. 如果 `s[i]` 不在区间 `[1, 6]` 内，`s[i - 1]` 只能选择 `1`。此时当前位置上的方案数为 `1`，即 `dp[i] = dp[i - 2] * 1`。

   3. 如果 `s[i - 1] == '1'` 并且 `s[i] == '*'`，`s[i]` 可以视作区间 `[1, 9]` 上任意一个数字。此时当前位置上的方案数为 `9`，即 `dp[i] = dp[i - 2] * 9`。
   4. 如果 `s[i - 1] == '1'` 并且 `s[i] != '*'`，`s[i]` 可以视作区间 `[1, 9]` 上的某一个数字。此时当前位置上的方案数为 `1`，即 `dp[i] = dp[i - 2] * 1`。
   5. 如果 `s[i - 1] == '2'` 并且 `s[i] == '*'`，`s[i]` 可以视作区间 `[1, 6]` 上任意一个数字。此时当前位置上的方案数为 `6`，即 `dp[i] = dp[i - 2] * 6`。
   6. 如果 `s[i - 1] == '2'` 并且 `s[i] != '*'`，则：
      1. 如果 `s[i]` 在区间 `[1, 6]` 内，此时当前位置上的方案数为 `1`，即 `dp[i] = dp[i - 2] * 1`。
      2. 如果 `s[i]` 不在区间 `[1, 6]` 内，此时当前位置上的方案数为 `0`，即 `dp[i] = dp[i - 2] * 0`。

   7. 其他情况下（即 `s[i - 1]` 在区间 `[3, 9]` 内），则无法被翻译，此时当前位置上的方案数为 `0`，即 `dp[i] = dp[i - 2] * 0`。


在进行转移的时候，需要将使用一个字符的翻译方案数与使用两个字符的翻译方案数进行相加。同时还要注意对 $10^9 + 7$ 的取余。

这里我们可以单独写两个方法 `，分别来表示「单个字符 `s[i]` 的翻译方案数」和「两个字符 `s[i - 1]` 和 `s[i]` 的翻译方案数」，这样代码逻辑会更加清晰。

###### 4. 初始条件

- 字符串为空时，只有一个翻译方案，翻译为空字符串，即 `dp[0] = 1`。
- 字符串只有一个字符时，单个字符 `s[i]` 的翻译方案数为转移条件的第一种求法，即`dp[1] = self.parse1(s[0])`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：字符串 `s` 前 `i` 个字符构成的字符串可能构成的翻译方案数。则最终结果为 `dp[size]`，`size` 为字符串长度。

### 思路 1：动态规划代码

```python
class Solution:
    def parse1(self, ch):
        if ch == '*':
            return 9
        if ch == '0':
            return 0
        return 1

    def parse2(self, ch1, ch2):
        if ch1 == '*' and ch2 == '*':
            return 15
        if ch1 == '*' and ch2 != '*':
            return 2 if ch2 <= '6' else 1

        if ch1 == '1' and ch2 == '*':
            return 9
        if ch1 == '1' and ch2 != '*':
            return 1

        if ch1 == '2' and ch2 == '*':
            return 6
        if ch1 == '2' and ch2 != '*':
            return 1 if ch2 <= '6' else 0

        return 0

    def numDecodings(self, s: str) -> int:
        mod = 10 ** 9 + 7
        size = len(s)

        dp = [0 for _ in range(size + 1)]
        dp[0] = 1
        dp[1] = self.parse1(s[0])

        for i in range(2, size + 1):
            dp[i] += dp[i - 1] * self.parse1(s[i - 1])
            dp[i] += dp[i - 2] * self.parse2(s[i - 2], s[i - 1])
            dp[i] %= mod
        
        return dp[size]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度是 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。# [0642. 设计搜索自动补全系统](https://leetcode.cn/problems/design-search-autocomplete-system/)

- 标签：设计、字典树、字符串、数据流
- 难度：困难

## 题目链接

- [0642. 设计搜索自动补全系统 - 力扣](https://leetcode.cn/problems/design-search-autocomplete-system/)

## 题目大意

要求：设计一个搜索自动补全系统。用户会输入一条语句（最少包含一个字母，以特殊字符 `#` 结尾）。除 `#` 以外用户输入的每个字符，返回历史中热度前三并以当前输入部分为前缀的句子。下面是详细规则：

- 一条句子的热度定义为历史上用户输入这个句子的总次数。
- 返回前三的句子需要按照热度从高到低排序（第一个是最热门的）。如果有多条热度相同的句子，请按照 ASCII 码的顺序输出（ASCII 码越小排名越前）。
- 如果满足条件的句子个数少于 3，将它们全部输出。
- 如果输入了特殊字符，意味着句子结束了，请返回一个空集合。

你的工作是实现以下功能：

- 构造函数： `AutocompleteSystem(String[] sentences, int[] times):` 
  - 输入历史数据。 `sentences` 是之前输入过的所有句子，`times` 是每条句子输入的次数，你的系统需要记录这些历史信息。

- 输入函数（用户输入一条新的句子，下面的函数会提供用户输入的下一个字符）：`List<String> input(char c):` 
  - 其中 `c` 是用户输入的下一个字符。字符只会是小写英文字母（`a` 到 `z` ），空格（` `）和特殊字符（`#`）。输出历史热度前三的具有相同前缀的句子。

## 解题思路

使用字典树来保存输入过的所有句子 `sentences`，并且在字典树中维护每条句子的输入次数 `times`。

构造函数中：

- 将所有句子及对应输入次数插入到字典树中。

输入函数中：

- 使用 `path` 变量保存当前输入句子的前缀。
- 如果遇到 `#`，则将当前句子插入到字典树中。
- 如果遇到其他字符，用 `path` 保存当前字符 `c`。并在字典树中搜索以 `path` 为前缀的节点的所有分支，将每个分支对应的单词 `path` 和它们出现的次数 `times` 存入数组中。然后借助 `heapq` 进行堆排序，根据出现次数和 ASCII 码大小排序，找出 `times` 最多的前三个单词。

## 代码

```python
import heapq

class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.times = 0


    def insert(self, word: str, times=1) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.times += times


    def search(self, word: str):
        """
        Returns if the word is in the trie.
        """
        cur = self

        for ch in word:
            if ch not in cur.children:
                return []
            cur = cur.children[ch]

        res = []
        path = [word]
        cur.dfs(res, path)
        return res


    def dfs(self, res, path):
        cur = self
        if cur.isEnd:
            res.append((-cur.times, ''.join(path)))
        for ch in cur.children:
            node = cur.children[ch]
            path.append(ch)
            node.dfs(res, path)
            path.pop()


class AutocompleteSystem:

    def __init__(self, sentences: List[str], times: List[int]):
        self.path = ''
        self.exists = True
        self.trie_tree = Trie()
        for i in range(len(sentences)):
            self.trie_tree.insert(sentences[i], times[i])


    def input(self, c: str) -> List[str]:
        if c == '#':
            self.trie_tree.insert(self.path, 1)
            self.path = ''
            self.exists = True
            return []
        else:
            self.path += c
            if not self.exists:
                return []
            words = self.trie_tree.search(self.path)
            if words:
                heapq.heapify(words)
                res = []
                while words and len(res) < 3:
                    res.append(heapq.heappop(words)[1])
                return res
            else:
                self.exists = False
                return []
```

# [0643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)

- 标签：数组、滑动窗口
- 难度：简单

## 题目链接

- [0643. 子数组最大平均数 I - 力扣](https://leetcode.cn/problems/maximum-average-subarray-i/)

## 题目大意

**描述**：给定一个由 $n$ 个元素组成的整数数组 $nums$ 和一个整数 $k$。

**要求**：找出平均数最大且长度为 $k$ 的连续子数组，并输出该最大平均数。

**说明**：

- 任何误差小于 $10^{-5}$ 的答案都将被视为正确答案。
- $n == nums.length$。
- $1 \le k \le n \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
```

- 示例 2：

```python
输入：nums = [5], k = 1
输出：5.00000
```

## 解题思路

### 思路 1：滑动窗口（固定长度）

这道题目是典型的固定窗口大小的滑动窗口题目。窗口大小为 $k$。具体做法如下：

1. $ans$ 用来维护子数组最大平均数，初始值为负无穷，即 `float('-inf')`。$window\underline{\hspace{0.5em}}total$ 用来维护窗口中元素的和。
2. $left$ 、$right$ 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
3. 向右移动 $right$，先将 $k$ 个元素填入窗口中。
4. 当窗口元素个数为 $k$ 时，即：$right - left + 1 >= k$ 时，计算窗口内的元素和平均值，并维护子数组最大平均数。
5. 然后向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $k$。
6. 重复 $4 \sim 5$ 步，直到 $right$ 到达数组末尾。
7. 最后输出答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        left = 0
        right = 0
        window_total = 0
        ans = float('-inf')
        while right < len(nums):
            window_total += nums[right]

            if right - left + 1 >= k:
                ans = max(window_total / k, ans)
                window_total -= nums[left]
                left += 1

            # 向右侧增大窗口
            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为数组 $nums$ 的元素个数。
- **空间复杂度**：$O(1)$。# [0647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [0647. 回文子串 - 力扣](https://leetcode.cn/problems/palindromic-substrings/)

## 题目大意

给定一个字符串 `s`，计算 `s` 中有多少个回文子串。

## 解题思路

动态规划求解。

先定义状态 `dp[i][j]` 表示为区间 `[i, j]` 的子串是否为回文子串，如果是，则 `dp[i][j] = True`，如果不是，则 `dp[i][j] = False`。

接下来确定状态转移共识：

如果 `s[i] == s[j]`，分为以下几种情况：

- `i == j`，单字符肯定是回文子串，`dp[i][j] == True`。
- `j - i == 1`，比如 `aa` 肯定也是回文子串，`dp[i][j] = True`。
- 如果 `j - i > 1`，则需要看 `[i + 1, j - 1]` 区间是不是回文子串，`dp[i][j] = dp[i + 1][j - 1]`。

如果 `s[i] != s[j]`，那肯定不是回文子串，`dp[i][j] = False`。

下一步确定遍历方向。

由于 `dp[i][j]` 依赖于 `dp[i + 1][j - 1]`，所以我们可以从左下角向右上角遍历。

同时，在递推过程中记录下 `dp[i][j] == True` 的个数，即为最后结果。

## 代码

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        size = len(s)
        dp = [[False for _ in range(size)] for _ in range(size)]
        res = 0
        for i in range(size - 1, -1, -1):
            for j in range(i, size):
                if s[i] == s[j]:
                    if j - i <= 1:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                else:
                    dp[i][j] = False
                if dp[i][j]:
                    res += 1
        return res
```

# [0648. 单词替换](https://leetcode.cn/problems/replace-words/)

- 标签：字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [0648. 单词替换 - 力扣](https://leetcode.cn/problems/replace-words/)

## 题目大意

**描述**：给定一个由许多词根组成的字典列表 `dictionary`，以及一个句子字符串 `sentence`。

**要求**：将句子中有词根的单词用词根替换掉。如果单词有很多词根，则用最短的词根替换掉他。最后输出替换之后的句子。

**说明**：

- $1 \le dictionary.length \le 1000$。
- $1 \le dictionary[i].length \le 100$。
- `dictionary[i]` 仅由小写字母组成。
- $1 \le sentence.length \le 10^6$。
- `sentence` 仅由小写字母和空格组成。
- `sentence` 中单词的总量在范围 $[1, 1000]$ 内。
- `sentence` 中每个单词的长度在范围 $[1, 1000]$ 内。
- `sentence` 中单词之间由一个空格隔开。
- `sentence` 没有前导或尾随空格。

**示例**：

- 示例 1：

```python
输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"
```

- 示例 2：

```python
输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
输出："a a b c"
```

## 解题思路

### 思路 1：字典树

1. 构造一棵字典树。
2. 将所有的词根存入到前缀树（字典树）中。
3. 然后在树上查找每个单词的最短词根。

### 思路 1：代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> str:
        """
        Returns if the word is in the trie.
        """
        cur = self
        index = 0
        for ch in word:
            if ch not in cur.children:
                return word
            cur = cur.children[ch]
            index += 1
            if cur.isEnd:
                break
        return word[:index]


class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie_tree = Trie()
        for word in dictionary:
            trie_tree.insert(word)

        words = sentence.split(" ")
        size = len(words)
        for i in range(size):
            word = words[i]
            words[i] = trie_tree.search(word)
        return ' '.join(words)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(|dictionary| + |sentence|)$。其中 $|dictionary|$ 是字符串数组 `dictionary` 中的字符总数，$|sentence|$ 是字符串 `sentence` 的字符总数。
- **空间复杂度**：$O(|dictionary| + |sentence|)$。# [0650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/)

- 标签：数学、动态规划
- 难度：中等

## 题目链接

- [0650. 只有两个键的键盘 - 力扣](https://leetcode.cn/problems/2-keys-keyboard/)

## 题目大意

**描述**：最初记事本上只有一个字符 `'A'`。你每次可以对这个记事本进行两种操作：

- **Copy All（复制全部）**：复制这个记事本中的所有字符（不允许仅复制部分字符）。
- **Paste（粘贴）**：粘贴上一次复制的字符。

现在，给定一个数字 $n$，需要使用最少的操作次数，在记事本上输出恰好 $n$ 个 `'A'` 。

**要求**：返回能够打印出 $n$ 个 `'A'` 的最少操作次数。

**说明**：

- $1 \le n \le 1000$。

**示例**：

- 示例 1：

```python
输入：3
输出：3
解释
最初, 只有一个字符 'A'。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 'AA'。
第 3 步, 使用 Paste 操作来获得 'AAA'。
```

- 示例 2：

```python
输入：n = 1
输出：0
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照字符 `'A'`  的个数进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 `'A'`，最少需要的操作数。

###### 3. 状态转移方程

1. 对于 $i$ 个字符 `'A'`，如果 $i$ 可以被一个小于 $i$ 的整数 $j$ 除尽（$j$ 是 $i$ 的因子），则说明 $j$ 个字符 `'A'` 可以通过「复制」+「粘贴」总共 $\frac{i}{j}$ 次得到 $i$ 个字符 `'A'`。
2. 而得到 $j$ 个字符 `'A'`，最少需要的操作数可以通过 $dp[j]$ 获取。

则我们可以枚举 $i$ 的因子，从中找到在满足 $j$ 能够整除 $i$ 的条件下，最小的 $dp[j] + \frac{i}{j}$，即为 $dp[i]$，即 $dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j})$。

由于 $j$ 能够整除 $i$，则 $j$ 与 $\frac{i}{j}$ 都是 $i$ 的因子，两者中必有一个因子是小于等于 $\sqrt{i}$ 的，所以在枚举 $i$ 的因子时，我们只需要枚举区间 $[1, \sqrt{i}]$ 即可。

综上所述，状态转移方程为：$dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j}, dp[\frac{i}{j}] + j)$。

###### 4. 初始条件

- 当 $i$ 为 $1$ 时，最少需要的操作数为 $0$。所以 $dp[1] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 `'A'`，最少需要的操作数。 所以最终结果为 $dp[n]$。

### 思路 1：动态规划代码

```python
import math

class Solution:
    def minSteps(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        for i in range(2, n + 1):
            dp[i] = float('inf')
            for j in range(1, int(math.sqrt(n)) + 1):
                if i % j == 0:
                    dp[i] = min(dp[i], dp[j] + i // j, dp[i // j] + j)

        return dp[n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \sqrt{n})$。外层循环遍历的时间复杂度是 $O(n)$，内层循环遍历的时间复杂度是 $O(\sqrt{n})$，所以总体时间复杂度为 $O(n \sqrt{n})$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。
# [0652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

- 标签：树、深度优先搜索、哈希表、二叉树
- 难度：中等

## 题目链接

- [0652. 寻找重复的子树 - 力扣](https://leetcode.cn/problems/find-duplicate-subtrees/)

## 题目大意

给定一个二叉树，返回所有重复的子树。对于重复的子树，只需返回其中任意一棵的根节点。

## 解题思路

对二叉树进行先序遍历，对遍历的所有的子树进行序列化处理，将序列化处理后的字符串作为哈希表的键，记录每棵子树出现的次数。

当出现第二次时，则说明该子树是重复的子树，将其加入答案数组。最后返回答案数组即可。

## 代码

```python
class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        tree_dict = dict()
        res = []
        def preorder(node):
            if not node:
                return '#'
            sub_tree = str(node.val) + ',' + preorder(node.left) + ',' + preorder(node.right)
            if sub_tree in tree_dict:
                tree_dict[sub_tree] += 1
            else:
                tree_dict[sub_tree] = 1
            if tree_dict[sub_tree] == 2:
                res.append(node)
            return sub_tree
        preorder(root)
        return res
```

# [0653. 两数之和 IV - 输入二叉搜索树](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

- 标签：树、深度优先搜索、广度优先搜索、二叉搜索树、哈希表、双指针、二叉树
- 难度：简单

## 题目链接

- [0653. 两数之和 IV - 输入二叉搜索树 - 力扣](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

## 题目大意

给定一个二叉搜索树的根节点 `root` 和一个整数 `k`。

要求：判断该二叉搜索树是否存在两个节点值的和等于 `k`。如果存在，则返回 `True`，不存在则返回 `False`。

## 解题思路

二叉搜索树中序遍历的结果是从小到大排序，所以我们可以先对二叉搜索树进行中序遍历，将中序遍历结果存储到列表中。再使用左右指针查找节点值和为 `k` 的两个节点。

## 代码

```python
class Solution:
    def inOrder(self, root, nums):
        if not root:
            return
        self.inOrder(root.left, nums)
        nums.append(root.val)
        self.inOrder(root.right, nums)

    def findTarget(self, root: TreeNode, k: int) -> bool:
        nums = []
        self.inOrder(root, nums)
        left, right = 0, len(nums) - 1
        while left < right:
            sum = nums[left] + nums[right]
            if sum == k:
                return True
            elif sum < k:
                left += 1
            else:
                right -= 1
        return False
```

# [0654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

- 标签：栈、树、数组、分治、二叉树、单调栈
- 难度：中等

## 题目链接

- [0654. 最大二叉树 - 力扣](https://leetcode.cn/problems/maximum-binary-tree/)

## 题目大意

给定一个不含重复元素的整数数组 `nums`。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

要求通过给定的数组构建最大二叉树，并且输出这个树的根节点。

## 解题思路

根据题意可知，数组中最大元素位置为根节点，最大元素位置左右部分可分别作为左右子树。则我们可以通过递归的方式构建最大二叉树。

- 定义 left、right 分别表示当前数组的左右边界位置，定义 `max_value_index` 为当前数组中最大值位置。
- 遍历当前数组，找到最大值位置 `max_value_index`，并建立根节点 `root`，将数组 `nums` 分为 `[left, max_value_index]` 和 `[max_value_index, right]` 两部分，并分别递归建树。
- 将其赋值给 `root` 的左右子节点，最后返回 root 节点。

## 代码

```python
class Solution:
    def createBinaryTree(self, nums: List[int], left: int, right: int) -> TreeNode:
        if left >= right:
            return None
        max_value_index = left
        for i in range(left + 1, right):
            if nums[i] > nums[max_value_index]:
                max_value_index = i

        root = TreeNode(nums[max_value_index])
        root.left = self.createBinaryTree(nums, left, max_value_index)
        root.right = self.createBinaryTree(nums, max_value_index + 1, right)

        return root

    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        return self.createBinaryTree(nums, 0, len(nums))
```

# [0658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

- 标签：数组、双指针、二分查找、排序、滑动窗口、堆（优先队列）
- 难度：中等

## 题目链接

- [0658. 找到 K 个最接近的元素 - 力扣](https://leetcode.cn/problems/find-k-closest-elements/)

## 题目大意

**描述**：给定一个有序数组 $arr$，以及两个整数 $k$、$x$。

**要求**：从数组中找到最靠近 $x$（两数之差最小）的 $k$ 个数。返回包含这 $k$ 个数的有序数组。

**说明**：

- 整数 $a$ 比整数 $b$ 更接近 $x$ 需要满足：
  - $|a - x| < |b - x|$ 或者
  - $|a - x| == |b - x|$ 且 $a < b$。

- $1 \le k \le arr.length$。
- $1 \le arr.length \le 10^4$。
- $arr$ 按升序排列。
- $-10^4 \le arr[i], x \le 10^4$。

**示例**：

- 示例 1：

```python
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
```

- 示例 2：

```python
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
```

## 解题思路

### 思路 1：二分查找算法

数组的区间为 $[0, n-1]$，查找的子区间长度为 $k$。我们可以通过查找子区间左端点位置，从而确定子区间。

查找子区间左端点可以通过二分查找来降低复杂度。

因为子区间为 $k$，所以左端点最多取到 $n - k$ 的位置。

设定两个指针 $left$，$right$。$left$ 指向 $0$，$right$ 指向 $n - k$。

每次取 $left$ 和 $right$ 中间位置，判断 $x$ 与左右边界的差值。$x$ 与左边的差值为 $x - arr[mid]$，$x$ 与右边界的差值为 $arr[mid + k] - x$。

- 如果 $x$ 与左边界的差值大于 $x$ 与右边界的差值，即 $x - arr[mid] > arr[mid + k] - x$，将 $left$ 右移，$left = mid + 1$，从右侧继续查找。
- 如果 $x$ 与左边界的差值小于等于 $x$ 与右边界的差值， 即 $x - arr[mid] \le arr[mid + k] - x$，则将 $right$ 向左侧靠拢，$right = mid$，从左侧继续查找。

最后返回 $arr[left, left + k]$ 即可。

### 思路 1：代码

```python
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        n = len(arr)
        left = 0
        right = n - k
        while left < right:
            mid = left + (right - left) // 2
            if x - arr[mid] > arr[mid + k] - x:
                left = mid + 1
            else:
                right = mid
        return arr[left: left + k]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log (n - k) + k)$，其中 $n$ 为数组中的元素个数。
- **空间复杂度**：$O(1)$。

# [0662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0662. 二叉树最大宽度 - 力扣](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

## 题目大意

**描述**：给你一棵二叉树的根节点 `root`。

**要求**：返回树的最大宽度。

**说明**：

- **每一层的宽度**：为该层最左和最右的非空节点（即两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。
- **树的最大宽度**：是所有层中最大的宽度。
- 题目数据保证答案将会在 32 位带符号整数范围内。
- 树中节点的数目范围是 $[1, 3000]$。
- $-100 \le Node.val \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg)

```python
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9)。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg)

```python
输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
```

## 解题思路

### 思路 1：广度优先搜索

最直观的做法是，求出每一层的宽度，然后求出所有层高度的最大值。

在计算每一层宽度时，根据题意，两端点之间的 `null` 节点也计入长度，所以我们可以对包括 `null` 节点在内的该二叉树的所有节点进行编号。

也就是满二叉树的编号规则：如果当前节点的编号为 $i$，则左子节点编号记为 $i \times 2 + 1$，则右子节点编号为 $i \times 2 + 2$。

接下来我们使用广度优先搜索方法遍历每一层的节点，在向队列中添加节点时，将该节点与该节点对应的编号一同存入队列中。

这样在计算每一层节点的宽度时，我们可以通过队列中队尾节点的编号与队头节点的编号，快速计算出当前层的宽度。并计算出所有层宽度的最大值。

### 思路 1：代码

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        if not root:
            return False

        queue = collections.deque([[root, 0]])
        ans = 0
        while queue:
            ans = max(ans, queue[-1][1] - queue[0][1] + 1)
            size = len(queue)
            for _ in range(size):
                cur, index = queue.popleft()
                if cur.left:
                    queue.append([cur.left, index * 2 + 1])
                if cur.right:
                    queue.append([cur.right, index * 2 + 2])
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉树的节点数。
- **空间复杂度**：$O(n)$。
# [0664. 奇怪的打印机](https://leetcode.cn/problems/strange-printer/)

- 标签：字符串、动态规划
- 难度：困难

## 题目链接

- [0664. 奇怪的打印机 - 力扣](https://leetcode.cn/problems/strange-printer/)

## 题目大意

**描述**：有一台奇怪的打印机，有以下两个功能：

1. 打印机每次只能打印由同一个字符组成的序列，比如：`"aaaa"`、`"bbb"`。
2. 每次可以从起始位置到结束的任意为止打印新字符，并且会覆盖掉原有字符。

现在给定一个字符串 $s$。

**要求**：计算这个打印机打印出字符串 $s$ 需要的最少打印次数。

**说明**：

- $1 \le s.length \le 100$。
- $s$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "aaabbb"
输出：2
解释：首先打印 "aaa" 然后打印 "bbb"。
```

- 示例 2：

```python
输入：s = "aba"
输出：2
解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
```

## 解题思路

对于字符串 $s$，我们可以先考虑区间 $[i, j]$ 上的子字符串需要的最少打印次数。

1. 如果区间 $[i, j]$ 内只有 $1$ 种字符，则最少打印次数为 $1$，即：$dp[i][i] = 1$。
2. 如果区间 $[i, j]$ 内首尾字符相同，即 $s[i] == s[j]$，则我们在打印 $s[i]$ 的同时我们可以顺便打印 $s[j]$，这样我们可以忽略 $s[j]$，只考虑剩下区间 $[i, j - 1]$ 的打印情况，即：$dp[i][j] = dp[i][j - 1]$。
3. 如果区间 $[i, j]$ 上首尾字符不同，即 $s[i] \ne s[j]$，则枚举分割点 $k$，将区间 $[i, j]$ 分为区间 $[i, k]$ 与区间 $[k + 1, j]$，使得 $dp[i][k] + dp[k + 1][j]$ 的值最小即为 $dp[i][j]$。

### 思路 1：动态规划

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：打印第 $i$ 个字符到第 $j$ 个字符需要的最少打印次数。

###### 3. 状态转移方程

1. 如果 $s[i] == s[j]$，则我们在打印 $s[i]$ 的同时我们可以顺便打印 $s[j]$，这样我们可以忽略 $s[j]$，只考虑剩下区间 $[i, j - 1]$ 的打印情况，即：$dp[i][j] = dp[i][j - 1]$。
2. 如果 $s[i] \ne s[j]$，则枚举分割点 $k$，将区间 $[i, j]$ 分为区间 $[i, k]$ 与区间 $[k + 1, j]$，使得 $dp[i][k] + dp[k + 1][j]$ 的值最小即为 $dp[i][j]$，即：$dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])$。

###### 4. 初始条件

- 初始时，打印单个字符的最少打印次数为 $1$，即 $dp[i][i] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：打印第 $i$ 个字符到第 $j$ 个字符需要的最少打印次数。 所以最终结果为 $dp[0][size - 1]$。

### 思路 1：代码

```python
class Solution:
    def strangePrinter(self, s: str) -> int:
        size = len(s)
        dp = [[float('inf') for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = 1
            
        for l in range(2, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                if s[i] == s[j]:
                    dp[i][j] = dp[i][j - 1]
                else:
                    for k in range(i, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])

        return dp[0][size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n^2)$。

# [0665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/)

- 标签：数组
- 难度：中等

## 题目链接

- [0665. 非递减数列 - 力扣](https://leetcode.cn/problems/non-decreasing-array/)

## 题目大意

给定一个整数数组 nums，问能否在最多改变 1 个元素的条件下，使数组变为非递减序列。若能，返回 True，不能则返回 False。

## 解题思路

循环遍历数组，寻找 nums[i] > nums[i+1] 的情况，一旦这种情况出现超过 2 次，则不可能最多改变 1 个元素，直接返回 False。

遇到 nums[i] > nums[i+1] 的情况，应该手动调节某位置上元素使数组有序。此时，有两种选择：

- 将 nums[i] 调低，与 nums[i-1] 持平
- 将 nums[i+1] 调高，与 nums[i] 持平

若选择第一种调节方式，如果调节前 nums[i-1] > nums[i+1]，那么调节完 nums[i] 之后，nums[i-1] 还是比 nums[i+1] 大，不可取。

所以应选择第二种调节方式，如果调节前 nums[i-1] > nums[i+1]，那么调节完 nums[i+1] 之后 nums[i-1] < nums[i] <= nums[i+1]，满足非递减要求。

最终如果最多调整过一次，且 nums[i] > nums[i+1] 的情况也最多出现过一次，则返回 True。

## 代码

```python
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        count = 0
        for i in range(len(nums)-1):
            if nums[i] > nums[i+1]:
                count += 1
                if count > 1:
                    return False
                if i > 0 and nums[i-1] > nums[i+1]:
                    nums[i+1] = nums[i]

        return True
```

# [0669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0669. 修剪二叉搜索树 - 力扣](https://leetcode.cn/problems/trim-a-binary-search-tree/)

## 题目大意

给定一棵二叉搜索树的根节点 `root`，同时给定最小边界 `low` 和最大边界 `high`。通过修建二叉搜索树，使得所有节点值都在 `[low, high]` 中。修剪树不应该改变保留在树中的元素的相对结构（即如果没有移除节点，则该节点的父节点关系、子节点关系都应当保留）。

现在要求返回修建过后的二叉树的根节点。

## 解题思路

递归修剪，函数返回值为修剪之后的树。

- 如果当前根节点为空，则直接返回 None。
- 如果当前根节点的值小于 `low`，则该节点左子树全部都小于最小边界，则删除左子树，然后递归遍历右子树，在右子树中寻找符合条件的节点。
- 如果当前根节点的值大于 `hight`，则该节点右子树全部都大于最大边界，则删除右子树，然后递归遍历左子树，在左子树中寻找符合条件的节点。
- 如果在最小边界和最大边界的区间内，则分别从左右子树寻找符合条件的节点作为根的左右子树。

## 代码

```python
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        if not root:
            return None
        if root.val < low:
            right = self.trimBST(root.right, low, high)
            return right
        if root.val > high:
            left = self.trimBST(root.left, low, high)
            return left

        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root
```

# [0673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

- 标签：树状数组、线段树、数组、动态规划
- 难度：中等

## 题目链接

- [0673. 最长递增子序列的个数 - 力扣](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

## 题目大意

**描述**：给定一个未排序的整数数组 `nums`。

**要求**：返回最长递增子序列的个数。

**说明**：

- 子数列必须是严格递增的。
- $1 \le nums.length \le 2000$。
- $-10^6 \le nums[i] \le 10^6$。

**示例**：

- 示例 1：

```python
输入：[1,3,5,4,7]
输出：2
解释：有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

## 解题思路

### 思路 1：动态规划

可以先做题目 [0300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)。

动态规划的状态 `dp[i]` 表示为：以第 `i` 个数字结尾的前 `i` 个元素中最长严格递增子序列的长度。

两重循环遍历前 `i` 个数字，对于 $0 \le j \le i$：

- 当 `nums[j] < nums[i]` 时，`nums[i]` 可以接在 `nums[j]` 后面，此时以第 `i` 个数字结尾的最长严格递增子序列长度 + 1，即 `dp[i] = dp[j] + 1`。
- 当 `nums[j] ≥ nums[i]` 时，可以直接跳过。

则状态转移方程为：`dp[i] = max(dp[i], dp[j] + 1)`，`0 ≤ j ≤ i`，`nums[j] < nums[i]`。

最后再遍历一遍 dp 数组，求出最大值即为最长递增子序列的长度。

现在求最长递增子序列的个数。则需要在求解的过程中维护一个 `count` 数组，用来保存以 `nums[i]` 结尾的最长递增子序列的个数。

对于 $0 \le j \le i$：

- 当 `nums[j] < nums[i]`，而且 `dp[j] + 1 > dp[i]` 时，说明第一次找到 `dp[j] + 1`长度且以`nums[i]`结尾的最长递增子序列，则以 `nums[i]` 结尾的最长递增子序列的组合数就等于以 `nums[j]` 结尾的组合数，即 `count[i] = count[j]`。
- 当 `nums[j] < nums[i]`，而且 `dp[j] + 1 == dp[i]` 时，说明以 `nums[i]` 结尾且长度为 `dp[j] + 1` 的递增序列已找到过一次了，则以 `nums[i]` 结尾的最长递增子序列的组合数要加上以 `nums[j]` 结尾的组合数，即 `count[i] += count[j]`。

- 然后根据遍历 dp 数组得到的最长递增子序列的长度 max_length，然后再一次遍历 dp 数组，将所有 `dp[i] == max_length` 情况下的组合数 `coun[i]` 累加起来，即为最长递增序列的个数。

### 思路 1：动态规划代码

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [1 for _ in range(size)]
        count = [1 for _ in range(size)]
        for i in range(size):
            for j in range(i):
                if nums[j] < nums[i]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        count[i] = count[j]
                    elif dp[j] + 1 == dp[i]:
                        count[i] += count[j]

        max_length = max(dp)
        res = 0
        for i in range(size):
            if dp[i] == max_length:
                res += count[i]
        return res
```

### 思路 2：线段树

题目中 `nums` 的长度 为 $[1, 2000]$，值域为 $[-10^6, 10^6]$。

值域范围不是特别大，我们可以直接用线段树保存整个值域区间。但因为数组的长度只有 `2000`，所以算法效率更高的做法是先对数组进行离散化处理。把数组中的元素按照大小依次映射到 `[0, len(nums) - 1]` 这个区间。

1. 构建一棵长度为 `len(nums)` 的线段树，其中每个线段树的节点保存一个二元组。这个二元组 `val = [length, count]` 用来表示：以当前节点为结尾的子序列所能达到的最长递增子序列长度 `length` 和最长递增子序列对应的数量 `count`。
2. 顺序遍历数组 `nums`。对于当前元素 `nums[i]`：
3. 查找 `[0, nums[i - 1]]` 离散化后对应区间节点的二元组，也就是查找以区间 `[0, nums[i - 1]]` 上的点为结尾的子序列所能达到的最长递增子序列长度和其对应的数量，即 `val = [length, count]`。
   - 如果所能达到的最长递增子序列长度为 `0`，则加入 `nums[i]` 之后最长递增子序列长度变为 `1`，且数量也变为 `1`。
   - 如果所能达到的最长递增子序列长度不为 `0`，则加入 `nums[i]` 之后最长递增子序列长度 +1，但数量不变。
4. 根据上述计算的 `val` 值更新 `nums[i]` 对应节点的 `val` 值。 
5. 然后继续向后遍历，重复进行第 `3` ~ `4` 步操作。
6. 最后查询以区间 `[0, nums[len(nums) - 1]]` 上的点为结尾的子序列所能达到的最长递增子序列长度和其对应的数量。返回对应的数量即为答案。

### 思路 2：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=[0, 1]):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, size):
        self.size = size
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
    
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.__update_point(i, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)

        
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = [0, 0]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树

        self.tree[index].val = self.merge(self.tree[left_index].val, self.tree[right_index].val)   # 向上更新节点的区间值
    
    # 单点更新实现方法：将 nums[i] 更改为 val，节点的存储下标为 index
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == i and right == i:
            self.tree[index].val = self.merge(self.tree[index].val, val)
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.tree[index].val = self.merge(self.tree[left_index].val, self.tree[right_index].val)   # 向上更新节点的区间值
    
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return [0, 0]

        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = [0, 0]
        res_right = [0, 0]
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        # 返回合并结果
        return self.merge(res_left, res_right)

    # 向上合并实现方法
    def merge(self, val1, val2):
        val = [0, 0]
        if val1[0] == val2[0]:                      # 递增子序列长度一致，则合并后最长递增子序列个数为之前两者之和
            val = [val1[0], val1[1] + val2[1]]
        elif val1[0] < val2[0]:                     # 如果递增子序列长度不一致，则合并后最长递增子序列个数取较长一方的个数
            val = [val2[0], val2[1]]
        else:
            val = [val1[0], val1[1]]
        return val

class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:

        # 离散化处理
        num_dict = dict()
        nums_sort = sorted(nums)
        for i in range(len(nums_sort)):
            num_dict[nums_sort[i]] = i
        
        # 构造线段树
        self.STree = SegmentTree(len(nums_sort))

        for num in nums:
            index = num_dict[num]
            # 查询 [0, nums[index - 1]] 区间上以 nums[index - 1] 结尾的子序列所能达到的最长递增子序列长度和对应数量
            val = self.STree.query_interval(0, index - 1)
            # 如果当前最长递增子序列长度为 0，则加入 num 之后最长递增子序列长度为 1，且数量为 1
            # 如果当前最长递增子序列长度不为 0，则加入 num 之后最长递增子序列长度 +1，但数量不变
            if val[0] == 0:
                val = [1, 1]
            else:
                val = [val[0] + 1, val[1]]
            self.STree.update_point(index, val)
        return self.STree.query_interval(0, len(nums_sort) - 1)[1]
```

# [0674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

- 标签：数组
- 难度：简单

## 题目链接

- [0674. 最长连续递增序列 - 力扣](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

## 题目大意

**描述**：给定一个未经排序的数组 $nums$。

**要求**：找到最长且连续递增的子序列，并返回该序列的长度。

**说明**：

- **连续递增的子序列**：可以由两个下标 $l$ 和 $r$（$l < r$）确定，如果对于每个 $l \le i < r$，都有 $nums[i] < nums[i + 1] $，那么子序列 $[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]$ 就是连续递增子序列。
- $1 \le nums.length \le 10^4$。
- $-10^9 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为 3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

- 示例 2：

```python
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为 1。
```

## 解题思路

### 思路 1：动态规划

###### 1. 定义状态

定义状态 $dp[i]$ 表示为：以 $nums[i]$ 结尾的最长且连续递增的子序列长度。

###### 2. 状态转移方程

因为求解的是连续子序列，所以只需要考察相邻元素的状态转移方程。

如果一个较小的数右侧相邻元素为一个较大的数，则会形成一个更长的递增子序列。

对于相邻的数组元素 $nums[i - 1]$ 和 $nums[i]$ 来说：

- 如果 $nums[i - 1] < nums[i]$，则 $nums[i]$ 可以接在 $nums[i - 1]$ 后面，此时以 $nums[i]$ 结尾的最长递增子序列长度会在「以 $nums[i - 1]$ 结尾的最长递增子序列长度」的基础上加 $1$，即 $dp[i] = dp[i - 1] + 1$。

- 如果 $nums[i - 1] >= nums[i]$，则 $nums[i]$ 不可以接在 $nums[i - 1]$ 后面，可以直接跳过。

综上，我们的状态转移方程为：$dp[i] = dp[i - 1] + 1$，$nums[i - 1] < nums[i]$。

###### 3. 初始条件

默认状态下，把数组中的每个元素都作为长度为 $1$ 的最长且连续递增的子序列长度。即 $dp[i] = 1$。

###### 4. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：以 $nums[i]$ 结尾的最长且连续递增的子序列长度。则为了计算出最大值，则需要再遍历一遍 $dp$ 数组，求出最大值即为最终结果。

### 思路 1：动态规划代码

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [1 for _ in range(size)]

        for i in range(1, size):
            if nums[i - 1] < nums[i]:
                dp[i] = dp[i - 1] + 1
        
        return max(dp)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$，最后求最大值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。

### 思路 2：滑动窗口（不定长度）

1. 设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口内为连续递增序列。使用 $window\underline{\hspace{0.5em}}len$ 存储当前窗口大小，使用 $max\underline{\hspace{0.5em}}len$ 维护最大窗口长度。
2. 一开始，$left$、$right$ 都指向 $0$。
3. 将最右侧元素 $nums[right]$ 加入当前连续递增序列中，即当前窗口长度加 $1$（`window_len += 1`）。
4. 判断当前元素 $nums[right]$ 是否满足连续递增序列。
5. 如果 $right > 0$ 并且 $nums[right - 1] \ge nums[right]$ ，说明不满足连续递增序列，则将 $left$ 移动到窗口最右侧，重置当前窗口长度为 $1$（`window_len = 1`）。
6. 记录当前连续递增序列的长度，并更新最长连续递增序列的长度。
7. 继续右移 $right$，直到 $right \ge len(nums)$ 结束。
8. 输出最长连续递增序列的长度 $max\underline{\hspace{0.5em}}len$。

### 思路 2：代码

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        size = len(nums)
        left, right = 0, 0
        window_len = 0
        max_len = 0
        
        while right < size:
            window_len += 1
            
            if right > 0 and nums[right - 1] >= nums[right]:
                left = right
                window_len = 1

            max_len = max(max_len, window_len)
            right += 1
            
        return max_len
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。# [0676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [0676. 实现一个魔法字典 - 力扣](https://leetcode.cn/problems/implement-magic-dictionary/)

## 题目大意

**要求**：设计一个使用单词表进行初始化的数据结构。单词表中的单词互不相同。如果给出一个单词，要求判定能否将该单词中的一个字母替换成另一个字母，是的所形成的新单词已经在够构建的单词表中。

实现 MagicDictionary 类：

- `MagicDictionary()` 初始化对象。
- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同。
- `bool search(String searchWord)` 给定一个字符串 `searchWord`，判定能否只将字符串中一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `True`；否则，返回 `False`。

**说明**：

- $1 \le dictionary.length \le 100$。
- $1 \le dictionary[i].length \le 100$。
- `dictionary[i]` 仅由小写英文字母组成。
- `dictionary` 中的所有字符串互不相同。
- $1 \le searchWord.length \le 100$。
- `searchWord` 仅由小写英文字母组成。
- `buildDict` 仅在 `search` 之前调用一次。
- 最多调用 $100$ 次 `search`。

**示例**：

- 示例 1：

```python
输入
["MagicDictionary", "buildDict", "search", "search", "search", "search"]
[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
输出
[null, null, false, true, false, false]

解释
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict(["hello", "leetcode"]);
magicDictionary.search("hello"); // 返回 False
magicDictionary.search("hhllo"); // 将第二个 'h' 替换为 'e' 可以匹配 "hello" ，所以返回 True
magicDictionary.search("hell"); // 返回 False
magicDictionary.search("leetcoded"); // 返回 False
```

## 解题思路

### 思路 1：字典树

1. 构造一棵字典树。
2. `buildDict` 方法中将所有单词存入字典树中。
3. `search` 方法中替换 `searchWord` 每一个位置上的字符，然后在字典树中查询。

### 思路 1：代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd


class MagicDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie_tree = Trie()


    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            self.trie_tree.insert(word)


    def search(self, searchWord: str) -> bool:
        size = len(searchWord)
        for i in range(size):
            for j in range(26):
                new_ch = chr(ord('a') + j)
                if searchWord[i] != new_ch:
                    new_word = searchWord[:i] + new_ch + searchWord[i + 1:]
                    if self.trie_tree.search(new_word):
                        return True
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：初始化操作是 $O(1)$。构建操作是 $O(|dictionary|)$，搜索操作是 $O(|searchWord| \times |\sum|)$。其中 $|dictionary|$ 是字符串数组 `dictionary` 中的字符个数，$|searchWord|$ 是查询操作中字符串的长度，$|\sum|$ 是字符集的大小。
- **空间复杂度**：$O(|dicitonary|)$。# [0677. 键值映射](https://leetcode.cn/problems/map-sum-pairs/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [0677. 键值映射 - 力扣](https://leetcode.cn/problems/map-sum-pairs/)

## 题目大意

**要求**：实现一个 MapSum 类，支持两个方法，`insert` 和 `sum`：

- `MapSum()` 初始化 MapSum 对象。
- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key`，整数表示值 `val`。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。
- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。

**说明**：

- $1 \le key.length, prefix.length \le 50$。
- `key` 和 `prefix` 仅由小写英文字母组成。
- $1 \le val \le 1000$。
- 最多调用 $50$ 次 `insert` 和 `sum`。

**示例**：

- 示例 1：

```python
输入：
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // 返回 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // 返回 5 (apple + app = 3 + 2 = 5)
```

## 解题思路

### 思路 1：字典树

可以构造前缀树（字典树）解题。

- 初始化时，构建一棵前缀树（字典树），并增加 `val` 变量。

- 调用插入方法时，用字典树存储 `key`，并在对应字母节点存储对应的 `val`。
- 在调用查询总和方法时，先查找该前缀 `prefix` 对应的前缀树节点，从该节点开始，递归遍历该节点的子节点，并累积子节点的 `val`，进行求和，并返回求和累加结果。

### 思路 1：代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.value = 0


    def insert(self, word: str, value: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.value = value


    def search(self, word: str) -> int:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return 0
            cur = cur.children[ch]
        return self.dfs(cur)

    def dfs(self, root) -> int:
        if not root:
            return 0
        res = root.value
        for node in root.children.values():
            res += self.dfs(node)
        return res



class MapSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie_tree = Trie()


    def insert(self, key: str, val: int) -> None:
        self.trie_tree.insert(key, val)


    def sum(self, prefix: str) -> int:
        return self.trie_tree.search(prefix)
```

### 思路 1：复杂度分析

- **时间复杂度**：`insert` 操作的时间复杂度为 $O(|key|)$。其中 $|key|$ 是每次插入字符串 `key` 的长度。`sum` 操作的时间复杂度是 $O(|prefix|)$，其中 $O(| prefix |)$ 是查询字符串 `prefix` 的长度。
- **空间复杂度**：$O(|T| \times m)$。其中 $|T|$ 表示字符串 `key` 的最大长度，$m$ 表示 `key - val` 的键值数目。# [0678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/)

- 标签：栈、贪心、字符串、动态规划
- 难度：中等

## 题目链接

- [0678. 有效的括号字符串 - 力扣](https://leetcode.cn/problems/valid-parenthesis-string/)

## 题目大意

**描述**：给定一个只包含三种字符的字符串：`（` ，`)` 和 `*`。有效的括号字符串具有如下规则：

1. 任何左括号 `(` 必须有相应的右括号 `)`。
2. 任何右括号 `)` 必须有相应的左括号 `(`。
3. 左括号 `(` 必须在对应的右括号之前 `)`。
4. `*` 可以被视为单个右括号 `)`，或单个左括号 `(`，或一个空字符串。
5. 一个空字符串也被视为有效字符串。

**要求**：验证这个字符串是否为有效字符串。如果是，则返回 `True`；否则，则返回 `False`。

**说明**：

- 字符串大小将在 `[1, 100]` 范围内。

**示例**：

- 示例 1：

```python
输入："(*)"
输出：True
```

## 解题思路

### 思路 1：动态规划（时间复杂度为 $O(n^3)$）

###### 1. 划分阶段

按照子串的起始位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：从下标 `i` 到下标 `j` 的子串是否为有效的括号字符串，其中 （$0 \le i < j < size$，$size$ 为字符串长度）。如果是则 `dp[i][j] = True`，否则，`dp[i][j] = False`。

###### 3. 状态转移方程

长度大于 `2` 时，我们需要根据 `s[i]` 和 `s[j]` 的情况，以及子串中间的有效字符串情况来判断 `dp[i][j]`。

- 如果 `s[i]`、`s[j]` 分别表示左括号和右括号，或者为 `'*'`（此时 `s[i]`、`s[j]` 可以分别看做是左括号、右括号）。则如果 `dp[i + 1][j - 1] == True` 时，`dp[i][j] = True`。
- 如果可以将从下标 `i` 到下标 `j` 的子串从中间分开为两个有效字符串，则 `dp[i][j] = True`。即如果存在 $i \le k < j$，使得 `dp[i][k] == True` 并且 `dp[k + 1][j] == True`，则 `dp[i][j] = True`。

###### 4. 初始条件

- 当子串的长度为 `1`，并且该字符串为 `'*'` 时，子串可看做是空字符串，此时子串是有效的括号字符串。
- 当子串的长度为 `2` 时，如果两个字符可以分别看做是左括号和右括号，子串可以看做是 `"()"`，此时子串是有效的括号字符串。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：从下标 `i` 到下标 `j` 的子串是否为有效的括号字符串。则最终结果为 `dp[0][size - 1]`。

### 思路 1：动态规划（时间复杂度为 $O(n^3)$）代码

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        size = len(s)
        dp = [[False for _ in range(size)] for _ in range(size)]

        for i in range(size):
            if s[i] == '*':
                dp[i][i] = True

        for i in range(1, size):
            if (s[i - 1] == '(' or s[i - 1] == '*') and (s[i] == ')' or s[i] == '*'):
                dp[i - 1][i] = True

        for i in range(size - 3, -1, -1):
            for j in range(i + 2, size):
                if (s[i] == '(' or s[i] == '*') and (s[j] == ')' or s[j] == '*'):
                    dp[i][j] = dp[i + 1][j - 1]
                for k in range(i, j):
                    if dp[i][j]:
                        break
                    dp[i][j] = dp[i][k] and dp[k + 1][j]

        return dp[0][size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$。三重循环遍历的时间复杂度是 $O(n^3)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。

### 思路 2：动态规划（时间复杂度为 $O(n^2)$）

###### 1. 划分阶段

按照字符串的结束位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：前 `i` 个字符能否通过补齐 `j` 个右括号成为有效的括号字符串。

###### 3. 状态转移方程

1. 如果 `s[i] == '('`，则如果前 `i - 1` 个字符通过补齐 `j - 1` 个右括号成为有效的括号字符串，则前 `i` 个字符就能通过补齐 `j` 个右括号成为有效的括号字符串（比前 `i - 1` 个字符需要多补一个右括号）。也就是说，如果 `s[i] == '('` 并且 `dp[i - 1][j - 1] == True`，则 `dp[i][j] = True`。
2. 如果 `s[i] == ')'`，则如果前 `i - 1` 个字符通过补齐 `j + 1` 个右括号成为有效的括号字符串，则前 `i` 个字符就能通过补齐 `j` 个右括号成为有效的括号字符串（比前 `i - 1` 个字符需要少补一个右括号）。也就是说，如果 `s[i] == ')'` 并且 `dp[i - 1][j + 1] == True`，则 `dp[i][j] = True`。
3. 如果 `s[i] == '*'`，而 `'*'` 可以表示空字符串、左括号或者右括号，则 `dp[i][j]` 取决于这三种情况，只要有一种情况为 `True`，则 `dp[i][j] = True`。也就是说，如果 `s[i] == '*'`，则 `dp[i][j] = dp[i - 1][j] or dp[i - 1][j - 1]`。

###### 4. 初始条件

- `0` 个字符可以通过补齐 `0` 个右括号成为有效的括号字符串（空字符串），即 `dp[0][0] = 0`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：前 `i` 个字符能否通过补齐 `j` 个右括号成为有效的括号字符串。。则最终结果为 `dp[size][0]`。

### 思路 2：动态规划（时间复杂度为 $O(n^2)$）代码

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        size = len(s)
        dp = [[False for _ in range(size + 1)] for _ in range(size + 1)]
        dp[0][0] = True
        for i in range(1, size + 1):
            for j in range(i + 1):
                if s[i - 1] == '(':
                    if j > 0:
                        dp[i][j] = dp[i - 1][j - 1]
                elif s[i - 1] == ')':
                    if j < i:
                        dp[i][j] = dp[i - 1][j + 1]
                else:
                    dp[i][j] = dp[i - 1][j]
                    if j > 0:
                        dp[i][j] = dp[i][j] or dp[i - 1][j - 1]
                    if j < i:
                        dp[i][j] = dp[i][j] or dp[i - 1][j + 1]

        return dp[size][0]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。# [0680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/)

- 标签：贪心、双指针、字符串
- 难度：简单

## 题目链接

- [0680. 验证回文串 II - 力扣](https://leetcode.cn/problems/valid-palindrome-ii/)

## 题目大意

给定一个非空字符串 `s`。

要求：判断如果最多从字符串中删除一个字符能否得到一个回文字符串。

## 解题思路

题目要求在最多删除一个字符的情况下是否能得到一个回文字符串。最直接的思路是遍历各个字符，判断将该字符删除之后，剩余字符串是否是回文串。但是这种思路的时间复杂度是 $O(n^2)$，解答的话会超时。

我们可以通过双指针 + 贪心算法来减少时间复杂度。具体做法如下：

- 使用两个指针变量 `left`、`right` 分别指向字符串的开始和结束位置。

- 判断 `s[left]` 是否等于 `s[right]`。
  - 如果等于，则 `left` 右移、`right`左移。
  - 如果不等于，则判断 `s[left: right - 1]` 或 `s[left + 1, right]` 是为回文串。
    - 如果是则返回 `True`。
    - 如果不是则返回 `False`，然后继续判断。
- 如果 `right >= left`，则说明字符串 `s` 本身就是回文串，返回 `True`。

## 代码

```python
class Solution:
    def checkPalindrome(self, s: str, left: int, right: int):
        i, j = left, right
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    def validPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] == s[right]:
                left += 1
                right -= 1
            else:
                return self.checkPalindrome(s, left + 1, right) or self.checkPalindrome(s, left, right - 1)
        return True
```

# [0683. K 个关闭的灯泡](https://leetcode.cn/problems/k-empty-slots/)

- 标签：树状数组、数组、有序集合、滑动窗口
- 难度：困难

## 题目链接

- [0683. K 个关闭的灯泡 - 力扣](https://leetcode.cn/problems/k-empty-slots/)

## 题目大意

**描述**：$n$ 个灯泡排成一行，编号从 $1$ 到 $n$。最初，所有灯泡都关闭。每天只打开一个灯泡，直到 $n$ 天后所有灯泡都打开。

给定一个长度为 $n$ 的灯泡数组 $blubs$，其中 `bulls[i] = x` 意味着在第 $i + 1$ 天，我们会把在位置 $x$ 的灯泡打开，其中 $i$ 从 $0$ 开始，$x$ 从 $1$ 开始。

再给定一个整数 $k$。

**要求**：输出在第几天恰好有两个打开的灯泡，使得它们中间正好有 $k$ 个灯泡且这些灯泡全部是关闭的 。如果不存在这种情况，则返回 $-1$。如果有多天都出现这种情况，请返回最小的天数 。

**说明**：

- $n == bulbs.length$。
- $1 \le n \le 2 \times 10^4$。
- $1 \le bulbs[i] \le n$。
- $bulbs$ 是一个由从 $1$ 到 $n$ 的数字构成的排列。
- $0 \le k \le 2 \times 10^4$。

**示例**：

- 示例 1：

```python
输入：
bulbs = [1,3,2]，k = 1
输出：2
解释：
第一天 bulbs[0] = 1，打开第一个灯泡 [1,0,0]
第二天 bulbs[1] = 3，打开第三个灯泡 [1,0,1]
第三天 bulbs[2] = 2，打开第二个灯泡 [1,1,1]
返回2，因为在第二天，两个打开的灯泡之间恰好有一个关闭的灯泡。
```

- 示例 2：

```python
输入：bulbs = [1,2,3]，k = 1
输出：-1
```

## 解题思路

### 思路 1：滑动窗口

$blubs[i]$ 记录的是第 $i + 1$ 天开灯的位置。我们将其转换一下，使用另一个数组 $days$ 来存储每个灯泡的开灯时间，其中 $days[i]$ 表示第 $i$ 个位置上的灯泡的开灯时间。

- 使用 $ans$ 记录最小满足条件的天数。维护一个窗口 $left$、$right$。其中 `right = left + k + 1`。使得区间 $(left, right)$ 中所有灯泡（总共为 $k$ 个）开灯时间都晚于 $days[left]$ 和 $days[right]$。
- 对于区间 $[left, right]$，$left < i < right$：
  - 如果出现 $days[i] < days[left]$ 或者 $days[i] < days[right]$，说明不符合要求。将 $left$、$right$ 移动到 $[i, i + k + 1]$，继续进行判断。
  - 如果对于 $left < i < right$ 中所有的 $i$，都满足 $days[i] \ge days[left]$ 并且 $days[i] \ge days[right]$，说明此时满足要求。将当前答案与 $days[left]$ 和 $days[right]$ 中的较大值作比较。如果比当前答案更小，则更新答案。同时将窗口向右移动 $k $位。继续检测新的不相交间隔 $[right, right + k + 1]$。
    - 注意：之所以检测新的不相交间隔，是因为如果检测的是相交间隔，原来的 $right$ 位置元素仍在区间中，肯定会出现 $days[right] < days[right_new]$，不满足要求。所以此时相交的区间可以直接跳过，直接检测不相交的间隔。
- 直到 $right \ge len(days)$ 时跳出循环，判断是否有符合要求的答案，并返回答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def kEmptySlots(self, bulbs: List[int], k: int) -> int:
        size = len(bulbs)
        days = [0 for _ in range(size)]
        for i in range(size):
            days[bulbs[i] - 1] = i + 1

        left, right = 0, k + 1
        ans = float('inf')
        while right < size:
            check_flag = True
            for i in range(left + 1, right):
                if days[i] < days[left] or days[i] < days[right]:
                    left, right = i, i + k + 1
                    check_flag = False
                    break
            if check_flag:
                ans = min(ans, max(days[left], days[right]))
                left, right = right, right + k + 1

        if ans != float('inf'):
            return ans
        else:
            return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $bulbs$ 的长度。
- **空间复杂度**：$O(n)$。

# [0684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0684. 冗余连接 - 力扣](https://leetcode.cn/problems/redundant-connection/)

## 题目大意

**描述**：一个 `n` 个节点的树（节点值为 `1~n`）添加一条边后就形成了图，添加的这条边不属于树中已经存在的边。图的信息记录存储与长度为 `n` 的二维数组 `edges`，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

现在给定代表边信息的二维数组 `edges`。

**要求**：找到一条可以山区的边，使得删除后的剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。

**说明**：

- $n == edges.length$。
- $3 \le n \le 1000$。
- $edges[i].length == 2$。
- $1 \le ai < bi \le edges.length$。
- $ai ≠ bi$。
- $edges$ 中无重复元素。
- 给定的图是连通的。

**示例**：

- 示例 1：

![img](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)

```python
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
```

- 示例 2：

![img](https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png)

```python
输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
```

## 解题思路

### 思路 1：并查集

树可以看做是无环的图，这道题就是要找出那条添加边之后成环的边。可以考虑用并查集来做。

1. 从前向后遍历每一条边。
2. 如果边的两个节点不在同一个集合，就加入到一个集合（链接到同一个根节点）。
3. 如果边的节点已经出现在同一个集合里，说明边的两个节点已经连在一起了，再加入这条边一定会出现环，则这条边就是所求答案。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        self.parent[root_x] = root_y

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        size = len(edges)
        union_find = UnionFind(size + 1)

        for edge in edges:
            if union_find.is_connected(edge[0], edge[1]):
                return edge
            union_find.union(edge[0], edge[1])

        return None
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \alpha(n))$。其中 $n$ 是图中的节点个数，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n)$。# [0686. 重复叠加字符串匹配](https://leetcode.cn/problems/repeated-string-match/)

- 标签：字符串、字符串匹配
- 难度：中等

## 题目链接

- [0686. 重复叠加字符串匹配 - 力扣](https://leetcode.cn/problems/repeated-string-match/)

## 题目大意

**描述**：给定两个字符串 `a` 和 `b`。

**要求**：寻找重复叠加字符串 `a` 的最小次数，使得字符串 `b` 成为叠加后的字符串 `a` 的子串，如果不存在则返回 `-1`。

**说明**：

- 字符串 `"abc"` 重复叠加 `0` 次是 `""`，重复叠加 `1` 次是 `"abc"`，重复叠加 `2` 次是 `"abcabc"`。
- $1 \le a.length \le 10^4$。
- $1 \le b.length \le 10^4$。
- `a` 和 `b` 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。
```

- 示例 2：

```python
输入：a = "a", b = "aa"
输出：2
```

## 解题思路

### 思路 1：KMP 算法

假设字符串 `a` 的长度为 `n`，`b` 的长度为 `m`。

把 `b` 看做是模式串，把字符串 `a` 叠加后的字符串看做是文本串，这道题就变成了单模式串匹配问题。

我们可以模拟叠加字符串 `a` 后进行单模式串匹配问题。模拟叠加字符串可以通过在遍历字符串匹配时对字符串 `a` 的长度 `n` 取余来实现。

那么问题关键点就变为了如何高效的进行单模式串匹配，以及字符串循环匹配的退出条件是什么。

**单模式串匹配问题**：可以用 KMP 算法来做。

**循环匹配退出条件问题**：假设我们用 `i` 遍历 `a` 叠加后字符串，用 `j` 遍历字符串 `b`。如果字符串 `b` 是 `a` 叠加后字符串的子串，那么 `b` 有两种可能：

1. `b` 直接是原字符串 `a` 的子串：这种情况下，最多遍历到 `len(a)`。
2. `b` 是 `a` 叠加后的字符串的子串：
   1. 最多遍历到 `len(a) + len(b)`，可以写为 `while i < len(a) + len(b):`，当 `i == len(a) + len(b)` 时跳出循环。
   2. 也可以写为 `while i - j < len(a):`，这种写法中 `i - j ` 表示的是字符匹配开始的位置，如果匹配到 `len(a)` 时（即 `i - j == len(a)` 时）最开始位置的字符仍没有匹配，那么 `b` 也不可能是 `a` 叠加后的字符串的子串了，此时跳出循环。

最后我们需要计算一下重复叠加字符串 `a` 的最小次数。假设 `index` 使我们求出的匹配位置。

1. 如果 `index == -1`，则说明 `b` 不可能是 `a` 叠加后的字符串的子串，返回 `False`。
2. 如果 `len(a) - index >= len(b)`，则说明匹配位置未超过字符串 `a` 的长度，叠加 `1` 次（字符串 `a` 本身）就可以匹配。
3. 如果 `len(a) - index < len(b)`，则说明需要叠加才能匹配。此时最小叠加次数为 $\lfloor \frac{index + len(b) - 1}{len(a)} \rfloor + 1$。其中 `index`  代笔匹配开始前的字符串长度，加上 `len(b)` 后就是匹配到字符串 `b` 结束时最少需要的字符数，再 `-1` 是为了向下取整。 除以 `len(a)` 表示至少需要几个 `a`， 因为是向下取整，所以最后要加上 `1`。写成代码就是：`(index + len(b) - 1) // len(a) + 1`。

### 思路 1：代码

```python
class Solution:
    # KMP 匹配算法，T 为文本串，p 为模式串
    def kmp(self, T: str, p: str) -> int:
        n, m = len(T), len(p)

        next = self.generateNext(p)

        i, j = 0, 0
        while i - j < n:
            while j > 0 and T[i % n] != p[j]:
                j = next[j - 1]
            if T[i % n] == p[j]:
                j += 1
            if j == m:
                return i - m + 1
            i += 1
        return -1

    def generateNext(self, p: str):
        m = len(p)
        next = [0 for _ in range(m)]

        left = 0
        for right in range(1, m):
            while left > 0 and p[left] != p[right]:
                left = next[left - 1]
            if p[left] == p[right]:
                left += 1
            next[right] = left

        return next

    def repeatedStringMatch(self, a: str, b: str) -> int:
        len_a = len(a)
        len_b = len(b)
        index = self.kmp(a, b)
        if index == -1:
            return -1
        if len_a - index >= len_b:
            return 1
        return (index + len(b) - 1) // len(a) + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中文本串 $a$ 的长度为 $n$，模式串 $b$ 的长度为 $m$。
- **空间复杂度**：$O(m)$。

# [0687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0687. 最长同值路径 - 力扣](https://leetcode.cn/problems/longest-univalue-path/)

## 题目大意

**描述**：给定一个二叉树的根节点 $root$。

**要求**：返回二叉树中最长的路径的长度，该路径中每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**说明**：

- 树的节点数的范围是 $[0, 10^4]$。
- $-1000 \le Node.val \le 1000$。
- 树的深度将不超过 $1000$。
- 两个节点之间的路径长度：由它们之间的边数表示。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)

```python
输入：root = [5,4,5,1,1,5]
输出：2
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg)

```python
输入：root = [1,4,5,4,4,5]
输出：2
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

这道题如果先不考虑「路径中每个节点具有相同值」这个条件，那么这道题就是在求「二叉树的直径长度（最长路径的长度）」。

「二叉树的直径长度」的定义为：二叉树中任意两个节点路径长度中的最大值。并且这条路径可能穿过也可能不穿过根节点。

对于根为 $root$ 的二叉树来说，其直径长度并不简单等于「左子树高度」加上「右子树高度」。

根据路径是否穿过根节点，我们可以将二叉树分为两种：

1. 直径长度所对应的路径穿过根节点，这种情况下：$\text{二叉树的直径} = \text{左子树高度} + \text{右子树高度}$。
2. 直径长度所对应的路径不穿过根节点，这种情况下：$\text{二叉树的直径} = \text{所有子树中最大直径长度}$。

也就是说根为 $root$ 的二叉树的直径长度可能来自于  $\text{左子树高度} + \text{右子树高度}$，也可能来自于 $\text{子树中的最大直径}$，即 $\text{二叉树的直径} = max(\text{左子树高度} + \text{右子树高度}, \quad \text{所有子树中最大直径长度})$。

那么现在问题就变成为如何求「子树的高度」和「子树中的最大直径」。

1. 子树的高度：我们可以利用深度优先搜索方法，递归遍历左右子树，并分别返回左右子树的高度。
2. 子树中的最大直径：我们可以在递归求解子树高度的时候维护一个 $ans$ 变量，用于记录所有 $\text{左子树高度} + \text{右子树高度}$ 中的最大值。

最终 $ans$ 就是我们所求的该二叉树的最大直径。

接下来我们再来加上「路径中每个节点具有相同值」这个限制条件。

1. 「左子树高度」应变为「左子树最长同值路径长度」。
2. 「右子树高度」应变为「右子树最长同值路径长度」。
3. 题目变为求「二叉树的最长同值路径长度」，式子为：$\text{二叉树的最长同值路径长度} = max(\text{左子树最长同值路径长度} + \text{右子树最长同值路径长度}, \quad \text{所有子树中最长同值路径长度})$。

在递归遍历的时候，我们还需要当前节点与左右子节点的值的相同情况，来维护更新「包含当前节点的最长同值路径长度」。

1. 在递归遍历左子树时，如果当前节点与左子树的值相同，则：$\text{包含当前节点向左的最长同值路径长度} = \text{左子树最长同值路径长度} + 1$，否则为 $0$。
2. 在递归遍历左子树时，如果当前节点与左子树的值相同，则：$\text{包含当前节点向右的最长同值路径长度} = \text{右子树最长同值路径长度} + 1$，否则为 $0$。

则：$\text{包含当前节点向左的最长同值路径长度} = max(\text{包含当前节点向左的最长同值路径长度}, \quad \text{包含当前节点向右的最长同值路径长度})$。

### 思路 1：代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.ans = 0

    def dfs(self, node):
        if not node:
            return 0

        left_len = self.dfs(node.left)          # 左子树高度
        right_len = self.dfs(node.right)        # 右子树高度
        if node.left and node.left.val == node.val:
            left_len += 1
        else:
            left_len = 0
        if node.right and node.right.val == node.val:
            right_len += 1
        else:
            right_len = 0
        self.ans = max(self.ans, left_len + right_len)
        return max(left_len, right_len)

    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
        self.dfs(root)

        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉树的节点个数。
- **空间复杂度**：$O(n)$。
# [0688. 骑士在棋盘上的概率](https://leetcode.cn/problems/knight-probability-in-chessboard/)

- 标签：动态规划
- 难度：中等

## 题目链接

- [0688. 骑士在棋盘上的概率 - 力扣](https://leetcode.cn/problems/knight-probability-in-chessboard/)

## 题目大意

**描述**：在一个 `n * n` 的国际象棋棋盘上，一个骑士从单元格 `(row, column)` 开始，尝试进行 `k` 次 移动。行和列是从 `0` 开始的，左上角的单元格是 `(0, 0)`，右下角的单元格是 `(n - 1, n - 1)`。

象棋骑士有 `8` 种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从 `8` 种可能的移动中选择一种（即使棋子会离开棋盘），然后移动到那里。骑士继续移动，直到它走了 `k` 步或离开了棋盘。

现在给定代表棋盘大小的整数 `n`、代表骑士移动次数的整数 `k`，以及代表骑士初始位置的坐标 `row` 和 `column`。

**要求**：返回骑士在棋盘停止移动后仍留在棋盘上的概率。

**说明**：

- $1 \le n \le 25$。
- $0 \le k \le 100$。
- $0 \le row, column \le n$。

**示例**：

- 示例 1：

```python
输入：n = 3, k = 2, row = 0, column = 0
输出：0.0625
解释：有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。在每一个位置上，也有两种移动可以让骑士留在棋盘上。骑士留在棋盘上的总概率是 0.0625。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照骑士所在位置和所走步数进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j][p]` 表示为：从位置 `(i, j)` 出发，移动不超过 `p` 步的情况下，最后仍留在棋盘内的概率。

###### 3. 状态转移方程

根据象棋骑士的 `8` 种可能的走法，`dp[i][j][p]` 的来源有八个方向（超出棋盘的无需再考虑）：

- 假设下一步的落点为 `(new_i, new_j)`。从当前步选择 `8` 个方向其中之一作为下一步方向的概率为 $\frac{1}{8}$。
- 而每个方向上落点仍在棋盘内的概率为 `dp[new_i][new_j][p - 1]`。所以从 `(i, j)` 走到 `(new_i, new_j)` 的可能性为 $dp[new_i][new_j] \times \frac{1}{8}$。

最终 $dp[i][j][p]$ 来源为 `8` 个方向上落点的概率之和，即：$dp[i][j][p] = \sum{ dp[new_i][new_j] \times \frac{1}{8} }$。

###### 4. 初始条件

- 从位置 `(i, j)` 出发，移动不超过 `0` 步的情况下，最后仍留在棋盘内的概率为 `1`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j][p]` 表示为：从位置 `(i, j)` 出发，移动不超过 `p` 步的情况下，最后仍留在棋盘内的概率。则最终结果为 `dp[row][column][k]`。

### 思路 1：动态规划代码

```python
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dp = [[[0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                dp[i][j][0] = 1

        directions = {(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, -1), (-2, 1), (2, -1), (2, 1)}

        for p in range(1, k + 1):
            for i in range(n):
                for j in range(n):
                    for direction in directions:
                        new_i = i + direction[0]
                        new_j = j + direction[1]
                        if 0 <= new_i < n and 0 <= new_j < n:
                            dp[i][j][p] += dp[new_i][new_j][p - 1] / 8
        
        return dp[row][column][k]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 * k)$。外三层循环的时间复杂度为 $O(n^2 * k)$，内层关于 `directions` 的循环每次执行 `8` 次，可以看做是常数级时间复杂度。
- **空间复杂度**：$O(n^2 * k)$。用到了三维数组保存状态。
# [0690. 员工的重要性](https://leetcode.cn/problems/employee-importance/)

- 标签：深度优先搜索、广度优先搜索、哈希表
- 难度：中等

## 题目链接

- [0690. 员工的重要性 - 力扣](https://leetcode.cn/problems/employee-importance/)

## 题目大意

给定一个公司的所有员工信息。其中每个员工信息包含：该员工 id，该员工重要度，以及该员工的所有下属 id。

再给定一个员工 id，要求返回该员工和他所有下属的重要度之和。

## 解题思路

利用哈希表，以「员工 id: 员工数据结构」的形式将员工信息存入哈希表中。然后深度优先搜索该员工以及下属员工。在搜索的同时，计算重要度之和，最终返回结果即可。

## 代码

```python
class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        employee_dict = dict()
        for employee in employees:
            employee_dict[employee.id] = employee

        def dfs(index: int) -> int:
            total = employee_dict[index].importance
            for sub_index in employee_dict[index].subordinates:
                total += dfs(sub_index)
            return total

        return dfs(id)
```

# [0691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)

- 标签：位运算、数组、字符串、动态规划、回溯、状态压缩
- 难度：困难

## 题目链接

- [0691. 贴纸拼词 - 力扣](https://leetcode.cn/problems/stickers-to-spell-word/)

## 题目大意

**描述**：给定一个字符串数组 $stickers$ 表示不同的贴纸，其中 $stickers[i]$ 表示第 $i$ 张贴纸上的小写英文单词。再给定一个字符串 $target$。为了拼出给定字符串 $target$，我们需要从贴纸中切割单个字母并重新排列它们。贴纸的数量是无限的，可以重复多次使用。

**要求**：返回需要拼出 $target$ 的最小贴纸数量。如果任务不可能，则返回 $-1$。

**说明**：

- 在所有的测试用例中，所有的单词都是从 $1000$ 个最常见的美国英语单词中随机选择的，并且 $target$ 被选择为两个随机单词的连接。
- $n == stickers.length$。
- $1 \le n \le 50$。
- $1 \le stickers[i].length \le 10$。
- $1 \le target.length \le 15$。
- $stickers[i]$ 和 $target$ 由小写英文单词组成。

**示例**：

- 示例 1：

```python
输入：stickers = ["with","example","science"], target = "thehat"
输出：3
解释：
我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
```

- 示例 2：

```python
输入：stickers = ["notice","possible"], target = "basicbasic"
输出：-1
解释：我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。
```

## 解题思路

### 思路 1：状态压缩 DP + 广度优先搜索

根据题意，$target$ 的长度最大为 $15$，所以我们可以使用一个长度最多为 $15$ 位的二进制数 $state$ 来表示 $target$ 的某个子序列，如果 $state$ 第 $i$ 位二进制值为 $1$，则说明 $target$ 的第 $i$ 个字母被选中。

然后我们从初始状态 $state = 0$（没有选中 $target$ 中的任何字母）开始进行广度优先搜索遍历。

在广度优先搜索过程中，对于当前状态 $cur\underline{\hspace{0.5em}}state$，我们遍历所有贴纸的所有字母，如果当前字母可以拼到 $target$ 中的某个位置上，则更新状态 $next\underline{\hspace{0.5em}}state$ 为「选中 $target$ 中对应位置上的字母」。

为了得到最小最小贴纸数量，我们可以使用动态规划的方法，定义 $dp[state]$ 表示为到达 $state$ 状态需要的最小贴纸数量。

那么在广度优先搜索中，在更新状态时，同时进行状态转移，即 $dp[next\underline{\hspace{0.5em}}state] = dp[cur\underline{\hspace{0.5em}}state] + 1$。

> 注意：在进行状态转移时，要跳过 $dp[next\underline{\hspace{0.5em}}state]$ 已经有值的情况。

这样在到达状态 $1 \text{ <}\text{< } len(target) - 1$ 时，所得到的 $dp[1 \text{ <}\text{< } len(target) - 1]$ 即为答案。

如果最终到达不了 $dp[1 \text{ <}\text{< } len(target) - 1]$，则说明无法完成任务，返回 $-1$。

### 思路 1：代码

```python
class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:
        size = len(target)
        states = 1 << size
        dp = [0 for _ in range(states)]

        queue = collections.deque([0])

        while queue:
            cur_state = queue.popleft()
            for sticker in stickers:
                next_state = cur_state
                cnts = [0 for _ in range(26)]
                for ch in sticker:
                    cnts[ord(ch) - ord('a')] += 1
                for i in range(size):
                    if cnts[ord(target[i]) - ord('a')] and next_state & (1 << i) == 0:
                        next_state |= (1 << i)
                        cnts[ord(target[i]) - ord('a')] -= 1
                
                if dp[next_state] or next_state == 0:
                    continue
                
                queue.append(next_state)
                dp[next_state] = dp[cur_state] + 1
                if next_state == states - 1:
                    return dp[next_state]
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n \times \sum_{i = 0}^{m - 1} len(stickers[i]) \times n$，其中 $n$ 为 $target$ 的长度，$m$ 为 $stickers$ 的元素个数。
- **空间复杂度**：$O(2^n)$。

# [0695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [0695. 岛屿的最大面积 - 力扣](https://leetcode.cn/problems/max-area-of-island/)

## 题目大意

**描述**：给定一个只包含 $0$、$1$ 元素的二维数组，$1$ 代表岛屿，$0$ 代表水。一座岛的面积就是上下左右相邻的 $1$ 所组成的连通块的数目。

**要求**：计算出最大的岛屿面积。

**说明**：

- $m == grid.length$。
- $n == grid[i].length$。
- $1 \le m, n \le 50$。
- $grid[i][j]$ 为 $0$ 或 $1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

```python
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

- 示例 2：

```python
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

## 解题思路

### 思路 1：深度优先搜索

1. 遍历二维数组的每一个元素，对于每个值为 $1$ 的元素：
   1. 将该位置上的值置为 $0$（防止二次重复计算）。
   2. 递归搜索该位置上下左右四个位置，并统计搜到值为 $1$ 的元素个数。
   3. 返回值为 $1$ 的元素个数（即为该岛的面积）。
2. 维护并更新最大的岛面积。
3. 返回最大的到面积。

### 思路 1：代码

```python
class Solution:
    def dfs(self, grid, i, j):
        n = len(grid)
        m = len(grid[0])
        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0:
            return 0
        ans = 1
        grid[i][j] = 0
        ans += self.dfs(grid, i + 1, j)
        ans += self.dfs(grid, i, j + 1)
        ans += self.dfs(grid, i - 1, j)
        ans += self.dfs(grid, i, j - 1)
        return ans

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    ans = max(ans, self.dfs(grid, i, j))
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(n \times m)$。

### 思路 2：广度优先搜索

1. 使用 $ans$ 记录最大岛屿面积。
2. 遍历二维数组的每一个元素，对于每个值为 $1$ 的元素：
   1. 将该元素置为 $0$。并使用队列  $queue$ 存储该节点位置。使用 $temp\underline{\hspace{0.5em}}ans$ 记录当前岛屿面积。
   2. 然后从队列 $queue$ 中取出第一个节点位置 $(i, j)$。遍历该节点位置上、下、左、右四个方向上的相邻节点。并将其置为 $0$（避免重复搜索）。并将其加入到队列中。并累加当前岛屿面积，即 `temp_ans += 1`。
   3. 不断重复上一步骤，直到队列 $queue$ 为空。
   4. 更新当前最大岛屿面积，即 `ans = max(ans, temp_ans)`。
3. 将 $ans$ 作为答案返回。

### 思路 2：代码

```python
import collections

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        rows, cols = len(grid), len(grid[0])
        ans = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    temp_ans = 1
                    q = collections.deque([(i, j)])
                    while q:
                        i, j = q.popleft()
                        for direct in directs:
                            new_i = i + direct[0]
                            new_j = j + direct[1]
                            if new_i < 0 or new_i >= rows or new_j < 0 or new_j >= cols or grid[new_i][new_j] == 0:
                                continue
                            grid[new_i][new_j] = 0
                            q.append((new_i, new_j))
                            temp_ans += 1

                    ans = max(ans, temp_ans)
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(n \times m)$。
# [0698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

- 标签：位运算、记忆化搜索、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目链接

- [0698. 划分为k个相等的子集 - 力扣](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个正整数 $k$。

**要求**：找出是否有可能把这个数组分成 $k$ 个非空子集，其总和都相等。

**说明**：

- $1 \le k \le len(nums) \le 16$。
- $0 < nums[i] < 10000$。
- 每个元素的频率在 $[1, 4]$ 范围内。

**示例**：

- 示例 1：

```python
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```

- 示例 2：

```python
输入: nums = [1,2,3,4], k = 3
输出: False
```

## 解题思路

### 思路 1：状态压缩 DP

根据题目要求，我们可以将几种明显不符合要求的情况过滤掉，比如：元素个数小于 $k$、元素总和不是 $k$ 的倍数、数组 $nums$ 中最大元素超过 $k$ 等分的目标和这几种情况。

然后再来考虑一般情况下，如何判断是否符合要求。

因为题目给定数组 $nums$ 的长度最多为 $16$，所以我们可以使用一个长度为 $16$ 位的二进制数来表示数组子集的选择状态。我们可以定义 $dp[state]$ 表示为当前选择状态下，是否可行。如果 $dp[state] == True$，表示可行；如果 $dp[state] == False$，则表示不可行。

接下来使用动态规划方法，进行求解。具体步骤如下：

###### 1. 划分阶段

按照数组元素选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[state]$ 表示为：当数组元素选择情况为 $state$ 时，是否存在一种方案，使得方案中的数字必定能分割成 $p(0 \le p \le k)$ 组恰好数字和等于目标和 $target$ 的集合和至多 $1$ 组数字和小于目标和 $target$ 的集合。

###### 3. 状态转移方程

对于当前状态 $state$，如果：

1. 当数组元素选择情况为 $state$ 时可行，即 $dp[state] == True$；
2. 第 $i$ 位数字没有被使用；
3. 加上第 $i$ 位元素后的状态为 $next\underline{\hspace{0.5em}}state$；
4. 加上第 $i$ 位元素后没有超出目标和。

则：$dp[next\underline{\hspace{0.5em}}state] = True$。

###### 4. 初始条件

- 当不选择任何元素时，可按照题目要求

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当数组元素选择情况为 $state$ 时，是否存在一种方案，使得方案中的数字必定能分割成 $p(0 \le p \le k)$ 组恰好数字和等于目标和 $target$ 的集合和至多 $1$ 组数字和小于目标和 $target$ 的集合。

所以当 $state == 1 << n - 1$ 时，状态就变为了：当数组元素都选上的情况下，是否存在一种方案，使得方案中的数字必定能分割成 $k$ 组恰好数字和等于目标和 $target$ 的集合。

这里之所以是 $k$ 组恰好数字和等于目标和 $target$ 的集合，是因为一开我们就限定了 $total \mod k == 0$ 这个条件，所以只能是 $k$ 组恰好数字和等于目标和 $target$ 的集合。

所以最终结果为 $dp[states - 1]$，其中 $states = 1 << n$。

### 思路 1：代码

```python
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        size = len(nums)
        if size < k:            # 元素个数小于 k
            return False

        total = sum(nums)
        if total % k != 0:      # 元素总和不是 k 的倍数
            return False

        target = total // k
        if nums[-1] > target:   # 最大元素超过 k 等分的目标和
            return False

        nums.sort()
        states = 1 << size      # 子集选择状态总数
        cur_sum = [0 for _ in range(states)]
        dp = [False for _ in range(states)]
        dp[0] = True

        for state in range(states):
            if not dp[state]:                   # 基于 dp[state] == True 前提下进行转移        
                continue
            for i in range(size):
                if state & (1 << i) != 0:       # 当前数字已被使用
                    continue
                
                if cur_sum[state] % target + nums[i] > target:
                    break                       # 如果加入当前数字超出目标和，则后续不用继续遍历

                next_state = state | (1 << i)   # 加入当前数字
                if dp[next_state]:              # 如果新状态能划分，则跳过继续
                    continue
                
                cur_sum[next_state] = cur_sum[state] + nums[i]  # 更新新状态下子集和
                dp[next_state] = True           # 更新新状态
                if dp[states - 1]:              # 找到一个符合要求的划分方案，提前返回
                    return True
                
        return dp[states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(2^n)$。

## 参考资料

- 【题解】[状态压缩的定义理解 - 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/zhuang-tai-ya-suo-de-ding-yi-li-jie-by-c-fo1b/)
# [0700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

- 标签：树、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [0700. 二叉搜索树中的搜索 - 力扣](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

## 题目大意

**描述**：给定一个二叉搜索树和一个值 `val`。

**要求**：在二叉搜索树中查找节点值等于 `val` 的节点，并返回该节点。

**说明**：

- 数中节点数在 $[1, 5000]$ 范围内。
- $1 \le Node.val \le 10^7$。
- `root` 是二叉搜索树。
- $1 \le val \le 10^7$。

**示例**：

- 示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)

```python
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)

```python
输入：root = [4,2,7,1,3], val = 5
输出：[]
```

## 解题思路

### 思路 1：递归

1. 从根节点 `root` 开始向下递归遍历。
   1. 如果 `val` 等于当前节点的值，即 `val == root.val`，则返回 `root`；
   2. 如果 `val` 小于当前节点的值 ，即 `val < root.val`，则递归遍历左子树，继续查找；
   3. 如果 `val` 大于当前节点的值 ，即 `val > root.val`，则递归遍历右子树，继续查找。
2. 如果遍历到最后也没有找到，则返回空节点。

### 思路 1：代码

```python
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root or val == root.val:
            return root
        if val < root.val:
            return self.searchBST(root.left, val)
        else:
            return self.searchBST(root.right, val)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉搜索树的节点数。
- **空间复杂度**：$O(n)$。# [0701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

- 标签：树、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [0701. 二叉搜索树中的插入操作 - 力扣](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

## 题目大意

**描述**：给定一个二叉搜索树的根节点和要插入树中的值 `val`。

**要求**：将 `val` 插入到二叉搜索树中，返回新的二叉搜索树的根节点。

**说明**：

- 树中的节点数将在 $[0, 10^4]$ 的范围内。
- $-10^8 \le Node.val \le 10^8$
- 所有值 `Node.val` 是独一无二的。
- $-10^8 \le val \le 10^8$。
- **保证** $val$ 在原始 BST 中不存在。

**示例**：

- 示例 1：

```python
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

- 示例 2：

```python
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
```

## 解题思路

### 思路 1：递归

已知搜索二叉树的性质：

- 左子树上任意节点值均小于根节点，即 `root.left.val < root.val`。
- 右子树上任意节点值均大于根节点，即 `root.left.val > root.val`。

那么根据 `val` 和当前节点的大小关系，则可以确定将 `val` 插入到当前节点的哪个子树上。具体步骤如下：

1. 从根节点 `root` 开始向下递归遍历。根据 `val` 值和当前子树节点 `cur` 的大小关系：
   1. 如果 `val < cur.val`，则应在当前节点的左子树继续遍历判断。
      1. 如果左子树为空，则新建节点，赋值为 `val`。链接到该子树的父节点上。并停止遍历。
      2. 如果左子树不为空，则继续向左子树移动。
   2. 如果 `val >= cur.val`，则应在当前节点的右子树继续遍历判断。
      1. 如果右子树为空，则新建节点，赋值为 `val`。链接到该子树的父节点上。并停止遍历。
      2. 如果右子树不为空，则继续向左子树移动。
2. 遍历完返回根节点 `root`。

### 思路 1：代码

```python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)

        cur = root
        while cur:
            if val < cur.val:
                if not cur.left:
                    cur.left = TreeNode(val)
                    break
                else:
                    cur = cur.left
            else:
                if not cur.right:
                    cur.right = TreeNode(val)
                    break
                else:
                    cur = cur.right
        return root
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉搜索树的节点数。
- **空间复杂度**：$O(n)$。# [0702. 搜索长度未知的有序数组](https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/)

- 标签：数组、二分查找、交互
- 难度：中等

## 题目链接

- [0702. 搜索长度未知的有序数组 - 力扣](https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/)

## 题目大意

**描述**：给定一个升序数组 $secret$，但是数组的大小是未知的。我们无法直接访问数组，智能通过 `ArrayReader` 接口去访问他。我们可以通过接口 `reader.get(k)`：

1. 如果数组访问未越界，则返回数组 $secret$ 中第 $k$ 个下标位置的元素值。
2. 如果数组访问越界，则接口返回 $2^{31} - 1$。

现在再给定一个数字 $target$。

**要求**：从 $secret$ 中找出 $secret[k] == target$ 的下标位置 $k$，如果 $secret$ 中不存在 $target$，则返回 $-1$。

**说明**：

- $1 \le secret.length \le 10^4$。
- $-10^4 \le secret[i], target \le 10^4$。
- $secret$ 严格递增。

**示例**：

- 示例 1：

```python
输入: secret = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 存在在 nums 中，下标为 4
```

- 示例 2：

```python
输入: secret = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不在数组中所以返回 -1
```

## 解题思路

### 思路 1：二分查找算法

这道题的关键点在于找到数组的大小，以便确定查找的右边界位置。右边界可以通过倍增的方式快速查找。在查找右边界的同时，也能将左边界的范围进一步缩小。等确定了左右边界，就可以使用二分查找算法快速查找 $target$。

### 思路 1：代码

```python
class Solution:
    def binarySearch(self, reader, left, right, target):
        while left < right:
            mid = left + (right - left) // 2
            if target > reader.get(mid):
                left = mid + 1
            else:
                right = mid
        if reader.get(left) == target:
            return left
        else:
            return -1

    def search(self, reader, target):
        left = 0
        right = 1
        while reader.get(right) < target:
            left = right
            right <<= 1

        return self.binarySearch(reader, left, right, target)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$，其中 $n$ 为数组长度。
- **空间复杂度**：$O(1)$。

# [0703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

- 标签：树、设计、二叉搜索树、二叉树、数据流、堆（优先队列）
- 难度：简单

## 题目链接

- [0703. 数据流中的第 K 大元素 - 力扣](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

## 题目大意

**要求**：设计一个 KthLargest 类，用于找到数据流中第 $k$ 大元素。

实现 KthLargest 类：

- `KthLargest(int k, int[] nums)`：使用整数 $k$ 和整数流 $nums$ 初始化对象。
- `int add(int val)`：将 $val$ 插入数据流 $nums$ 后，返回当前数据流中第 $k$ 大的元素。

**说明**：

- $1 \le k \le 10^4$。
- $0 \le nums.length \le 10^4$。
- $-10^4 \le nums[i] \le 10^4$。
- $-10^4 \le val \le 10^4$。
- 最多调用 `add` 方法 $10^4$ 次。
- 题目数据保证，在查找第 $k$ 大元素时，数组中至少有 $k$ 个元素。

**示例**：

- 示例 1：

```python
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```

## 解题思路

### 思路 1：堆

1. 建立大小为 $k$ 的大顶堆，堆中元素保证不超过 $k$ 个。
2. 每次 `add` 操作时，将新元素压入堆中，如果堆中元素超出了 $k$ 个，则将堆中最小元素（堆顶）移除。

- 此时堆中最小元素（堆顶）就是整个数据流中的第 $k$ 大元素。

### 思路 1：代码

```python
import heapq

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.min_heap = []
        self.k = k
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > k:
                heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

### 思路 1：复杂度分析

- **时间复杂度**：
  - 初始化时间复杂度：$O(n \times \log k)$，其中 $n$ 为 $nums$ 初始化时的元素个数。
  - 单次插入时间复杂度：$O(\log k)$。
- **空间复杂度**：$O(k)$。

# [0704. 二分查找](https://leetcode.cn/problems/binary-search/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [0704. 二分查找 - 力扣](https://leetcode.cn/problems/binary-search/)

## 题目大意

**描述**：给定一个升序的数组 $nums$，和一个目标值 $target$。

**要求**：返回 $target$ 在数组中的位置，如果找不到，则返回 -1。

**说明**：

- 你可以假设 $nums$ 中的所有元素是不重复的。
- $n$ 将在 $[1, 10000]$之间。
- $nums$ 的每个元素都将在 $[-9999, 9999]$之间。

**示例**：

- 示例 1：

```python
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

- 示例 2：

```python
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

## 解题思路

### 思路 1：二分查找

设定左右节点为数组两端，即 `left = 0`，`right = len(nums) - 1`，代表待查找区间为 $[left, right]$（左闭右闭）。

取两个节点中心位置 $mid$，先比较中心位置值 $nums[mid]$ 与目标值 $target$ 的大小。

- 如果 $target == nums[mid]$，则返回中心位置。
- 如果 $target > nums[mid]$，则将左节点设置为 $mid + 1$，然后继续在右区间 $[mid + 1, right]$ 搜索。
- 如果中心位置值 $target < nums[mid]$，则将右节点设置为 $mid - 1$，然后继续在左区间 $[left, mid - 1]$ 搜索。

### 思路 1：代码

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        # 在区间 [left, right] 内查找 target
        while left <= right:
            # 取区间中间节点
            mid = (left + right) // 2
            # 如果找到目标值，则直接返回中心位置
            if nums[mid] == target:
                return mid
            # 如果 nums[mid] 小于目标值，则在 [mid + 1, right] 中继续搜索
            elif nums[mid] < target:
                left = mid + 1
            # 如果 nums[mid] 大于目标值，则在 [left, mid - 1] 中继续搜索
            else:
                right = mid - 1
        # 未搜索到元素，返回 -1
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0705. 设计哈希集合](https://leetcode.cn/problems/design-hashset/)

- 标签：设计、数组、哈希表、链表、哈希函数
- 难度：简单

## 题目链接

- [0705. 设计哈希集合 - 力扣](https://leetcode.cn/problems/design-hashset/)

## 题目大意

**要求**：不使用内建的哈希表库，自行实现一个哈希集合（HashSet）。

需要满足以下操作：

- `void add(key)` 向哈希集合中插入值 $key$。
- `bool contains(key)` 返回哈希集合中是否存在这个值 $key$。
- `void remove(key)` 将给定值 $key$ 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。

**说明**：

- $0 \le key \le 10^6$。
- 最多调用 $10^4$ 次 `add`、`remove` 和 `contains`。

**示例**：

- 示例 1：

```python
输入：
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
输出：
[null, null, null, true, false, null, true, null, false]

解释：
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // 返回 True
myHashSet.contains(3); // 返回 False ，（未找到）
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // 返回 True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // 返回 False ，（已移除）
```

## 解题思路

### 思路 1：数组 + 链表

定义一个一维长度为 $buckets$ 的二维数组 $table$。

第一维度用于计算哈希函数，为 $key$ 进行分桶。第二个维度用于寻找 $key$ 存放的具体位置。第二维度的数组会根据 $key$ 值动态增长，模拟真正的链表。

### 思路 1：代码

```python
class MyHashSet:

    def __init__(self):
        self.buckets = 1003
        self.table = [[] for _ in range(self.buckets)]

        
    def hash(self, key):
        return key % self.buckets

    
    def add(self, key: int) -> None:
        hash_key = self.hash(key)
        if key in self.table[hash_key]:
            return
        self.table[hash_key].append(key)


    def remove(self, key: int) -> None:
        hash_key = self.hash(key)
        if key not in self.table[hash_key]:
            return
        self.table[hash_key].remove(key)


    def contains(self, key: int) -> bool:
        hash_key = self.hash(key)
        return key in self.table[hash_key]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\frac{n}{m})$，其中 $n$ 为哈希表中的元素数量，$b$ 为 $table$ 的元素个数，也就是链表的数量。
- **空间复杂度**：$O(n + m)$。

# [0706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)

- 标签：设计、数组、哈希表、链表、哈希函数
- 难度：简单

## 题目链接

- [0706. 设计哈希映射 - 力扣](https://leetcode.cn/problems/design-hashmap/)

## 题目大意

**要求**：不使用任何内建的哈希表库设计一个哈希映射（`HashMap`）。

需要满足以下操作：

- `MyHashMap()` 用空映射初始化对象。
- `void put(int key, int value) 向 HashMap` 插入一个键值对 `(key, value)` 。如果 `key` 已经存在于映射中，则更新其对应的值 `value`。
- `int get(int key)` 返回特定的 `key` 所映射的 `value`；如果映射中不包含 `key` 的映射，返回 `-1`。
- `void remove(key)` 如果映射中存在 key 的映射，则移除 `key` 和它所对应的 `value` 。

**说明**：

- $0 \le key, value \le 10^6$。
- 最多调用 $10^4$ 次 `put`、`get` 和 `remove` 方法。

**示例**：

- 示例 1：

```python
输入：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
输出：
[null, null, null, 1, -1, null, 1, null, -1]

解释：
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]
```

## 解题思路

### 思路 1：链地址法

和 [0705. 设计哈希集合](https://leetcode.cn/problems/design-hashset/) 类似。这里我们使用「链地址法」来解决哈希冲突。即利用「数组 + 链表」的方式实现哈希集合。

1. 定义哈希表长度 `buckets` 为 `1003`。
2. 定义一个一维长度为 `buckets` 的二维数组 `table`。其中第一维度用于计算哈希函数，为关键字 `key` 分桶。第二个维度用于存放 `key` 和对应的 `value`。第二维度的数组会根据 `key` 值动态增长，用数组模拟真正的链表。
3. 定义一个 `hash(key)` 的方法，将 `key` 转换为对应的地址 `hash_key`。
4. 进行 `put` 操作时，根据 `hash(key)` 方法，获取对应的地址 `hash_key`。然后遍历 `hash_key` 对应的数组元素，查找与 `key` 值一样的元素。
   1. 如果找到与 `key` 值相同的元素，则更改该元素对应的 `value` 值。
   2. 如果没找到与 `key` 值相同的元素，则在第二维数组 `table[hask_key]` 中增加元素，元素为 `(key, value)` 组成的元组。

5. 进行 `get` 操作跟 `put` 操作差不多。根据 `hash(key)` 方法，获取对应的地址 `hash_key`。然后遍历 `hash_key` 对应的数组元素，查找与 `key` 值一样的元素。
   1. 如果找到与 `key` 值相同的元素，则返回该元素对应的 `value`。
   2. 如果没找到与 `key` 值相同的元素，则返回 `-1`。

### 思路 1：代码

```python
class MyHashMap:

    def __init__(self):
        self.buckets = 1003
        self.table = [[] for _ in range(self.buckets)]


    def hash(self, key):
        return key % self.buckets


    def put(self, key: int, value: int) -> None:
        hash_key = self.hash(key)
        for item in self.table[hash_key]:
            if key == item[0]:
                item[1] = value
                return
        self.table[hash_key].append([key, value])


    def get(self, key: int) -> int:
        hash_key = self.hash(key)
        for item in self.table[hash_key]:
            if key == item[0]:
                return item[1]
        return -1


    def remove(self, key: int) -> None:
        hash_key = self.hash(key)
        for i, item in enumerate(self.table[hash_key]):
            if key == item[0]:
                self.table[hash_key].pop(i)
                return
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\frac{n}{b})$。其中 $n$ 为哈希表中元素数量，$b$ 为链表的数量。
- **空间复杂度**：$O(n + b)$。# [0707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

- 标签：设计、链表
- 难度：中等

## 题目链接

- [0707. 设计链表 - 力扣](https://leetcode.cn/problems/design-linked-list/)

## 题目大意

**要求**：设计实现一个链表，需要支持以下操作：

- `get(index)`：获取链表中第 `index` 个节点的值。如果索引无效，则返回 `-1`。
- `addAtHead(val)`：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- `addAtTail(val)`：将值为 `val` 的节点追加到链表的最后一个元素。
- `addAtIndex(index, val)`：在链表中的第 `index` 个节点之前添加值为 `val`  的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果 `index` 小于 `0`，则在头部插入节点。
- `deleteAtIndex(index)`：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

**说明**：

- 所有`val`值都在 $[1, 1000]$ 之内。
- 操作次数将在 $[1, 1000]$ 之内。
- 请不要使用内置的 `LinkedList` 库。

**示例**：

- 示例 1：

```python
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   // 链表变为 1 -> 2 -> 3
linkedList.get(1);            // 返回 2
linkedList.deleteAtIndex(1);  // 现在链表是 1-> 3
linkedList.get(1);            // 返回 3
```

## 解题思路

### 思路 1：单链表

新建一个带有 `val` 值 和 `next` 指针的链表节点类， 然后按照要求对节点进行操作。

### 思路 1：代码

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class MyLinkedList:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.size = 0
        self.head = ListNode(0)


    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if index < 0 or index >= self.size:
            return -1

        curr = self.head
        for _ in range(index + 1):
            curr = curr.next
        return curr.val


    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size, val)


    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index > self.size:
            return

        if index < 0:
            index = 0

        self.size += 1
        pre = self.head
        for _ in range(index):
            pre = pre.next

        add_node = ListNode(val)
        add_node.next = pre.next
        pre.next = add_node


    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index < 0 or index >= self.size:
            return

        self.size -= 1
        pre = self.head
        for _ in range(index):
            pre = pre.next

        pre.next = pre.next.next
```

### 思路 1：复杂度分析

- **时间复杂度**：
  - `addAtHead(val)`：$O(1)$。
  - `get(index)`、`addAtTail(val)`、`del eteAtIndex(index)`：$O(k)$。$k$ 指的是元素的索引。
  - `addAtIndex(index, val)`：$O(n)$。$n$ 指的是链表的元素个数。

- **空间复杂度**：$O(1)$。

### 思路 2：双链表

新建一个带有 `val` 值和 `next` 指针、`prev` 指针的链表节点类，然后按照要求对节点进行操作。

### 思路 2：代码

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
        self.prev = None

class MyLinkedList:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.size = 0
        self.head = ListNode(0)
        self.tail = ListNode(0)
        self.head.next = self.tail
        self.tail.prev = self.head


    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if index < 0 or index >= self.size:
            return -1

        if index + 1 < self.size - index:
            curr = self.head
            for _ in range(index + 1):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self.size - index):
                curr = curr.prev
        return curr.val


    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0, val)


    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size, val)


    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index > self.size:
            return

        if index < 0:
            index = 0

        if index < self.size - index:
            prev = self.head
            for _ in range(index):
                prev = prev.next
            next = prev.next
        else:
            next = self.tail
            for _ in range(self.size - index):
                next = next.prev
            prev = next.prev

        self.size += 1
        add_node = ListNode(val)
        add_node.prev = prev
        add_node.next = next
        prev.next = add_node
        next.prev = add_node

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index < 0 or index >= self.size:
            return

        if index < self.size - index:
            prev = self.head
            for _ in range(index):
                prev = prev.next
            next = prev.next.next
        else:
            next = self.tail
            for _ in range(self.size - index - 1):
                next = next.prev
            prev = next.prev.prev

        self.size -= 1
        prev.next = next
        next.prev = prev
```

### 思路 2：复杂度分析

- **时间复杂度**：
  - `addAtHead(val)`、`addAtTail(val)`：$O(1)$。
  - `get(index)`、`addAtIndex(index, val)`、`del eteAtIndex(index)`：$O(min(k, n - k))$。$n$ 指的是链表的元素个数，$k$ 指的是元素的索引。
- **空间复杂度**：$O(1)$。

# [0708. 循环有序列表的插入](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/)

- 标签：链表
- 难度：中等

## 题目链接

- [0708. 循环有序列表的插入 - 力扣](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/)

## 题目大意

给定循环升序链表中的一个节点 `head` 和一个整数 `insertVal`。

要求：将整数 `insertVal` 插入循环升序链表中，并且满足链表仍为循环升序链表。最终返回原先给定的节点。

## 解题思路

- 先判断所给节点 `head` 是否为空，为空直接创建一个值为 `insertVal` 的新节点，并指向自己，返回即可。

- 如果 `head` 不为空，把 `head` 赋值给 `node` ，方便最后返回原节点 `head`。
- 然后遍历 `node`，判断插入值 `insertVal` 与 `node.val` 和 `node.next.val` 的关系，找到插入位置，具体判断如下：
  - 如果新节点值在两个节点值中间， 即 `node.val <= insertVal <= node.next.val`。则说明新节点值在最大值最小值中间，应将新节点插入到当前位置，则应将 `insertVal` 插入到这个位置。
  - 如果新节点值比当前节点值和当前节点下一节点值都大，并且当前节点值比当前节点值的下一节点值大，即 `node.next.val < node.val <= insertVal`，则说明 `insertVal` 比链表最大值都大，应插入最大值后边。
  - 如果新节点值比当前节点值和当前节点下一节点值都小，并且当前节点值比当前节点值的下一节点值大，即 `insertVal < node.next.val < node.val`，则说明 `insertVal` 比链表中最小值都小，应插入最小值前边。
- 找到插入位置后，跳出循环，在插入位置插入值为 `insertVal` 的新节点。

## 代码

```python
class Solution:
    def insert(self, head: 'Node', insertVal: int) -> 'Node':
        if not head:
            node = Node(insertVal)
            node.next = node
            return node

        node = head
        while node.next != head:
            if node.val <= insertVal <= node.next.val:
                break
            elif node.next.val < node.val <= insertVal:
                break
            elif insertVal < node.next.val < node.val:
                break
            else:
                node = node.next

        insert_node = Node(insertVal)
        insert_node.next = node.next
        node.next = insert_node
        return head
```

# [0709. 转换成小写字母](https://leetcode.cn/problems/to-lower-case/)

- 标签：字符串
- 难度：简单

## 题目链接

- [0709. 转换成小写字母 - 力扣](https://leetcode.cn/problems/to-lower-case/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。

**说明**：

- $1 \le s.length \le 100$。
- $s$ 由 ASCII 字符集中的可打印字符组成。

**示例**：

- 示例 1：

```python
输入：s = "Hello"
输出："hello"
```

- 示例 2：

```python
输入：s = "LOVELY"
输出："lovely"
```

## 解题思路

### 思路 1：直接模拟

- 大写字母 $A \sim Z$ 的 ASCII 码范围为 $[65, 90]$。
- 小写字母 $a \sim z$ 的 ASCII 码范围为 $[97, 122]$。

将大写字母的 ASCII 码加 $32$，就得到了对应的小写字母，则解决步骤如下：

1. 使用一个字符串变量 $ans$ 存储最终答案字符串。
2. 遍历字符串 $s$，对于当前字符 $ch$：
   1. 如果 $ch$ 的 ASCII 码范围在 $[65, 90]$，则说明 $ch$ 为大写字母。将 $ch$ 的 ASCII 码增加 $32$，再转换为对应的字符，存入字符串 $ans$ 的末尾。
   2. 如果 $ch$ 的 ASCII 码范围不在 $[65, 90]$，则说明 $ch$ 为小写字母。直接将 $ch$ 存入字符串 $ans$ 的末尾。
3. 遍历完字符串 $s$，返回答案字符串 $ans$。

### 思路 1：代码

```python
class Solution:
    def toLowerCase(self, s: str) -> str:
        ans = ""
        for ch in s:
            if ord('A') <= ord(ch) <= ord('Z'):
                ans += chr(ord(ch) + 32)
            else:
                ans += ch
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(n)$。不算上则空间复杂度为 $O(1)$。

### 思路 2：使用 API

Python 语言中自带大写字母转小写字母的 API：`lower()`，用 API 转换完成之后，直接返回新的字符串。

### 思路 2：代码

```python
class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(n)$。不算上则空间复杂度为 $O(1)$。# [0713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

- 标签：数组、滑动窗口
- 难度：中等

## 题目链接

- [0713. 乘积小于 K 的子数组 - 力扣](https://leetcode.cn/problems/subarray-product-less-than-k/)

## 题目大意

**描述**：给定一个正整数数组 $nums$ 和整数 $k$。

**要求**：找出该数组内乘积小于 $k$ 的连续的子数组的个数。

**说明**：

- $1 \le nums.length \le 3 * 10^4$。
- $1 \le nums[i] \le 1000$。
- $0 \le k \le 10^6$。

**示例**：

- 示例 1：

```python
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
```

- 示例 2：

```python
输入：nums = [1,2,3], k = 0
输出：0
```

## 解题思路

### 思路 1：滑动窗口（不定长度）

1. 设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口内所有数的乘积 $window\underline{\hspace{0.5em}}product$ 都小于 $k$。使用 $window\underline{\hspace{0.5em}}product$ 记录窗口中的乘积值，使用 $count$ 记录符合要求的子数组个数。
2. 一开始，$left$、$right$ 都指向 $0$。
3. 向右移动 $right$，将最右侧元素加入当前子数组乘积 $window\underline{\hspace{0.5em}}product$ 中。
4. 如果 $window\underline{\hspace{0.5em}}product \ge k$，则不断右移 $left$，缩小滑动窗口长度，并更新当前乘积值 $window\underline{\hspace{0.5em}}product$  直到 $window\underline{\hspace{0.5em}}product < k$。
5. 记录累积答案个数加 $1$，继续右移 $right$，直到 $right \ge len(nums)$ 结束。
6. 输出累积答案个数。

### 思路 1：代码

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0

        size = len(nums)
        left = 0
        right = 0
        window_product = 1
        
        count = 0
        
        while right < size:
            window_product *= nums[right]

            while window_product >= k:
                window_product /= nums[left]
                left += 1

            count += (right - left + 1)
            right += 1
            
        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [0714. 买卖股票的最佳时机含手续费 - 力扣](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

## 题目大意

给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

最后要求返回获得利润的最大值。

## 解题思路

这道题的解题思路和「[0122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)」类似，同样可以买卖多次。122 题是在跌入谷底的时候买入，在涨到波峰的时候卖出，这道题多了手续费，则在判断波峰波谷的时候还要考虑手续费。贪心策略如下：

- 当股票价格小于当前最低股价时，更新最低股价，不卖出。
- 当股票价格大于最小价格 + 手续费时，累积股票利润（实质上暂未卖出，等到波峰卖出），同时最低股价减去手续费，以免重复计算。

## 代码

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        res = 0
        min_price = prices[0]

        for i in range(1, len(prices)):
            if prices[i] < min_price:
                min_price = prices[i]
            elif prices[i] > min_price + fee:
                res += prices[i] - min_price - fee
                min_price = prices[i] - fee
        return res
```

# [0715. Range 模块](https://leetcode.cn/problems/range-module/)

- 标签：设计、线段树、有序集合
- 难度：困难

## 题目链接

- [0715. Range 模块 - 力扣](https://leetcode.cn/problems/range-module/)

## 题目大意

**描述**：`Range` 模块是跟踪数字范围的模块。

**要求**：

- 设计一个数据结构来跟踪查询半开区间 `[left, right)` 内的数字是否被跟踪。
- 实现 `RangeModule` 类：
  - `RangeModule()` 初始化数据结构的对象。
  - `void addRange(int left, int right)` 添加半开区间 `[left, right)`，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 `[left, right)` 中尚未跟踪的任何数字到该区间中。
  - `boolean queryRange(int left, int right)` 只有在当前正在跟踪区间 `[left, right)` 中的每一个实数时，才返回 `True` ，否则返回 `False`。
  - `void removeRange(int left, int right)` 停止跟踪半开区间 `[left, right)` 中当前正在跟踪的每个实数。

**说明**：

- $1 \le left < right \le 10^9$。

**示例**：

- 示例 1：

```
rangeModule = RangeModule() -> null
rangeModule.addRange(10, 20) -> null
rangeModule.removeRange(14, 16) -> null
rangeModule.queryRange(10, 14) -> True
rangeModule.queryRange(13, 15) -> False
rangeModule.queryRange(16, 17) -> True
```

## 解题思路

### 思路 1：线段树

这道题可以使用线段树来做，但是效率比较差。

区间的范围是 $[0, 10^9]$，普通数组构成的线段树不满足要求。需要用到动态开点线段树。题目要求的是半开区间 `[left, right)` ，而线段树中常用的是闭合区间。但是我们可以将半开区间 `[left, right)` 转为 `[left, right - 1]` 的闭合空间。

这样构建线段树的时间复杂度为 $O(\log n)$，单次区间更新的时间复杂度为 $O(\log n)$，单次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(\log n)$。

## 代码

### 思路 1 代码：

```python
# 线段树的节点类
class TreeNode:
    def __init__(self, left, right, val=False, lazy_tag=None, letNode=None, rightNode=None):
        self.left = left  # 区间左边界
        self.right = right  # 区间右边界
        self.mid = (left + right) >> 1
        self.leftNode = letNode  # 区间左节点
        self.rightNode = rightNode  # 区间右节点
        self.val = val  # 节点值（区间值）
        self.lazy_tag = lazy_tag  # 区间问题的延迟更新标记


class RangeModule:

    def __init__(self):
        self.tree = TreeNode(0, int(1e9))

    # 向上更新 node 节点区间值，节点的区间值等于该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.leftNode and node.rightNode:
            node.val = node.leftNode.val and node.rightNode.val
        else:
            node.val = False

    # 向下更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if not node.leftNode:
            node.leftNode = TreeNode(node.left, node.mid)
        if not node.rightNode:
            node.rightNode = TreeNode(node.mid + 1, node.right)
        if node.lazy_tag is not None:
            node.leftNode.lazy_tag = node.lazy_tag  # 更新左子节点懒惰标记
            node.leftNode.val = node.lazy_tag  # 左子节点每个元素值增加 lazy_tag

            node.rightNode.lazy_tag = node.lazy_tag  # 更新右子节点懒惰标记
            node.rightNode.val = node.lazy_tag  # 右子节点每个元素值增加 lazy_tag

            node.lazy_tag = None  # 更新当前节点的懒惰标记

    # 区间更新
    def __update_interval(self, q_left, q_right, val, node):
        if q_left <= node.left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            node.lazy_tag = val  # 将当前节点的延迟标记增加 val
            node.val = val  # 当前节点所在区间每个元素值增加 val
            return

        self.__pushdown(node)

        if q_left <= node.mid:
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:
            self.__update_interval(q_left, q_right, val, node.rightNode)

        self.__pushup(node)

    # 区间查询，在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if q_left <= node.left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.val  # 直接返回节点值

        # 需要向下更新节点所在区间的左右子节点的值和懒惰标记
        self.__pushdown(node)

        if q_right <= node.mid:
            return self.__query_interval(q_left, q_right, node.leftNode)
        if q_left > node.mid:
            return self.__query_interval(q_left, q_right, node.rightNode)

        return self.__query_interval(q_left, q_right, node.leftNode) and self.__query_interval(q_left, q_right, node.rightNode)  # 返回左右子树元素值的聚合计算结果


    def addRange(self, left: int, right: int) -> None:
        self.__update_interval(left, right - 1, True, self.tree)


    def queryRange(self, left: int, right: int) -> bool:
        return self.__query_interval(left, right - 1, self.tree)


    def removeRange(self, left: int, right: int) -> None:
        self.__update_interval(left, right - 1, False, self.tree)
```

# [0718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

- 标签：数组、二分查找、动态规划、滑动窗口、哈希函数、滚动哈希
- 难度：中等

## 题目链接

- [0718. 最长重复子数组 - 力扣](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

## 题目大意

**描述**：给定两个整数数组 $nums1$、$nums2$。

**要求**：计算两个数组中公共的、长度最长的子数组长度。

**说明**：

- $1 \le nums1.length, nums2.length \le 1000$。
- $0 \le nums1[i], nums2[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

- 示例 2：

```python
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

## 解题思路

### 思路 1：暴力（超时）

1. 枚举数组 $nums1$ 和 $nums2$ 的子数组开始位置 $i$、$j$。
2. 如果遇到相同项，即 $nums1[i] == nums2[j]$，则以 $nums1[i]$、$nums2[j]$ 为前缀，同时向后遍历，计算当前的公共子数组长度 $subLen$ 最长为多少。
3. 直到遇到超出数组范围或者 $nums1[i + subLen] == nums2[j + subLen]$ 情况时，停止遍历，并更新答案。
4. 继续执行 $1 \sim 3$ 步，直到遍历完，输出答案。

### 思路 1：代码

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        size1, size2 = len(nums1), len(nums2)
        ans = 0
        for i in range(size1):
            for j in range(size2):
                if nums1[i] == nums2[j]:
                    subLen = 1
                    while i + subLen < size1 and j + subLen < size2 and nums1[i + subLen] == nums2[j + subLen]:
                        subLen += 1
                    ans = max(ans, subLen)
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m \times min(n, m))$。其中 $n$ 是数组 $nums1$ 的长度，$m$ 是数组 $nums2$ 的长度。
- **空间复杂度**：$O(1)$。

### 思路 2：滑动窗口

暴力方法中，因为子数组在两个数组中的位置不同，所以会导致子数组之间会进行多次比较。

我们可以将两个数组分别看做是两把直尺。然后将数组 $nums1$ 固定， 让 $nums2$ 的尾部与 $nums1$ 的头部对齐，如下所示。

```python
nums1 =             [1, 2, 3, 2, 1]
nums2 = [3, 2, 1, 4, 7]
```

然后逐渐向右移动直尺 $nums2$，比较 $nums1$ 与 $nums2$ 重叠部分中的公共子数组的长度，直到直尺 $nums2$ 的头部移动到 $nums1$ 的尾部。

```python
nums1 =             [1, 2, 3, 2, 1]
nums2 =    [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =       [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =          [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =             [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =                [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =                   [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =                      [3, 2, 1, 4, 7]

nums1 =             [1, 2, 3, 2, 1]
nums2 =                         [3, 2, 1, 4, 7]
```

在这个过程中求得的 $nums1$ 与 $nums2$ 重叠部分中的最大的公共子数组的长度就是 $nums1$ 与 $nums2$ 数组中公共的、长度最长的子数组长度。

### 思路 2：代码

```python
class Solution:
    def findMaxLength(self, nums1, nums2, i, j):
        size1, size2 = len(nums1), len(nums2)
        max_len = 0
        cur_len = 0
        while i < size1 and j < size2:
            if nums1[i] == nums2[j]:
                cur_len += 1
                max_len = max(max_len, cur_len)
            else:
                cur_len = 0
            i += 1
            j += 1
        return max_len

    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        size1, size2 = len(nums1), len(nums2)
        res = 0
        for i in range(size1):
            res = max(res, self.findMaxLength(nums1, nums2, i, 0))

        for i in range(size2):
            res = max(res, self.findMaxLength(nums1, nums2, 0, i))
        
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n + m) \times min(n, m)$。其中 $n$ 是数组 $nums1$ 的长度，$m$ 是数组 $nums2$ 的长度。
- **空间复杂度**：$O(1)$。

### 思路 3：动态规划

###### 1. 划分阶段

按照子数组结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]...nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]...nums2[j - 1]$）」的最长公共子数组长度。

###### 3. 状态转移方程

1. 如果 $nums1[i - 1] = nums2[j - 1]$，则当前元素可以构成公共子数组，此时 $dp[i][j] = dp[i - 1][j - 1] + 1$。
2. 如果 $nums1[i - 1] \ne nums2[j - 1]$，则当前元素不能构成公共子数组，此时 $dp[i][j] = 0$。

###### 4. 初始条件

- 当 $i = 0$ 时，$nums1[0]...nums1[i - 1]$ 表示的是空数组，空数组与 $nums2[0]...nums2[j - 1]$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。
- 当 $j = 0$ 时，$nums2[0]...nums2[j - 1]$ 表示的是空数组，空数组与 $nums1[0]...nums1[i - 1]$ 的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。

###### 5. 最终结果

- 根据状态定义， $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]...nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]...nums2[j - 1]$）」的最长公共子数组长度。在遍历过程中，我们可以使用 $res$ 记录下所有 $dp[i][j]$ 中最大值即为答案。

### 思路 3：代码

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        size1 = len(nums1)
        size2 = len(nums2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]
        res = 0
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > res:
                    res = dp[i][j]

        return res
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times m)$。其中 $n$ 是数组 $nums1$ 的长度，$m$ 是数组 $nums2$ 的长度。
- **空间复杂度**：$O(n \times m)$。# [0719. 找出第 K 小的距离对](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

- 标签：数组、双指针、二分查找、排序
- 难度：困难

## 题目链接

- [0719. 找出第 K 小的距离对 - 力扣](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

## 题目大意

**描述**：给定一个整数数组 $nums$，对于数组中不同的数 $nums[i]$、$nums[j]$ 之间的距离定义为 $nums[i]$ 和 $nums[j]$ 的绝对差值，即 $dist(nums[i], nums[j]) = abs(nums[i] - nums[j])$。

**要求**：求所有数对之间第 $k$ 个最小距离。

**说明**：

- $n == nums.length$
- $2 \le n \le 10^4$。
- $0 \le nums[i] \le 10^6$。
- $1 \le k \le n \times (n - 1) / 2$。

**示例**：

- 示例 1：

```python
输入：nums = [1,3,1], k = 1
输出：0
解释：数对和对应的距离如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
距离第 1 小的数对是 (1,1) ，距离为 0。
```

- 示例 2：

```python
输入：nums = [1,1,1], k = 2
输出：0
```

## 解题思路

### 思路 1：二分查找算法

一般来说 topK 问题都可以用堆排序来解决。但是这道题使用堆排序超时了。所以需要换其他方法。

先来考虑第 $k$ 个最小距离的范围。这个范围一定在 $[0, max(nums) - min(nums)]$ 之间。

我们可以对 $nums$ 先进行排序，然后得到最小距离为 $0$，最大距离为 $nums[-1] - nums[0]$。我们可以在这个区间上进行二分，对于二分的位置 $mid$，统计距离小于等于 $mid$ 的距离对数，并根据它和 $k$ 的关系调整区间上下界。

统计对数可以使用双指针来计算出所有小于等于 $mid$ 的距离对数目。

1. 维护两个指针 $left$、$right$。$left$、$right$ 都指向数组开头位置。
2. 然后不断移动 $right$，计算 $nums[right]$ 和 $nums[left]$ 之间的距离。
3. 如果大于 $mid$，则 $left$ 向右移动，直到距离小于等于 $mid$ 时，统计当前距离对数为 $right - left$。
4. 最终将这些符合要求的距离对数累加，就得到了所有小于等于 $mid$ 的距离对数目。

### 思路 1：代码

```python
class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        def get_count(dist):
            left, count = 0, 0
            for right in range(1, len(nums)):
                while nums[right] - nums[left] > dist:
                    left += 1
                count += (right - left)
            return count

        nums.sort()
        left, right = 0, nums[-1] - nums[0]
        while left < right:
            mid = left + (right - left) // 2
            if get_count(mid) >= k:
                right = mid
            else:
                left = mid + 1
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $nums$ 中的元素个数。
- **空间复杂度**：$O(\log n)$，排序算法所用到的空间复杂度为 $O(\log n)$。
# [0720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)

- 标签：字典树、数组、哈希表、字符串、排序
- 难度：中等

## 题目链接

- [0720. 词典中最长的单词 - 力扣](https://leetcode.cn/problems/longest-word-in-dictionary/)

## 题目大意

给出一个字符串数组 `words` 组成的一本英语词典。

要求：从中找出最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

## 解题思路

使用字典树存储每一个单词。再在字典树中查找每一个单词，查找的时候判断是否有以当前单词为前缀的单词。如果有，则该单词可以由前缀构成的单词逐步添加字母获得。此时，如果该单词比答案单词更长，则维护更新答案单词。

最后输出答案单词。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children or not cur.children[ch].isEnd:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def longestWord(self, words: List[str]) -> str:

        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        ans = ""
        for word in words:
            if trie_tree.search(word):
                if len(word) > len(ans):
                    ans = word
                elif len(word) == len(ans) and word < ans:
                    ans = word
        return ans
```

# [0724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

- 标签：数组、前缀和
- 难度：简单

## 题目链接

- [0724. 寻找数组的中心下标 - 力扣](https://leetcode.cn/problems/find-pivot-index/)

## 题目大意

**描述**：给定一个数组 $nums$。

**要求**：找到「左侧元素和」与「右侧元素和相等」的位置，若找不到，则返回 $-1$。

**说明**：

- $1 \le nums.length \le 10^4$。
- $-1000 \le nums[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11，二者相等。
```

- 示例 2：

```python
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

## 解题思路

### 思路 1：两次遍历

两次遍历，第一次遍历先求出数组全部元素和。第二次遍历找到左侧元素和恰好为全部元素和一半的位置。

### 思路 1：代码

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        sum = 0
        for i in range(len(nums)):
            sum += nums[i]
        curr_sum = 0
        for i in range(len(nums)):
            if curr_sum * 2 + nums[i] == sum:
                return i
            curr_sum += nums[i]
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。两次遍历的时间复杂度为 $O(2 \times n)$ ，$O(2 \times n) == O(n)$。
- **空间复杂度**：$O(1)$。

# [0727. 最小窗口子序列](https://leetcode.cn/problems/minimum-window-subsequence/)

- 标签：字符串、动态规划、滑动窗口
- 难度：困难

## 题目链接

- [0727. 最小窗口子序列 - 力扣](https://leetcode.cn/problems/minimum-window-subsequence/)

## 题目大意

给定字符串 `s1` 和 `s2`。

要求：找出 `s1` 中最短的（连续）子串 `w`，使得 `s2` 是 `w` 的子序列 。如果 `s1` 中没有窗口可以包含 `s2` 中的所有字符，返回空字符串 `""`。如果有不止一个最短长度的窗口，返回开始位置最靠左的那个。

## 解题思路

这道题跟「[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)」有点类似。但这道题中字符的相对顺序需要保持一致。求解的思路如下：

- 向右扩大窗口，匹配字符，直到匹配完 `s2` 的最后一个字符。
- 当满足条件时，缩小窗口，并更新最小窗口的起始位置和最短长度。
- 缩小窗口到不满足条件为止。

这道题的难点在于第二步中如何缩小窗口。当匹配到一个子序列时，可以采用逆向匹配的方式，从 `s2` 的最后一位字符匹配到 `s2` 的第一位字符。找到符合要求的最大下标，即是窗口的左边界。

整个算法的解题步骤如下：

- 使用两个指针 `left`、`right` 代表窗口的边界，一开始都指向 `0` 。`min_len` 用来记录最小子序列的长度。`i`、`j` 作为索引，用于遍历字符串 `s1` 和 `s2`，一开始都为 `0`。
- 遍历字符串 `s1` 的每一个字符，如果 `s1[i] == s2[j]`，则说明 `s2` 中第 `j` 个字符匹配了，向右移动 `j`，即 `j += 1`，然后继续匹配。
- 如果 `j == len(s2)`，则说明 `s2` 中所有字符都匹配了。
  - 此时确定了窗口的右边界 `right = i`，并令 `j` 指向 `s2` 最后一个字符位置。
  - 从右至左逆向匹配字符串，找到窗口的左边界。
  - 判断当前窗口长度和窗口的最短长度，并更新最小窗口的起始位置和最短长度。
  - 令 `j = 0`，重新继续匹配 `s2`。
- 向右移动 `i`，继续匹配。
- 遍历完输出窗口的最短长度（需要判断是否有解）。

## 代码

```python
class Solution:
    def minWindow(self, s1: str, s2: str) -> str:
        i, j = 0, 0
        min_len = float('inf')
        left, right = 0, 0
        while i < len(s1):
            if s1[i] == s2[j]:
                j += 1
            # 完成了匹配
            if j == len(s2):
                right = i
                j -= 1
                while j >= 0:
                    if s1[i] == s2[j]:
                        j -= 1
                    i -= 1
                i += 1
                if right - i + 1 < min_len:
                    left = i
                    min_len = right - left + 1
                j = 0
            i += 1
        if min_len != float('inf'):
            return s1[left: left + min_len]
        return ""
```

## 参考资料

- 【题解】[c++ 简单好理解的 滑动窗口解法 和 动态规划解法 - 最小窗口子序列 - 力扣](https://leetcode.cn/problems/minimum-window-subsequence/solution/c-jian-dan-hao-li-jie-de-hua-dong-chuang-wguk/)
- 【题解】[727. 最小窗口子序列 C++ 滑动窗口 - 最小窗口子序列 - 力扣](https://leetcode.cn/problems/minimum-window-subsequence/solution/727-zui-xiao-chuang-kou-zi-xu-lie-c-hua-dong-chuan/)

# [0729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

- 标签：设计、线段树、二分查找、有序集合
- 难度：中等

## 题目链接

- [0729. 我的日程安排表 I - 力扣](https://leetcode.cn/problems/my-calendar-i/)

## 题目大意

**要求**：实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成重复预订 ，则可以存储这个新的日程安排。

日程可以用一对整数 $start$ 和 $end$ 表示，这里的时间是半开区间，即 $[start, end)$，实数 $x$ 的范围为 $start \le x < end$。

`MyCalendar` 类：

- `MyCalendar()` 初始化日历对象。
- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `True` 。否则，返回 `False` 并且不要将该日程安排添加到日历中。

**说明**：

- 重复预订：当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订 。
- $0 \le start < end \le 10^9$
- 每个测试用例，调用 `book` 方法的次数最多不超过 `1000` 次。

**示例**：

- 示例 1：

```python
输入：
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]

输出：
[null, true, false, true]

解释：
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
```

## 解题思路

### 思路 1：线段树

这道题可以使用线段树来做。

因为区间的范围是 $[0, 10^9]$，普通数组构成的线段树不满足要求。需要用到动态开点线段树。

- 构建一棵线段树。每个线段树的节点类存储当前区间中保存的日程区间个数。

- 在 `book` 方法中，从线段树中查询 `[start, end - 1]` 区间上保存的日程区间个数。
  - 如果日程区间个数大于等于 `1`，则说明该日程添加到日历中会导致重复预订，则直接返回 `False`。
  - 如果日程区间个数小于 `1`，则说明该日程添加到日历中不会导致重复预定，则在线段树中将区间 `[start, end - 1]` 的日程区间个数 + 1，然后返回 `True`。

### 思路 1：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, left=-1, right=-1, val=0, lazy_tag=None, leftNode=None, rightNode=None):
        self.left = left                            # 区间左边界
        self.right = right                          # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = leftNode                    # 区间左节点
        self.rightNode = rightNode                  # 区间右节点
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = lazy_tag                    # 区间问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, function):
        self.tree = SegTreeNode(0, int(1e9))
        self.function = function                    # function 是一个函数，左右区间的聚合方法
            
    # 单点更新，将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.__update_point(i, val, self.tree)
    
    # 区间更新，将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.tree)
        
    # 区间查询，查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.tree)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self, length):
        nums = [0 for _ in range(length)]
        for i in range(length):
            nums[i] = self.query_interval(i, i)
        return nums
    
    
    # 以下为内部实现方法
    
    # 单点更新，将 nums[i] 更改为 val。node 节点的区间为 [node.left, node.right]
    def __update_point(self, i, val, node):
        if node.left == node.right:
            node.val = val                          # 叶子节点，节点值修改为 val
            return
        
        if i <= node.mid:                           # 在左子树中更新节点值
            self.__update_point(i, val, node.leftNode)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, node.rightNode)
        self.__pushup(node)                         # 向上更新节点的区间值
    
    # 区间更新
    def __update_interval(self, q_left, q_right, val, node):
        if node.left >= q_left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            if node.lazy_tag is not None:
                node.lazy_tag += val                # 将当前节点的延迟标记增加 val
            else:
                node.lazy_tag = val                 # 将当前节点的延迟标记增加 val
            node.val += val          # 当前节点所在区间每个元素值增加 val
            return
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
    
        if q_left <= node.mid:                      # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:                      # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
            
        self.__pushup(node)
    
    # 区间查询，在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if node.left >= q_left and node.right <= q_right:   # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.val                         # 直接返回节点值
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
                                  
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
        
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= node.mid:                      # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, node.leftNode)
        if q_right > node.mid:                      # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, node.rightNode)
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果

    # 向上更新 node 节点区间值，节点的区间值等于该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.leftNode and node.rightNode:
            node.val = self.function(node.leftNode.val, node.rightNode.val)
    
    # 向下更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if node.leftNode is None:
            node.leftNode = SegTreeNode(node.left, node.mid)
        if node.rightNode is None:
            node.rightNode = SegTreeNode(node.mid + 1, node.right)
            
        lazy_tag = node.lazy_tag
        if node.lazy_tag is None:
            return
            
        if node.leftNode.lazy_tag is not None:
            node.leftNode.lazy_tag += lazy_tag      # 更新左子节点懒惰标记
        else:
            node.leftNode.lazy_tag = lazy_tag       # 更新左子节点懒惰标记
        node.leftNode.val += lazy_tag               # 左子节点每个元素值增加 lazy_tag
        
        if node.rightNode.lazy_tag is not None:
            node.rightNode.lazy_tag += lazy_tag     # 更新右子节点懒惰标记
        else:
            node.rightNode.lazy_tag = lazy_tag      # 更新右子节点懒惰标记
        node.rightNode.val += lazy_tag              # 右子节点每个元素值增加 lazy_tag
        
        node.lazy_tag = None                        # 更新当前节点的懒惰标记

class MyCalendar:

    def __init__(self):
        self.STree = SegmentTree(lambda x, y: max(x, y))


    def book(self, start: int, end: int) -> bool:
        if self.STree.query_interval(start, end - 1) >= 1:
            return False
        self.STree.update_interval(start, end - 1, 1)
        return True
```
# [731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/)

- 标签：设计、线段树、二分查找、有序集合
- 难度：中等

## 题目链接

- [731. 我的日程安排表 II - 力扣](https://leetcode.cn/problems/my-calendar-ii/)

## 题目大意

**要求**：实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。

日程可以用一对整数 $start$ 和 $end$ 表示，这里的时间是半开区间，即 $[start, end)$，实数 $x$ 的范围为 $start \le x < end$。

`MyCalendar` 类：

- `MyCalendar()` 初始化日历对象。
- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 `True` 。否则，返回 `False` 并且不要将该日程安排添加到日历中。

**说明**：

- 三重预定：当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订 。
- $0 \le start < end \le 10^9$。
- 每个测试用例，调用 `book` 方法的次数最多不超过 `1000` 次。

**示例**：

- 示例 1：

```python
输入：
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
输出：
[null, true, false, true]

解释：
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。
myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。
```

## 解题思路

### 思路 1：线段树

这道题可以使用线段树来做。

因为区间的范围是 $[0, 10^9]$，普通数组构成的线段树不满足要求。需要用到动态开点线段树。

- 构建一棵线段树。每个线段树的节点类存储当前区间中保存的日程区间个数。

- 在 `book` 方法中，从线段树中查询 `[start, end - 1]` 区间上保存的日程区间个数。
  - 如果日程区间个数大于等于 `2`，则说明该日程添加到日历中会导致三重预订，则直接返回 `False`。
  - 如果日程区间个数小于 `2`，则说明该日程添加到日历中不会导致三重预订，则在线段树中将区间 `[start, end - 1]` 的日程区间个数 + 1，然后返回 `True`。

### 思路 1：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, left=-1, right=-1, val=0, lazy_tag=None, leftNode=None, rightNode=None):
        self.left = left                            # 区间左边界
        self.right = right                          # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = leftNode                    # 区间左节点
        self.rightNode = rightNode                  # 区间右节点
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = lazy_tag                    # 区间问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, function):
        self.tree = SegTreeNode(0, int(1e9))
        self.function = function                    # function 是一个函数，左右区间的聚合方法
            
    # 单点更新，将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.__update_point(i, val, self.tree)
    
    # 区间更新，将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.tree)
        
    # 区间查询，查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.tree)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self, length):
        nums = [0 for _ in range(length)]
        for i in range(length):
            nums[i] = self.query_interval(i, i)
        return nums
    
    
    # 以下为内部实现方法
    
    # 单点更新，将 nums[i] 更改为 val。node 节点的区间为 [node.left, node.right]
    def __update_point(self, i, val, node):
        if node.left == node.right:
            node.val = val                          # 叶子节点，节点值修改为 val
            return
        
        if i <= node.mid:                           # 在左子树中更新节点值
            self.__update_point(i, val, node.leftNode)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, node.rightNode)
        self.__pushup(node)                         # 向上更新节点的区间值
    
    # 区间更新
    def __update_interval(self, q_left, q_right, val, node):
        if node.left >= q_left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            if node.lazy_tag is not None:
                node.lazy_tag += val                # 将当前节点的延迟标记增加 val
            else:
                node.lazy_tag = val                 # 将当前节点的延迟标记增加 val
            node.val += val                         # 当前节点所在区间增加 val
            return
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
    
        if q_left <= node.mid:                      # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:                      # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
            
        self.__pushup(node)
    
    # 区间查询，在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if node.left >= q_left and node.right <= q_right:   # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.val                         # 直接返回节点值
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
                                  
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
        
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= node.mid:                      # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, node.leftNode)
        if q_right > node.mid:                      # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, node.rightNode)
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果

    # 向上更新 node 节点区间值，节点的区间值等于该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.leftNode and node.rightNode:
            node.val = self.function(node.leftNode.val, node.rightNode.val)
    
    # 向下更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if node.leftNode is None:
            node.leftNode = SegTreeNode(node.left, node.mid)
        if node.rightNode is None:
            node.rightNode = SegTreeNode(node.mid + 1, node.right)
            
        lazy_tag = node.lazy_tag
        if node.lazy_tag is None:
            return
            
        if node.leftNode.lazy_tag is not None:
            node.leftNode.lazy_tag += lazy_tag      # 更新左子节点懒惰标记
        else:
            node.leftNode.lazy_tag = lazy_tag       # 更新左子节点懒惰标记
        node.leftNode.val += lazy_tag               # 左子节点区间增加 lazy_tag
        
        if node.rightNode.lazy_tag is not None:
            node.rightNode.lazy_tag += lazy_tag     # 更新右子节点懒惰标记
        else:
            node.rightNode.lazy_tag = lazy_tag      # 更新右子节点懒惰标记
        node.rightNode.val += lazy_tag              # 右子节点区间增加 lazy_tag
        
        node.lazy_tag = None                        # 更新当前节点的懒惰标记

class MyCalendarTwo:

    def __init__(self):
        self.STree = SegmentTree(lambda x, y: max(x, y))


    def book(self, start: int, end: int) -> bool:
        if self.STree.query_interval(start, end - 1) >= 2:
            return False
        self.STree.update_interval(start, end - 1, 1)
        return True
```# [0732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)

- 标签：设计、线段树、二分查找、有序集合
- 难度：困难

## 题目链接

- [0732. 我的日程安排表 III - 力扣](https://leetcode.cn/problems/my-calendar-iii/)

## 题目大意

**要求**：实现一个 `MyCalendarThree` 类来存放你的日程安排，你可以一直添加新的日程安排。

日程可以用一对整数 $start$ 和 $end$ 表示，这里的时间是半开区间，即 $[start, end)$，实数 $x$ 的范围为 $start \le x < end$。

`MyCalendarThree` 类：

- `MyCalendarThree()` 初始化对象。
- `int book(int start, int end)` 返回一个整数 `k`，表示日历中存在的 `k` 次预订的最大值。

**说明**：

- `k` 次预定：当 `k` 个日程安排有一些时间上的交叉时（例如 `k` 个日程安排都在同一时间内），就会产生 `k` 次预订。
- $0 \le start < end \le 10^9$
- 每个测试用例，调用 `book` 函数最多不超过 `400` 次。

**示例**：

- 示例 1：

```python
输入
["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
输出
[null, 1, 1, 2, 3, 3, 3]

解释
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。
myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。
myCalendarThree.book(5, 10); // 返回 3
myCalendarThree.book(25, 55); // 返回 3
```

## 解题思路

### 思路 1：线段树

这道题可以使用线段树来做。

因为区间的范围是 $[0, 10^9]$，普通数组构成的线段树不满足要求。需要用到动态开点线段树。

- 构建一棵线段树。每个线段树的节点类存储当前区间中保存的日程区间个数。

- 在 `book` 方法中，在线段树中更新 `[start, end - 1]` 的交叉日程区间个数，即令其区间值整体加 `1`。

- 然后从线段树中查询区间 $[0, 10^9]$ 上保存的交叉日程区间个数，并返回。


### 思路 1：代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, left=-1, right=-1, val=0, lazy_tag=None, leftNode=None, rightNode=None):
        self.left = left                            # 区间左边界
        self.right = right                          # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = leftNode                    # 区间左节点
        self.rightNode = rightNode                  # 区间右节点
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = lazy_tag                    # 区间问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, function):
        self.tree = SegTreeNode(0, int(1e9))
        self.function = function                    # function 是一个函数，左右区间的聚合方法
            
    # 单点更新，将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.__update_point(i, val, self.tree)
    
    # 区间更新，将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.tree)
        
    # 区间查询，查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.tree)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self, length):
        nums = [0 for _ in range(length)]
        for i in range(length):
            nums[i] = self.query_interval(i, i)
        return nums
    
    
    # 以下为内部实现方法
    
    # 单点更新，将 nums[i] 更改为 val。node 节点的区间为 [node.left, node.right]
    def __update_point(self, i, val, node):
        if node.left == node.right:
            node.val = val                          # 叶子节点，节点值修改为 val
            return
        
        if i <= node.mid:                           # 在左子树中更新节点值
            self.__update_point(i, val, node.leftNode)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, node.rightNode)
        self.__pushup(node)                         # 向上更新节点的区间值
    
    # 区间更新
    def __update_interval(self, q_left, q_right, val, node):
        if node.left >= q_left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            if node.lazy_tag is not None:
                node.lazy_tag += val                # 将当前节点的延迟标记增加 val
            else:
                node.lazy_tag = val                 # 将当前节点的延迟标记增加 val
            node.val += val                         # 当前节点所在区间增加 val
            return
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
    
        if q_left <= node.mid:                      # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:                      # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
            
        self.__pushup(node)
    
    # 区间查询，在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if node.left >= q_left and node.right <= q_right:   # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.val                         # 直接返回节点值
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
                                  
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
        
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= node.mid:                      # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, node.leftNode)
        if q_right > node.mid:                      # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, node.rightNode)
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果

    # 向上更新 node 节点区间值，节点的区间值等于该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.leftNode and node.rightNode:
            node.val = self.function(node.leftNode.val, node.rightNode.val)
    
    # 向下更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if node.leftNode is None:
            node.leftNode = SegTreeNode(node.left, node.mid)
        if node.rightNode is None:
            node.rightNode = SegTreeNode(node.mid + 1, node.right)
            
        lazy_tag = node.lazy_tag
        if node.lazy_tag is None:
            return
            
        if node.leftNode.lazy_tag is not None:
            node.leftNode.lazy_tag += lazy_tag      # 更新左子节点懒惰标记
        else:
            node.leftNode.lazy_tag = lazy_tag       # 更新左子节点懒惰标记
        node.leftNode.val += lazy_tag               # 左子节点区间增加 lazy_tag
        
        if node.rightNode.lazy_tag is not None:
            node.rightNode.lazy_tag += lazy_tag     # 更新右子节点懒惰标记
        else:
            node.rightNode.lazy_tag = lazy_tag      # 更新右子节点懒惰标记
        node.rightNode.val += lazy_tag              # 右子节点区间增加 lazy_tag
        
        node.lazy_tag = None                        # 更新当前节点的懒惰标记


class MyCalendarThree:

    def __init__(self):
        self.STree = SegmentTree(lambda x, y: max(x, y))


    def book(self, start: int, end: int) -> int:
        self.STree.update_interval(start, end - 1, 1)
        return self.STree.query_interval(0, int(1e9))



# Your MyCalendarThree object will be instantiated and called as such:
# obj = MyCalendarThree()
# param_1 = obj.book(start,end)
```
# [0733. 图像渲染](https://leetcode.cn/problems/flood-fill/)

- 标签：深度优先搜索、广度优先搜索、数组、矩阵
- 难度：简单

## 题目链接

- [0733. 图像渲染 - 力扣](https://leetcode.cn/problems/flood-fill/)

## 题目大意

给定一个二维数组 image 表示图画，数组的每个元素值表示该位置的像素值大小。再给定一个坐标 (sr, sc) 表示图像渲染开始的位置。然后再给定一个新的颜色值 newColor。现在要求：将坐标 (sr, sc) 以及 (sr, sc) 相连的上下左右区域上与 (sr, sc) 原始颜色相同的区域染色为 newColor。返回染色后的二维数组。



## 解题思路

从起点开始，对上下左右四个方向进行广度优先搜索。每次搜索到一个位置时，如果该位置上的像素值与初始位置像素值相同，则更新该位置像素值，并将该位置加入队列中。最后将二维数组返回。

- 注意：如果起点位置初始颜色和新颜色值 newColor 相同，则不需要染色，直接返回原数组即可。

## 代码

```python
import collections

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if newColor == image[sr][sc]:
            return image
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        queue = collections.deque([(sr, sc)])
        oriColor = image[sr][sc]
        while queue:
            point = queue.popleft()
            image[point[0]][point[1]] = newColor
            for direction in directions:
                new_i = point[0] + direction[0]
                new_j = point[1] + direction[1]
                if 0 <= new_i < len(image) and 0 <= new_j < len(image[0]) and image[new_i][new_j] == oriColor:
                    queue.append((new_i, new_j))
        return image
```

# [0735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

- 标签：栈、数组
- 难度：中等

## 题目链接

- [0735. 行星碰撞 - 力扣](https://leetcode.cn/problems/asteroid-collision/)

## 题目大意

给定一个整数数组 `asteroids`，表示在同一行的小行星。

数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。小行星按照下面的规则发生碰撞。

-  碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

要求：找出碰撞后剩下的所有小行星，将答案存入数组并返回。

## 解题思路

用栈模拟小行星碰撞，具体步骤如下：

- 遍历数组 `asteroids`。
- 如果栈为空或者当前元素 `asteroid` 为正数，将其压入栈。
- 如果当前栈不为空并且当前元素 `asteroid` 为负数：
  - 与栈中元素发生碰撞，判断当前元素和栈顶元素的大小和方向，如果栈顶元素为正数，并且当前元素的绝对值大于栈顶元素，则将栈顶元素弹出，并继续与栈中元素发生碰撞。
  - 碰撞完之后，如果栈为空并且栈顶元素为负数，则将当前元素 `asteroid` 压入栈，表示碰撞完剩下了 `asteroid`。
  - 如果栈顶元素恰好与当前元素值大小相等、方向相反，则弹出栈顶元素，表示碰撞完两者都爆炸了。
- 最后返回栈作为答案。

## 代码

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for asteroid in asteroids:
            if not stack or asteroid > 0:
                stack.append(asteroid)
            else:
                while stack and 0 < stack[-1] < -asteroid:
                    stack.pop()
                if not stack or stack[-1] < 0:
                    stack.append(asteroid)
                elif stack[-1] == -asteroid:
                    stack.pop()

        return stack
```

# [0738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

- 标签：贪心、数学
- 难度：中等

## 题目链接

- [0738. 单调递增的数字 - 力扣](https://leetcode.cn/problems/monotone-increasing-digits/)

## 题目大意

给定一个非负整数 n，找出小于等于 n 的最大整数，同时该整数需要满足其各个位数上的数字是单调递增的。

## 解题思路

为了方便操作，我们先将整数 n 转为 list 数组，即 n_list。

题目要求这个整数尽可能的大，那么这个数从高位开始，就应该尽可能的保持不变。那么我们需要从高位到低位，找到第一个满足 `n_list[i - 1] > n_list[i]` 的位置，然后把 `n_list[i] - 1`，再把剩下的低位都变为 9。 

##  代码

```python
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        n_list = list(str(n))
        size = len(n_list)
        start_i = size
        for i in range(size - 1, 0, -1):
            if n_list[i - 1] > n_list[i]:
                start_i = i
                n_list[i - 1] = chr(ord(n_list[i - 1]) - 1)

        for i in range(start_i, size, 1):
            n_list[i] = '9'
        res = int(''.join(n_list))
        return res
```

# [0739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

- 标签：栈、数组、单调栈
- 难度：中等

## 题目链接

- [0739. 每日温度 - 力扣](https://leetcode.cn/problems/daily-temperatures/)

## 题目大意

**描述**：给定一个列表 `temperatures`，`temperatures[i]` 表示第 `i` 天的气温。

**要求**：输出一个列表，列表上每个位置代表「如果要观测到更高的气温，至少需要等待的天数」。如果之后的气温不再升高，则用 `0` 来代替。

**说明**：

- $1 \le temperatures.length \le 10^5$。
- $30 \le temperatures[i] \le 100$。

**示例**：

- 示例 1：

```python
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

- 示例 2：

```python
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

## 解题思路

题目的意思实际上就是给定一个数组，每个位置上有整数值。对于每个位置，在该位置右侧找到第一个比当前元素更大的元素。求「该元素」与「右侧第一个比当前元素更大的元素」之间的距离，将所有距离保存为数组返回结果。

最简单的思路是对于每个温度值，向后依次进行搜索，找到比当前温度更高的值。

更好的方式使用「单调递增栈」，栈中保存元素的下标。

### 思路 1：单调栈

1. 首先，将答案数组 `ans` 全部赋值为 0。然后遍历数组每个位置元素。
2. 如果栈为空，则将当前元素的下标入栈。
3. 如果栈不为空，且当前数字大于栈顶元素对应数字，则栈顶元素出栈，并计算下标差。
4. 此时当前元素就是栈顶元素的下一个更高值，将其下标差存入答案数组 `ans` 中保存起来，判断栈顶元素。
5. 直到当前数字小于或等于栈顶元素，则停止出栈，将当前元素下标入栈。
6. 最后输出答案数组 `ans`。

### 思路 1：代码

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n = len(T)
        stack = []
        ans = [0 for _ in range(n)]
        for i in range(n):
            while stack and T[i] > T[stack[-1]]:
                index = stack.pop()
                ans[index] = (i-index)
            stack.append(i)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0744. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [0744. 寻找比目标字母大的最小字母 - 力扣](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)

## 题目大意

**描述**：给你一个字符数组 $letters$，该数组按非递减顺序排序，以及一个字符 $target$。$letters$ 里至少有两个不同的字符。

**要求**：找出 $letters$ 中大于 $target$ 的最小的字符。如果不存在这样的字符，则返回 $letters$ 的第一个字符。

**说明**：

- $2 \le letters.length \le 10^4$。
- $letters[i]$$ 是一个小写字母。
- $letters$ 按非递减顺序排序。
- $letters$ 最少包含两个不同的字母。
- $target$ 是一个小写字母。

**示例**：

- 示例 1：

```python
输入: letters = ["c", "f", "j"]，target = "a"
输出: "c"
解释：letters 中字典上比 'a' 大的最小字符是 'c'。
```

- 示例 2：

```python
输入: letters = ["c","f","j"], target = "c"
输出: "f"
解释：letters 中字典顺序上大于 'c' 的最小字符是 'f'。
```

## 解题思路

### 思路 1：二分查找

利用二分查找，找到比 $target$ 大的字母。注意 $target$ 可能大于 $letters$ 的所有字符，此时应返回 $letters$ 的第一个字母。

我们可以假定 $target$ 的取值范围为 $[0, len(letters)]$。当 $target$ 取到 $len(letters)$ 时，说明 $target$ 大于 $letters$ 的所有字符，对 $len(letters)$ 取余即可得到 $letters[0]$。

### 思路 1：代码

```python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        left = 0
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if letters[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return letters[left % n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 为字符数组 $letters$ 的长度。
- **空间复杂度**：$O(1)$。

# [0746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

- 标签：数组、动态规划
- 难度：简单

## 题目链接

- [0746. 使用最小花费爬楼梯 - 力扣](https://leetcode.cn/problems/min-cost-climbing-stairs/)

## 题目大意

给定一个数组 `cost` 代表一段楼梯，`cost[i]` 代表爬上第 `i` 阶楼梯醒酒药花费的体力值（下标从 `0` 开始）。

每爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

要求：找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 `0` 或 `1` 的元素作为初始阶梯。

## 解题思路

使用动态规划方法。

状态 `dp[i]` 表示为：到达第 `i` 个台阶所花费的最少体⼒。

则状态转移方程为： `dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]`。

表示为：到达第 `i` 个台阶所花费的最少体⼒ = 到达第 `i - 1` 个台阶所花费的最小体力 与 到达第 `i - 2` 个台阶所花费的最小体力中的最小值 + 到达第 `i` 个台阶所需要花费的体力值。

## 代码

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        size = len(cost)
        dp = [0 for _ in range(size + 1)]
        for i in range(2, size+1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        return dp[size]
```

# [0752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/)

- 标签：广度优先搜索、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [0752. 打开转盘锁 - 力扣](https://leetcode.cn/problems/open-the-lock/)

## 题目大意

**描述**：有一把带有四个数字的密码锁，每个位置上有 `0` ~ `9` 共 `10` 个数字。每次只能将其中一个位置上的数字转动一下。可以向上转，也可以向下转。比如：`1 -> 2`、`2 -> 1`。

密码锁的初始数字为：`0000`。现在给定一组表示死亡数字的字符串数组 `deadends`，和一个带有四位数字的目标字符串 `target`。

如果密码锁转动到 `deadends` 中任一字符串状态，则锁就会永久锁定，无法再次旋转。

**要求**：给出使得锁的状态由 `0000` 转动到 `target` 的最小的选择次数。如果无论如何不能解锁，返回 `-1` 。

**说明**：

- $1 \le deadends.length \le 500$
  $deadends[i].length == 4$
  $target.length == 4$
  $target$ 不在 $deadends$ 之中
  $target$ 和 $deadends[i]$ 仅由若干位数字组成。

**示例**：

- 示例 1：

```python
输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"
输出：6
解释：
可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。
注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，
因为当拨动到 "0102" 时这个锁就会被锁定。
```

- 示例 2：

```python
输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
输出：-1
解释：无法旋转到目标数字且不被锁定。
```

## 解题思路

### 思路 1：广度优先搜索

1. 定义 `visited` 为标记访问节点的 set 集合变量，`queue` 为存放节点的队列。
2. 将`0000` 状态标记为访问，并将其加入队列 `queue`。
3. 将当前队列中的所有状态依次出队，判断这些状态是否为死亡字符串。
   1. 如果为死亡字符串，则跳过该状态，否则继续执行。
   2. 如果为目标字符串，则返回当前路径长度，否则继续执行。

4. 枚举当前状态所有位置所能到达的所有状态（通过向上或者向下旋转），并判断是否访问过该状态。
5. 如果之前出现过该状态，则继续执行，否则将其存入队列，并标记访问。
6. 遍历完步骤 3 中当前队列中的所有状态，令路径长度加 `1`，继续执行 3 ~ 5 步，直到队列为空。
7. 如果队列为空，也未能到达目标状态，则返回 `-1`。

### 思路 1：代码

```python
import collections

class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        queue = collections.deque(['0000'])
        visited = set(['0000'])
        deadset = set(deadends)
        level = 0
        while queue:
            size = len(queue)
            for _ in range(size):
                cur = queue.popleft()
                if cur in deadset:
                    continue
                if cur == target:
                    return level
                for i in range(len(cur)):
                    up = self.upward_adjust(cur, i)
                    if up not in visited:
                        queue.append(up)
                        visited.add(up)
                    down = self.downward_adjust(cur, i)
                    if down not in visited:
                        queue.append(down)
                        visited.add(down)
            level += 1
        return -1

    def upward_adjust(self, s, i):
        s_list = list(s)
        if s_list[i] == '9':
            s_list[i] = '0'
        else:
            s_list[i] = chr(ord(s_list[i]) + 1)
        return "".join(s_list)

    def downward_adjust(self, s, i):
        s_list = list(s)
        if s_list[i] == '0':
            s_list[i] = '9'
        else:
            s_list[i] = chr(ord(s_list[i]) - 1)
        return "".join(s_list)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(10^d \times d^2 + m \times d)$。其中 $d$ 是数字的位数，$m$ 是数组 $deadends$ 的长度。
- **空间复杂度**：$O(10^D \times d + m)$。
# [0758. 字符串中的加粗单词](https://leetcode.cn/problems/bold-words-in-string/)

- 标签：字典树、数组、哈希表、字符串、字符串匹配
- 难度：中等

## 题目链接

- [0758. 字符串中的加粗单词 - 力扣](https://leetcode.cn/problems/bold-words-in-string/)

## 题目大意

给定一个关键词集合 `words` 和一个字符串 `s`。

要求：在所有 `s` 中出现的关键词前后位置上添加加粗闭合标签 `<b>` 和 `</b>`。如果两个子串有重叠部分，则将它们一起用一对闭合标签包围起来。同理，如果两个子字符串连续被加粗，那么你也需要把它们合起来用一对加粗标签包围。最后返回添加加粗标签后的字符串 `s`。

## 解题思路

构建字典树，将字符串列表 `words` 中所有字符串添加到字典树中。

然后遍历字符串 `s`，从每一个位置开始查询字典树。在第一个符合要求的单词前面添加 `<b>`。在连续符合要求的单词中的最后一个单词后面添加 `</b>`。

最后返回添加加粗标签后的字符串 `s`。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def boldWords(self, words: List[str], s: str) -> str:
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        size = len(s)
        bold_left, bold_right = -1, -1
        ans = ""
        for i in range(size):
            cur = trie_tree
            if s[i] in cur.children:
                bold_left = i
                while bold_left < size and s[bold_left] in cur.children:
                    cur = cur.children[s[bold_left]]
                    bold_left += 1
                    if cur.isEnd:
                        if bold_right == -1:
                            ans += "<b>"
                        bold_right = max(bold_left, bold_right)
            if i == bold_right:
                ans += "</b>"
                bold_right = -1
            ans += s[i]
        if bold_right >= 0:
            ans += "</b>"
        return ans
```

# [0763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

- 标签：贪心、哈希表、双指针、字符串
- 难度：中等

## 题目链接

- [0763. 划分字母区间 - 力扣](https://leetcode.cn/problems/partition-labels/)

## 题目大意

给定一个由小写字母组成的字符串 `s`。要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

要求：返回一个表示每个字符串片段的长度的列表。

## 解题思路

因为同一字母最多出现在一个片段中，则同一字母第一次出现的下标位置和最后一次出现的下标位置肯定在同一个片段中。

我们先遍历一遍字符串，用哈希表 letter_map 存储下每一个字母最后一次出现的下标位置。

为了得到尽可能的片段，我们使用贪心的思想：

- 从头开始遍历字符串，遍历同时维护当前片段的开始位置 start 和结束位置 end。
- 对于字符串中的每个字符 `s[i]`，得到当前字母的最后一次出现的下标位置 `letter_map[s[i]]`，则当前片段的结束位置一定不会早于 `letter_map[s[i]]`，所以更新 end 值为 `end = max(end, letter_map[s[i]])`。
- 当访问到 `i == end` 时，当前片段访问结束，当前片段的下标范围为 `[start, end]`，长度为 `end - start + 1`，将其长度加入答案数组，并更新 start 值为 `i + 1`，继续遍历。
- 最终返回答案数组。

## 代码

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        letter_map = dict()
        for i in range(len(s)):
            letter_map[s[i]] = i
        res = []
        start, end = 0, 0
        for i in range(len(s)):
            end = max(end, letter_map[s[i]])
            if i == end:
                res.append(end - start + 1)
                start = i + 1
        return res
```

# [0765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/)

- 标签：贪心、深度优先搜索、广度优先搜索、并查集、图
- 难度：困难

## 题目链接

- [0765. 情侣牵手 - 力扣](https://leetcode.cn/problems/couples-holding-hands/)

## 题目大意

**描述**：$n$ 对情侣坐在连续排列的 $2 \times n$ 个座位上，想要牵对方的手。人和座位用 $0 \sim 2 \times n - 1$ 的整数表示。情侣按顺序编号，第一对是 $(0, 1)$，第二对是 $(2, 3)$，以此类推，最后一对是 $(2 \times n - 2, 2 \times n - 1)$。

给定代表情侣初始座位的数组 `row`，`row[i]` 表示第 `i` 个座位上的人的编号。

**要求**：计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。每一次交换可以选择任意两人，让他们互换座位。

**说明**：

- $2 \times n == row.length$。
- $2 \le n \le 30$。
- $n$ 是偶数。
- $0 \le row[i] < 2 \times n$。
- $row$ 中所有元素均无重复。

**示例**：

- 示例 1：

```python
输入: row = [0,2,1,3]
输出: 1
解释: 只需要交换row[1]和row[2]的位置即可。
```

- 示例 2：

```python
输入: row = [3,2,0,1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。
```

## 解题思路

### 思路 1：并查集

先观察一下可以直接牵手的情侣特点：

- 编号一定相邻。
- 编号为一个奇数一个偶数。
- 偶数 + 1 = 奇数。

将每对情侣的编号 `(0, 1) (2, 3) (4, 5) ...` 除以 `2` 可以得到 `(0, 0) (1, 1) (2, 2) ...`，这样相同编号就代表是一对情侣。

1. 按照 `2` 个一组的顺序，遍历一下所有编号。
   1. 如果相邻的两人编号除以 `2` 相同，则两人是情侣，将其合并到一个集合中。
   2. 如果相邻的两人编号不同，则将其合并到同一个集合中，而这两个人分别都有各自的对象，所以在后续遍历中两个人各自的对象和他们同组上的另一个人一定都会并到统一集合中，最终形成一个闭环。比如 `(0, 1) (1, 3) (2, 0) (3, 2)`。假设闭环对数为 `k`，最少需要交换 `k  - 1` 次才能让情侣牵手。
2. 假设 `n` 对情侣中有 `m` 个闭环，则 `至少交换次数 = (n1 - 1) + (n2 - 1) + ... + (nn - 1) = n - m`。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        self.parent[root_x] = root_y
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        size = len(row)
        n = size // 2
        count = n
        union_find = UnionFind(n)
        for i in range(0, size, 2):
            if union_find.union(row[i] // 2, row[i + 1] // 2):
                count -= 1
        return n - count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \alpha(n))$。其中 $n$ 是数组  $row$ 长度，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n)$。# [0766. 托普利茨矩阵](https://leetcode.cn/problems/toeplitz-matrix/)

- 标签：数组、矩阵
- 难度：简单

## 题目链接

- [0766. 托普利茨矩阵 - 力扣](https://leetcode.cn/problems/toeplitz-matrix/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的矩阵 $matrix$。

**要求**：如果 $matrix$ 是托普利茨矩阵，则返回 `True`；否则返回 `False`。

**说明**：

- **托普利茨矩阵**：矩阵上每一条由左上到右下的对角线上的元素都相同。
- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 20$。
- $0 \le matrix[i][j] \le 99$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg)

```python
输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
输出：true
解释：
在上述矩阵中, 其对角线为: 
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。 
各条对角线上的所有元素均相同, 因此答案是 True。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg)

```python
输入：matrix = [[1,2],[2,2]]
输出：false
解释：
对角线 "[1, 2]" 上的元素不同。
```

## 解题思路

### 思路 1：简单模拟

1. 两层循环遍历矩阵，依次判断矩阵当前位置 $(i, j)$ 上的值 $matrix[i][j]$ 与其左上角位置 $(i - 1, j - 1)$ 位置上的值 $matrix[i - 1][j - 1]$ 是否相等。
2. 如果不相等，则返回 `False`。
3. 遍历完，则返回 `True`。

### 思路 1：代码

```python
class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(1, len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i][j] != matrix[i - 1][j - 1]:
                    return False
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$、$n$ 分别是矩阵 $matrix$ 的行数、列数。
- **空间复杂度**：$O(m \times n)$。
# [0771. 宝石与石头](https://leetcode.cn/problems/jewels-and-stones/)

- 标签：哈希表、字符串
- 难度：简单

## 题目链接

- [0771. 宝石与石头 - 力扣](https://leetcode.cn/problems/jewels-and-stones/)

## 题目大意

**描述**：给定一个字符串 $jewels$ 代表石头中宝石的类型，再给定一个字符串 $stones$ 代表你拥有的石头。$stones$ 中每个字符代表了一种你拥有的石头的类型。

**要求**：计算出拥有的石头中有多少是宝石。

**说明**：

- 字母区分大小写，因此 $a$ 和 $A$ 是不同类型的石头。
- $1 \le jewels.length, stones.length \le 50$。
- $jewels$ 和 $stones$ 仅由英文字母组成。
- $jewels$ 中的所有字符都是唯一的。

**示例**：

- 示例 1：

```python
输入：jewels = "aA", stones = "aAAbbbb"
输出：3
```

- 示例 2：

```python
输入：jewels = "z", stones = "ZZ"
输出：0
```

## 解题思路

### 思路 1：哈希表

1. 用 $count$ 来维护石头中的宝石个数。
2. 先使用哈希表或者集合存储宝石。
3. 再遍历数组 $stones$，并统计每块石头是否在哈希表中或集合中。
   1. 如果当前石头在哈希表或集合中，则令 $count$ 加 $1$。
   2. 如果当前石头不在哈希表或集合中，则不统计。
4. 最后返回 $count$。

### 思路 1：代码

```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        jewel_dict = dict()
        for jewel in jewels:
            jewel_dict[jewel] = 1
        count = 0
        for stone in stones:
            if stone in jewel_dict:
                count += 1
        return count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$，其中 $m$ 是字符串 $jewels$ 的长度，$n$ 是 $stones$ 的长度。
- **空间复杂度**：$O(m)$，其中 $m$ 是字符串 $jewels$ 的长度。

# [0778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、二分查找、矩阵、堆（优先队列）
- 难度：困难

## 题目链接

- [0778. 水位上升的泳池中游泳 - 力扣](https://leetcode.cn/problems/swim-in-rising-water/)

## 题目大意

**描述**：给定一个 $n \times n$ 大小的二维数组 $grid$，每一个方格的值 $grid[i][j]$ 表示为位置 $(i, j)$ 的高度。

现在要从左上角 $(0, 0)$ 位置出发，经过方格的一些点，到达右下角 $(n - 1, n - 1)$  位置上。其中所经过路径的花费为这条路径上所有位置的最大高度。

**要求**：计算从 $(0, 0)$ 位置到 $(n - 1, n - 1)$  的最优路径的花费。

**说明**：

- **最优路径**：路径上最大高度最小的那条路径。
- $n == grid.length$。
- $n == grid[i].length$。
- $1 \le n \le 50$。
- $0 \le grid[i][j] < n2$。
- $grid[i][j]$ 中每个值均无重复。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg)

```python
输入: grid = [[0,2],[1,3]]
输出: 3
解释:
时间为 0 时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)

```python
输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
输出: 16
解释: 最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的。
```

## 解题思路

### 思路 1：并查集

将整个网络抽象为一个无向图，每个点与相邻的点（上下左右）之间都存在一条无向边，边的权重为两个点之间的最大高度。

我们要找到左上角到右下角的最优路径，可以遍历所有的点，将所有的边存储到数组中，每条边的存储格式为 $[x, y, h]$，意思是编号 $x$ 的点和编号为 $y$ 的点之间的权重为 $h$。

然后按照权重从小到大的顺序，对所有边进行排序。

再按照权重大小遍历所有边，将其依次加入并查集中。并且每次都需要判断 $(0, 0)$ 点和 $(n - 1, n - 1)$ 点是否连通。

如果连通，则该边的权重即为答案。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        row_size = len(grid)
        col_size = len(grid[0])
        size = row_size * col_size
        edges = []
        for row in range(row_size):
            for col in range(col_size):
                if row < row_size - 1:
                    x = row * col_size + col
                    y = (row + 1) * col_size + col
                    h = max(grid[row][col], grid[row + 1][col])
                    edges.append([x, y, h])
                if col < col_size - 1:
                    x = row * col_size + col
                    y = row * col_size + col + 1
                    h = max(grid[row][col], grid[row][col + 1])
                    edges.append([x, y, h])

        edges.sort(key=lambda x: x[2])

        union_find = UnionFind(size)

        for edge in edges:
            x, y, h = edge[0], edge[1], edge[2]
            union_find.union(x, y)
            if union_find.is_connected(0, size - 1):
                return h
        return 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n \times \alpha(m \times n))$，其中 $\alpha$ 是反 Ackerman 函数。
- **空间复杂度**：$O(m \times n)$。

# [0779. 第K个语法符号](https://leetcode.cn/problems/k-th-symbol-in-grammar/)

- 标签：位运算、递归、数学
- 难度：中等

## 题目链接

- [0779. 第K个语法符号 - 力扣](https://leetcode.cn/problems/k-th-symbol-in-grammar/)

## 题目大意

**描述**：给定两个整数 $n$ 和 $k$​。我们可以按照下面的规则来生成字符串：

- 第一行写上一个 $0$。
- 从第二行开始，每一行将上一行的 $0$ 替换成 $01$，$1$ 替换为 $10$。

**要求**：输出第 $n$ 行字符串中的第 $k$ 个字符。

**说明**：

- $1 \le n \le 30$。
- $1 \le k \le 2^{n - 1}$。

**示例**：

- 示例 1：

```python
输入: n = 2, k = 1
输出: 0
解释: 
第一行: 0 
第二行: 01
```

- 示例 2：

```python
输入: n = 4, k = 4
输出: 0
解释: 
第一行：0
第二行：01
第三行：0110
第四行：01101001
```

## 解题思路

### 思路 1：递归算法 + 找规律

每一行都是由上一行生成的。我们可以将多行写到一起找下规律。

可以发现：第 $k$ 个数字是由上一位对应位置上的数字生成的。 

- $k$ 在奇数位时，由上一行 $(k + 1) / 2$ 位置的值生成。且与上一行 $(k + 1) / 2$ 位置的值相同；
- $k$ 在偶数位时，由上一行 $k / 2$ 位置的值生成。且与上一行 $k / 2$ 位置的值相反。

接下来就是递归求解即可。

### 思路 1：代码

```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 0:
            return 0
        if k % 2 == 1:
            return self.kthGrammar(n - 1, (k + 1) // 2)
        else:
            return abs(self.kthGrammar(n - 1, k // 2) - 1)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

- 标签：树、深度优先搜索、广度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [0783. 二叉搜索树节点最小距离 - 力扣](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

## 题目大意

**描述**：给定一个二叉搜索树的根节点 $root$。

**要求**：返回树中任意两不同节点值之间的最小差值。

**说明**：

- **差值**：是一个正数，其数值等于两值之差的绝对值。
- 树中节点的数目范围是 $[2, 100]$。
- $0 \le Node.val \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

```python
输入：root = [4,2,6,1,3]
输出：1
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

```python
输入：root = [1,0,48,null,null,12,49]
输出：1
```

## 解题思路

### 思路 1：中序遍历

先来看二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

题目要求二叉搜索树上任意两节点的差的绝对值的最小值。

二叉树的中序遍历顺序是：左 -> 根 -> 右，二叉搜索树的中序遍历最终得到就是一个升序数组。而升序数组中绝对值差的最小值就是比较相邻两节点差值的绝对值，找出其中最小值。

那么我们就可以先对二叉搜索树进行中序遍历，并保存中序遍历的结果。然后再比较相邻节点差值的最小值，从而找出最小值。

### 思路 1：代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)

        inorder(root)
        return res

    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        inorder = self.inorderTraversal(root)
        ans = float('inf')
        for i in range(1, len(inorder)):
            ans = min(ans, abs(inorder[i - 1] - inorder[i]))

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉搜索树中的节点数量。
- **空间复杂度**：$O(n)$。

# [0784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/)

- 标签：位运算、字符串、回溯
- 难度：中等

## 题目链接

- [0784. 字母大小写全排列 - 力扣](https://leetcode.cn/problems/letter-case-permutation/)

## 题目大意

**描述**：给定一个字符串 $s$，通过将字符串 $s$ 中的每个字母转变大小写，我们可以获得一个新的字符串。

**要求**：返回所有可能得到的字符串集合。

**说明**：

- 答案可以以任意顺序返回输出。
- $1 \le s.length \le 12$。
- $s$ 由小写英文字母、大写英文字母和数字组成。

**示例**：

- 示例 1：

```python
输入：s = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]
```

- 示例 2：

```python
输入: s = "3z4"
输出: ["3z4","3Z4"]
```

## 解题思路

### 思路 1：回溯算法

- $i$ 代表当前要处理的字符在字符串 $s$ 中的下标，$path$ 表示当前路径，$ans$ 表示答案数组。
- 如果处理到 $i == len(s)$ 时，将当前路径存入答案数组中返回，否则进行递归处理。
  - 不修改当前字符，直接递归处理第 $i + 1$ 个字符。
  - 如果当前字符是小写字符，则变为大写字符之后，递归处理第 $i + 1$ 个字符。
  - 如果当前字符是大写字符，则变为小写字符之后，递归处理第 $i + 1$ 个字符。

### 思路 1：代码

```python
class Solution:
    def dfs(self, s, path, i, ans):
        if i == len(s):
            ans.append(path)
            return

        self.dfs(s, path + s[i], i + 1, ans)
        if ord('a') <= ord(s[i]) <= ord('z'):
            self.dfs(s, path + s[i].upper(), i + 1, ans)
        elif ord('A') <= ord(s[i]) <= ord('Z'):
            self.dfs(s, path + s[i].lower(), i + 1, ans)

    def letterCasePermutation(self, s: str) -> List[str]:
        ans, path = [], ""
        self.dfs(s, path, 0, ans)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$n \times 2^n$，其中 $n$ 为字符串的长度。
- **空间复杂度**：$O(1)$，除返回值外不需要额外的空间。

# [0785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0785. 判断二分图 - 力扣](https://leetcode.cn/problems/is-graph-bipartite/)

## 题目大意

给定一个代表 n 个节点的无向图的二维数组 `graph`，其中 `graph[u]` 是一个节点数组，由节点 `u` 的邻接节点组成。对于 `graph[u]` 中的每个 `v`，都存在一条位于节点 `u` 和节点 `v` 之间的无向边。

该无向图具有以下属性：

- 不存在自环（`graph[u]` 不包含 `u`）。
- 不存在平行边（`graph[u]` 不包含重复值）。
- 如果 `v` 在 `graph[u]` 内，那么 `u` 也应该在 `graph[v]` 内（该图是无向图）。
- 这个图可能不是连通图，也就是说两个节点 `u` 和 `v` 之间可能不存在一条连通彼此的路径。

要求：判断该图是否是二分图，如果是二分图，则返回 `True`；否则返回 `False`。

- 二分图：如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B`，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 二分图 。

## 解题思路

对于图中的任意节点 `u` 和 `v`，如果 `u` 和 `v` 之间有一条无向边，那么 `u` 和 `v` 必然属于不同的集合。

我们可以通过在深度优先搜索中对邻接点染色标记的方式，来识别该图是否是二分图。具体做法如下：

- 找到一个没有染色的节点 `u`，将其染成红色。
- 然后遍历该节点直接相连的节点 `v`，如果该节点没有被染色，则将该节点直接相连的节点染成蓝色，表示两个节点不是同一集合。如果该节点已经被染色并且颜色跟 `u` 一样，则说明该图不是二分图，直接返回 `False`。
- 从上面染成蓝色的节点 `v` 出发，遍历该节点直接相连的节点。。。依次类推的递归下去。
- 如果所有节点都顺利染上色，则说明该图为二分图，返回 `True`。否则，如果在途中不能顺利染色，则返回 `False`。

## 代码

```python
class Solution:
    def dfs(self, graph, colors, i, color):
        colors[i] = color
        for j in graph[i]:
            if colors[j] == colors[i]:
                return False
            if colors[j] == 0 and not self.dfs(graph, colors, j, -color):
                return False
        return True

    def isBipartite(self, graph: List[List[int]]) -> bool:
        size = len(graph)
        colors = [0 for _ in range(size)]
        for i in range(size):
            if colors[i] == 0 and not self.dfs(graph, colors, i, 1):
                return False
        return True
```

# [0788. 旋转数字](https://leetcode.cn/problems/rotated-digits/)

- 标签：数学、动态规划
- 难度：中等

## 题目链接

- [0788. 旋转数字 - 力扣](https://leetcode.cn/problems/rotated-digits/)

## 题目大意

**描述**：给定搞一个正整数 $n$。

**要求**：计算从 $1$ 到 $n$ 中有多少个数 $x$ 是好数。

**说明**：

- **好数**：如果一个数 $x$ 的每位数字逐个被旋转 180 度之后，我们仍可以得到一个有效的，且和 $x$ 不同的数，则成该数为好数。
- 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。$0$、$1$ 和 $8$ 被旋转后仍然是它们自己；$2$ 和 $5$ 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，$2$ 和 $5$ 互为镜像）；$6$ 和 $9$ 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
- $n$ 的取值范围是 $[1, 10000]$。

**示例**：

- 示例 1：

```python
输入: 10
输出: 4
解释: 
在 [1, 10] 中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
```

## 解题思路

### 思路 1：枚举算法

根据题目描述，一个数满足：数中没有出现 $3$、$4$、$7$，并且至少出现一次 $2$、$5$、$6$ 或 $9$，就是好数。

因此，我们可以枚举 $[1, n]$ 中的每一个正整数 $x$，并判断该正整数 $x$ 的数位中是否满足没有出现 $3$、$4$、$7$，并且至少一次出现了 $2$、$5$、$6$ 或 $9$，如果满足，则该正整数 $x$ 位好数，否则不是好数。

最后统计好数的方案个数并将其返回即可。

### 思路 1：代码

```python
class Solution:
    def rotatedDigits(self, n: int) -> int:
        check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1]
        ans = 0
        for i in range(1, n + 1):
            flag = False
            num = i
            while num:
                digit = num % 10
                num //= 10
                if check[digit] == 1:
                    flag = True
                elif check[digit] == -1:
                    flag = False
                    break
            if flag:
                ans += 1
            	
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(\log n)$。

### 思路 2：动态规划 + 数位 DP

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, hasDiff, isLimit):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。其中：

1. $pos$ 表示当前枚举的数位位置。
2. $hasDiff$ 表示当前是否用到 $2$、$5$、$6$ 或 $9$ 中任何一个数字。
3. $isLimit$ 表示前一位数位是否等于上界，用于限制本次搜索的数位范围。

接下来按照如下步骤进行递归。

1. 从 `dfs(0, False, True)` 开始递归。 `dfs(0, False, True)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 初始没有用到 $2$、$5$、$6$ 或 $9$ 中任何一个数字。
   3. 开始时受到数字 $n$ 对应最高位数位的约束。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
   1. 如果 $hasDiff == True$，说明当前方案符合要求，则返回方案数 $1$。
   2. 如果 $hasDiff == False$，说明当前方案不符合要求，则返回方案数 $0$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 因为不需要考虑前导 $0$，所以当前所能选择的最小数字 $minX$ 为 $0$。
5. 根据 $isLimit$ 来决定填当前位数位所能选择的最大数字（$maxX$）。
6. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
7. 如果当前数位与之前数位没有出现 $3$、$4$、$7$，则方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, hasDiff or check[d], isLimit and d == maxX)`。
   1. `hasDiff or check[d]` 表示当前是否用到 $2$、$5$、$6$ 或 $9$ 中任何一个数字或者没有用到 $3$、$4$、$7$。
   2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位限制和 $pos$ 位限制。
8. 最后的方案数为 `dfs(0, False, True)`，将其返回即可。

### 思路 2：代码

```python
class Solution:
    def rotatedDigits(self, n: int) -> int:
        check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1]

        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # hasDiff: 之前选过的数字是否包含 2,5,6,9 中至少一个。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        def dfs(pos, hasDiff, isLimit):
            if pos == len(s):
                # isNum 为 True，则表示当前方案符合要求
                return int(hasDiff)
            
            ans = 0
            # 不需要考虑前导 0，则最小可选择数字为 0
            minX = 0
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                # d 不在选择的数字集合中，即之前没有选择过 d
                if check[d] != -1:
                    ans += dfs(pos + 1, hasDiff or check[d], isLimit and d == maxX)
            return ans
    
        return dfs(0, False, True)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。

# [0795. 区间子数组个数](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

- 标签：数组、双指针
- 难度：中等

## 题目链接

- [0795. 区间子数组个数 - 力扣](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

## 题目大意

给定一个元素都是正整数的数组`A` ，正整数 `L` 以及 `R` (`L <= R`)。

求连续、非空且其中最大元素满足大于等于`L` 小于等于`R`的子数组个数。

## 解题思路

最大元素满足大于等于`L` 小于等于`R`的子数组个数 = 最大元素小于等于 `R` 的子数组个数 - 最大元素小于 `L` 的子数组个数。

其中「最大元素小于 `L` 的子数组个数」也可以转变为「最大元素小于等于 `L - 1` 的子数组个数」。那么现在的问题就变为了如何计算最大元素小于等于 `k` 的子数组个数。

我们使用 `count` 记录 小于等于 `k` 的连续元素数量，遍历一遍数组，如果遇到 `nums[i] <= k` 时，`count` 累加，表示在此位置上结束的有效子数组数量为 `count + 1`。如果遇到 `nums[i] > k` 时，`count` 重新开始计算。每次遍历完将有效子数组数量累加到答案中。

## 代码

```python
class Solution:
    def numSubarrayMaxK(self, nums, k):
        ans = 0
        count = 0
        for i in range(len(nums)):
            if nums[i] <= k:
                count += 1
            else:
                count = 0
            ans += count
        return ans

    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        return self.numSubarrayMaxK(nums, right) - self.numSubarrayMaxK(nums, left - 1)
```

# [0796. 旋转字符串](https://leetcode.cn/problems/rotate-string/)

- 标签：字符串、字符串匹配
- 难度：简单

## 题目链接

- [0796. 旋转字符串 - 力扣](https://leetcode.cn/problems/rotate-string/)

## 题目大意

**描述**：给定两个字符串 `s` 和 `goal`。

**要求**：如果 `s` 在若干次旋转之后，能变为 `goal`，则返回 `True`，否则返回 `False`。

**说明**：

- `s` 的旋转操作：将 `s` 最左侧的字符移动到最右边。
  - 比如：`s = "abcde"`，在旋转一次之后结果就是 `s = "bcdea"`。
- $1 \le s.length, goal.length \le 100$。
- `s` 和 `goal` 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入: s = "abcde", goal = "cdeab"
输出: true
```

- 示例 2：

```python
输入: s = "abcde", goal = "abced"
输出: false
```

## 解题思路

### 思路 1：KMP 算法

其实将两个字符串 `s` 拼接在一起，就包含了所有从 `s` 进行旋转后的字符串。那么我们只需要判断一下 `goal` 是否为 `s + s` 的子串即可。可以用 KMP 算法来做。

1. 先排除掉几种不可能的情况，比如 `s` 为空串的情况，`goal` 为空串的情况，`len(s) != len(goal)` 的情况。
2. 然后使用 KMP 算法计算出 `goal` 在 `s + s` 中的下标位置 `index`（`s + s` 可用取余运算模拟）。
3. 如果 `index == -1`，则说明 `s` 在若干次旋转之后，不能能变为 `goal`，则返回 `False`。
4. 如果 `index != -1`，则说明 `s` 在若干次旋转之后，能变为 `goal`，则返回 `True`。

### 思路 1：代码

```python
class Solution:
    def kmp(self, T: str, p: str) -> int:
        n, m = len(T), len(p)

        next = self.generateNext(p)

        i, j = 0, 0
        while i - j < n:
            while j > 0 and T[i % n] != p[j]:
                j = next[j - 1]
            if T[i % n] == p[j]:
                j += 1
            if j == m:
                return i - m + 1
            i += 1
        return -1

    def generateNext(self, p: str):
        m = len(p)
        next = [0 for _ in range(m)]

        left = 0
        for right in range(1, m):
            while left > 0 and p[left] != p[right]:
                left = next[left - 1]
            if p[left] == p[right]:
                left += 1
            next[right] = left

        return next

    def rotateString(self, s: str, goal: str) -> bool:
        if not s or not goal or len(s) != len(goal):
            return False
        index = self.kmp(s, goal)
        if index == -1:
            return False
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中文本串 $s$ 的长度为 $n$，模式串 $goal$ 的长度为 $m$。
- **空间复杂度**：$O(m)$。
# [0797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

- 标签：深度优先搜索、广度优先搜索、图、回溯
- 难度：中等

## 题目链接

- [0797. 所有可能的路径 - 力扣](https://leetcode.cn/problems/all-paths-from-source-to-target/)

## 题目大意

给定一个有 `n` 个节点的有向无环图（DAG），用二维数组 `graph` 表示。

要求：找出所有从节点 `0` 到节点 `n - 1` 的路径并输出（不要求按特定顺序）。

二维数组 `graph` 的第 `i` 个数组 `graph[i]` 中的单元都表示有向图中 `i` 号节点所能到达的下一个节点，如果为空就是没有下一个结点了。

## 解题思路

从第 `0` 个节点开始进行深度优先搜索遍历。在遍历的同时，通过回溯来寻找所有路径。具体做法如下：

- 使用 `ans` 数组存放所有答案路径，使用 `path` 数组记录当前路径。
- 从第 `0` 个节点开始进行深度优先搜索遍历。
  - 如果当前开始节点 `start` 等于目标节点 `target`。则将当前路径 `path` 添加到答案数组 `ans` 中，并返回。
  - 然后遍历当前节点 `start` 所能达到的下一个节点。
    - 将下一个节点加入到当前路径中。
    - 从该节点出发进行深度优先搜索遍历。
    - 然后将下一个节点从当前路径中移出，进行回退操作。
- 最后返回答案数组 `ans`。

## 代码

```python
class Solution:
    def dfs(self, graph, start, target, path, ans):
        if start == target:
            ans.append(path[:])
            return
        for end in graph[start]:
            path.append(end)
            self.dfs(graph, end, target, path, ans)
            path.remove(end)

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        path = [0]
        ans = []
        self.dfs(graph, 0, len(graph) - 1, path, ans)
        return ans
```

# [0800. 相似 RGB 颜色](https://leetcode.cn/problems/similar-rgb-color/)

- 标签：数学、字符串、枚举
- 难度：简单

## 题目链接

- [0800. 相似 RGB 颜色 - 力扣](https://leetcode.cn/problems/similar-rgb-color/)

## 题目大意

**描述**：RGB 颜色 `"#AABBCC"` 可以简写成 `"#ABC"` 。例如，`"#1155cc"` 可以简写为 `"#15c"`。现在给定一个按 `"#ABCDEF"` 形式定义的字符串 `color` 表示 RGB 颜色。

**要求**：返回一个与 `color` 相似度最大并且可以简写的颜色。

**说明**：

- 两个颜色 `"#ABCDEF"` 和 `"#UVWXYZ"` 的相似度计算公式为：$-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2$。

**示例**：

- 示例 1：

```python
输入 color = "#09f166"
输出 "#11ee66"
解释： 因为相似度计算得出 -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73，这是所有可以简写的颜色中与 color 最相似的颜色
```

## 解题思路

### 思路 1：枚举算法

所有可以简写的颜色范围是 `"#000"` ~ `"#fff"`，共 $16^3 = 4096$ 种颜色。因此，我们可以枚举这些可以简写的颜色，并计算出其与 $color$的相似度，从而找出与 $color$ 最相似的颜色。具体做法如下：

- 将  $color$ 转换为十六进制数，即 `hex_color = int(color[1:], 16)`。
- 三重循环遍历 $R$、$G$、$B$ 三个通道颜色，每一重循环范围为 $0 \sim 15$。
- 计算出每一种可以简写的颜色对应的十六进制，即 $17 \times R \times (1 << 16) + 17 \times G \times (1 << 8) + 17 \times B$，$17$ 是 $0x11 = 16 + 1 = 17$，$(1 << 16)$ 为 $R$ 左移的位数，$17 \times R \times (1 << 16)$ 就表示 $R$ 通道上对应的十六进制数。$(1 << 8)$ 为 $G$ 左移的位数，$17 \times G \times (1 << 8)$ 就表示 $G$ 通道上对应的十六进制数。$17 \times B$ 就表示 $B$ 通道上对应的十六进制数。
- 然后我们根据 $color$ 的十六进制数，与每一个可以简写的颜色对应的十六进制数，计算出相似度，并找出大相似对应的颜色。将其转换为字符串，并输出。

### 思路 1：枚举算法代码

```python
class Solution:
    def similar(self, hex1, hex2):
        r1, g1, b1 = hex1 >> 16, (hex1 >> 8) % 256, hex1 % 256
        r2, g2, b2 = hex2 >> 16, (hex2 >> 8) % 256, hex2 % 256
        return - (r1 - r2) ** 2 - (g1 - g2) ** 2 - (b1 - b2) ** 2

    def similarRGB(self, color: str) -> str:
        ans = 0
        hex_color = int(color[1:], 16)
        for r in range(16):
            for g in range(16):
                for b in range(16):
                    hex_cur = 17 * r * (1 << 16) + 17 * g * (1 << 8) + 17 * b
                    if self.similar(hex_color, hex_cur) > self.similar(hex_color, ans):
                        ans = hex_cur
        
        return "#{:06x}".format(ans)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(16^3)$。
- **空间复杂度**：$O(1)$。
# [0801. 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [0801. 使序列递增的最小交换次数 - 力扣](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

## 题目大意

给定两个长度相等的整形数组 A 和 B。可以交换两个数组相同位置上的元素，比如 A[i] 与 B[i] 交换，可以交换多个位置，但要保证交换之后保证数组 A和数组 B 是严格递增的。

要求：返回使得数组 A和数组 B 保持严格递增状态的最小交换次数。假设给定的输入一定有效。

## 解题思路

可以用动态规划来做。

对于两个数组每一个位置上的元素 A[i] 和 B[i] 来说，只有两种情况：换或者不换。

动态规划的状态 `dp[i][j]` 表示为：第 i 个位置元素，不交换（j = 0）、交换（j = 1）状态时的最小交换次数。

如果数组元素个数只有一个，则：

- `dp[0][0] = 0` ，第 0 个元素不做交换，交换次数为 0。
- `dp[0][1] = 1`，第 0 个元素做交换，交换次数为 1。

如果有 2 个元素，为了保证两个数组中的相邻元素都为递增元素，则第 2 个元素交换与否与第 1 个元素有关。同理如果有多个元素，那么第 i 个元素交换与否，只与第 i - 1 个元素有关。现在来考虑第 i 个元素与第 i - 1 的元素的情况。

先按原本数组当前是否满足递增关系来划分，可以划分为：

- 原本数组都满足递增关系，即 `A[i - 1] < A[i]` 并且 `B[i - 1] < B[i]`。
- 不满足上述递增关系的情况，即 `A[i - 1] >= A[i]` 或者 `B[i - 1] >= B[i]`。

可以看出，不满足递增关系的情况下是肯定要交换的。只需要考虑交换第 i 位元素，还是第 i - 1 位元素。

- `dp[i][0] = dp[i - 1][1]`，第 i 位若不交换，则第 i - 1 位必须交换。
- `dp[i][1] = dp[i - 1][0] + 1`，第 i 位交换，则第 i - 1 位不能交换。

下面再来考虑原本数组都满足递增关系的情况。考虑两个数组间相邻元素的关系。

-  `A[i - 1] < B[i]` 并且 `B[i - 1] < A[i]`。
-  `A[i - 1] >= B[i]` 或者 `B[i - 1] >= A[i]`。

如果是 `A[i - 1] < B[i]` 并且 `B[i - 1] < A[i]` 情况下，第 i 位交换，与第 i - 1 位交换与否无关，则 `dp[i][j]` 只需取 `dp[i-1][j]` 上较小结果进行计算即可，即：

- `dp[i][0] = min(dp[i-1][0], dp[i-1][1])`
- `dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + 1`

如果是 `A[i - 1] >= B[i]` 或者 `B[i - 1] >= A[i]` 情况下，则如果第 i 位交换，则第 i - 1 位必须跟着交换。如果第 i 位不交换，则第 i - 1 为也不能交换，即：

- `dp[i][0] = dp[i - 1][0]`，如果第 i 位不交换，则第 i - 1 位也不交换。
- `dp[i][1] = dp[i - 1][1] + 1`，如果第 i 位交换，则第 i - 1 位也必须交换。

这样就考虑了所有的情况，最终返回最后一个元素，（交换、不交换）状态下的最小值即可。

## 代码

```python
class Solution:
    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
        size = len(nums1)
        dp = [[0 for _ in range(size)] for _ in range(size)]
        dp[0][1] = 1
        for i in range(1, size):
            if nums1[i - 1] < nums1[i] and nums2[i - 1] < nums2[i]:
                if nums1[i - 1] < nums2[i] and nums2[i - 1] < nums1[i]:
                    # 第 i 位交换，与第 i - 1 位交换与否无关
                    dp[i][0] = min(dp[i-1][0], dp[i-1][1])
                    dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + 1
                else:
                    # 如果第 i 位不交换，则第 i - 1 位也不交换
                    # 如果第 i 位交换，则第 i - 1 位也必须交换
                    dp[i][0] = dp[i - 1][0]
                    dp[i][1] = dp[i - 1][1] + 1
            else:
                dp[i][0] = dp[i - 1][1]         # 如果第 i 位若不交换，则第 i - 1 位必须交换
                dp[i][1] = dp[i - 1][0] + 1     # 如果第 i 位交换，则第 i - 1 位不能交换
        return min(dp[size - 1][0], dp[size - 1][1])
```

# [0802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [0802. 找到最终的安全状态 - 力扣](https://leetcode.cn/problems/find-eventual-safe-states/)

## 题目大意

**描述**：给定一个有向图 $graph$，其中 $graph[i]$ 是与节点 $i$ 相邻的节点列表，意味着从节点 $i$ 到节点 $graph[i]$ 中的每个节点都有一条有向边。

**要求**：找出图中所有的安全节点，将其存入数组作为答案返回，答案数组中的元素应当按升序排列。

**说明**：

- **终端节点**：如果一个节点没有连出的有向边，则它是终端节点。或者说，如果没有出边，则节点为终端节点。
- **安全节点**：如果从该节点开始的所有可能路径都通向终端节点，则该节点为安全节点。
- $n == graph.length$。
- $1 \le n \le 10^4$。
- $0 \le graph[i].length \le n$。
- $0 \le graph[i][j] \le n - 1$。
- $graph[i]$ 按严格递增顺序排列。
- 图中可能包含自环。
- 图中边的数目在范围 $[1, 4 \times 10^4]$ 内。

**示例**：

- 示例 1：

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)

```python
输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。
节点 5 和节点 6 是终端节点，因为它们都没有出边。
从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6。
```

- 示例 2：

```python
输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出：[4]
解释:
只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4。
```

## 解题思路

### 思路 1：拓扑排序

1. 根据题意可知，安全节点所对应的终点，一定是出度为 $0$ 的节点。而安全节点一定能在有限步内到达终点，则说明安全节点一定不在「环」内。
2. 我们可以利用拓扑排序来判断顶点是否在环中。
3. 为了找出安全节点，可以采取逆序建图的方式，将所有边进行反向。这样出度为 $0$ 的终点就变为了入度为 $0$ 的点。
4. 然后通过拓扑排序不断移除入度为 $0$ 的点之后，如果不在「环」中的点，最后入度一定为 $0$，这些点也就是安全节点。而在「环」中的点，最后入度一定不为 $0$。
5. 最后将所有安全的起始节点存入数组作为答案返回。

### 思路 1：代码

```python
class Solution:
    # 拓扑排序，graph 中包含所有顶点的有向边关系（包括无边顶点）
    def topologicalSortingKahn(self, graph: dict):
        indegrees = {u: 0 for u in graph}   # indegrees 用于记录所有节点入度
        for u in graph:
            for v in graph[u]:
                indegrees[v] += 1           # 统计所有节点入度
        
        # 将入度为 0 的顶点存入集合 S 中
        S = collections.deque([u for u in indegrees if indegrees[u] == 0])
        
        while S:
            u = S.pop()                     # 从集合中选择一个没有前驱的顶点 0
            for v in graph[u]:              # 遍历顶点 u 的邻接顶点 v
                indegrees[v] -= 1           # 删除从顶点 u 出发的有向边
                if indegrees[v] == 0:       # 如果删除该边后顶点 v 的入度变为 0
                    S.append(v)             # 将其放入集合 S 中
        
        res = []
        for u in indegrees:
            if indegrees[u] == 0:
                res.append(u)
        
        return res
        
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        graph_dict = {u: [] for u in range(len(graph))}

        for u in range(len(graph)):
            for v in graph[u]:
                graph_dict[v].append(u)     # 逆序建图

        return self.topologicalSortingKahn(graph_dict)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 是图中节点数目，$m$ 是图中边数目。
- **空间复杂度**：$O(n + m)$。

# [0803. 打砖块](https://leetcode.cn/problems/bricks-falling-when-hit/)

- 标签：并查集、数组、矩阵
- 难度：困难

## 题目链接

- [0803. 打砖块 - 力扣](https://leetcode.cn/problems/bricks-falling-when-hit/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的二元网格，其中 $1$ 表示砖块，$0$ 表示空白。砖块稳定（不会掉落）的前提是：

- 一块砖直接连接到网格的顶部。
- 或者至少有一块相邻（4 个方向之一）砖块稳定不会掉落时。

再给定一个数组 $hits$，这是需要依次消除砖块的位置。每当消除 $hits[i] = (row_i, col_i)$ 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。

**要求**：返回一个数组 $result$，其中 $result[i]$ 表示第 $i$ 次消除操作对应掉落的砖块数目。

**说明**：

- 消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
- $m == grid.length$。
- $n == grid[i].length$。
- $1 \le m, n \le 200$。
- $grid[i][j]$ 为 $0$ 或 $1$。
- $1 \le hits.length \le 4 \times 10^4$。
- $hits[i].length == 2$。
- $0 \le xi \le m - 1$。
- $0 \le yi \le n - 1$。
- 所有 $(xi, yi)$ 互不相同。

**示例**：

- 示例 1：

```python
输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
输出：[2]
解释：网格开始为：
[[1,0,0,0]，
 [1,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,1,1,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2]。
```

- 示例 2：

```python
输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
输出：[0,0]
解释：网格开始为：
[[1,0,0,0],
 [1,1,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0], 
 [1,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0]。
```

## 解题思路

### 思路 1：并查集

一个很直观的想法：

- 将所有砖块放入一个集合中。
- 根据 $hits$ 数组的顺序，每敲掉一块砖。则将这块砖与相邻（4 个方向）的砖块断开集合。
- 然后判断哪些砖块会掉落，从集合中删除会掉落的砖块，并统计掉落砖块的数量。
  - **掉落砖块的数目 = 击碎砖块之前与屋顶相连的砖块数目 - 击碎砖块之后与屋顶相连的砖块数目 - 1**。

涉及集合问题，很容易想到用并查集来做。但是并查集主要用于合并查找集合，不适合断开集合。我们可以反向思考问题：

- 先将 $hits$ 中的所有位置上的砖块敲掉。
- 将剩下的砖块建立并查集。
- 逆序填回被敲掉的砖块，并与相邻（4 个方向）的砖块合并。这样问题就变为了 **补上砖块会新增多少个砖块粘到屋顶**。

整个算法步骤具体如下：

1. 先将二维数组 $grid$ 复制一份到二维数组 $copy\underline{\hspace{0.5em}}gird$ 上。这是因为遍历 $hits$ 元素时需要判断原网格是空白还是被打碎的砖块。
2. 在 $copy\underline{\hspace{0.5em}}grid$ 中将 $hits$ 中打碎的砖块赋值为 $0$。
3. 建立并查集，将房顶上的砖块合并到一个集合中。
4. 逆序遍历 $hits$，将 $hits$ 中的砖块补到 $copy\underline{\hspace{0.5em}}grid$ 中，并计算每一步中有多少个砖块粘到屋顶上（与屋顶砖块在一个集合中），并存入答案数组对应位置。
5. 最后输出答案数组。

### 思路 1：代码

```python
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.size = [1 for _ in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        self.parent[root_x] = root_y
        self.size[root_y] += self.size[root_x]
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

    def get_size(self, x):
        root_x = self.find(x)
        return self.size[root_x]

class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        directions = {(0, 1), (1, 0), (-1, 0), (0, -1)}
        rows, cols = len(grid), len(grid[0])

        def is_area(x, y):
            return 0 <= x < rows and 0 <= y < cols

        def get_index(x, y):
            return x * cols + y

        copy_grid = [[grid[i][j] for j in range(cols)] for i in range(rows)]

        for hit in hits:
            copy_grid[hit[0]][hit[1]] = 0

        union_find = UnionFind(rows * cols + 1)

        for j in range(cols):
            if copy_grid[0][j] == 1:
                union_find.union(j, rows * cols)

        for i in range(1, rows):
            for j in range(cols):
                if copy_grid[i][j] == 1:
                    if copy_grid[i - 1][j] == 1:
                        union_find.union(get_index(i - 1, j), get_index(i, j))
                    if j > 0 and copy_grid[i][j - 1] == 1:
                        union_find.union(get_index(i, j - 1), get_index(i, j))

        size_hits = len(hits)
        res = [0 for _ in range(size_hits)]
        for i in range(size_hits - 1, -1, -1):
            x, y = hits[i][0], hits[i][1]
            if grid[x][y] == 0:
                continue
            origin = union_find.get_size(rows * cols)
            if x == 0:
                union_find.union(y, rows * cols)
            for direction in directions:
                new_x = x + direction[0]
                new_y = y + direction[1]
                if is_area(new_x, new_y) and copy_grid[new_x][new_y] == 1:
                    union_find.union(get_index(x, y), get_index(new_x, new_y))
            curr = union_find.get_size(rows * cols)
            res[i] = max(0, curr - origin - 1)
            copy_grid[x][y] = 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n \times \alpha(m \times n))$，其中 $\alpha$ 是反 Ackerman 函数。
- **空间复杂度**：$O(m \times n)$。

# [0804. 唯一摩尔斯密码词](https://leetcode.cn/problems/unique-morse-code-words/)

- 标签：数组、哈希表、字符串
- 难度：简单

## 题目链接

- [0804. 唯一摩尔斯密码词 - 力扣](https://leetcode.cn/problems/unique-morse-code-words/)

## 题目大意

**描述**：国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:

- `'a'` 对应 `".-"`，
- `'b'` 对应 `"-..."`，
- `'c'` 对应 `"-.-."` ，以此类推。

为了方便，所有 $26$ 个英文字母的摩尔斯密码表如下：

`[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]`

给定一个字符串数组 $words$，每个单词可以写成每个字母对应摩尔斯密码的组合。

- 例如，`"cab"` 可以写成 `"-.-..--..."` ，(即 `"-.-."` + `".-"` + `"-..."` 字符串的结合)。我们将这样一个连接过程称作单词翻译。

**要求**：对 $words$ 中所有单词进行单词翻译，返回不同单词翻译的数量。

**说明**：

- $1 \le words.length \le 100$。
- $1 \le words[i].length \le 12$。
- $words[i]$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
```

- 示例 2：

```python
输入：words = ["a"]
输出：1
```

## 解题思路

### 思路 1：模拟 + 哈希表

1. 根据题目要求，将所有单词都转换为对应摩斯密码。
2. 使用哈希表存储所有转换后的摩斯密码。
3. 返回哈希表中不同的摩斯密码个数（脊哈希表的长度）作为答案。

### 思路 1：代码

```Python
class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        table = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
        word_set = set()

        for word in words:
            word_mose = ""
            for ch in word:
                word_mose += table[ord(ch) - ord('a')]
            word_set.add(word_mose)

        return len(word_set)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(s)$，其中 $s$ 为数组 $words$ 中所有单词的长度之和。
- **空间复杂度**：$O(s)$。

# [0806. 写字符串需要的行数](https://leetcode.cn/problems/number-of-lines-to-write-string/)

- 标签：数组、字符串
- 难度：简单

## 题目链接

- [0806. 写字符串需要的行数 - 力扣](https://leetcode.cn/problems/number-of-lines-to-write-string/)

## 题目大意

**描述**：给定一个数组 $widths$，其中 $words[0]$ 代表 `'a'` 需要的单位，$words[1]$ 代表 `'b'` 需要的单位，…，$words[25]$ 代表 `'z'` 需要的单位。再给定一个字符串 $s$，现在需要将字符串 $s$ 从左到右写到每一行上，每一行的最大宽度为 $100$ 个单位，如果在写某个字符的时候使改行超过了 $100$ 个单位，那么我们应该将这个字母写到下一行。

**要求**：计算出能放下 $s$ 的最少行数，以及最后一行使用的宽度单位。

**说明**：

- 字符串 $s$ 的长度在 $[1, 1000]$ 的范围。
- $s$ 只包含小写字母。
- $widths$ 是长度为 $26$ 的数组。
- $widths[i]$ 值的范围在 $[2, 10]$。

**示例**：

- 示例 1：

```python
输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。
```

- 示例 2：

```python
输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
输出: [2, 4]
解释: 
除去字母'a'所有的字符都是相同的单位10，并且字符串 "bbbcccdddaa" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。
```

## 解题思路

### 思路 1：模拟

1. 使用变量 $line\underline{\hspace{0.5em}}cnt$ 记录行数，使用变量 $last\underline{\hspace{0.5em}}cnt$ 记录最后一行使用的单位数。
2. 遍历字符串，如果当前最后一行使用的单位数 + 当前字符需要的单位超过了 $100$，则：
   1. 另起一行填充字符。（即行数加 $1$，最后一行使用的单位数为当前字符宽度）。
3. 如果当前最后一行使用的单位数 + 当前字符需要的单位没有超过 $100$，则：
   1. 在当前行填充字符。（即最后一行使用的单位数累加上当前字符宽度）。

### 思路 1：代码

```python
class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        line_cnt, last_cnt = 1, 0
        for ch in s:
            width = widths[ord(ch) - ord('a')]
            if last_cnt + width > 100:
                line_cnt += 1
                last_cnt = width
            else:
                last_cnt += width
                
        return [line_cnt, last_cnt]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0811. 子域名访问计数](https://leetcode.cn/problems/subdomain-visit-count/)

- 标签：数组、哈希表、字符串、计数
- 难度：中等

## 题目链接

- [0811. 子域名访问计数 - 力扣](https://leetcode.cn/problems/subdomain-visit-count/)

## 题目大意

**描述**：网站域名是由多个子域名构成的。

- 例如 `"discuss.leetcode.com"` 的顶级域名为 `"com"`，二级域名为 `"leetcode.com"`，三级域名为 `"discuss.leetcode.com"`。

当访问 `"discuss.leetcode.com"` 时，也会隐式访问其父域名 `"leetcode.com"` 以及 `"com"`。

计算机配对域名的格式为 `"rep d1.d2.d3"` 或 `"rep d1.d2"`。其中 `rep` 表示访问域名的次数，`d1.d2.d3` 或 `d1.d2` 为域名本身。

- 例如：`"9001 discuss.leetcode.com"` 就是一个 计数配对域名 ，表示 `discuss.leetcode.com` 被访问了 `9001` 次。

现在给定一个由计算机配对域名组成的数组 `cpdomains`。

**要求**：解析每一个计算机配对域名，计算出所有域名的访问次数，并以数组形式返回。可以按任意顺序返回答案。

## 解题思路

这道题求解的是不同层级的域名的次数汇总，很容易想到使用哈希表。我们可以使用哈希表来统计不同层级的域名访问次数。具体做如下：

1. 如果数组 `cpdomains` 为空，直接返回空数组。
2. 使用哈希表 `times_dict` 存储不同层级的域名访问次数。
3. 遍历数组 `cpdomains`。对于每一个计算机配对域名 `cpdomain`：
    1. 先将计算机配对域名的访问次数 `times` 和域名 `domain` 进行分割。
    2. 然后将域名转为子域名数组 `domain_list`，逆序拼接不同等级的子域名 `sub_domain`。
    3. 如果子域名 `sub_domain` 没有出现在哈希表 `times_dict` 中，则在哈希表中存入 `sub_domain` 和访问次数 `times` 的键值对。
    4. 如果子域名 `sub_domain` 曾经出现在哈希表 `times_dict` 中，则在哈希表对应位置加上 `times`。
4. 遍历完之后，遍历哈希表 `times_dict`，将所有域名和访问次数拼接为字符串，存入答案数组中。
5. 最后返回答案数组。

## 代码

```python
class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        if not cpdomains:
            return []

        times_dict = dict()
        for cpdomain in cpdomains:
            tiems, domain = cpdomain.split()
            tiems = int(tiems)
            
            domain_list = domain.split('.')
            for i in range(len(domain_list) - 1, -1, -1):
                sub_domain = '.'.join(domain_list[i:])
                if sub_domain not in times_dict:
                    times_dict[sub_domain] = tiems
                else:
                    times_dict[sub_domain] += tiems
        
        res = []
        for key in times_dict.keys():
            res.append(str(times_dict[key]) + ' ' + key)
        return res
```

# [0814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0814. 二叉树剪枝 - 力扣](https://leetcode.cn/problems/binary-tree-pruning/)

## 题目大意

给定一棵二叉树的根节点 `root`，树的每个节点值要么是 `0`，要么是 `1`。

要求：剪除该二叉树中所有节点值为 `0` 的子树。

- 节点 `node` 的子树为： `node` 本身，以及所有 `node` 的后代。

## 解题思路

定义辅助方法 `containsOnlyZero(root)` 递归判断以 `root` 为根的子树中是否只包含 `0`。如果子树中只包含 `0`，则返回 `True`。如果子树中含有 `1`，则返回 `False`。当 `root` 为空时，也返回 `True`。

然后递归遍历二叉树，判断当前节点 `root` 是否只包含 `0`。如果只包含 `0`，则将其置空，返回 `None`。否则递归遍历左右子树，并设置对应的左右指针。

最后返回根节点 `root`。

## 代码

```python
class Solution:
    def containsOnlyZero(self, root: TreeNode):
        if not root:
            return True
        if root.val == 1:
            return False
        return self.containsOnlyZero(root.left) and self.containsOnlyZero(root.right)

    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        if self.containsOnlyZero(root):
            return None

        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        return root
```

# [0819. 最常见的单词](https://leetcode.cn/problems/most-common-word/)

- 标签：哈希表、字符串、计数
- 难度：简单

## 题目链接

- [0819. 最常见的单词 - 力扣](https://leetcode.cn/problems/most-common-word/)

## 题目大意

**描述**：给定一个字符串 $paragraph$ 表示段落，再给定搞一个禁用单词列表 $banned$。

**要求**：返回出现次数最多，同时不在禁用列表中的单词。

**说明**：

- 题目保证至少有一个词不在禁用列表中，而且答案唯一。
- 禁用列表 $banned$ 中的单词用小写字母表示，不含标点符号。
- 段落 $paragraph$ 只包含字母、空格和下列标点符号`!?',;.`
- 段落中的单词不区分大小写。
- $1 \le \text{段落长度} \le 1000$。
- $0 \le \text{禁用单词个数} \le 100$。
- $1 \le \text{禁用单词长度} \le 10$。
- 答案是唯一的，且都是小写字母（即使在 $paragraph$ 里是大写的，即使是一些特定的名词，答案都是小写的）。
- 不存在没有连字符或者带有连字符的单词。
- 单词里只包含字母，不会出现省略号或者其他标点符号。

**示例**：

- 示例 1：

```python
输入: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
输出: "ball"
解释: 
"hit" 出现了3次，但它是一个禁用的单词。
"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"）， 
"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。
```

- 示例 2：

```python
输入：
paragraph = "a."
banned = []
输出："a"
```

## 解题思路

### 思路 1：哈希表

1. 将禁用词列表转为集合 $banned\underline{\hspace{0.5em}}set$。
2. 遍历段落 $paragraph$，获取段落中的所有单词。
3. 判断当前单词是否在禁用词集合中，如果不在禁用词集合中，则使用哈希表对该单词进行计数。
4. 遍历完，找出哈希表中频率最大的单词，将该单词作为答案进行返回。

### 思路 1：代码

```python
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        banned_set = set(banned)
        cnts = Counter()

        word = ""
        for ch in paragraph:
            if ch.isalpha():
                word += ch.lower()
            else:
                if word and word not in banned_set:
                    cnts[word] += 1
                word = ""
        if word and word not in banned_set:
            cnts[word] += 1

        max_cnt, ans = 0, ""
        for word, cnt in cnts.items():
            if cnt > max_cnt:
                max_cnt = cnt
                ans = word
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 为段落 $paragraph$ 的长度，$m$ 是禁用词 $banned$ 的长度。
- **空间复杂度**：$O(n + m)$。

# [0820. 单词的压缩编码](https://leetcode.cn/problems/short-encoding-of-words/)

- 标签：字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [0820. 单词的压缩编码 - 力扣](https://leetcode.cn/problems/short-encoding-of-words/)

## 题目大意

给定一个单词数组 `words`。要求对 `words` 进行编码成一个助记字符串，用来帮助记忆。`words` 中拥有相同字符后缀的单词可以合并成一个单词，比如`time` 和 `me` 可以合并成 `time`。同时每个不能再合并的单词末尾以 `#` 为结束符，将所有合并后的单词排列起来就是一个助记字符串。

要求：返回对 `words` 进行编码的最小助记字符串 `s` 的长度。

## 解题思路

构建一个字典树。然后对字符串长度进行从小到大排序。

再依次将去重后的所有单词插入到字典树中。如果出现比当前单词更长的单词，则将短单词的结尾置为 `False`，意为替换掉短单词。

然后再依次在字典树中查询所有单词，「单词长度 + 1」就是当前不能在合并的单词，累加起来就是答案。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
            cur.isEnd = False
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        trie_tree = Trie()
        words = list(set(words))
        words.sort(key=lambda i: len(i))

        ans = 0
        for word in words:
            trie_tree.insert(word[::-1])

        for word in words:
            if trie_tree.search(word[::-1]):
                ans += len(word) + 1

        return ans
```

# [0821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)

- 标签：数组、双指针、字符串
- 难度：简单

## 题目链接

- [0821. 字符的最短距离 - 力扣](https://leetcode.cn/problems/shortest-distance-to-a-character/)

## 题目大意

**描述**：给定一个字符串 $s$ 和一个字符 $c$，并且 $c$ 是字符串 $s$ 中出现过的字符。

**要求**：返回一个长度与字符串 $s$ 想通的整数数组 $answer$，其中 $answer[i]$ 是字符串 $s$ 中从下标 $i$ 到离下标 $i$ 最近的字符 $c$ 的距离。

**说明**：

- 两个下标 $i$ 和 $j$ 之间的 **距离** 为 $abs(i - j)$ ，其中 $abs$ 是绝对值函数。
- $1 \le s.length \le 10^4$。
- $s[i]$ 和 $c$ 均为小写英文字母
- 题目数据保证 $c$ 在 $s$ 中至少出现一次。

**示例**：

- 示例 1：

```python
输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3，所以距离为 abs(0 - 3) = 3。
距下标 1 最近的 'e' 出现在下标 3，所以距离为 abs(1 - 3) = 2。
对于下标 4，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1。
距下标 8 最近的 'e' 出现在下标 6，所以距离为 abs(8 - 6) = 2。
```

- 示例 2：

```python
输入：s = "aaab", c = "b"
输出：[3,2,1,0]
```

## 解题思路

### 思路 1：两次遍历

第一次从左到右遍历，记录每个 $i$ 左边最近的 $c$ 的位置，并将其距离记录到 $answer[i]$ 中。

第二次从右到左遍历，记录每个 $i$ 右侧最近的 $c$ 的位置，并将其与第一次遍历左侧最近的 $c$ 的位置相比较，并将较小的距离记录到 $answer[i]$ 中。

### 思路 1：代码

```python
class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        size = len(s)
        ans = [size + 1 for _ in range(size)]

        pos = -1
        for i in range(size):
            if s[i] == c:
                pos = i
            if pos != -1:
                ans[i] = i - pos
        
        pos = -1
        for i in range(size - 1, -1, -1):
            if s[i] == c:
                pos = i
            if pos != -1:
                ans[i] = min(ans[i], pos - i)

        return ans

```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0824. 山羊拉丁文](https://leetcode.cn/problems/goat-latin/)

- 标签：字符串
- 难度：简单

## 题目链接

- [0824. 山羊拉丁文 - 力扣](https://leetcode.cn/problems/goat-latin/)

## 题目大意

**描述**：给定一个由若干单词组成的句子 $sentence$，单词之间由空格分隔。每个单词仅由大写和小写字母组成。

**要求**：将句子转换为「山羊拉丁文（Goat Latin）」，并返回将 $sentence$ 转换为山羊拉丁文后的句子。

**说明**：

- 山羊拉丁文的规则如下：
  - 如果单词以元音开头（`a`，`e`，`i`，`o`，`u`），在单词后添加 `"ma"`。
    - 例如，单词 `"apple"` 变为 `"applema"`。

  - 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加 `"ma"`。
    - 例如，单词 `"goat"` 变为 `"oatgma"`。

  - 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母 `a`，索引从 $1$ 开始。
    - 例如，在第一个单词后添加 `"a"` ，在第二个单词后添加 `"aa"`，以此类推。

- $1 \le sentence.length \le 150$。
- $sentence$ 由英文字母和空格组成。
- $sentence$ 不含前导或尾随空格。
- $sentence$ 中的所有单词由单个空格分隔。

**示例**：

- 示例 1：

```python
输入：sentence = "I speak Goat Latin"
输出："Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
```

- 示例 2：

```python
输入：sentence = "The quick brown fox jumped over the lazy dog"
输出："heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
```

## 解题思路

### 思路 1：模拟

1. 使用集合 $vowels$ 存储元音字符，然后将 $sentence$ 按照空格分隔成单词数组 $words$。
2. 遍历单词数组 $words$，对于当前单词 $word$，根据山羊拉丁文的规则，将其转为山羊拉丁文的单词，并存入答案数组 $res$ 中。
3. 遍历完之后将答案数组拼接为字符串并返回。

### 思路 1：代码

```python
class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])
        words = sentence.split(' ')
        res = []
        for i in range(len(words)):
            word = words[i]
            ans = ""
            if word[0] in vowels:
                ans += word + "ma"
            else:
                ans += word[1:] + word[0] + "ma"
            ans += 'a' * (i + 1)
            res.append(ans)

        return " ".join(res)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0830. 较大分组的位置](https://leetcode.cn/problems/positions-of-large-groups/)

- 标签：字符串
- 难度：简单

## 题目链接

- [0830. 较大分组的位置 - 力扣](https://leetcode.cn/problems/positions-of-large-groups/)

## 题目大意

**描述**：给定由小写字母构成的字符串 $s$。字符串 $s$ 包含一些连续的相同字符所构成的分组。

**要求**：找到每一个较大分组的区间，按起始位置下标递增顺序排序后，返回结果。

**说明**：

- **较大分组**：我们称所有包含大于或等于三个连续字符的分组为较大分组。

**示例**：

- 示例 1：

```python
输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
```

- 示例 2：

```python
输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
```

## 解题思路

### 思路 1：简单模拟

遍历字符串 $s$，统计出所有大于等于 $3$ 个连续字符的子字符串的开始位置与结束位置。具体步骤如下：

1. 令 $cnt = 1$，然后从下标 $1$ 位置开始遍历字符串 $s$。
	1. 如果 $s[i - 1] == s[i]$，则令 $cnt$ 加 $1$。
	2. 如果 $s[i - 1] \ne s[i]$，说明出现了不同字符，则判断之前连续字符个数 $cnt$ 是否大于等于 $3$。
	3. 如果 $cnt \ge 3$，则将对应包含 $cnt$ 个连续字符的子字符串的开始位置与结束位置存入答案数组中。
	4. 令 $cnt = 1$，重新开始记录连续字符个数。
2. 遍历完字符串 $s$，输出答案数组。

### 思路 1：代码

```python
class Solution:
    def largeGroupPositions(self, s: str) -> List[List[int]]:
        res = []
        cnt = 1
        size = len(s)
        for i in range(1, size):
            if s[i] == s[i - 1]:
                cnt += 1
            else:
                if cnt >= 3:
                    res.append([i - cnt, i - 1])
                cnt = 1
        if cnt >= 3:
            res.append([size - cnt, size - 1])
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [0832. 翻转图像](https://leetcode.cn/problems/flipping-an-image/)

- 标签：数组、双指针、矩阵、模拟
- 难度：简单

## 题目链接

- [0832. 翻转图像 - 力扣](https://leetcode.cn/problems/flipping-an-image/)

## 题目大意

给定一个二进制矩阵 `A` 代表图像，先将矩阵进行水平翻转，再进行翻转（将 0 变为 1，1 变为 0）。

## 解题思路

两重 for 循环，第二层 for 循环遍历到一半即可。对于 `image[i][j]`、`image[i][n-1-j]` 先水平翻转操作，再进行翻转。

## 代码

```python
class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        n = len(image)
        for i in range(n):
            for j in range((n+1)//2):
                image[i][j], image[i][n-1-j] = image[i][n-1-j], image[i][j]
                image[i][j] = 0 if image[i][j] == 1 else 1
                if j != n-1-j:
                    image[i][n-1-j] = 0 if image[i][n-1-j] == 1 else 1
        return image
```

# [0834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/)

- 标签：树、深度优先搜索、图、动态规划
- 难度：困难

## 题目链接

- [0834. 树中距离之和 - 力扣](https://leetcode.cn/problems/sum-of-distances-in-tree/)

## 题目大意

**描述**：给定一个无向、连通的树。树中有 $n$ 个标记为 $0 \sim n - 1$ 的节点以及 $n - 1$ 条边 。

给定整数 $n$ 和数组 $edges$，其中 $edges[i] = [ai, bi]$ 表示树中的节点 $ai$ 和 $bi$ 之间有一条边。

**要求**：返回长度为 $n$ 的数组 $answer$，其中 $answer[i]$ 是树中第 $i$ 个节点与所有其他节点之间的距离之和。

**说明**：

- $1 \le n \le 3 \times 10^4$。
- $edges.length == n - 1$。
- $edges[i].length == 2$。
- $0 \le ai, bi < n$。
- $ai \ne bi$。
- 给定的输入保证为有效的树。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg)

```python
输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
输出: [8,12,6,10,10,10]
解释: 树如图所示。
我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 
也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg)

```python
输入: n = 2, edges = [[1,0]]
输出: [1,1]
```

## 解题思路

### 思路 1：树形 DP + 二次遍历换根法

最容易想到的做法是：枚举 $n$ 个节点，以每个节点为根节点进行树形 DP。

对于节点 $u$，定义 $dp[u]$ 为：以节点 $u$ 为根节点的树，它的所有子节点到它的距离之和。

然后进行一轮深度优先搜索，在搜索的过程中得到以节点 $v$ 为根节点的树，节点 $v$ 与所有其他子节点之间的距离之和 $dp[v]$。还能得到子树的节点个数 $sizes[v]$。

对于节点 $v$ 来说，其对 $dp[u]$ 的贡献为：节点 $v$ 与所有其他子节点之间的距离之和，再加上需要经过 $u \rightarrow v$ 这条边的节点个数，即 $dp[v] + sizes[v]$。

可得到状态转移方程为：$dp[u] = \sum_{v \in graph[u]}(dp[v] + sizes[v])$。

这样，对于 $n$ 个节点来说，需要进行 $n$ 次树形 DP，这种做法的时间复杂度为 $O(n^2)$，而 $n$ 的范围为 $[1, 3 \times 10^4]$，这样做会导致超时，因此需要进行优化。

我们可以使用「二次遍历换根法」进行优化，从而在 $O(n)$ 的时间复杂度内解决这道题。

以编号为 $0$ 的节点为根节点，进行两次深度优先搜索。

1. 第一次遍历：从编号为 $0$ 的根节点开始，自底向上地计算出节点 $0$ 到其他的距离之和，记录在 $ans[0]$ 中。并且统计出以子节点为根节点的子树节点个数 $sizes[v]$。
2. 第二次遍历：从编号为 $0$ 的根节点开始，自顶向下地枚举每个点，计算出将每个点作为新的根节点时，其他节点到根节点的距离之和。如果当前节点为 $v$，其父节点为 $u$，则自顶向下计算出 $ans[u]$ 之后，我们将根节点从 $u$ 换为节点 $v$，子树上的点到新根节点的距离比原来都小了 $1$，非子树上剩下所有点到新根节点的距离比原来都大了 $1$。则可以据此计算出节点 $v$ 与其他节点的距离和为：$ans[v] = ans[u] + n - 2 \times sizes[u]$。

### 思路 1：代码

```python
class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]

        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)


        ans = [0 for _ in range(n)]

        sizes = [1 for _ in range(n)]
        def dfs(u, fa, depth):
            ans[0] += depth
            for v in graph[u]:
                if v == fa:
                    continue
                dfs(v, u, depth + 1)
                sizes[u] += sizes[v]

        def reroot(u, fa):
            for v in graph[u]:
                if v == fa:
                    continue
                ans[v] = ans[u] + n - 2 * size[v]
                reroot(v, u)

        dfs(0, -1, 0)
        reroot(0, -1)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树的节点个数。
- **空间复杂度**：$O(n)$。

# [0836. 矩形重叠](https://leetcode.cn/problems/rectangle-overlap/)

- 标签：几何、数学
- 难度：简单

## 题目链接

- [0836. 矩形重叠 - 力扣](https://leetcode.cn/problems/rectangle-overlap/)

## 题目大意

给定两个矩形的左下角、右上角坐标：[x1, y1, x2, y2]。[x1, y1] 表示左下角坐标，[x2, y2] 表示右上角坐标。如果两个矩形相交面积大于 0，则称两矩形重叠。

要求：根据给定的矩形 rec1 和 rec2 的左下角、右上角坐标，如果重叠，则返回 True，否则返回 False。

## 解题思路

如果两个矩形重叠，则两个矩形的水平边投影到 x 轴上的线段会有交集，同理竖直边投影到 y 轴上的线段也会有交集。因此我们可以把问题看做是：判断两条线段是否有交集。

矩形 rec1 和 rec2 水平边投影到 x 轴上的线段为 `(rec1[0], rec1[2])` 和 `(rec2[0], rec2[2])`。如果两条线段有交集，则 `min(rec1[2], rec2[2]) > max(rec1[0], rec2[0])`。

矩形 rec1 和 rec2 竖直边投影到 y 轴上的线段为 `(rec1[1], rec1[3])` 和 `(rec2[1], rec2[3])`。如果两条线段有交集，则 `min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])`。

判断是否满足上述条件，若满足则说明两个矩形重叠，返回 True，若不满足则返回 False。

## 代码

```python
class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
         return min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) and min(rec1[3], rec2[3]) > max(rec1[1], rec2[1])
```

# [0841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

- 标签：深度优先搜索、广度优先搜索、图
- 难度：中等

## 题目链接

- [0841. 钥匙和房间 - 力扣](https://leetcode.cn/problems/keys-and-rooms/)

## 题目大意

**描述**：有 `n` 个房间，编号为 `0` ~ `n - 1`，每个房间都有若干把钥匙，每把钥匙上都有一个编号，可以开启对应房间号的门。最初，除了 `0` 号房间外其他房间的门都是锁着的。

现在给定一个二维数组 `rooms`，`rooms[i][j]` 表示第 `i` 个房间的第 `j` 把钥匙所能开启的房间号。

**要求**：判断是否能开启所有房间的门。如果能开启，则返回 `True`。否则返回 `False`。

**说明**：

- $n == rooms.length$。
- $2 \le n \le 1000$。
- $0 \le rooms[i].length \le 1000$。
- $1 \le sum(rooms[i].length) \le 3000$。
- $0 \le rooms[i][j] < n$。
- 所有 $rooms[i]$ 的值互不相同。

**示例**：

- 示例 1：

```python
输入：rooms = [[1],[2],[3],[]]
输出：True
解释：
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
```

- 示例 2：

```python
输入：rooms = [[1,3],[3,0,1],[2],[0]]
输出：False
解释：我们不能进入 2 号房间。
```

## 解题思路

### 思路 1：深度优先搜索

当 `x` 号房间有 `y` 号房间的钥匙时，就可以认为我们可以通过 `x` 号房间去往 `y` 号房间。现在把 `n` 个房间看做是拥有 `n` 个节点的图，则上述关系可以看做是 `x` 与 `y` 点之间有一条有向边。

那么问题就变为了给定一张有向图，从 `0` 节点开始出发，问是否能到达所有的节点。

我们可以使用深度优先搜索的方式来解决这道题，具体做法如下：

1. 使用 set 集合变量 `visited` 来统计遍历到的节点个数。
2. 从 `0` 节点开始，使用深度优先搜索的方式遍历整个图。
3. 将当前节点 `x` 加入到集合 `visited` 中，遍历当前节点的邻接点。
   1. 如果邻接点不再集合 `visited` 中，则继续递归遍历。
4. 最后深度优先搜索完毕，判断一下遍历到的节点个数是否等于图的节点个数（即集合 `visited` 中的元素个数是否等于节点个数）。
   1. 如果等于，则返回 `True`
   2. 如果不等于，则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        def dfs(x):
            visited.add(x)
            for key in rooms[x]:
                if key not in visited:
                    dfs(key)
        visited = set()
        dfs(0)
        return len(visited) == len(rooms)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 是房间的数量，$m$ 是所有房间中的钥匙数量的总数。
- **空间复杂度**：$O(n)$，递归调用的栈空间深度不超过 $n$。# [0844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

- 标签：栈、双指针、字符串、模拟
- 难度：简单

## 题目链接

- [0844. 比较含退格的字符串 - 力扣](https://leetcode.cn/problems/backspace-string-compare/)

## 题目大意

**描述**：给定 $s$ 和 $t$ 两个字符串。字符串中的 `#` 代表退格字符。

**要求**：当它们分别被输入到空白的文本编辑器后，判断二者是否相等。如果相等，返回 $True$；否则，返回 $False$。

**说明**：

- 如果对空文本输入退格字符，文本继续为空。
- $1 \le s.length, t.length \le 200$。
- $s$ 和 $t$ 只含有小写字母以及字符 `#`。

**示例**：

- 示例 1：

```python
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

- 示例 2：

```python
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

## 解题思路

这道题的第一个思路是用栈，第二个思路是使用分离双指针。

### 思路 1：栈

- 定义一个构建方法，用来将含有退格字符串构建为删除退格的字符串。构建方法如下。
  - 使用一个栈存放删除退格的字符串。
  - 遍历字符串，如果遇到的字符不是 `#`，则将其插入到栈中。
  - 如果遇到的字符是 `#`，且当前栈不为空，则将当前栈顶元素弹出。
- 分别使用构建方法处理字符串 $s$ 和 $t$，如果处理完的字符串 $s$ 和 $t$ 相等，则返回 $True$，否则返回 $False$。

### 思路 1：代码

```python
class Solution:
    def build(self, s: str):
        stack = []
        for ch in s:
            if ch != '#':
                stack.append(ch)
            elif stack:
                stack.pop()
        return stack
        
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.build(s) == self.build(t)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 和 $m$ 分别为字符串 $s$、$t$ 的长度。
- **空间复杂度**：$O(n + m)$。

### 思路 2：分离双指针

由于 `#` 会消除左侧字符，而不会影响右侧字符，所以我们选择从字符串尾端遍历 $s$、$t$ 字符串。具体做法如下：

- 使用分离双指针 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$。$left\underline{\hspace{0.5em}}1$ 指向字符串 $s$ 末尾，$left\underline{\hspace{0.5em}}2$ 指向字符串 $t$ 末尾。使用 $sign\underline{\hspace{0.5em}}1$、$sign\underline{\hspace{0.5em}}2$ 标记字符串 $s$、$t$ 中当前退格字符个数。
- 从后到前遍历字符串 $s$、$t$。
  - 先来循环处理字符串 $s$ 尾端 `#` 的影响，具体如下：
    - 如果当前字符是 `#`，则更新 $s$ 当前退格字符个数，即 `sign_1 += 1`。同时将 $left\underline{\hspace{0.5em}}1$ 左移。 
    - 如果 $s$ 当前退格字符个数大于 $0$，则退格数减一，即 `sign_1 -= 1`。同时将 $left\underline{\hspace{0.5em}}1$ 左移。 
    - 如果 $s$ 当前为普通字符，则跳出循环。
  - 同理再来处理字符串 $t$ 尾端 `#` 的影响，具体如下：
    - 如果当前字符是 `#`，则更新 $t$ 当前退格字符个数，即 `sign_2 += 1`。同时将 $left\underline{\hspace{0.5em}}2$ 左移。 
    - 如果 $t$ 当前退格字符个数大于 $0$，则退格数减一，即 `sign_2 -= 1`。同时将 $left\underline{\hspace{0.5em}}2$ 左移。 
    - 如果 $t$ 当前为普通字符，则跳出循环。
  - 处理完，如果两个字符串为空，则说明匹配，直接返回 $True$。
  - 再先排除长度不匹配的情况，直接返回 $False$。
  - 最后判断 $s[left\underline{\hspace{0.5em}}1]$ 是否等于 $s[left\underline{\hspace{0.5em}}2]$。不等于则直接返回 $False$，等于则令 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$ 左移，继续遍历。
- 遍历完没有出现不匹配的情况，则返回 $True$。

### 思路 2：代码

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        left_1, left_2 = len(s) - 1, len(t) - 1
        sign_1, sign_2 = 0, 0
        while left_1 >= 0 or left_2 >= 0:
            while left_1 >= 0:
                if s[left_1] == '#':
                    sign_1 += 1
                    left_1 -= 1
                elif sign_1 > 0:
                    sign_1 -= 1
                    left_1 -= 1
                else:
                    break

            while left_2 >= 0:
                if t[left_2] == '#':
                    sign_2 += 1
                    left_2 -= 1
                elif sign_2 > 0:
                    sign_2 -= 1
                    left_2 -= 1
                else:
                    break

            if left_1 < 0 and left_2 < 0:
                return True
            if left_1 >= 0 and left_2 < 0:
                return False
            if left_1 < 0 and left_2 >= 0:
                return False
            if s[left_1] != t[left_2]:
                return False

            left_1 -= 1
            left_2 -= 1

        return True
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 和 $m$ 分别为字符串 $s$、$t$ 的长度。
- **空间复杂度**：$O(1)$。

# [0845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/)

- 标签：数组、双指针、动态规划、枚举
- 难度：中等

## 题目链接

- [0845. 数组中的最长山脉 - 力扣](https://leetcode.cn/problems/longest-mountain-in-array/)

## 题目大意

**描述**：给定一个整数数组 $arr$。

**要求**：返回最长山脉子数组的长度。如果不存在山脉子数组，返回 $0$。

**说明**：

- **山脉数组**：符合下列属性的数组 $arr$ 称为山脉数组。
  - $arr.length \ge 3$。
  - 存在下标 $i(0 < i < arr.length - 1)$ 满足：
    - $arr[0] < arr[1] < … < arr[i]$
    - $arr[i] > arr[i + 1] > … > arr[arr.length - 1]$

- $1 \le arr.length \le 10^4$。
- $0 \le arr[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：arr = [2,1,4,7,3,2,5]
输出：5
解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。
```

- 示例 2：

```python
输入：arr = [2,2,2]
输出：0
解释：不存在山脉子数组。
```

## 解题思路

### 思路 1：快慢指针

1. 使用变量 $ans$ 保存最长山脉长度。
2. 遍历数组，假定当前节点为山峰。
3. 使用双指针 $left$、$right$ 分别向左、向右查找山脉的长度。
4. 如果当前山脉的长度比最长山脉长度更长，则更新最长山脉长度。
5. 最后输出 $ans$。

### 思路 1：代码

```python
class Solution:
    def longestMountain(self, arr: List[int]) -> int:
        size = len(arr)
        res = 0
        for i in range(1, size - 1):
            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:
                left = i - 1
                right = i + 1

                while left > 0 and arr[left - 1] < arr[left]:
                    left -= 1
                while right < size - 1 and arr[right + 1] < arr[right]:
                    right += 1
                if right - left + 1 > res:
                    res = right - left + 1
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $arr$ 中的元素数量。
- **空间复杂度**：$O(1)$。

# [0846. 一手顺子](https://leetcode.cn/problems/hand-of-straights/)

- 标签：贪心、数组、哈希表、排序
- 难度：中等

## 题目链接

- [0846. 一手顺子 - 力扣](https://leetcode.cn/problems/hand-of-straights/)

## 题目大意

**描述**：`Alice` 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌都是顺子（即由连续的牌构成），并且每一组的牌数都是 `groupSize`。现在给定一个整数数组 `hand`，其中 `hand[i]` 是表示第 `i` 张牌的数值，和一个整数 `groupSize`。

**要求**：如果 `Alice` 能将这些牌重新排列成若干组、并且每组都是 `goupSize` 张牌的顺子，则返回 `True`；否则，返回 `False`。

**说明**：

- $1 \le hand.length \le 10^4$。
- $0 \le hand[i] \le 10^9$。
- $1 \le groupSize \le hand.length$。

**示例**：

- 示例 1：

```python
输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：True
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
```

## 解题思路

### 思路 1：哈希表 + 排序

1. 使用哈希表存储每个数出现的次数。
2. 将哈希表中每个键从小到大排序。
3. 从哈希表中最小的数开始，以它作为当前顺子的开头，然后依次判断顺子里的数是否在哈希表中，如果在的话，则将哈希表中对应数的数量减 `1`。不在的话，说明无法满足题目要求，直接返回 `False`。
4. 重复执行 2 ~ 3 步，直到哈希表为空。最后返回 `True`。

### 思路 1：哈希表 + 排序代码

```python
class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        hand_map = collections.defaultdict(int)
        for i in range(len(nums)):
            hand_map[nums[i]] += 1
        for key in sorted(hand_map.keys()):
            value = hand_map[key]
            if value == 0:
                continue
            count = 0
            for i in range(k):
                hand_map[key + count] -= value
                if hand_map[key + count] < 0:
                    return False
                count += 1
        return True
```
# [0847. 访问所有节点的最短路径](https://leetcode.cn/problems/shortest-path-visiting-all-nodes/)

- 标签：位运算、广度优先搜索、图、动态规划、状态压缩
- 难度：困难

## 题目链接

- [0847. 访问所有节点的最短路径 - 力扣](https://leetcode.cn/problems/shortest-path-visiting-all-nodes/)

## 题目大意

**描述**：存在一个由 $n$ 个节点组成的无向连通图，图中节点编号为 $0 \sim n - 1$。现在给定一个数组 $graph$ 表示这个图。其中，$graph[i]$ 是一个列表，由所有与节点 $i$ 直接相连的节点组成。

**要求**：返回能够访问所有节点的最短路径长度。可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。

**说明**：

- $n == graph.length$。
- $1 \le n \le 12$。
- $0 \le graph[i].length < n$。
- $graph[i]$ 不包含 $i$。
- 如果 $graph[a]$ 包含 $b$，那么 $graph[b]$ 也包含 $a$。
- 输入的图总是连通图。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)

```python
输入：graph = [[1,2,3],[0],[0],[0]]
输出：4
解释：一种可能的路径为 [1,0,2,0,3]
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)

```python
输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
输出：4
解释：一种可能的路径为 [0,1,4,2,3]
```

## 解题思路

### 思路 1：状态压缩 + 广度优先搜索

 题目需要求解的是「能够访问所有节点的最短路径长度」，并且每个节点都可以作为起始点。

如果对于一个特定的起点，我们可以将该起点放入队列中，然后对其进行广度优先搜索，并使用访问数组 $visited$ 标记访问过的节点，直到所有节点都已经访问过时，返回路径长度即为「从某点开始出发，所能够访问所有节点的最短路径长度」。

而本题中，每个节点都可以作为起始点，则我们可以直接将所有节点放入队列中，然后对所有节点进行广度优先搜索。

因为本题中节点数目 $n$ 的范围为 $[1, 12]$，所以我们可以采用「状态压缩」的方式，标记节点的访问情况。每个点的初始状态可以表示为 `(u, 1 << u)`。当状态 $state == 1 \text{ <}\text{< } n - 1$ 时，表示所有节点都已经访问过了，此时返回其对应路径长度即为「能够访问所有节点的最短路径长度」。

为了方便在广度优先搜索的同事，记录当前的「路径长度」以及「节点的访问情况」。我们可以使用一个三元组 $(u, state, dist)$ 来表示当前节点情况，其中：

- $u$：表示当前节点编号。
- $state$：一个 $n$ 位的二进制数，表示 $n$ 个节点的访问情况。$state$ 第 $i$ 位为 $0$ 时表示未访问过，$state$ 第 $i$ 位为 $1$ 时表示访问过。
- $dist$ 表示当前的「路径长度」。

同时为了避免重复搜索同一个节点 $u$ 以及相同节点的访问情况，我们可以使用集合记录 $(u, state)$ 是否已经被搜索过。

整个算法步骤如下：

1. 将所有节点的 `(节点编号, 起始状态, 路径长度)` 作为三元组存入队列，并使用集合 $visited$ 记录所有节点的访问情况。
2. 对所有点开始进行广度优先搜索：
   1. 从队列中弹出队头节点。
   2. 判断节点的当前状态，如果所有节点都已经访问过，则返回答案。
   3. 如果没有全访问过，则遍历当前节点的邻接节点。
   4. 将邻接节点的访问状态标记为访问过。
   5. 如果节点即当前路径没有访问过，则加入队列继续遍历，并标记为访问过。
3. 重复进行第 $2$ 步，直到队列为空。

### 思路 1：代码

```python
import collections


class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        size = len(graph)

        queue = collections.deque([])
        visited = set()
        for u in range(size):
            queue.append((u, 1 << u, 0))            # 将 (节点编号, 起始状态, 路径长度) 存入队列
            visited.add((u, 1 << u))                # 标记所有节点的节点编号，以及当前状态

        while queue:                                # 对所有点开始进行广度优先搜索
            u, state, dist = queue.popleft()        # 弹出队头节点
            if state == (1 << size) - 1:            # 所有节点都访问完，返回答案
                return dist
            for v in graph[u]:                      # 遍历邻接节点
                next_state = state | (1 << v)       # 标记邻接节点的访问状态
                if (v, next_state) not in visited:  # 如果节点即当前路径没有访问过，则加入队列继续遍历，并标记为访问过
                    queue.append((v, next_state, dist + 1))
                    visited.add((v, next_state))

        return 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times 2^n)$，其中 $n$ 为图的节点数量。
- **空间复杂度**：$O(n \times 2^n)$。

# [0850. 矩形面积 II](https://leetcode.cn/problems/rectangle-area-ii/)

- 标签：线段树、数组、有序集合、扫描线
- 难度：困难

## 题目链接

- [0850. 矩形面积 II - 力扣](https://leetcode.cn/problems/rectangle-area-ii/)

## 题目大意

**描述**：给定一个二维矩形列表 `rectangles`，其中 `rectangle[i] = [x1, y1, x2, y2]` 表示第 `i` 个矩形，`(x1, y1)` 是第 `i` 个矩形左下角的坐标，`(x2, y2)` 是第 `i` 个矩形右上角的坐标。。

**要求**：计算 `rectangles` 中所有矩形所覆盖的总面积，并返回总面积。

**说明**：

- 任何被两个或多个矩形覆盖的区域应只计算一次 。
- 因为答案可能太大，返回 $10^9 + 7$ 的模。
- $1 \le rectangles.length \le 200$。
- $rectanges[i].length = 4$。
- $0 \le x_1, y_1, x_2, y_2 \le 10^9$。
- 矩形叠加覆盖后的总面积不会超越 $2^63 - 1$，这意味着可以用一个 $64$ 位有符号整数来保存面积结果。

**示例**：

- 示例 1：

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png)

```python
输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形覆盖了总面积为6的区域。
从 (1,1) 到 (2,2)，绿色矩形和红色矩形重叠。
从 (1,0) 到 (2,3)，三个矩形都重叠。
```

## 解题思路

### 思路 1：扫描线 + 动态开点线段树



### 思路 1：扫描线 + 动态开点线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, left=-1, right=-1, cnt=0, height=0, leftNode=None, rightNode=None):
        self.left = left                            # 区间左边界
        self.right = right                          # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = leftNode                    # 区间左节点
        self.rightNode = rightNode                  # 区间右节点
        self.cnt = cnt                              # 节点值（区间值）
        self.height = height                        # 区间问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self):
        self.tree = SegTreeNode(0, int(1e9))
        
    # 区间更新接口：将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.tree)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.tree)
    
    
    # 以下为内部实现方法
        
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, node):
    
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return
        
        if node.left >= q_left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            node.cnt += val                              # 当前节点所在区间每个元素值改为 val
            self.__pushup(node)
            return

        
        self.__pushdown(node) 
        
        if q_left <= node.mid:                      # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:                      # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
    
        self.__pushup(node)
    
    # 区间查询实现方法：在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
        
        if node.left >= q_left and node.right <= q_right:   # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.height                      # 直接返回节点值
        
        self.__pushdown(node) 
        
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= node.mid:                      # 在左子树中查询
            res_left = self.__query_interval(q_left, node.mid, node.leftNode)
        if q_right > node.mid:                      # 在右子树中查询
            res_right = self.__query_interval(node.mid + 1, q_right, node.rightNode)
            
        
        return res_left + res_right                 # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新 node 节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.cnt > 0:
            node.height = node.right - node.left + 1
        else:
            if node.leftNode and node.rightNode:
                node.height = node.leftNode.height + node.rightNode.height
            else:
                node.height = 0
    
    # 向下更新实现方法：更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if node.leftNode is None:
            node.leftNode = SegTreeNode(node.left, node.mid)
        if node.rightNode is None:
            node.rightNode = SegTreeNode(node.mid + 1, node.right)
            
class Solution:
    def rectangleArea(self, rectangles) -> int:
        # lines 存储每个矩阵的上下两条边
        lines = []
        
        for rectangle in rectangles:
            x1, y1, x2, y2 = rectangle
            lines.append([x1, y1 + 1, y2, 1])
            lines.append([x2, y1 + 1, y2, -1])
            
        lines.sort(key=lambda line: line[0])
            
        # 建立线段树
        self.STree = SegmentTree()
        
        ans = 0
        mod = 10 ** 9 + 7
        prev_x = lines[0][0]
        for i in range(len(lines)):
            x, y1, y2, val = lines[i]
            height = self.STree.query_interval(0, int(1e9))
            ans += height * (x - prev_x)
            ans %= mod
            self.STree.update_interval(y1, y2, val)
            prev_x = x
            
        return ans
```

## 参考资料

- 【文章】[【hdu1542】线段树求矩形面积并 - 拦路雨偏似雪花](https://www.cnblogs.com/KonjakJuruo/p/6024266.html)
# [0851. 喧闹和富有](https://leetcode.cn/problems/loud-and-rich/)

- 标签：深度优先搜索、图、拓扑排序、数组
- 难度：中等

## 题目链接

- [0851. 喧闹和富有 - 力扣](https://leetcode.cn/problems/loud-and-rich/)

## 题目大意

**描述**：有一组 `n` 个人作为实验对象，从 `0` 到 `n - 1` 编号，其中每个人都有不同数目的钱，以及不同程度的安静值 `quietness`。

现在给定一个数组 `richer`，其中 `richer[i] = [ai, bi]` 表示第 `ai` 个人比第 `bi` 个人更有钱。另给你一个整数数组 `quiet`，其中 `quiet[i]` 是第 `i` 个人的安静值。数组 `richer` 中所给出的数据逻辑自洽（也就是说，在第 `ai` 个人比第 `bi` 个人更有钱的同时，不会出现第 `bi` 个人比第 `ai` 个人更有钱的情况 ）。

**要求**：返回一个长度为 `n` 的整数数组 `answer` 作为答案，其中 `answer[i]` 表示在所有比第 `i` 个人更有钱或者和他一样有钱的人中，安静值最小的那个人的编号。 

**说明**：

- $n == quiet.length$
- $1 \le n \le 500$。
- $0 \le quiet[i] \le n$。
- $quiet$ 的所有值互不相同。
- $0 \le richer.length \le n * (n - 1) / 2$。
- $0 \le ai, bi < n$。
- $ai != bi$。
- $richer$ 中的所有数对 互不相同。
- 对 $richer$ 的观察在逻辑上是一致的。

**示例**：

- 示例 1：

```python
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]

解释：
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。
```

## 解题思路

### 思路 1：拓扑排序

对于第 `i` 个人，我们要求解的是比第 `i` 个人更有钱或者和他一样有钱的人中，安静值最小的那个人的编号。 

我们可以建立一张有向无环图，由富人指向穷人。这样，对于任意一点来说（比如 `x`），通过有向边链接的点（比如 `y`），拥有的钱都没有 `x` 多。则我们可以根据 `answer[x]` 去更新所有 `x` 能连接到的点的 `answer` 值。

我们可以先将数组 `answer`  元素初始化为当前元素编号。然后对建立的有向无环图进行拓扑排序，按照拓扑排序的顺序去更新 `x` 能连接到的点的 `answer` 值。

### 思路 1：拓扑排序代码

```python
import collections

class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        
        size = len(quiet)
        indegrees = [0 for _ in range(size)]
        edges = collections.defaultdict(list)

        for x, y in richer:
            edges[x].append(y)
            indegrees[y] += 1

        res = [i for i in range(size)]
        queue = collections.deque([])
        for i in range(size):
            if not indegrees[i]:
                queue.append(i)

        while queue:
            x = queue.popleft()
            size -= 1
            for y in edges[x]:
                if quiet[res[x]] < quiet[res[y]]:
                    res[y] = res[x]
                indegrees[y] -= 1
                if not indegrees[y]:
                    queue.append(y)
        return res
```
# [0852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0852. 山脉数组的峰顶索引 - 力扣](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

## 题目大意

**描述**：给定由整数组成的山脉数组 $arr$。

**要求**：返回任何满足 $arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[len(arr) - 1] $ 的下标 $i$。

**说明**：

- **山脉数组**：满足以下属性的数组：
  1. $len(arr) \ge 3$；
  2. 存在 $i$（$0 < i < len(arr) - 1$），使得：
     1. $arr[0] < arr[1] < ... arr[i-1] < arr[i]$；
     2. $arr[i] > arr[i+1] > ... > arr[len(arr) - 1]$。
- $3 <= arr.length <= 105$
- $0 <= arr[i] <= 106$
- 题目数据保证 $arr$ 是一个山脉数组

**示例**：

- 示例 1：

```python
输入：arr = [0,1,0]
输出：1
```

- 示例 2：

```python
输入：arr = [0,2,1,0]
输出：1
```

## 解题思路

### 思路 1：二分查找

1. 使用两个指针 $left$、$right$ 。$left$ 指向数组第一个元素，$right$ 指向数组最后一个元素。
2. 取区间中间节点 $mid$，并比较 $nums[mid]$ 和 $nums[mid + 1]$ 的值大小。
   1. 如果 $nums[mid]< nums[mid + 1]$，则右侧存在峰值，令 `left = mid + 1`。
   2. 如果 $nums[mid] \ge nums[mid + 1]$，则左侧存在峰值，令 `right = mid`。
3. 最后，当 $left == right$ 时，跳出循环，返回 $left$。

### 思路 1：代码

```python
class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        left = 0
        right = len(arr) - 1
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < arr[mid + 1]:
                left = mid + 1
            else:
                right = mid
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

- 标签：贪心、数组
- 难度：简单

## 题目链接

- [0860. 柠檬水找零 - 力扣](https://leetcode.cn/problems/lemonade-change/)

## 题目大意

**描述**：一杯柠檬水的售价是 $5$ 美元。现在有 $n$ 个顾客排队购买柠檬水，每人只能购买一杯。顾客支付的钱面额有 $5$ 美元、$10$ 美元、$20$ 美元。必须给每个顾客正确找零（就是每位顾客需要向你支付 $5$ 美元，多出的钱要找还回顾客）。

现在给定 $n$ 个顾客支付的钱币面额数组 `bills`。

**要求**：如果能给每位顾客正确找零，则返回 `True`，否则返回 `False`。

**说明**：

- 一开始的时候手头没有任何零钱。
- $1 \le bills.length \le 10^5$。
- `bills[i]` 不是 $5$ 就是 $10$ 或是 $20$。

**示例**：

- 示例 1：

```python
输入：bills = [5,5,5,10,20]
输出：True
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 True。
```

- 示例 2：

```python
输入：bills = [5,5,10,10,20]
输出：False
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 False。
```

## 解题思路

### 思路 1：贪心算法

由于顾客只能给我们 $5$、$10$、$20$ 三种面额的钞票，且一开始我们手头没有任何钞票，所以我们手中所能拥有的钞票面额只能是 $5$、$10$、$20$。因此可以采取下面的策略：

1. 如果顾客支付 $5$ 美元，直接收下。
2. 如果顾客支付 $10$ 美元，如果我们手头有 $5$ 美元面额的钞票，则找给顾客，否则无法正确找零，返回 `False`。
3. 如果顾客支付 $20$ 美元，如果我们手头有 $1$ 张 $10$ 美元和 $1$ 张 $5$ 美元的钞票，或者有 $3$ 张 $5$ 美元的钞票，则可以找给顾客。如果两种组合方式同时存在，倾向于第 $1$ 种方式找零，因为使用 $5$ 美元的场景比使用 $10$ 美元的场景多，要尽可能的保留 $5$ 美元的钞票。如果这两种组合方式都不通知，则无法正确找零，返回 `False`。

所以，我们可以使用两个变量 `five` 和 `ten` 来维护手中 $5$ 美元、$10$ 美团的钞票数量， 然后遍历一遍根据上述条件分别判断即可。

### 思路 1：代码

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five, ten, twenty = 0, 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            if bill == 10:
                if five <= 0:
                    return False
                ten += 1
                five -= 1
            if bill == 20:
                if five > 0 and ten > 0:
                    five -= 1
                    ten -= 1
                    twenty += 1
                elif five >= 3:
                    five -= 3
                    twenty += 1
                else:
                    return False

        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `bill` 的长度。
- **空间复杂度**：$O(1)$。

# [0861. 翻转矩阵后的得分](https://leetcode.cn/problems/score-after-flipping-matrix/)

- 标签：贪心、位运算、数组、矩阵
- 难度：中等

## 题目链接

- [0861. 翻转矩阵后的得分 - 力扣](https://leetcode.cn/problems/score-after-flipping-matrix/)

## 题目大意

**描述**：给定一个二维矩阵 `A`，其中每个元素的值为 `0` 或 `1`。

我们可以选择任一行或列，并转换该行或列中的每一个值：将所有 `0` 都更改为 `1`，将所有 `1` 都更改为 `0`。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

**要求**：返回尽可能高的分数。

**说明**：

- $1 \le A.length \le 20$。
- $1 \le A[0].length \le 20$。
- `A[i][j]` 值为 `0` 或 `1`。

**示例**：

- 示例 1：

```python
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为  [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
```

## 解题思路

### 思路 1：贪心算法

对于一个二进制数来说，应该优先保证高位（靠前的列）尽可能的大，也就是保证高位尽可能值为 `1`。

- 我们先来看矩阵的第一列数，只要第一列的某一行为 `0`，则将这一行的值进行翻转。这样就保证了最高位一定为 `1`。
- 接下来，我们再来关注除了第一列的其他列，这里因为有最高位限制，所以我们不能随意再将某一行的值进行翻转，只能选择某一列进行翻转。
- 为了保证当前位上有尽可能多的 `1`。我们可以用两个变量 `one_cnt`、`zeo_cnt` 来记录当前列上 `1` 的个数和 `0` 的个数。如果 `0` 的个数多于 `1` 的个数，那么我们就将当前列进行翻转。从而保证当前位上有尽可能多的 `1`。
- 当所有列都遍历完成后，我们会得到加和最大的情况。

### 思路 1：贪心算法代码

```python
class Solution:
    def matrixScore(self, grid: List[List[int]]) -> int:
        zero_cnt, one_cnt = 0, 0
        res = 0
        rows, cols = len(grid), len(grid[0])

        for col in range(cols):
            for row in range(rows):
                if col == 0 and grid[row][col] == 0:
                    for j in range(cols):
                        grid[row][j] = 1 - grid[row][j]
                else:
                    if grid[row][col] == 1:
                        one_cnt += 1
                    else:
                        zero_cnt += 1
            if zero_cnt > one_cnt:
                for row in range(rows):
                    grid[row][col] = 1 - grid[row][col]

            for row in range(rows):
                if grid[row][col] == 1:
                    res += pow(2, cols - col - 1)
            zero_cnt = 0
            one_cnt = 0
        return res
```
# [0862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

- 标签：队列、数组、二分查找、前缀和、滑动窗口、单调队列、堆（优先队列）
- 难度：困难

## 题目链接

- [0862. 和至少为 K 的最短子数组 - 力扣](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $k$。

**要求**：找出 $nums$ 中和至少为 $k$ 的最短非空子数组，并返回该子数组的长度。如果不存在这样的子数组，返回 $-1$。

**说明**：

- **子数组**：数组中连续的一部分。
- $1 \le nums.length \le 10^5$。
- $-10^5 \le nums[i] \le 10^5$。
- $1 \le k \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1], k = 1
输出：1
```

- 示例 2：

```python
输入：nums = [1,2], k = 4
输出：-1
```

## 解题思路

### 思路 1：前缀和 + 单调队列

题目要求得到满足和至少为 $k$ 的子数组的最短长度。

先来考虑暴力做法。如果使用两重循环分别遍历子数组的开始和结束位置，则可以直接求出所有满足条件的子数组，以及对应长度。但是这种做法的时间复杂度为 $O(n^2)$。我们需要对其进行优化。

#### 1. 前缀和优化

首先对于子数组和，我们可以使用「前缀和」的方式，方便快速的得到某个子数组的和。

对于区间 $[left, right]$，通过 $pre\underline{\hspace{0.5em}}sum[right + 1] - prefix\underline{\hspace{0.5em}}cnts[left]$  即可快速求解出区间 $[left, right]$ 的子数组和。

此时问题就转变为：是否能找到满足 $i > j$ 且 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j] \ge k$ 两个条件的子数组 $[j, i)$？如果能找到，则找出 $i - j$ 差值最小的作为答案。

#### 2. 单调队列优化

对于区间 $[j, i)$ 来说，我们应该尽可能的减少不成立的区间枚举。

1. 对于某个区间 $[j, i)$ 来说，如果 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j] \ge k$，那么大于 $i$ 的索引值就不用再进行枚举了，不可能比 $i - j$ 的差值更优了。此时我们应该尽可能的向右移动 $j$，从而使得 $i - j$ 更小。
2. 对于某个区间 $[j, i)$ 来说，如果 $pre\underline{\hspace{0.5em}}sum[j] \ge pre\underline{\hspace{0.5em}}sum[i]$，对于任何大于等于 $i$ 的索引值 $r$ 来说，$pre\underline{\hspace{0.5em}}sum[r] - pre\underline{\hspace{0.5em}}sum[i]$ 一定比 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j]$ 更小且长度更小，此时 $pre\underline{\hspace{0.5em}}sum[j]$ 可以直接忽略掉。

因此，我们可以使用单调队列来维护单调递增的前缀数组 $pre\underline{\hspace{0.5em}}sum$。其中存放了下标 $x:x_0, x_1, …$，满足 $pre\underline{\hspace{0.5em}}sum[x_0] < pre\underline{\hspace{0.5em}}sum[x_1] < …$ 单调递增。

1. 使用一重循环遍历位置 $i$，将当前位置 $i$ 存入倒掉队列中。
2. 对于每一个位置 $i$，如果单调队列不为空，则可以判断其之前存入在单调队列中的 $pre\underline{\hspace{0.5em}}sum[j]$ 值，如果 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j] \ge k$，则更新答案，并将 $j$ 从队头位置弹出。直到不再满足 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j] \ge k$ 时为止（即 $pre\underline{\hspace{0.5em}}sum[i] - pre\underline{\hspace{0.5em}}sum[j] < k$）。
3. 如果队尾 $pre\underline{\hspace{0.5em}}sum[j] \ge pre\underline{\hspace{0.5em}}sum[i]$，那么说明以后无论如何都不会再考虑 $pre\underline{\hspace{0.5em}}sum[j]$ 了，则将其从队尾弹出。
4. 最后遍历完返回答案。

### 思路 1：代码

```Python
class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        size = len(nums)
        
        # 优化 1
        pre_sum = [0 for _ in range(size + 1)]
        for i in range(size):
            pre_sum[i + 1] = pre_sum[i] + nums[i]

        ans = float('inf')
        queue = collections.deque()

        for i in range(size + 1):            
          	# 优化 2
            while queue and pre_sum[i] - pre_sum[queue[0]] >= k:
                ans = min(ans, i - queue.popleft())
            while queue and pre_sum[queue[-1]] >= pre_sum[i]:
                queue.pop()
            queue.append(i)

        if ans == float('inf'):
            return -1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。

## 参考资料

- 【题解】[862. 和至少为 K 的最短子数组 - 力扣](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solutions/1925036/liang-zhang-tu-miao-dong-dan-diao-dui-li-9fvh/)
- 【题解】[Leetcode 862：和至少为 K 的最短子数组 - 掘金](https://juejin.cn/post/7076316608460750856)
- 【题解】[LeetCode 862. 和至少为 K 的最短子数组 - AcWing](https://www.acwing.com/solution/leetcode/content/612/)
- 【题解】[0862. Shortest Subarray With Sum at Least K | LeetCode Cookbook](https://books.halfrost.com/leetcode/ChapterFour/0800~0899/0862.Shortest-Subarray-with-Sum-at-Least-K/)
# [0867. 转置矩阵](https://leetcode.cn/problems/transpose-matrix/)

- 标签：数组、矩阵、模拟
- 难度：简单

## 题目链接

- [0867. 转置矩阵 - 力扣](https://leetcode.cn/problems/transpose-matrix/)

## 题目大意

给定一个二维数组 matrix。返回 matrix 的转置矩阵。

## 解题思路

直接模拟求解即可。先求出 matrix 的规模。若 matrix 是 m * n 的矩阵。则创建一个 n * m 大小的矩阵 transposed。根据转置的规则对 transposed 的每个元素进行赋值。最终返回 transposed。

## 代码

```python
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        transposed = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(m):
            for j in range(n):
                transposed[j][i] = matrix[i][j]
        return transposed
```

# [0868. 二进制间距](https://leetcode.cn/problems/binary-gap/)

- 标签：位运算
- 难度：简单

## 题目链接

- [0868. 二进制间距 - 力扣](https://leetcode.cn/problems/binary-gap/)

## 题目大意

**描述**：给定一个正整数 $n$。

**要求**：找到并返回 $n$ 的二进制表示中两个相邻 $1$ 之间的最长距离。如果不存在两个相邻的 $1$，返回 $0$。

**说明**：

- $1 \le n \le 10^9$。

**示例**：

- 示例 1：

```python
输入：n = 22
输出：2
解释：22 的二进制是 "10110"。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1。
第一对相邻的 1 中，两个 1 之间的距离为 2。
第二对相邻的 1 中，两个 1 之间的距离为 1。
答案取两个距离之中最大的，也就是 2。
```

- 示例 2：

```python
输入：n = 8
输出：0
解释：8 的二进制是 "1000"。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0。
```

## 解题思路

### 思路 1：遍历

1. 将正整数 $n$ 转为二进制字符串形式 $bin\underline{\hspace{0.5em}}n$。
2. 使用变量 $pre$ 记录二进制字符串中上一个 $1$ 的位置，使用变量 $ans$ 存储两个相邻 $1$ 之间的最长距离。
3. 遍历二进制字符串形式 $bin\underline{\hspace{0.5em}}n$ 的每一位，遇到 $1$ 时判断并更新两个相邻 $1$ 之间的最长距离。
4. 遍历完返回两个相邻 $1$ 之间的最长距离，即 $ans$。

### 思路 1：代码

```Python
class Solution:
    def binaryGap(self, n: int) -> int:
        bin_n = bin(n)
        pre, ans = 2, 0
        
        for i in range(2, len(bin_n)):
            if bin_n[i] == '1':
                ans = max(ans, i - pre)
                pre = i
            
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。

# [0872. 叶子相似的树](https://leetcode.cn/problems/leaf-similar-trees/)

- 标签：树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0872. 叶子相似的树 - 力扣](https://leetcode.cn/problems/leaf-similar-trees/)

## 题目大意

将一棵二叉树树上所有的叶子，按照从左到右的顺序排列起来就形成了一个「叶值序列」。如果两棵二叉树的叶值序列是相同的，我们就认为它们是叶相似的。

现在给定两棵二叉树的根节点 `root1`、`root2`。如果两棵二叉是叶相似的，则返回 `True`，否则返回 `False`。

## 解题思路

分别 DFS 遍历两棵树，得到对应的叶值序列，判断两个叶值序列是否相等。

## 代码

```python
class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def dfs(node: TreeNode, res: List[int]):
            if not node:
                return
            if not node.left and not node.right:
                res.append(node.val)
            dfs(node.left, res)
            dfs(node.right, res)

        res1 = []
        dfs(root1, res1)
        res2 = []
        dfs(root2, res2)
        return res1 == res2
```

# [0873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)

- 标签：数组、哈希表、动态规划
- 难度：中等

## 题目链接

- [0873. 最长的斐波那契子序列的长度 - 力扣](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)

## 题目大意

**描述**：给定一个严格递增的正整数数组 $arr$。

**要求**：从数组 $arr$ 中找出最长的斐波那契式的子序列的长度。如果不存斐波那契式的子序列，则返回 0。

**说明**：

- **斐波那契式序列**：如果序列 $X_1, X_2, ..., X_n$ 满足：

  - $n \ge 3$；
  - 对于所有 $i + 2 \le n$，都有 $X_i + X_{i+1} = X_{i+2}$。

  则称该序列为斐波那契式序列。

- **斐波那契式子序列**：从序列 $A$ 中挑选若干元素组成子序列，并且子序列满足斐波那契式序列，则称该序列为斐波那契式子序列。例如：$A = [3, 4, 5, 6, 7, 8]$。则 $[3, 5, 8]$ 是 $A$ 的一个斐波那契式子序列。

- $3 \le arr.length \le 1000$。

- $1 \le arr[i] < arr[i + 1] \le 10^9$。

**示例**：

- 示例 1：

```python
输入: arr = [1,2,3,4,5,6,7,8]
输出: 5
解释: 最长的斐波那契式子序列为 [1,2,3,5,8]。
```

- 示例 2：

```python
输入: arr = [1,3,7,11,12,14,18]
输出: 3
解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18]。
```

## 解题思路

### 思路 1： 暴力枚举（超时）

假设 $arr[i]$、$arr[j]$、$arr[k]$ 是序列 $arr$ 中的 $3$ 个元素，且满足关系：$arr[i] + arr[j] == arr[k]$，则 $arr[i]$、$arr[j]$、$arr[k]$ 就构成了 $arr$ 的一个斐波那契式子序列。

通过  $arr[i]$、$arr[j]$，我们可以确定下一个斐波那契式子序列元素的值为 $arr[i] + arr[j]$。

因为给定的数组是严格递增的，所以对于一个斐波那契式子序列，如果确定了 $arr[i]$、$arr[j]$，则可以顺着 $arr$ 序列，从第 $j + 1$ 的元素开始，查找值为 $arr[i] + arr[j]$ 的元素 。找到 $arr[i] + arr[j]$ 之后，然后再顺着查找子序列的下一个元素。

简单来说，就是确定了 $arr[i]$、$arr[j]$，就能尽可能的得到一个长的斐波那契式子序列，此时我们记录下子序列长度。然后对于不同的  $arr[i]$、$arr[j]$，统计不同的斐波那契式子序列的长度。

最后将这些长度进行比较，其中最长的长度就是答案。

### 思路 1：代码

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        ans = 0
        for i in range(size):
            for j in range(i + 1, size):
                temp_ans = 0
                temp_i = i
                temp_j = j
                k = j + 1
                while k < size:
                    if arr[temp_i] + arr[temp_j] == arr[k]:
                        temp_ans += 1
                        temp_i = temp_j
                        temp_j = k
                    k += 1
                if temp_ans > ans:
                    ans = temp_ans

        if ans > 0:
            return ans + 2
        else:
            return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为数组 $arr$ 的元素个数。
- **空间复杂度**：$O(1)$。

### 思路 2：哈希表

对于 $arr[i]$、$arr[j]$，要查找的元素 $arr[i] + arr[j]$ 是否在 $arr$ 中，我们可以预先建立一个反向的哈希表。键值对关系为 $value : idx$，这样就能在 $O(1)$ 的时间复杂度通过 $arr[i] + arr[j]$ 的值查找到对应的 $arr[k]$，而不用像原先一样线性查找 $arr[k]$ 了。

### 思路 2：代码

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        ans = 0
        idx_map = dict()
        for idx, value in enumerate(arr):
            idx_map[value] = idx
        
        for i in range(size):
            for j in range(i + 1, size):
                temp_ans = 0
                temp_i = i
                temp_j = j
                while arr[temp_i] + arr[temp_j] in idx_map:
                    temp_ans += 1
                    k = idx_map[arr[temp_i] + arr[temp_j]]
                    temp_i = temp_j
                    temp_j = k

                if temp_ans > ans:
                    ans = temp_ans

        if ans > 0:
            return ans + 2
        else:
            return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。
- **空间复杂度**：$O(n)$。

### 思路 3：动态规划 + 哈希表

###### 1. 划分阶段

按照斐波那契式子序列相邻两项的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。

###### 3. 状态转移方程

以 $arr[j]$、$arr[k]$ 结尾的斐波那契式子序列的最大长度 = 满足 $arr[i] + arr[j] = arr[k]$ 条件下，以 $arr[i]$、$arr[j]$ 结尾的斐波那契式子序列的最大长度加 $1$。即状态转移方程为：$dp[j][k] = max_{(A[i] + A[j] = A[k], i < j < k)}(dp[i][j] + 1)$。

###### 4. 初始条件

默认状态下，数组中任意相邻两项元素都可以作为长度为 $2$ 的斐波那契式子序列，即 $dp[i][j] = 2$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。那为了计算出最大的最长递增子序列长度，则需要在进行状态转移时，求出最大值 $ans$ 即为最终结果。

因为题目定义中，斐波那契式中 $n \ge 3$，所以只有当 $ans \ge 3$ 时，返回 $ans$。如果 $ans < 3$，则返回 $0$。

> **注意**：在进行状态转移的同时，我们应和「思路 2：哈希表」一样采用哈希表优化的方式来提高效率，降低算法的时间复杂度。

### 思路 3：代码

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        
        dp = [[0 for _ in range(size)] for _ in range(size)]
        ans = 0

        # 初始化 dp
        for i in range(size):
            for j in range(i + 1, size):
                dp[i][j] = 2

        idx_map = {}
        # 将 value : idx 映射为哈希表，这样可以快速通过 value 获取到 idx
        for idx, value in enumerate(arr):
            idx_map[value] = idx

        for i in range(size):
            for j in range(i + 1, size):
                if arr[i] + arr[j] in idx_map:    
                    # 获取 arr[i] + arr[j] 的 idx，即斐波那契式子序列下一项元素
                    k = idx_map[arr[i] + arr[j]]
                    
                    dp[j][k] = max(dp[j][k], dp[i][j] + 1)
                    ans = max(ans, dp[j][k])

        if ans >= 3:
            return ans
        return 0
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。
- **空间复杂度**：$O(n)$。

# [0875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [0875. 爱吃香蕉的珂珂 - 力扣](https://leetcode.cn/problems/koko-eating-bananas/)

## 题目大意

**描述**：给定一个数组 $piles$ 代表 $n$ 堆香蕉。其中 $piles[i]$ 表示第 $i$ 堆香蕉的个数。再给定一个整数 $h$ ，表示最多可以在 $h$ 小时内吃完所有香蕉。珂珂决定以速度每小时 $k$（未知）根的速度吃香蕉。每一个小时，她讲选择其中一堆香蕉，从中吃掉 $k$ 根。如果这堆香蕉少于 $k$ 根，珂珂将在这一小时吃掉这堆的所有香蕉，并且这一小时不会再吃其他堆的香蕉。  

**要求**：返回珂珂可以在 $h$ 小时内吃掉所有香蕉的最小速度 $k$（$k$ 为整数）。

**说明**：

- $1 \le piles.length \le 10^4$。
- $piles.length \le h \le 10^9$。
- $1 \le piles[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：piles = [3,6,7,11], h = 8
输出：4
```

- 示例 2：

```python
输入：piles = [30,11,23,4,20], h = 5
输出：30
```

## 解题思路

### 思路 1：二分查找算法

先来看 $k$ 的取值范围，因为 $k$ 是整数，且速度肯定不能为 $0$ 吧，为 $0$ 的话就永远吃不完了。所以$k$ 的最小值可以取 $1$。$k$ 的最大值根香蕉中最大堆的香蕉个数有关，因为 $1$ 个小时内只能选择一堆吃，不能再吃其他堆的香蕉，则 $k$ 的最大值取香蕉堆的最大值即可。即 $k$ 的最大值为 $max(piles)$。

我们的目标是求出 $h$ 小时内吃掉所有香蕉的最小速度 $k$。现在有了区间「$[1, max(piles)]$」，有了目标「最小速度 $k$」。接下来使用二分查找算法来查找「最小速度 $k$」。至于计算 $h$ 小时内能否以 $k$ 的速度吃完香蕉，我们可以再写一个方法 $canEat$ 用于判断。如果能吃完就返回 $True$，不能吃完则返回 $False$。下面说一下算法的具体步骤。

- 使用两个指针 $left$、$right$。令 $left$ 指向 $1$，$right$ 指向 $max(piles)$。代表待查找区间为 $[left, right]$

- 取两个节点中心位置 $mid$，判断是否能在 $h$ 小时内以 $k$ 的速度吃完香蕉。
  - 如果不能吃完，则将区间 $[left, mid]$ 排除掉，继续在区间 $[mid + 1, right]$ 中查找。
  - 如果能吃完，说明 $k$ 还可以继续减小，则继续在区间 $[left, mid]$ 中查找。
- 当 $left == right$ 时跳出循环，返回 $left$。

### 思路 1：代码

```python
class Solution:
    def canEat(self, piles, hour, speed):
        time = 0
        for pile in piles:
            time += (pile + speed - 1) // speed
        return time <= hour

    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        left, right = 1, max(piles)

        while left < right:
            mid = left + (right - left) // 2
            if not self.canEat(piles, h, mid):
                left = mid + 1
            else:
                right = mid

        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log max(piles))$，$n$ 表示数组 $piles$ 中的元素个数。
- **空间复杂度**：$O(1)$。

# [0876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

- 标签：链表、双指针
- 难度：简单

## 题目链接

- [0876. 链表的中间结点 - 力扣](https://leetcode.cn/problems/middle-of-the-linked-list/)

## 题目大意

**描述**：给定一个单链表的头节点 `head`。

**要求**：返回链表的中间节点。如果有两个中间节点，则返回第二个中间节点。

**说明**：

- 给定链表的结点数介于 `1` 和 `100` 之间。

**示例**：

- 示例 1：

```python
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
解释：返回的结点值为 3 。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
```

- 示例 2：

```python
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
解释：由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
```

## 解题思路

### 思路 1：单指针

先遍历一遍链表，统计一下节点个数为 `n`，再遍历到 `n / 2` 的位置，返回中间节点。

### 思路 1：代码

```python
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        n = 0
        curr = head
        while curr:
            n += 1
            curr = curr.next
        k = 0
        curr = head
        while k < n // 2:
            k += 1
            curr = curr.next
        return curr
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：快慢指针

使用步长不一致的快慢指针进行一次遍历找到链表的中间节点。具体做法如下：

1. 使用两个指针 `slow`、`fast`。`slow`、`fast` 都指向链表的头节点。
2. 在循环体中将快、慢指针同时向右移动。其中慢指针每次移动 `1` 步，即 `slow = slow.next`。快指针每次移动 `2` 步，即 `fast = fast.next.next`。
3. 等到快指针移动到链表尾部（即 `fast == Node`）时跳出循环体，此时 `slow` 指向链表中间位置。
4. 返回 `slow` 指针。

### 思路 2：代码

```python
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        fast = head
        slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。# [0877. 石子游戏](https://leetcode.cn/problems/stone-game/)

- 标签：数组、数学、动态规划、博弈
- 难度：中等

## 题目链接

- [0877. 石子游戏 - 力扣](https://leetcode.cn/problems/stone-game/)

## 题目大意

亚历克斯和李在玩石子游戏。总共有偶数堆石子，每堆都有正整数颗石子 `piles[i]`，总共的石子数为奇数 。每回合，玩家从开始位置或者结束位置取走一整堆石子。直到没有石子堆为止结束游戏，最终手中石子颗数多的玩家获胜。假设亚历克斯和李每回合都能发挥出最佳水平，并且亚历克斯先开始。

给定代表每个位置石子颗数的数组 `piles`。

要求：判断亚历克斯是否能赢得比赛。如果亚历克斯赢得比赛，则返回 `True`。如果李赢得比赛返回 `False`。

## 解题思路

能取的次数是偶数个，总数是奇数个。

- 如果亚历克斯开始取了开始偶数位置 `0`，那么李只能取奇数位置 `1` 或者末尾位置 `len(piles) - 1`。然后亚历克斯可以j接着取偶数位。
- 或者亚历克斯开始取了最后奇数位置 `len(piles) - 1`，那么李只能取偶数位置 `0` 或 `len(piles) - 2`。然后亚历克斯可以接着取奇数位。
- 这样亚历克斯只要一开始计算好奇数位置上的石子总数多，还是偶数位置上的石子总数多，然后就可以选择一开始取奇数位置还是偶数位置。所以最后肯定会赢
- 游戏一开始，其实就没李啥事了。。。

## 代码

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True
```

# [0881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/)

- 标签：贪心、数组、双指针、排序
- 难度：中等

## 题目链接

- [0881. 救生艇 - 力扣](https://leetcode.cn/problems/boats-to-save-people/)

## 题目大意

**描述**：给定一个整数数组 `people` 代表每个人的体重，其中第 `i` 个人的体重为 `people[i]`。再给定一个整数 `limit`，代表每艘船可以承载的最大重量。每艘船最多可同时载两人，但条件是这些人的重量之和最多为 `limit`。

**要求**：返回载到每一个人所需的最小船数（保证每个人都能被船载）。

**说明**：

- $1 \le people.length \le 5 \times 10^4$。
- $1 \le people[i] \le limit \le 3 \times 10^4$。

**示例**：

- 示例 1：

```python
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
```

- 示例 2：

```python
输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)
```

## 解题思路

### 思路 1：贪心算法 + 双指针

暴力枚举的时间复杂度为 $O(n^2)$。使用双指针可以减少循环内的时间复杂度。

我们可以利用贪心算法的思想，让最重的和最轻的人一起走。这样一只船就可以尽可能的带上两个人。

具体做法如下：

1. 先对数组进行升序排序，使用 `ans` 记录所需最小船数。
2. 使用两个指针 `left`、`right`。`left` 指向数组开始位置，`right` 指向数组结束位置。
3. 判断 `people[left]` 和 `people[right]` 加一起是否超重。
   1. 如果 `people[left] + people[right] > limit`，则让重的人上船，船数量 + 1，令 `right` 左移，继续判断。
   2. 如果 `people[left] + people[right] <= limit`，则两个人都上船，船数量 + 1，并令 `left` 右移，`right` 左移，继续判断。
4. 如果 `lefft == right`，则让最后一个人上船，船数量 + 1。并返回答案。

### 思路 1：代码

```python
class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        size = len(people)
        left, right = 0, size - 1
        ans = 0
        while left < right:
            if people[left] + people[right] > limit:
                right -= 1
            else:
                left += 1
                right -= 1
            ans += 1
        if left == right:
            ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 是数组 `people` 的长度。
- **空间复杂度**：$O(\log n)$。

# [0884. 两句话中的不常见单词](https://leetcode.cn/problems/uncommon-words-from-two-sentences/)

- 标签：哈希表、字符串
- 难度：简单

## 题目链接

- [0884. 两句话中的不常见单词 - 力扣](https://leetcode.cn/problems/uncommon-words-from-two-sentences/)

## 题目大意

**描述**：给定两个字符串 $s1$ 和 $s2$ ，分别表示两个句子。

**要求**：返回所有不常用单词的列表。返回列表中单词可以按任意顺序组织。

**说明**：

- **句子**：是一串由空格分隔的单词。
- **单词**：仅由小写字母组成的子字符串。
- **不常见单词**：如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。
- $1 \le s1.length, s2.length \le 200$。
- $s1$ 和 $s2$ 由小写英文字母和空格组成。
- $s1$ 和 $s2$ 都不含前导或尾随空格。
- $s1$ 和 $s2$ 中的所有单词间均由单个空格分隔。

**示例**：

- 示例 1：

```python
输入：s1 = "this apple is sweet", s2 = "this apple is sour"
输出：["sweet","sour"]
```

- 示例 2：

```python
输入：s1 = "apple apple", s2 = "banana"
输出：["banana"]
```

## 解题思路

### 思路 1：哈希表

题目要求找出在其中一个句子中恰好出现一次，在另一个句子中却没有出现的单词，其实就是找出在两个句子中只出现过一次的单词，我们可以用哈希表统计两个句子中每个单词的出现频次，然后将出现频次为 $1$ 的单词就是不常见单词，将其加入答案数组即可。

具体步骤如下：

1.  遍历字符串 $s1$、$s2$，使用哈希表 $table$ 统计字符串 $s1$、$s2$ 各个单词的出现频次。
2. 遍历哈希表，找出出现频次为 $1$ 的单词，将其加入答案数组 $res$ 中。
3. 遍历完返回答案数组 $res$。

### 思路 1：代码

```python
class Solution:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        table = dict()
        for word in s1.split(' '):
            if word not in table:
                table[word] = 1
            else:
                table[word] += 1
        
        for word in s2.split(' '):
            if word not in table:
                table[word] = 1
            else:
                table[word] += 1
       
        res = []
        for word in table:
            if table[word] == 1:
                res.append(word)
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$，其中 $m$、$n$ 分别为字符串 $s1$、$s2$ 的长度。
- **空间复杂度**：$O(m + n)$。
# [0886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0886. 可能的二分法 - 力扣](https://leetcode.cn/problems/possible-bipartition/)

## 题目大意

把 n 个人（编号为 1, 2, ... , n）分为任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。

给定表示不喜欢关系的数组 `dislikes`，其中 `dislikes[i] = [a, b]` 表示 `a` 和 `b` 互相不喜欢，不允许将编号 `a` 和 `b` 的人归入同一组。

要求：如果可以以这种方式将所有人分为两组，则返回 `True`；如果不能则返回 `False`。

## 解题思路

先构建图，对于 `dislikes[i] = [a, b]`，在节点 `a` 和 `b` 之间建立一条无向边，然后判断该图是否为二分图。具体做法如下：

- 找到一个没有染色的节点 `u`，将其染成红色。
- 然后遍历该节点直接相连的节点 `v`，如果该节点没有被染色，则将该节点直接相连的节点染成蓝色，表示两个节点不是同一集合。如果该节点已经被染色并且颜色跟 `u` 一样，则说明该图不是二分图，直接返回 `False`。
- 从上面染成蓝色的节点 `v` 出发，遍历该节点直接相连的节点。。。依次类推的递归下去。
- 如果所有节点都顺利染上色，则说明该图为二分图，可以将所有人分为两组，返回 `True`。否则，如果在途中不能顺利染色，不能将所有人分为两组，则返回 `False`。

## 代码

```python
class Solution:
    def dfs(self, graph, colors, i, color):
        colors[i] = color
        for j in graph[i]:
            if colors[j] == colors[i]:
                return False
            if colors[j] == 0 and not self.dfs(graph, colors, j, -color):
                return False
        return True

    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        graph = [[] for _ in range(n + 1)]
        colors = [0 for _ in range(n + 1)]

        for x, y in dislikes:
            graph[x].append(y)
            graph[y].append(x)

        for i in range(1, n + 1):
            if colors[i] == 0 and not self.dfs(graph, colors, i, 1):
                return False
        return True
```

# [0887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

- 标签：数学、二分查找、动态规划
- 难度：困难

## 题目链接

- [0887. 鸡蛋掉落 - 力扣](https://leetcode.cn/problems/super-egg-drop/)

## 题目大意

**描述**：给定一个整数 `k` 和整数 `n`，分别代表 `k` 枚鸡蛋和可以使用的一栋从第 `1` 层到第 `n` 层楼的建筑。

已知存在楼层 `f`，满足 `0 <= f <= n`，任何从高于 `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会碎。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`），如果鸡蛋碎了，就不能再次使用它。如果鸡蛋没碎，则可以再次使用。

**要求**：计算并返回要确定 `f` 确切值的最小操作次数是多少。

**说明**：

- $1 \le k \le 100$。
- $1 \le n \le 10^4$。

**示例**：

- 示例 1：

```python
输入：k = 1, n = 2
输入：2
解释：鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0。否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1。如果它没碎，那么肯定能得出 f = 2。因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
```

## 解题思路

这道题目的题意不是很容易理解，我们先把题目简化一下，忽略一些限制条件，理解简单情况下的题意。然后再一步步增加限制条件，从而弄明白这道题目的意思，以及思考清楚这道题的解题思路。

我们先忽略 `k` 个鸡蛋这个条件，假设有无限个鸡蛋。

现在有 `1` ~ `n` 一共 `n` 层楼。已知存在楼层 `f`，低于等于 `f` 层的楼层扔下去的鸡蛋都不会碎，高于 `f` 的楼层扔下去的鸡蛋都会碎。

当然这个楼层 `f` 的确切值题目没有给出，需要我们一次次去测试鸡蛋最高会在哪一层不会摔碎。

在每次操作中，我们可以选定一个楼层，将鸡蛋扔下去：

- 如果鸡蛋没摔碎，则可以继续选择其他楼层进行测试。
- 如果鸡蛋摔碎了，则该鸡蛋无法继续测试。

现在题目要求：**已知有 `n` 层楼，无限个鸡蛋，求出至少需要扔几次鸡蛋，才能保证无论 `f` 是多少层，都能将 `f` 找出来？**

最简单且直观的想法：

1. 从第 `1` 楼开始扔鸡蛋。`1` 楼不碎，再去 `2` 楼扔。
2. `2` 楼还不碎，就去 `3` 楼扔。
3. …… 
4. 直到鸡蛋碎了，也就找到了鸡蛋不会摔碎的最高层 `f`。

用这种方法，最坏情况下，鸡蛋在第 `n` 层也没摔碎。这种情况下我们总共试了 `n` 次才确定鸡蛋不会摔碎的最高楼层 `f`。

下面再来说一下比 `n` 次要少的情况。

如果我们可以通过二分查找的方法，先从 `1` ~ `n` 层的中间层开始扔鸡蛋。

- 如果鸡蛋碎了，则从第 `1` 层到中间层这个区间中去扔鸡蛋。
- 如果鸡蛋没碎，则从中间层到第 `n` 层这个区间中去扔鸡蛋。

每次扔鸡蛋都从区间的中间层去扔，这样每次都能排除当前区间一半的答案，从而最终确定鸡蛋不会摔碎的最高楼层 `f`。

通过这种二分查找的方法，可以优化到 $\log n$ 次就能确定鸡蛋不会摔碎的最高楼层 `f`。

因为 $\log n \le n$，所以通过二分查找的方式，「至少」比线性查找的次数要少。

同样，我们还可以通过三分查找、五分查找等等方式减少次数。

这是在不限制鸡蛋个数的情况下，现在我们来限制一下鸡蛋个数为 `k`。

现在题目要求：**已知有 `n` 层楼，`k` 个鸡蛋，求出至少需要扔几次鸡蛋，才能保证无论 `f` 是多少层，都能将 `f` 找出来？**

如果鸡蛋足够多（大于等于 $\log_2 n$ 个），可以通过二分查找的方法来测试。如果鸡蛋不够多，可能二分查找过程中，鸡蛋就用没了，则不能通过二分查找的方法来测试。

那么这时候为了找出 `f` ，我们应该如何求出最少的扔鸡蛋次数？

### 思路 1：动态规划（超时）

可以这样考虑。题目限定了 `n` 层楼，`k` 个鸡蛋。

如果我们尝试在 `1` ~ `n` 层中的任意一层 `x` 扔鸡蛋：

1. 如果鸡蛋没碎，则说明 `1` ~ `x` 层都不用再考虑了，我们需要用 `k` 个鸡蛋去考虑剩下的 `n - x` 层，问题就从 `(n, k)` 转变为了 `(n - x, k)`。
2. 如果鸡蛋碎了，则说明 `x + 1` ~ `n` 层都不用再考虑了，我们需要去剩下的 `k - 1` 个鸡蛋考虑剩下的 `x - 1` 层，问题就从 `(n, k)` 转变为了 `(x - 1, k - 1)`。

这样一来，我们就可以根据上述关系使用动态规划方法来解决这道题目了。具体步骤如下：

###### 1. 划分阶段

按照楼层数量、剩余鸡蛋个数进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：一共有 `i` 层楼，`j` 个鸡蛋的条件下，为了找出 `f` ，最坏情况下的最少扔鸡蛋次数。

###### 3. 状态转移方程

根据之前的描述，`dp[i][j]` 有两个来源，其状态转移方程为：

$dp[i][j] = min_{1 \le x \le n} (max(dp[i - x][j], dp[x - 1][j - 1])) + 1$ 

###### 4. 初始条件

给定鸡蛋 `k` 的取值范围为 `[1, 100]`，`f` 值取值范围为 `[0, n]`，初始化时，可以考虑将所有值设置为当前拥有的楼层数。

- 当鸡蛋数为 `1` 时，`dp[i][1] = i`。这是如果唯一的蛋碎了，则无法测试了。只能从低到高，一步步进行测试，最终最少测试数为当前拥有的楼层数（如果刚开始初始化时已经将所有值设置为当前拥有的楼层数，其实这一步可省略）。
- 当楼层为 `1` 时，在 `1` 层扔鸡蛋，`dp[1][j] = 1`。这是因为：
  - 如果在 `1` 层扔鸡蛋碎了，则 `f < 1`。同时因为 `f` 的取值范围为 `[0, n]`。所以能确定 `f = 0`。
  - 如果在 `1` 层扔鸡蛋没碎，则 `f >= 1`。同时因为 `f` 的取值范围为 `[0, n]`。所以能确定 `f = 0`。 

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：一共有 `i` 层楼，`j` 个鸡蛋的条件下，为了找出 `f` ，最坏情况下的最少扔鸡蛋次数。则最终结果为 `dp[n][k]`。

### 思路 1：代码

```python
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        dp = [[0 for _ in range(k + 1)] for i in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = i

        # for i in range(1, n + 1):
        #     dp[i][1] = i

        for j in range(1, k + 1):
            dp[1][j] = 1

        for i in range(2, n + 1):
            for j in range(2, k + 1):
                for x in range(1, i + 1):
                    dp[i][j] = min(dp[i][j], max(dp[i - x][j], dp[x - 1][j - 1]) + 1)
                
        return dp[n][k]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times k)$。三重循环的时间复杂度为 $O(n^2 \times k)$。
- **空间复杂度**：$O(n \times k)$。

### 思路 2：动态规划优化

上一步中时间复杂度为 $O(n^2 \times k)$。根据 $n$ 的规模，提交上去不出意外的超时了。

我们可以观察一下上面的状态转移方程：$dp[i][j] = min_{1 \le x \le n} (max(dp[i - x][j], dp[x - 1][j - 1])) + 1$ 。

这里最外两层循环的 `i`、`j` 分别为状态的阶段，可以先将 `i`、`j` 看作固定值。最里层循环的 `x` 代表选择的任意一层 `x` ，值从 `1` 遍历到 `i`。

此时我们把 `dp[i - x][j]` 和 `dp[x - 1][j - 1]` 分别单独来看。可以看出：

- 对于 `dp[i - x][j]`：当 `x` 增加时，`i - x` 的值减少，`dp[i - x][j]` 的值跟着减小。自变量 `x` 与函数 `dp[i - x][j]` 是一条单调非递增函数。
- 对于 `dp[x - 1][j - 1]`：当 `x` 增加时， `x - 1` 的值增加，`dp[x - 1][j - 1]` 的值跟着增加。自变量 `x` 与函数 `dp[x - 1][j - 1]` 是一条单调非递减函数。

两条函数的交点处就是两个函数较大值的最小值位置。即 `dp[i][j]` 所取位置。而这个位置可以通过二分查找满足 `dp[x - 1][j - 1] >= dp[i - x][j]` 最大的那个 `x`。这样时间复杂度就从 $O(n^2 \times k)$ 优化到了 $O(n  \log n \times k)$。

### 思路 2：代码

```python
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        dp = [[0 for _ in range(k + 1)] for i in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = i

        # for i in range(1, n + 1):
        #     dp[i][1] = i

        for j in range(1, k + 1):
            dp[1][j] = 1

        for i in range(2, n + 1):
            for j in range(2, k + 1):
                left, right = 1, i
                while left < right:
                    mid = left + (right - left) // 2
                    if dp[mid - 1][j - 1] < dp[i - mid][j]:
                        left = mid + 1
                    else:
                        right = mid
                dp[i][j] = max(dp[left - 1][j - 1], dp[i - left][j]) + 1
                    
        return dp[n][k]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n  \log n \times k)$。两重循环的时间复杂度为 $O(n \times k)$，二分查找的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(n \times k)$。

### 思路 3：动态规划 + 逆向思维

再看一下我们现在的题目要求：已知有 `n` 层楼，`k` 个鸡蛋，求出至少需要扔几次鸡蛋，才能保证无论 `f` 是多少层，都能将 `f` 找出来？

我们可以逆向转换一下思维，将题目转变为：**已知有 `k` 个鸡蛋，最多扔 `x` 次鸡蛋（碎没碎都算 `1` 次），求最多可以检测的多少层？**

我们把未知条件「扔鸡蛋的次数」变为了已知条件，将「检测的楼层个数」变为了未知条件。

这样如果求出来的「检测的楼层个数」大于等于 `n`，则说明 `1` ~ `n` 层楼都考虑全了，`f` 值也就明确了。我们只需要从符合条件的情况中，找出「扔鸡蛋次数」最少的次数即可。

动态规划的具体步骤如下：

###### 1. 划分阶段

按照鸡蛋个数、扔鸡蛋的次数进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：一共有 `i` 个鸡蛋，最多扔 `j` 次鸡蛋（碎没碎都算 `1` 次）的条件下，最多可以检测的楼层个数。

###### 3. 状态转移方程

我们现在有 `i` 个鸡蛋，`j` 次扔鸡蛋的机会，现在尝试在 `1` ~ `n` 层中的任意一层 `x` 扔鸡蛋：

1. 如果鸡蛋没碎，剩下 `i` 个鸡蛋，还有 `j - 1` 次扔鸡蛋的机会，最多可以检测 `dp[i][j - 1]` 层楼层。
2. 如果鸡蛋碎了，剩下 `i - 1` 个鸡蛋，还有 `j - 1` 次扔鸡蛋的机会，最多可以检测 `dp[i - 1][j - 1]` 层楼层。
3. 再加上我们扔鸡蛋的第 `x` 层，`i` 个鸡蛋，`j` 次扔鸡蛋的机会最多可以检测 `dp[i][j - 1] + dp[i - 1][j - 1] + 1` 层。

则状态转移方程为：$dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] + 1$。

###### 4. 初始条件

- 当鸡蛋数为 `1` 时，只有 `1` 次扔鸡蛋的机会时，最多可以检测 `1` 层，即 `dp[1][1] = 1`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：一共有 `i` 个鸡蛋，最多扔 `j` 次鸡蛋（碎没碎都算 `1` 次）的条件下，最多可以检测的楼层个数。则我们需要从满足 `i == k` 并且 `dp[i][j] >= n`（即 `k` 个鸡蛋，`j` 次扔鸡蛋，一共检测出 `n` 层楼）的情况中，找出最小的 ` j`，将其返回。

### 思路 3：代码

```python
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        dp = [[0 for _ in range(n + 1)] for i in range(k + 1)]
        dp[1][1] = 1

        for i in range(1, k + 1):
            for j in range(1, n + 1):
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] + 1
                if i == k and dp[i][j] >= n:
                    return j
        return n
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times k)$。两重循环的时间复杂度为 $O(n \times k)$。
- **空间复杂度**：$O(n \times k)$。

## 参考资料

- 【题解】[题目理解 + 基本解法 + 进阶解法 - 鸡蛋掉落 - 力扣](https://leetcode.cn/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/)
- 【题解】[动态规划（只解释官方题解方法一）（Java） - 鸡蛋掉落 - 力扣](https://leetcode.cn/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/)
- 【题解】[动态规划 & 记忆化搜索 2000ms -> 32ms 的过程 - 鸡蛋掉落 - 力扣](https://leetcode.cn/problems/super-egg-drop/solution/python-dong-tai-gui-hua-ji-yi-hua-sou-su-hnj9/)
# [0889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

- 标签：树、数组、哈希表、分治、二叉树
- 难度：中等

## 题目链接

- [0889. 根据前序和后序遍历构造二叉树 - 力扣](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

## 题目大意

**描述**：给定一棵无重复值二叉树的前序遍历结果 `preorder` 和后序遍历结果 `postorder`。

**要求**：构造出该二叉树并返回其根节点。如果存在多个答案，则可以返回其中任意一个。

**说明**：

- $1 \le preorder.length \le 30$。
- $1 \le preorder[i] \le preorder.length$。
- `preorder` 中所有值都不同。
- `postorder.length == preorder.length`。
- $1 \le postorder[i] \le postorder.length$。
- `postorder` 中所有值都不同。
- 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)

```python
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

- 示例 2：

```python
输入: preorder = [1], postorder = [1]
输出: [1]
```

## 解题思路

### 思路 1：递归

如果已知二叉树的前序遍历序列和后序遍历序列，是不能唯一地确定一棵二叉树的。这是因为没有中序遍历序列无法确定左右部分，也就无法进行子序列的分割。

只有二叉树中每个节点度为 `2` 或者 `0` 的时候，已知前序遍历序列和后序遍历序列，才能唯一地确定一颗二叉树，如果二叉树中存在度为 `1` 的节点时是无法唯一地确定一棵二叉树的，这是因为我们无法判断该节点是左子树还是右子树。

而这道题说明了，如果存在多个答案，则可以返回其中任意一个。

我们可以默认指定前序遍历序列的第 `2` 个值为左子树的根节点，由此递归划分左右子序列。具体操作步骤如下：

1. 从前序遍历序列中可知当前根节点的位置在 `preorder[0]`。

2. 前序遍历序列的第 `2` 个值为左子树的根节点，即 `preorder[1]`。通过在后序遍历中查找上一步根节点对应的位置 `postorder[k]`（该节点右侧为右子树序列），从而将二叉树的左右子树分隔开，并得到左右子树节点的个数。

3. 从上一步得到的左右子树个数将后序遍历结果中的左右子树分开。

4. 构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历并执行上述三步，直到节点为空。

### 思路 1：代码

```python
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        def createTree(preorder, postorder, n):
            if n == 0:
                return None
            node = TreeNode(preorder[0])
            if n == 1:
                return node
            k = 0
            while postorder[k] != preorder[1]:
                k += 1
            node.left = createTree(preorder[1: k + 2], postorder[: k + 1], k + 1)
            node.right = createTree(preorder[k + 2: ], postorder[k + 1: -1], n - k - 2)
            return node
        return createTree(preorder, postorder, len(preorder))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n^2)$。# [0892. 三维形体的表面积](https://leetcode.cn/problems/surface-area-of-3d-shapes/)

- 标签：几何、数组、数学、矩阵
- 难度：简单

## 题目链接

- [0892. 三维形体的表面积 - 力扣](https://leetcode.cn/problems/surface-area-of-3d-shapes/)

## 题目大意

**描述**：给定一个 $n \times n$ 的网格 $grid$，上面放置着一些 $1 \times 1 \times 1$ 的正方体。每个值 $v = grid[i][j]$ 表示 $v$ 个正方体叠放在对应单元格 $(i, j)$ 上。

放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。

**要求**：返回最终这些形体的总面积。

**说明**：

- 每个形体的底面也需要计入表面积中。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg)

```python
输入：grid = [[1,2],[3,4]]
输出：34
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg)

```python
输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：32
```

## 解题思路

### 思路 1：模拟

使用二重循环遍历所有的正方体，计算每一个正方体所贡献的表面积，将其累积起来即为答案。

而每一个正方体所贡献的表面积，可以通过枚举当前正方体前后左右相邻四个方向上的正方体的个数，从而通过判断计算得出。

- 如果当前位置 $(row, col)$ 存在正方体，则正方体在上下位置上起码贡献了 $2$ 的表面积。
- 如果当前位置 $(row, col)$ 的相邻位置 $(new\underline{\hspace{0.5em}}row, new\underline{\hspace{0.5em}}col)$ 上不存在正方体，说明当前正方体在该方向为最外侧，则 $(row, col)$ 位置所贡献的表面积为当前位置上的正方体个数，即 $grid[row][col]$。
- 如果当前位置 $(row, col)$ 的相邻位置 $(new\underline{\hspace{0.5em}}row, new\underline{\hspace{0.5em}}col)$ 上存在正方体：
	- 如果 $grid[row][col] > grid[new\underline{\hspace{0.5em}}row][new\underline{\hspace{0.5em}}col]$，说明 $grid[row][col]$ 在该方向上底面一部分被 $grid[new\underline{\hspace{0.5em}}row][new\underline{\hspace{0.5em}}col]$ 遮盖了，则 $(row, col)$ 位置所贡献的表面积为 $grid[row][col] - grid[new_row][new_col]$。
	- 如果 $grid[row][col] \le grid[new\underline{\hspace{0.5em}}row][new\underline{\hspace{0.5em}}col]$，说明 $grid[row][col]$ 在该方向上完全被 $grid[new\underline{\hspace{0.5em}}row][new\underline{\hspace{0.5em}}col]$ 遮盖了，则 $(row, col)$ 位置所贡献的表面积为 $0$。

### 思路 1：代码

```Python
class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        size = len(grid)

        ans = 0
        for row in range(size):
            for col in range(size):
                if grid[row][col]:
                    # 底部、顶部贡献表面积
                    ans += 2
                    for direction in directions:
                        new_row = row + direction[0]
                        new_col = col + direction[1]
                        if 0 <= new_row < size and 0 <= new_col < size:
                            if grid[row][col] > grid[new_row][new_col]:
                                add = grid[row][col] - grid[new_row][new_col]
                            else:
                                add = 0
                        else:
                            add = grid[row][col]
                        ans += add
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为二位数组 $grid$ 的行数或列数。
- **空间复杂度**：$O(1)$。

# [0897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/)

- 标签：栈、树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [0897. 递增顺序搜索树 - 力扣](https://leetcode.cn/problems/increasing-order-search-tree/)

## 题目大意

给定一棵二叉搜索树的根节点 `root`。

要求：按中序遍历顺序将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

## 解题思路

可以分为两步：

1. 中序遍历二叉搜索树，将节点先存储到列表中。
2. 将列表中的节点构造成一棵递增顺序搜索树。

中序遍历直接按照 `左 -> 根 -> 右` 的顺序递归遍历，然后将遍历的节点存储到 `res` 中。

构造递增顺序搜索树，则用 `head` 保存头节点位置。遍历列表中的每个节点，将其左右指针先置空，再将其连接在上一个节点的右子节点上。

最后返回 `head.right` 即可。

## 代码

```python
class Solution:
    def inOrder(self, root, res):
        if not root:
            return
        self.inOrder(root.left, res)
        res.append(root)
        self.inOrder(root.right, res)

    def increasingBST(self, root: TreeNode) -> TreeNode:
        res = []
        self.inOrder(root, res)

        if not res:
            return
        head = TreeNode(-1)
        cur = head
        for node in res:
            node.left = node.right = None
            cur.right = node
            cur = cur.right
        return head.right
```



# [0900. RLE 迭代器](https://leetcode.cn/problems/rle-iterator/)

- 标签：设计、数组、计数、迭代器
- 难度：中等

## 题目链接

- [0900. RLE 迭代器 - 力扣](https://leetcode.cn/problems/rle-iterator/)

## 题目大意

**描述**：我们可以使用游程编码（即 RLE）来编码一个整数序列。在偶数长度 $encoding$ ( 从 $0$ 开始 )的游程编码数组中，对于所有偶数 $i$，$encoding[i]$ 告诉我们非负整数 $encoding[i + 1]$ 在序列中重复的次数。

- 例如，序列 $arr = [8,8,8,5,5]$ 可以被编码为 $encoding =[3,8,2,5]$。$encoding =[3,8,0,9,2,5]$ 和 $encoding =[2,8,1,8,2,5]$ 也是 $arr$ 有效的 RLE。

给定一个游程长度的编码数组 $encoding$。

**要求**：设计一个迭代器来遍历它。

实现 `RLEIterator` 类:

- `RLEIterator(int[] encoded)` 用编码后的数组初始化对象。
- `int next(int n)` 以这种方式耗尽后 $n$ 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 $-1$。

**说明**：

- $2 \le encoding.length \le 1000$。
- $encoding.length$ 为偶。
- $0 \le encoding[i] \le 10^9$。
- $1 \le n \le 10^9$。
- 每个测试用例调用 `next` 不高于 $1000$ 次。

**示例**：

- 示例 1：

```python
输入：
["RLEIterator","next","next","next","next"]
[[[3,8,0,9,2,5]],[2],[1],[1],[2]]
输出：
[null,8,8,5,-1]
解释：
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，
但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。
```

## 解题思路

### 思路 1：模拟

1. 初始化时：
   1. 保存数组 $encoding$ 作为成员变量。
   2. 保存当前位置 $index$，表示当前迭代器指向元素 $encoding[index + 1]$。初始化赋值为 $0$。
   3. 保存当前指向元素 $encoding[index + 1]$ 已经被删除的元素个数 $d\underline{\hspace{0.5em}}cnt$。初始化赋值为 $0$。
2. 调用 `next(n)` 时：
   1. 对于当前元素，先判断当前位置是否超出 $encoding$ 范围，超过则直接返回 $-1$。
   2. 如果未超过，再判断当前元素剩余个数 $encoding[index] - d\underline{\hspace{0.5em}}cnt$ 是否小于 $n$ 个。
      1. 如果小于 $n$ 个，则删除当前元素剩余所有个数，并指向下一位置继续删除剩余元素。
      2. 如果等于大于等于 $n$ 个，则令当前指向元素 $encoding[index + 1]$ 已经被删除的元素个数 $d\underline{\hspace{0.5em}}cnt$ 加上 $n$。

### 思路 1：代码

```Python
class RLEIterator:

    def __init__(self, encoding: List[int]):
        self.encoding = encoding
        self.index = 0
        self.d_cnt = 0

    def next(self, n: int) -> int:
        while self.index < len(self.encoding):
            if self.d_cnt + n > self.encoding[self.index]:
                n -= self.encoding[self.index] - self.d_cnt
                self.d_cnt = 0
                self.index += 2
            else:
                self.d_cnt += n
                return self.encoding[self.index + 1]
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 为数组 $encoding$ 的长度，$m$ 是调用 `next(n)` 的次数。
- **空间复杂度**：$O(n)$。

# [0901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/)

- 标签：栈、设计、数据流、单调栈
- 难度：中等

## 题目链接

- [0901. 股票价格跨度 - 力扣](https://leetcode.cn/problems/online-stock-span/)

## 题目大意

要求：编写一个 `StockSpanner` 类，用于收集某些股票的每日报价，并返回该股票当日价格的跨度。

- 今天股票价格的跨度：股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如：如果未来 7 天股票的价格是 `[100, 80, 60, 70, 60, 75, 85]`，那么股票跨度将是 `[1, 1, 1, 2, 1, 4, 6]`。

## 解题思路

「求解小于或等于今天价格的最大连续日」等价于「求出左侧第一个比当前股票价格大的股票，并计算距离」。求出左侧第一个比当前股票价格大的股票我们可以使用「单调递减栈」来做。具体步骤如下：

- 初始化方法：初始化一个空栈，即 `self.stack = []`

- 求解今天股票价格的跨度：

  - 初始化跨度 `span` 为 `1`。
  - 如果今日股票价格 `price` 大于等于栈顶元素 `self.stack[-1][0]`，则：
    - 将其弹出，即 `top = self.stack.pop()`。
    - 跨度累加上弹出栈顶元素的跨度，即 `span += top[1]`。
    - 继续判断，直到遇到一个今日股票价格 `price` 小于栈顶元素的元素位置，再将 `[price, span]` 压入栈中。
  - 如果今日股票价格 `price` 小于栈顶元素 `self.stack[-1][0]`，则直接将 `[price, span]` 压入栈中。

  - 最后输出今天股票价格的跨度 `span`。    

## 代码

```python
class StockSpanner:

    def __init__(self):
        self.stack = []

    def next(self, price: int) -> int:
        span = 1
        while self.stack and price >= self.stack[-1][0]:
            top = self.stack.pop()
            span += top[1]
        self.stack.append([price, span])
        return span
```

# [0902. 最大为 N 的数字组合](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/)

- 标签：数组、数学、字符串、二分查找、动态规划
- 难度：困难

## 题目链接

- [0902. 最大为 N 的数字组合 - 力扣](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/)

## 题目大意

**描述**：给定一个按非递减序列排列的数字数组 $digits$。我们可以使用任意次数的 $digits[i]$ 来写数字。例如，如果 `digits = ["1", "3", "5"]`，我们可以写数字，如 `"13"`, `"551"`, 和 `"1351315"`。

**要求**：返回可以生成的小于等于给定整数 $n$ 的正整数个数。

**说明**：

- $1 \le digits.length \le 9$。
- $digits[i].length == 1$。
- $digits[i]$ 是从 `'1'` 到 `'9'` 的数。
- $digits$ 中的所有值都不同。
- $digits$ 按非递减顺序排列。
- $1 \le n \le 10^9$。

**示例**：

- 示例 1：

```python
输入：digits = ["1","3","5","7"], n = 100
输出：20
解释：
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77。
```

- 示例 2：

```python
输入：digits = ["1","4","9"], n = 1000000000
输出：29523
解释：
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，
81 个四位数字，243 个五位数字，729 个六位数字，
2187 个七位数字，6561 个八位数字和 19683 个九位数字。
总共，可以使用D中的数字写出 29523 个整数。
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

数位 DP 模板的应用。因为这道题目中可以使用任意次数的 $digits[i]$，所以不需要用状态压缩的方式来表示数字集合。

这道题的具体步骤如下：

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, isLimit, isNum):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, True, False)` 开始递归。 `dfs(0, True, False)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 开始时受到数字 $n$ 对应最高位数位的约束。
   3. 开始时没有填写数字。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
   1. 如果 $isNum == True$，说明当前方案符合要求，则返回方案数 $1$。
   2. 如果 $isNum == False$，说明当前方案不符合要求，则返回方案数 $0$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
   1. 根据 $isNum$ 和 $isLimit$ 来决定填当前位数位所能选择的最大数字（$maxX$）。
   2. 然后枚举 $digits$ 数组中所有能够填入的数字 $d$。
   3. 如果 $d$ 超过了所能选择的最大数字 $maxX$ 则直接跳出循环。
   4. 如果 $d$ 是合法数字，则方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, isLimit and d == maxX, True)`。
      1. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位限制和 $pos$ 位限制。
      2. $isNum == True$ 表示 $pos$ 位选择了数字。
6. 最后的方案数为 `dfs(0, True, False)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        # isNum: 表示 pos 前面的数位是否填了数字。如果为真，则当前位不可跳过；如果为假，则当前位可跳过。
        def dfs(pos, isLimit, isNum):
            if pos == len(s):
                # isNum 为 True，则表示当前方案符合要求
                return int(isNum)
            
            ans = 0
            if not isNum:
                # 如果 isNumb 为 False，则可以跳过当前数位
                ans = dfs(pos + 1, False, False)
            
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = s[pos] if isLimit else '9'
            
            # 枚举可选择的数字
            for d in digits:
                if d > maxX:
                    break
                ans += dfs(pos + 1, isLimit and d == maxX, True)

            return ans
        
        return dfs(0, True, False)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times \log n)$，其中 $m$ 是数组 $digits$ 的长度，$\log n$ 是 $n$ 转为字符串之后的位数长度。
- **空间复杂度**：$O(\log n)$。

# [0904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

- 标签：数组、哈希表、滑动窗口
- 难度：中等

## 题目链接

- [0904. 水果成篮 - 力扣](https://leetcode.cn/problems/fruit-into-baskets/)

## 题目大意

给定一个数组 `fruits`。其中 `fruits[i]` 表示第 `i` 棵树会产生 `fruits[i]` 型水果。

你可以从你选择的任何树开始，然后重复执行以下步骤：

- 把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
- 移动到当前树右侧的下一棵树。如果右边没有树，就停下来。
- 请注意，在选择一棵树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

你有 `2` 个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。

要求：返回你能收集的水果树的最大总量。

## 解题思路

只有 `2` 个篮子，要求在连续子数组中装最多 `2` 种不同水果。可以理解为维护一个水果种类数为 `2` 的滑动数组，求窗口中最大的水果树数目。具体做法如下：

- 用滑动窗口 `window` 来维护不同种类水果树数目。`window` 为哈希表类型。`ans` 用来维护能收集的水果树的最大总量。设定两个指针：`left`、`right`，分别指向滑动窗口的左右边界，保证窗口中水果种类数不超过 `2` 种。
- 一开始，`left`、`right` 都指向 `0`。
- 将最右侧数组元素 `fruits[right]` 加入当前窗口 `window` 中，该水果树数目 +1。
- 如果该窗口中该水果树种类多于 `2` 种，即 `len(window) > 2`，则不断右移 `left`，缩小滑动窗口长度，并更新窗口中对应水果树的个数，直到 `len(window) <= 2`。
- 维护更新能收集的水果树的最大总量。然后右移 `right`，直到 `right >= len(fruits)` 结束。
- 输出能收集的水果树的最大总量。

## 代码

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        window = dict()
        window_size = 2
        ans = 0
        left, right = 0, 0
        while right < len(fruits):
            if fruits[right] in window:
                window[fruits[right]] += 1
            else:
                window[fruits[right]] = 1

            while len(window) > window_size:
                window[fruits[left]] -= 1
                if window[fruits[left]] == 0:
                    del window[fruits[left]]
                left += 1
            ans = max(ans, right - left + 1)
            right += 1
        return ans
```

# [0908. 最小差值 I](https://leetcode.cn/problems/smallest-range-i/)

- 标签：数组、数学
- 难度：简单

## 题目链接

- [0908. 最小差值 I - 力扣](https://leetcode.cn/problems/smallest-range-i/)

## 题目大意

**描述**：给定一个整数数组 `nums`，和一个整数 `k`。给数组中的每个元素 `nums[i]` 都加上一个任意数字 `x` （`-k <= x <= k`），从而得到一个新数组 `result`。

**要求**：返回数组 `result` 的最大值和最小值之间可能存在的最小差值。

**说明**：

- $1 \le nums.length \le 10^4$。
- $0 \le nums[i] \le 10^4$。
- $0 \le k \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1], k = 0
输出：0
解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。
```

- 示例 2：

```python
输入：nums = [0,10], k = 2
输出：6
解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。
```

## 解题思路

### 思路 1：数学

`nums` 中的每个元素可以波动 `[-k, k]`。最小的差值就是「最大值减去 `k`」和「最小值加上 `k`」之间的差值。而如果差值小于 `0`，则说明每个数字都可以波动成相等的数字，此时直接返回 `0` 即可。

### 思路 1：代码

```python
class Solution:
    def smallestRangeI(self, nums: List[int], k: int) -> int:
        return max(0, max(nums) - min(nums) - 2*k)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [0912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

- 标签：数组、分治、桶排序、计数排序、基数排序、排序、堆（优先队列）、归并排序
- 难度：中等

## 题目链接

- [0912. 排序数组 - 力扣](https://leetcode.cn/problems/sort-an-array/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：将该数组升序排列。

**说明**：

- $1 \le nums.length \le 5 * 10^4$。
- $-5 * 10^4 \le nums[i] \le 5 * 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

- 示例 2：

```python
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

## 解题思路

这道题是一道用来复习排序算法，测试算法时间复杂度的好题。我试过了十种排序算法。得到了如下结论：

- 超时算法（时间复杂度为 $O(n^2)$）：冒泡排序、选择排序、插入排序。
- 通过算法（时间复杂度为 $O(n \times \log n)$）：希尔排序、归并排序、快速排序、堆排序。
- 通过算法（时间复杂度为 $O(n)$）：计数排序、桶排序。
- 解答错误算法（普通基数排序只适合非负数）：基数排序。

### 思路 1：冒泡排序（超时）

> **冒泡排序（Bubble Sort）基本思想**：经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

假设数组的元素个数为 $n$ 个，则冒泡排序的算法步骤如下：

1. 第 $1$ 趟「冒泡」：对前 $n$ 个元素执行「冒泡」，从而使第 $1$ 个值最大的元素放置在正确位置上。
	1. 先将序列中第 $1$ 个元素与第 $2$ 个元素进行比较，如果前者大于后者，则两者交换位置，否则不交换。
	2. 然后将第 $2$ 个元素与第 $3$ 个元素比较，如果前者大于后者，则两者交换位置，否则不交换。
	3. 依次类推，直到第 $n - 1$ 个元素与第 $n$ 个元素比较（或交换）为止。
	4. 经过第 $1$ 趟排序，使得 $n$ 个元素中第 $i$ 个值最大元素被安置在第 $n$ 个位置上。
2. 第 $2$ 趟「冒泡」：对前 $n - 1$ 个元素执行「冒泡」，从而使第 $2$ 个值最大的元素放置在正确位置上。
	1. 先将序列中第 $1$ 个元素与第 $2$ 个元素进行比较，若前者大于后者，则两者交换位置，否则不交换。
	2. 然后将第 $2$ 个元素与第 $3$ 个元素比较，若前者大于后者，则两者交换位置，否则不交换。
	3. 依次类推，直到第 $n - 2$ 个元素与第 $n - 1$ 个元素比较（或交换）为止。
	4. 经过第 $2$ 趟排序，使得数组中第 $2$ 个值最大元素被安置在第 $n$ 个位置上。
3. 依次类推，重复上述「冒泡」过程，直到某一趟排序过程中不出现元素交换位置的动作，则排序结束。

### 思路 1：代码

```python
class Solution:
    def bubbleSort(self, nums: [int]) -> [int]:
        # 第 i 趟「冒泡」
        for i in range(len(nums) - 1):
            flag = False    # 是否发生交换的标志位
            # 对数组未排序区间 [0, n - i - 1] 的元素执行「冒泡」
            for j in range(len(nums) - i - 1):
                # 相邻两个元素进行比较，如果前者大于后者，则交换位置
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    flag = True
            if not flag:    # 此趟遍历未交换任何元素，直接跳出
                break
        
        return nums
    
    def sortArray(self, nums: [int]) -> [int]:
        return self.bubbleSort(nums)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：选择排序（超时）

>**选择排序（Selection Sort）基本思想**：将数组分为两个区间，左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。

假设数组的元素个数为 $n$ 个，则选择排序的算法步骤如下：

1. 初始状态下，无已排序区间，未排序区间为 $[0, n - 1]$。
2. 第 $1$ 趟选择：
	1. 遍历未排序区间 $[0, n - 1]$，使用变量 $min\underline{\hspace{0.5em}}i$ 记录区间中值最小的元素位置。
	2. 将 $min\underline{\hspace{0.5em}}i$ 与下标为 $0$ 处的元素交换位置。如果下标为 $0$ 处元素就是值最小的元素位置，则不用交换。
	3. 此时，$[0, 0]$ 为已排序区间，$[1, n - 1]$（总共 $n - 1$ 个元素）为未排序区间。
3. 第 $2$ 趟选择：
	1. 遍历未排序区间 $[1, n - 1]$，使用变量 $min\underline{\hspace{0.5em}}i$ 记录区间中值最小的元素位置。
	2. 将 $min\underline{\hspace{0.5em}}i$ 与下标为 $1$ 处的元素交换位置。如果下标为 $1$ 处元素就是值最小的元素位置，则不用交换。
	3. 此时，$[0, 1]$ 为已排序区间，$[2, n - 1]$（总共 $n - 2$ 个元素）为未排序区间。
4. 依次类推，对剩余未排序区间重复上述选择过程，直到所有元素都划分到已排序区间，排序结束。

### 思路 2：代码

```python
class Solution:
    def selectionSort(self, nums: [int]) -> [int]:
        for i in range(len(nums) - 1):
            # 记录未排序区间中最小值的位置
            min_i = i
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[min_i]:
                    min_i = j
            # 如果找到最小值的位置，将 i 位置上元素与最小值位置上的元素进行交换
            if i != min_i:
                nums[i], nums[min_i] = nums[min_i], nums[i]
        return nums

    def sortArray(self, nums: [int]) -> [int]:
        return self.selectionSort(nums)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 3：插入排序（超时）

>**插入排序（Insertion Sort）基本思想**：将数组分为两个区间，左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。

假设数组的元素个数为 $n$ 个，则插入排序的算法步骤如下：

1. 初始状态下，有序区间为 $[0, 0]$，无序区间为 $[1, n - 1]$。
2. 第 $1$ 趟插入：
	1. 取出无序区间 $[1, n - 1]$ 中的第 $1$ 个元素，即 $nums[1]$。
	2. 从右到左遍历有序区间中的元素，将比 $nums[1]$ 小的元素向后移动 $1$ 位。
	3. 如果遇到大于或等于 $nums[1]$ 的元素时，说明找到了插入位置，将 $nums[1]$ 插入到该位置。
	4. 插入元素后有序区间变为 $[0, 1]$，无序区间变为 $[2, n - 1]$。
3. 第 $2$ 趟插入：
	1. 取出无序区间 $[2, n - 1]$ 中的第 $1$ 个元素，即 $nums[2]$。
	2. 从右到左遍历有序区间中的元素，将比 $nums[2]$ 小的元素向后移动 $1$ 位。
	3. 如果遇到大于或等于 $nums[2]$ 的元素时，说明找到了插入位置，将 $nums[2]$ 插入到该位置。
	4. 插入元素后有序区间变为 $[0, 2]$，无序区间变为 $[3, n - 1]$。
4. 依次类推，对剩余无序区间中的元素重复上述插入过程，直到所有元素都插入到有序区间中，排序结束。

### 思路 3：代码

```python
class Solution:
    def insertionSort(self, nums: [int]) -> [int]:
        # 遍历无序区间
        for i in range(1, len(nums)):
            temp = nums[i]
            j = i
            # 从右至左遍历有序区间
            while j > 0 and nums[j - 1] > temp:
                # 将有序区间中插入位置右侧的所有元素依次右移一位
                nums[j] = nums[j - 1]
                j -= 1
            # 将该元素插入到适当位置
            nums[j] = temp

        return nums

    def sortArray(self, nums: [int]) -> [int]:
        return self.insertionSort(nums)
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 4：希尔排序（通过）

> **希尔排序（Shell Sort）基本思想**：将整个数组切按照一定的间隔取值划分为若干个子数组，每个子数组分别进行插入排序。然后逐渐缩小间隔进行下一轮划分子数组和对子数组进行插入排序。直至最后一轮排序间隔为 $1$，对整个数组进行插入排序。

假设数组的元素个数为 $n$ 个，则希尔排序的算法步骤如下：

1. 确定一个元素间隔数 $gap$。
2. 将参加排序的数组按此间隔数从第 $1$ 个元素开始一次分成若干个子数组，即分别将所有位置相隔为 $gap$ 的元素视为一个子数组。
3. 在各个子数组中采用某种排序算法（例如插入排序算法）进行排序。
4. 减少间隔数，并重新将整个数组按新的间隔数分成若干个子数组，再分别对各个子数组进行排序。
5. 依次类推，直到间隔数 $gap$ 值为 $1$，最后进行一次排序，排序结束。

### 思路 4：代码

```python
class Solution:
    def shellSort(self, nums: [int]) -> [int]:
        size = len(nums)
        gap = size // 2
        # 按照 gap 分组
        while gap > 0:
            # 对每组元素进行插入排序
            for i in range(gap, size):
                # temp 为每组中无序数组第 1 个元素
                temp = nums[i]
                j = i
                # 从右至左遍历每组中的有序数组元素
                while j >= gap and nums[j - gap] > temp:
                    # 将每组有序数组中插入位置右侧的元素依次在组中右移一位
                    nums[j] = nums[j - gap]
                    j -= gap
                # 将该元素插入到适当位置
                nums[j] = temp
            # 缩小 gap 间隔
            gap = gap // 2
        return nums

    def sortArray(self, nums: [int]) -> [int]:
        return self.shellSort(nums)
```

### 思路 4：复杂度分析

- **时间复杂度**：介于 $O(n \times \log n)$ 与 $O(n^2)$ 之间。
- **空间复杂度**：$O(1)$。

### 思路 5：归并排序（通过）

> **归并排序（Merge Sort）基本思想**：采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。

假设数组的元素个数为 $n$ 个，则归并排序的算法步骤如下：

1. **分解过程**：先递归地将当前数组平均分成两半，直到子数组长度为 $1$。
	1. 找到数组中心位置 $mid$，从中心位置将数组分成左右两个子数组 $left\underline{\hspace{0.5em}}nums$、$right\underline{\hspace{0.5em}}nums$。
	2. 对左右两个子数组 $left\underline{\hspace{0.5em}}nums$、$right\underline{\hspace{0.5em}}nums$ 分别进行递归分解。
	3. 最终将数组分解为 $n$ 个长度均为 $1$ 的有序子数组。
2. **归并过程**：从长度为 $1$ 的有序子数组开始，依次将有序数组两两合并，直到合并成一个长度为 $n$ 的有序数组。
	1. 使用数组变量 $nums$ 存放合并后的有序数组。
	2. 使用两个指针 $left\underline{\hspace{0.5em}}i$、$right\underline{\hspace{0.5em}}i$ 分别指向两个有序子数组 $left\underline{\hspace{0.5em}}nums$、$right\underline{\hspace{0.5em}}nums$ 的开始位置。
	3. 比较两个指针指向的元素，将两个有序子数组中较小元素依次存入到结果数组 $nums$ 中，并将指针移动到下一位置。
	4. 重复步骤 $3$，直到某一指针到达子数组末尾。
	5. 将另一个子数组中的剩余元素存入到结果数组 $nums$ 中。
	6. 返回合并后的有序数组 $nums$。

### 思路 5：代码

```python
class Solution:
    # 合并过程
    def merge(self, left_nums: [int], right_nums: [int]):
        nums = []
        left_i, right_i = 0, 0
        while left_i < len(left_nums) and right_i < len(right_nums):
            # 将两个有序子数组中较小元素依次插入到结果数组中
            if left_nums[left_i] < right_nums[right_i]:
                nums.append(left_nums[left_i])
                left_i += 1
            else:
                nums.append(right_nums[right_i])
                right_i += 1
        
        # 如果左子数组有剩余元素，则将其插入到结果数组中
        while left_i < len(left_nums):
            nums.append(left_nums[left_i])
            left_i += 1
        
        # 如果右子数组有剩余元素，则将其插入到结果数组中
        while right_i < len(right_nums):
            nums.append(right_nums[right_i])
            right_i += 1
        
        # 返回合并后的结果数组
        return nums

    # 分解过程
    def mergeSort(self, nums: [int]) -> [int]:
        # 数组元素个数小于等于 1 时，直接返回原数组
        if len(nums) <= 1:
            return nums
        
        mid = len(nums) // 2                        # 将数组从中间位置分为左右两个数组
        left_nums = self.mergeSort(nums[0: mid])    # 递归将左子数组进行分解和排序
        right_nums =  self.mergeSort(nums[mid:])    # 递归将右子数组进行分解和排序
        return self.merge(left_nums, right_nums)    # 把当前数组组中有序子数组逐层向上，进行两两合并

    def sortArray(self, nums: [int]) -> [int]:
        return self.mergeSort(nums)
```

### 思路 5：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

### 思路 6：快速排序（通过）

> **快速排序（Quick Sort）基本思想**：采用经典的分治策略，选择数组中某个元素作为基准数，通过一趟排序将数组分为独立的两个子数组，一个子数组中所有元素值都比基准数小，另一个子数组中所有元素值都比基准数大。然后再按照同样的方式递归的对两个子数组分别进行快速排序，以达到整个数组有序。

假设数组的元素个数为 $n$ 个，则快速排序的算法步骤如下：

1. **哨兵划分**：选取一个基准数，将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。
	1. 从当前数组中找到一个基准数 $pivot$（这里以当前数组第 $1$ 个元素作为基准数，即 $pivot = nums[low]$）。
	2. 使用指针 $i$ 指向数组开始位置，指针 $j$  指向数组末尾位置。
	3. 从右向左移动指针 $j$，找到第 $1$ 个小于基准值的元素。
	4. 从左向右移动指针 $i$，找到第 $1$ 个大于基准数的元素。
	5. 交换指针 $i$、指针 $j$ 指向的两个元素位置。
	6. 重复第 $3 \sim 5$ 步，直到指针 $i$ 和指针 $j$ 相遇时停止，最后将基准数放到两个子数组交界的位置上。
2. **递归分解**：完成哨兵划分之后，对划分好的左右子数组分别进行递归排序。
	1. 按照基准数的位置将数组拆分为左右两个子数组。
	2. 对每个子数组分别重复「哨兵划分」和「递归分解」，直到各个子数组只有 $1$ 个元素，排序结束。

### 思路 6：代码

```python
import random

class Solution:
    # 随机哨兵划分：从 nums[low: high + 1] 中随机挑选一个基准数，并进行移位排序
    def randomPartition(self, nums: [int], low: int, high: int) -> int:
        # 随机挑选一个基准数
        i = random.randint(low, high)
        # 将基准数与最低位互换
        nums[i], nums[low] = nums[low], nums[i]
        # 以最低位为基准数，然后将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。最后将基准数放到正确位置上
        return self.partition(nums, low, high)
    
    # 哨兵划分：以第 1 位元素 nums[low] 为基准数，然后将比基准数小的元素移动到基准数左侧，将比基准数大的元素移动到基准数右侧，最后将基准数放到正确位置上
    def partition(self, nums: [int], low: int, high: int) -> int:        
        # 以第 1 位元素为基准数
        pivot = nums[low]
        
        i, j = low, high
        while i < j:
            # 从右向左找到第 1 个小于基准数的元素
            while i < j and nums[j] >= pivot:
                j -= 1
            # 从左向右找到第 1 个大于基准数的元素
            while i < j and nums[i] <= pivot:
                i += 1
            # 交换元素
            nums[i], nums[j] = nums[j], nums[i]
        
        # 将基准数放到正确位置上
        nums[j], nums[low] = nums[low], nums[j]
        return j

    def quickSort(self, nums: [int], low: int, high: int) -> [int]:
        if low < high:
            # 按照基准数的位置，将数组划分为左右两个子数组
            pivot_i = self.partition(nums, low, high)
            # 对左右两个子数组分别进行递归快速排序
            self.quickSort(nums, low, pivot_i - 1)
            self.quickSort(nums, pivot_i + 1, high)

        return nums

    def sortArray(self, nums: [int]) -> [int]:
        return self.quickSort(nums, 0, len(nums) - 1)
```

### 思路 6：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

### 思路 7：堆排序（通过）

> **堆排序（Heap sort）基本思想**：借用「堆结构」所设计的排序算法。将数组转化为大顶堆，重复从大顶堆中取出数值最大的节点，并让剩余的堆结构继续维持大顶堆性质。

假设数组的元素个数为 $n$ 个，则堆排序的算法步骤如下：

1. **构建初始大顶堆**：
	1. 定义一个数组实现的堆结构，将原始数组的元素依次存入堆结构的数组中（初始顺序不变）。
	2. 从数组的中间位置开始，从右至左，依次通过「下移调整」将数组转换为一个大顶堆。

2. **交换元素，调整堆**：
	1. 交换堆顶元素（第 $1$ 个元素）与末尾（最后 $1$ 个元素）的位置，交换完成后，堆的长度减 $1$。
	2. 交换元素之后，由于堆顶元素发生了改变，需要从根节点开始，对当前堆进行「下移调整」，使其保持堆的特性。

3. **重复交换和调整堆**：
	1. 重复第 $2$ 步，直到堆的大小为 $1$ 时，此时大顶堆的数组已经完全有序。

### 思路 7：代码

```python
class Solution:
    # 调整为大顶堆
    def heapify(self, arr, index, end):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子节点
            max_index = index
            if arr[left] > arr[max_index]:
                max_index = left
            if right <= end and arr[right] > arr[max_index]:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            arr[index], arr[max_index] = arr[max_index], arr[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1

    # 初始化大顶堆
    def buildMaxHeap(self, arr):
        size = len(arr)
        # (size-2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((size - 2) // 2, -1, -1):
            self.heapify(arr, i, size - 1)
        return arr

    # 升序堆排序，思路如下：
    # 1. 先建立大顶堆
    # 2. 让堆顶最大元素与最后一个交换，然后调整第一个元素到倒数第二个元素，这一步获取最大值
    # 3. 再交换堆顶元素与倒数第二个元素，然后调整第一个元素到倒数第三个元素，这一步获取第二大值
    # 4. 以此类推，直到最后一个元素交换之后完毕。
    def maxHeapSort(self, arr):
        self.buildMaxHeap(arr)
        size = len(arr)
        for i in range(size):
            arr[0], arr[size-i-1] = arr[size-i-1], arr[0]
            self.heapify(arr, 0, size-i-2)
        return arr

    def sortArray(self, nums: List[int]) -> List[int]:
        return self.maxHeapSort(nums)
```

### 思路 7：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

### 思路 8：计数排序（通过）

> **计数排序（Counting Sort）基本思想**：通过统计数组中每个元素在数组中出现的次数，根据这些统计信息将数组元素有序的放置到正确位置，从而达到排序的目的。

假设数组的元素个数为 $n$ 个，则计数排序的算法步骤如下：

1. **计算排序范围**：遍历数组，找出待排序序列中最大值元素 $nums\underline{\hspace{0.5em}}max$ 和最小值元素 $nums\underline{\hspace{0.5em}}min$，计算出排序范围为 $nums\underline{\hspace{0.5em}}max - nums\underline{\hspace{0.5em}}min + 1$。
2. **定义计数数组**：定义一个大小为排序范围的计数数组 $counts$，用于统计每个元素的出现次数。其中：
	1. 数组的索引值 $num - nums\underline{\hspace{0.5em}}min$ 表示元素的值为 $num$。
	2. 数组的值 $counts[num - nums\underline{\hspace{0.5em}}min]$ 表示元素 $num$ 的出现次数。

3. **对数组元素进行计数统计**：遍历待排序数组 $nums$，对每个元素在计数数组中进行计数，即将待排序数组中「每个元素值减去最小值」作为索引，将「对计数数组中的值」加 $1$，即令 $counts[num - nums\underline{\hspace{0.5em}}min]$ 加 $1$。
4. **生成累积计数数组**：从 $counts$ 中的第 $1$ 个元素开始，每一项累家前一项和。此时 $counts[num - nums\underline{\hspace{0.5em}}min]$ 表示值为 $num$ 的元素在排序数组中最后一次出现的位置。
5. **逆序填充目标数组**：逆序遍历数组 $nums$，将每个元素 $num$ 填入正确位置。
  6. 将其填充到结果数组 $res$ 的索引 $counts[num - nums\underline{\hspace{0.5em}}min]$ 处。
  7. 放入后，令累积计数数组中对应索引减 $1$，从而得到下个元素 $num$ 的放置位置。

### 思路 8：代码

```python
class Solution:
    def countingSort(self, nums: [int]) -> [int]:
        # 计算待排序数组中最大值元素 nums_max 和最小值元素 nums_min
        nums_min, nums_max = min(nums), max(nums)
        # 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1
        size = nums_max - nums_min + 1
        counts = [0 for _ in range(size)]
        
        # 统计值为 num 的元素出现的次数
        for num in nums:
            counts[num - nums_min] += 1
        
        # 生成累积计数数组
        for i in range(1, size):
            counts[i] += counts[i - 1]

        # 反向填充目标数组
        res = [0 for _ in range(len(nums))]
        for i in range(len(nums) - 1, -1, -1):
            num = nums[i]
            # 根据累积计数数组，将 num 放在数组对应位置
            res[counts[num - nums_min] - 1] = num
            # 将 num 的对应放置位置减 1，从而得到下个元素 num 的放置位置
            counts[nums[i] - nums_min] -= 1

        return res

    def sortArray(self, nums: [int]) -> [int]:
        return self.countingSort(nums)
```

### 思路 8：复杂度分析

- **时间复杂度**：$O(n + k)$。其中 $k$ 代表待排序序列的值域。
- **空间复杂度**：$O(k)$。其中 $k$ 代表待排序序列的值域。

### 思路 9：桶排序（通过）

> **桶排序（Bucket Sort）基本思想**：将待排序数组中的元素分散到若干个「桶」中，然后对每个桶中的元素再进行单独排序。

假设数组的元素个数为 $n$ 个，则桶排序的算法步骤如下：

1. **确定桶的数量**：根据待排序数组的值域范围，将数组划分为 $k$ 个桶，每个桶可以看做是一个范围区间。
2. **分配元素**：遍历待排序数组元素，将每个元素根据大小分配到对应的桶中。
3. **对每个桶进行排序**：对每个非空桶内的元素单独排序（使用插入排序、归并排序、快排排序等算法）。
4. **合并桶内元素**：将排好序的各个桶中的元素按照区间顺序依次合并起来，形成一个完整的有序数组。

### 思路 9：代码

```python
class Solution:
    def insertionSort(self, nums: [int]) -> [int]:
        # 遍历无序区间
        for i in range(1, len(nums)):
            temp = nums[i]
            j = i
            # 从右至左遍历有序区间
            while j > 0 and nums[j - 1] > temp:
                # 将有序区间中插入位置右侧的元素依次右移一位
                nums[j] = nums[j - 1]
                j -= 1
            # 将该元素插入到适当位置
            nums[j] = temp
            
        return nums

    def bucketSort(self,  nums: [int], bucket_size=5) -> [int]:
        # 计算待排序序列中最大值元素 nums_max、最小值元素 nums_min
        nums_min, nums_max = min(nums), max(nums)
        # 定义桶的个数为 (最大值元素 - 最小值元素) // 每个桶的大小 + 1
        bucket_count = (nums_max - nums_min) // bucket_size + 1
        # 定义桶数组 buckets
        buckets = [[] for _ in range(bucket_count)]

        # 遍历待排序数组元素，将每个元素根据大小分配到对应的桶中
        for num in nums:
            buckets[(num - nums_min) // bucket_size].append(num)

        # 对每个非空桶内的元素单独排序，排序之后，按照区间顺序依次合并到 res 数组中
        res = []
        for bucket in buckets:
            self.insertionSort(bucket)
            res.extend(bucket)
        
        # 返回结果数组
        return res

    def sortArray(self, nums: [int]) -> [int]:
        return self.bucketSort(nums)
```

### 思路 9：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n + m)$。$m$ 为桶的个数。

### 思路 10：基数排序（提交解答错误，普通基数排序只适合非负数）

> **基数排序（Radix Sort）基本思想**：将整数按位数切割成不同的数字，然后从低位开始，依次到高位，逐位进行排序，从而达到排序的目的。

我们以最低位优先法为例，讲解一下基数排序的算法步骤。

1. **确定排序的最大位数**：遍历数组元素，获取数组最大值元素，并取得对应位数。
2. **从最低位（个位）开始，到最高位为止，逐位对每一位进行排序**：
	1. 定义一个长度为 $10$ 的桶数组 $buckets$，每个桶分别代表 $0 \sim 9$ 中的 $1$ 个数字。
	2. 按照每个元素当前位上的数字，将元素放入对应数字的桶中。
	3. 清空原始数组，然后按照桶的顺序依次取出对应元素，重新加入到原始数组中。

### 思路 10：代码

```python
class Solution:
    def radixSort(self, nums: [int]) -> [int]:
        # 桶的大小为所有元素的最大位数
        size = len(str(max(nums)))
        
        # 从最低位（个位）开始，逐位遍历每一位
        for i in range(size):
            # 定义长度为 10 的桶数组 buckets，每个桶分别代表 0 ~ 9 中的 1 个数字。
            buckets = [[] for _ in range(10)]
            # 遍历数组元素，按照每个元素当前位上的数字，将元素放入对应数字的桶中。
            for num in nums:
                buckets[num // (10 ** i) % 10].append(num)
            # 清空原始数组
            nums.clear()
            # 按照桶的顺序依次取出对应元素，重新加入到原始数组中。
            for bucket in buckets:
                for num in bucket:
                    nums.append(num)
                    
        # 完成排序，返回结果数组
        return nums
    
    def sortArray(self, nums: [int]) -> [int]:
        return self.radixSort(nums)
```

### 思路 10：复杂度分析

- **时间复杂度**：$O(n \times k)$。其中 $n$ 是待排序元素的个数，$k$ 是数字位数。$k$ 的大小取决于数字位的选择（十进制位、二进制位）和待排序元素所属数据类型全集的大小。
- **空间复杂度**：$O(n + k)$。

# [0918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

- 标签：队列、数组、分治、动态规划、单调队列
- 难度：中等

## 题目链接

- [0918. 环形子数组的最大和 - 力扣](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

## 题目大意

给定一个环形整数数组 nums，数组 nums 的尾部和头部是相连状态。求环形数组 nums 的非空子数组的最大和（子数组中每个位置元素最多出现一次）。

## 解题思路

构成环形整数数组 nums 的非空子数组的最大和的子数组有两种情况：

- 最大和的子数组为一个子区间：$nums[i] + nums[i+1] + nums[i+2] + ... + num[j]$。
- 最大和的子数组为首尾的两个子区间：$(nums[0] + nums[1] + ... + nums[i]) + (nums[j] + nums[j+1] + ... + num[N-1])$。

第一种情况其实就是无环情况下的整数数组的非空子数组最大和问题，跟「[53. 最大子序和](https://leetcode.cn/problems/maximum-subarray/)」问题是一致的，我们假设求解结果为 `max_num`。

下来来思考第二种情况，第二种情况下，要使首尾两个子区间的和尽可能的大，则中间的子区间的和应该尽可能的小。

使得中间子区间的和尽可能小的问题，可以转变为求解：整数数组 nums 的非空子数组最小和问题。求解思路跟上边是相似的，只不过最大变为了最小。我们假设求解结果为 `min_num`。

而首尾两个区间和尽可能大的结果为数组 nums 的和减去中间最小子数组和，即 `sum(nums) - min_num`。

 最终的结果就是比较 `sum(nums) - min_num` 和 `max_num`的大小，返回较大值即可。

## 代码

```python
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        size = len(nums)

        dp_max, dp_min = nums[0], nums[0]
        max_num, min_num = nums[0], nums[0]
        for i in range(1, size):
            dp_max = max(dp_max + nums[i], nums[i])
            dp_min = min(dp_min + nums[i], nums[i])
            max_num = max(dp_max, max_num)
            min_num = min(dp_min, min_num)
        sum_num = sum(nums)
        if max_num < 0:
            return max_num
        return max(sum_num - min_num, max_num)
```

# [0919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

- 标签：树、广度优先搜索、设计、二叉树
- 难度：中等

## 题目链接

- [0919. 完全二叉树插入器 - 力扣](https://leetcode.cn/problems/complete-binary-tree-inserter/)

## 题目大意

要求：设计一个用完全二叉树初始化的数据结构 `CBTInserter`，并支持以下几种操作：

- `CBTInserter(TreeNode root)` 使用根节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)`  向树中插入一个新节点，节点类型为 `TreeNode`，值为 `v`。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；
- `CBTInserter.get_root()` 返回树的根节点。

## 解题思路

使用数组标记完全二叉树中节点的序号，初始化数组为 `[None]`。完全二叉树中节点的序号从 `1` 开始，对于序号为 `k` 的节点，其左子节点序号为 `2k`，右子节点的序号为 `2k + 1`，其父节点的序号为 `k // 2`。

然后在初始化和插入节点的同时，按顺序向数组中插入节点。

## 代码

```python
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.queue = [root]
        self.nodelist = [None]

        while self.queue:
            node = self.queue.pop(0)
            self.nodelist.append(node)
            if node.left:
                self.queue.append(node.left)
            if node.right:
                self.queue.append(node.right)


    def insert(self, v: int) -> int:
        self.nodelist.append(TreeNode(v))
        index = len(self.nodelist) - 1
        father = self.nodelist[index // 2]
        if index % 2 == 0:
            father.left = self.nodelist[-1]
        else:
            father.right = self.nodelist[-1]
        return father.val


    def get_root(self) -> TreeNode:
        return self.nodelist[1]
```

# [0921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

- 标签：栈、贪心、字符串
- 难度：中等

## 题目链接

- [0921. 使括号有效的最少添加 - 力扣](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

## 题目大意

**描述**：给定一个括号字符串 `s`，可以在字符串的任何位置插入一个括号。

**要求**：返回为使结果字符串 `s` 有效而必须添加的最少括号数。

**说明**：

- $1 \le s.length \le 1000$。
- `s` 只包含 `'('` 和 `')'` 字符。

只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
- 它可以被写作 (A)，其中 A 是有效字符串。

例如，如果 `s = "()))"`，你可以插入一个开始括号为 `"(()))"` 或结束括号为 `"())))"`。

**示例**：

- 示例 1：

```python
输入：s = "())"
输出：1
```

## 解题思路

### 思路 1：贪心算法

为了最终添加的最少括号数，我们应该尽可能将当前能够匹配的括号先进行配对。则剩余的未完成配对的括号数量就是答案。

我们使用变量 `left_cnt` 来记录当前左括号的数量。使用 `res` 来记录添加的最少括号数量。

- 遍历字符串，判断当前字符。
- 如果当前字符为左括号 `(`，则令 `left_cnt` 加 `1`。
- 如果当前字符为右括号 `)`，则令 `left_cnt` 减 `1`。如果 `left_cnt` 减到 `-1`，说明当前有右括号不能完成匹配，则答案数量 `res` 加 `1`，并令 `left_cnt` 重新赋值为 `0`。
- 遍历完之后，令 `res` 加上剩余不匹配的 `left_cnt` 数量。
- 最后输出 `res`。

### 思路 1：贪心算法代码

```python
class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        res = 0
        left_cnt = 0
        for ch in s:
            if ch == '(':
                left_cnt += 1
            elif ch == ')':
                left_cnt -= 1
                if left_cnt == -1:
                    left_cnt = 0
                    res += 1
        res += left_cnt
        return res
```
# [0925. 长按键入](https://leetcode.cn/problems/long-pressed-name/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [0925. 长按键入 - 力扣](https://leetcode.cn/problems/long-pressed-name/)

## 题目大意

**描述**：你的朋友正在使用键盘输入他的名字 $name$。偶尔，在键入字符时，按键可能会被长按，而字符可能被输入 $1$ 次或多次。

现在给定代表名字的字符串 $name$，以及实际输入的字符串 $typed$。

**要求**：检查键盘输入的字符 $typed$。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），就返回 `True`。否则返回 `False`。

**说明**：

- $1 \le name.length, typed.length \le 1000$。
- $name$ 和 $typed$ 的字符都是小写字母。

**示例**：

- 示例 1：

```python
输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
```

- 示例 2：

```python
输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
```

## 解题思路

### 思路 1：分离双指针

这道题目的意思是在 $typed$ 里边匹配 $name$，同时要考虑字符重复问题，以及不匹配的情况。可以使用分离双指针来做。具体做法如下：

1. 使用两个指针 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$，$left\underline{\hspace{0.5em}}1$ 指向字符串 $name$ 开始位置，$left\underline{\hspace{0.5em}}2$ 指向字符串 $type$ 开始位置。
2. 如果 $name[left\underline{\hspace{0.5em}}1] == name[left\underline{\hspace{0.5em}}2]$，则将 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$ 同时右移。
3. 如果 $nmae[left\underline{\hspace{0.5em}}1] \ne name[left\underline{\hspace{0.5em}}2]$，则：
   1. 如果 $typed[left\underline{\hspace{0.5em}}2]$ 和前一个位置元素 $typed[left\underline{\hspace{0.5em}}2 - 1]$ 相等，则说明出现了重复元素，将 $left\underline{\hspace{0.5em}}2$ 右移，过滤重复元素。
   2. 如果 $typed[left\underline{\hspace{0.5em}}2]$ 和前一个位置元素 $typed[left\underline{\hspace{0.5em}}2 - 1]$ 不等，则说明出现了多余元素，不匹配。直接返回 `False` 即可。

4. 当 $left\underline{\hspace{0.5em}}1 == len(name)$ 或者 $left\underline{\hspace{0.5em}}2 == len(typed)$ 时跳出循环。然后过滤掉 $typed$ 末尾的重复元素。
5. 最后判断，如果 $left\underline{\hspace{0.5em}}1 == len(name)$ 并且 $left\underline{\hspace{0.5em}}2 == len(typed)$，则说明匹配，返回 `True`，否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        left_1, left_2 = 0, 0

        while left_1 < len(name) and left_2 < len(typed):
            if name[left_1] == typed[left_2]:
                left_1 += 1
                left_2 += 1
            elif left_2 > 0 and typed[left_2 - 1] == typed[left_2]:
                left_2 += 1
            else:
                return False
        while 0 < left_2 < len(typed) and typed[left_2] == typed[left_2 - 1]:
            left_2 += 1

        if left_1 == len(name) and left_2 == len(typed):
            return True
        else:
            return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$。其中 $n$、$m$ 分别为字符串 $name$、$typed$ 的长度。
- **空间复杂度**：$O(1)$。

# [0932. 漂亮数组](https://leetcode.cn/problems/beautiful-array/)

- 标签：数组、数学、分治
- 难度：中等

## 题目链接

- [0932. 漂亮数组 - 力扣](https://leetcode.cn/problems/beautiful-array/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回长度为 $n$ 的任一漂亮数组。

**说明**：

- **漂亮数组**（长度为 $n$ 的数组 $nums$ 满足下述条件）：
  - $nums$ 是由范围 $[1, n]$ 的整数组成的一个排列。
  - 对于每个 $0 \le i < j < n$，均不存在下标 $k$（$i < k < j$）使得 $2 \times nums[k] == nums[i] + nums[j]$。
- $1 \le n \le 1000$。
- 本题保证对于给定的 $n$ 至少存在一个有效答案。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：[2,1,4,3]
```

- 示例 2：

```python
输入：n = 5
输出：[3,1,2,5,4]
```

## 解题思路

### 思路 1：分治算法

根据题目要求，我们可以得到以下信息：

1. 题目要求 $2 \times nums[k] == nums[i] + nums[j], (0 \le i < k < j < n)$ 不能成立，可知：等式左侧必为偶数，只要右侧和为奇数则等式不成立。
2. 已知：奇数 + 偶数 = 奇数，则令 $nums[i]$ 和 $nums[j]$ 其中一个为奇数，另一个为偶数，即可保证 $nums[i] + nums[j]$ 一定为奇数。这里我们不妨令 $nums[i]$ 为奇数，令 $nums[j]$ 为偶数。
3. 如果数组 $nums$ 是漂亮数组，那么对数组 $nums$ 的每一位元素乘以一个常数或者加上一个常数之后，$nums$ 仍是漂亮数组。
   - 即如果 $[a_1, a_2, ..., a_n]$ 是一个漂亮数组，那么 $[k \times a_1 + b, k \times a_2 + b, ..., k \times a_n + b]$ 也是漂亮数组。

那么，我们可以按照下面的规则构建长度为 $n$ 的漂亮数组。

1. 当 $n = 1$ 时，返回 $[1]$。此时数组 $nums$ 中仅有 $1$ 个元素，并且满足漂亮数组的条件。
2. 当 $n > 1$ 时，我们将 $nums$ 分解为左右两个部分：`left_nums`、`right_nums`。如果左右两个部分满足：
   1. 数组 `left_nums` 中元素全为奇数（可以通过 `nums[i] * 2 - 1` 将 `left_nums` 中元素全部映射为奇数）。
   2. 数组 `right_nums` 中元素全为偶数（可以通过 `nums[i] * 2` 将 `right_nums` 中元素全部映射为偶数）。
   3. `left_nums` 和 `right_nums` 都是漂亮数组。
3. 那么 `left_nums + right_nums` 构成的数组一定也是漂亮数组，即 $nums$ 为漂亮数组，将 $nums$ 返回即可。

### 思路 1：代码

```python
class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        if n == 1:
            return [1]

        nums = [0 for _ in range(n)]
        left_cnt = (n + 1) // 2
        right_cnt = n - left_cnt
        left_nums = self.beautifulArray(left_cnt)
        right_nums = self.beautifulArray(right_cnt)

        for i in range(left_cnt):
            nums[i] = 2 * left_nums[i] - 1
        
        for i in range(right_cnt):
            nums[left_cnt + i] = 2 * right_nums[i]
        
        return nums
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n \times \log n)$。
# [0933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)

- 标签：设计、队列、数据流
- 难度：简单

## 题目链接

- [0933. 最近的请求次数 - 力扣](https://leetcode.cn/problems/number-of-recent-calls/)

## 题目大意

要求：实现一个用来计算特定时间范围内的最近请求的 `RecentCounter` 类：

- `RecentCounter()` 初始化计数器，请求数为 0 。
- `int ping(int t)` 在时间 `t` 时添加一个新请求，其中 `t` 表示以毫秒为单位的某个时间，并返回在 `[t-3000, t]` 内发生的请求数。

## 解题思路

使用一个队列，用于存储 `[t - 3000, t]` 范围内的请求。

获取请求数时，将队首所有小于 `t - 3000` 时间的请求将其从队列中移除，然后返回队列的长度即可。

## 代码

```python
class RecentCounter:

    def __init__(self):
        self.queue = []


    def ping(self, t: int) -> int:
        self.queue.append(t)
        while self.queue[0] < t - 3000:
            self.queue.pop(0)
        return len(self.queue)
```

# [0935. 骑士拨号器](https://leetcode.cn/problems/knight-dialer/)

- 标签：动态规划
- 难度：中等

## 题目链接

- [0935. 骑士拨号器 - 力扣](https://leetcode.cn/problems/knight-dialer/)

## 题目大意

**描述**：象棋骑士可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格（两者都形成一个 $L$ 的形状），如下图所示。

![](https://assets.leetcode.com/uploads/2020/08/18/chess.jpg)

现在我们有一个象棋其实和一个电话垫，如下图所示，骑士只能站在一个数字单元格上（$0 \sim 9$）。

![](https://assets.leetcode.com/uploads/2020/08/18/phone.jpg)

现在给定一个整数 $n$。

**要求**：返回我们可以拨多少个长度为 $n$ 的不同电话号码。因为答案可能很大，所以最终答案需要对 $10^9 + 7$ 进行取模。

**说明**：

- 可以将骑士放在任何数字单元格上，然后执行 $n - 1$ 次移动来获得长度为 $n$ 的电话号码。
- $1 \le n \le 5000$。

**示例**：

- 示例 1：

```python
输入：n = 1
输出：10
解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。
```

- 示例 2：

```python
输入：n = 2
输出：20
解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
```

## 解题思路

### 思路 1：动态规划

根据象棋骑士的跳跃规则，以及电话键盘的样式，我们可以预先处理一下象棋骑士当前位置与下一步能跳跃到的位置关系，将其存入哈希表中，方便查询。

接下来我们可以用动态规划的方式，计算出跳跃 $n - 1$ 次总共能得到多少个长度为 $n$ 的不同电话号码。

###### 1. 划分阶段

按照步数、所处数字位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][v]$ 表示为：第 $i$ 步到达键位 $u$ 总共能到的长度为 $i + 1$ 的不同电话号码个数。

###### 3. 状态转移方程

第 $i$ 步到达键位 $v$ 所能得到的不同电话号码个数，取决于 $i - 1$ 步中所有能到达 $v$ 的键位 $u$ 的不同电话号码个数总和。

呢状态转移方程为：$dp[i][v] = \sum dp[i - 1][u]$（可以从 $u$ 跳到 $v$）。

###### 4. 初始条件

- 第 $0$ 步（位于开始位置）所能得到的电话号码个数为 $1$，因为开始时可以将骑士放在任何数字单元格上，所以所有的 $dp[0][v] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][v]$ 表示为：第 $i$ 步到达键位 $u$ 总共能到的长度为 $i + 1$ 的不同电话号码个数。 所以最终结果为第 $n - 1$ 行所有的 $dp[n - 1][v]$ 的总和。

###  思路 1：代码

```python
class Solution:
    def knightDialer(self, n: int) -> int:
        graph = {
            0: [4, 6],
            1: [6, 8],
            2: [7, 9],
            3: [4, 8],
            4: [0, 3, 9],
            5: [],
            6: [0, 1, 7],
            7: [2, 6],
            8: [1, 3],
            9: [2, 4]
        }

        MOD = 10 ** 9 + 7
        dp = [[0 for _ in range(10)] for _ in range(n)]
        for v in range(10):
            dp[0][v] = 1

        for i in range(1, n):
            for u in range(10):
                for v in graph[u]:
                    dp[i][v] = (dp[i][v] + dp[i - 1][u]) % MOD
        
        return sum(dp[n - 1]) % MOD
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 10)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n \times 10)$。

# [0938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [0938. 二叉搜索树的范围和 - 力扣](https://leetcode.cn/problems/range-sum-of-bst/)

## 题目大意

给定一个二叉搜索树，和一个范围 [low, high]。求范围 [low, high] 之间所有节点的值的和。

## 解题思路

二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

这道题求解 [low, high] 之间所有节点的值的和，需要递归求解。

- 当前节点为 None 时返回 0；
- 当前节点值 val > high 时，则返回左子树之和；
- 当前节点值 val < low 时，则返回右子树之和；
- 当前节点 val <= high，且 val >= low 时，则返回当前节点值 + 左子树之和 + 右子树之和。

## 代码

```python
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        if not root:
            return 0
        if root.val > high:
            return self.rangeSumBST(root.left, low, high)
        if root.val < low:
            return self.rangeSumBST(root.right, low, high)
        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)
```

# [0946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)

- 标签：栈、数组、模拟
- 难度：中等

## 题目链接

- [0946. 验证栈序列 - 力扣](https://leetcode.cn/problems/validate-stack-sequences/)

## 题目大意

**描述**：给定两个整数序列 `pushed` 和 `popped`，每个序列中的值都不重复。

**要求**：如果第一个序列为空栈的压入顺序，而第二个序列 `popped` 为该栈的压出序列，则返回 `True`，否则返回 `False`。

**说明**：

- $1 \le pushed.length \le 1000$。
- $0 \le pushed[i] \le 1000$。
- $pushed$ 的所有元素互不相同。
- $popped.length == pushed.length$。
- $popped$ 是 $pushed$ 的一个排列。

**示例**：

- 示例 1：

```python
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

- 示例 2：

```python
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

## 解题思路

### 思路 1：栈

借助一个栈来模拟压入、压出的操作。检测最后是否能模拟成功。

### 思路 1：代码

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack = []
        index = 0
        for item in pushed:
            stack.append(item)
            while (stack and stack[-1] == popped[index]):
                stack.pop()
                index += 1

        return len(stack) == 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [0947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

- 标签：深度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0947. 移除最多的同行或同列石头 - 力扣](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

## 题目大意

**描述**：二维平面中有 $n$ 块石头，每块石头都在整数坐标点上，且每个坐标点上最多只能有一块石头。如果一块石头的同行或者同列上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 $n$ 的数组 $stones$ ，其中 $stones[i] = [xi, yi]$ 表示第 $i$ 块石头的位置。

**要求**：返回可以移除的石子的最大数量。

**说明**：

- $1 \le stones.length \le 1000$。
- $0 \le xi, yi \le 10^4$。
- 不会有两块石头放在同一个坐标点上。

**示例**：

- 示例 1：

```python
输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
```

- 示例 2：

```python
输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
```

## 解题思路

### 思路 1：并查集

题目「求最多可以移走的石头数目」也可以换一种思路：「求最少留下的石头数目」。

- 如果两个石头 $A$、$B$ 处于同一行或者同一列，我们就可以删除石头 $A$  或 $B$，最少留下 $1$ 个石头。
- 如果三个石头 $A$、$B$、$C$，其中 $A$、$B$ 处于同一行，$B$、$C$ 处于同一列，则我们可以先删除石头 $A$，再删除石头 $C$，最少留下 $1$ 个石头。
- 如果有 $n$ 个石头，其中每个石头都有一个同行或者同列的石头，则我们可以将 $n - 1$ 个石头都删除，最少留下 $1$ 个石头。

通过上面的分析，我们可以利用并查集，将同行、同列的石头都加入到一个集合中。这样「最少可以留下的石头」就是并查集中集合的个数。

则答案为：**最多可以移走的石头数目 = 所有石头个数 - 最少可以留下的石头（并查集的集合个数）**。

因为石子坐标是二维的，在使用并查集的时候要区分横纵坐标，因为 $0 <= xi, yi <= 10^4$，可以取 $n = 10010$，将纵坐标映射到 $[n, n + 10000]$ 的范围内，这样就可以得到所有节点的标号。

最后计算集合个数，可以使用 set 集合去重，然后统计数量。

整体步骤如下：

1. 定义一个 $10010 \times 2$ 大小的并查集。
2. 遍历每块石头的横纵坐标：
   1. 将纵坐标映射到 $[10010, 10010 + 10000]$ 的范围内。
   2. 然后将当前石头的横纵坐标相连接（加入到并查集中）。
3. 建立一个 set 集合，查找每块石头横坐标所在集合对应的并查集编号，将编号加入到 set 集合中。
4. 最后，返回「所有石头个数 - 并查集集合个数」即为答案。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        size = len(stones)
        n = 10010
        union_find = UnionFind(n * 2)
        for i in range(size):
            union_find.union(stones[i][0], stones[i][1] + n)

        stones_set = set()
        for i in range(size):
            stones_set.add(union_find.find(stones[i][0]))

        return size - len(stones_set)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \alpha(n))$。其中 $n$ 是石子个数。$\alpha$ 是反 Ackerman 函数。
- **空间复杂度**：$O(n)$。# [0953. 验证外星语词典](https://leetcode.cn/problems/verifying-an-alien-dictionary/)

- 标签：数组、哈希表、字符串
- 难度：简单

## 题目链接

- [0953. 验证外星语词典 - 力扣](https://leetcode.cn/problems/verifying-an-alien-dictionary/)

## 题目大意

给定一组用外星语书写的单词字符串数组 `words`，以及表示外星字母表的顺序的字符串 `order` 。

要求：判断 `words` 中的单词是否都是按照 `order` 来排序的。如果是，则返回 `True`，否则返回 `False`。

## 解题思路

如果所有单词是按照 `order` 的规则升序排列，则所有单词都符合规则。而判断所有单词是升序排列，只需要两两比较相邻的单词即可。所以我们可以先用哈希表存储所有字母的顺序，然后对所有相邻单词进行两两比较，如果最终是升序排列，则符合要求。具体步骤如下：

- 使用哈希表 `order_map` 存储字母的顺序。
- 遍历单词数组 `words`，比较相邻单词 `word1` 和 `word2` 中所有字母在 `order_map` 中的下标，看是否满足 `word1 <= word2`。
- 如果全部满足，则返回 `True`。如果有不满足的情况，则直接返回 `False`。 

## 代码

```python
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        order_map = dict()
        for i in range(len(order)):
            order_map[order[i]] = i
        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i + 1]

            flag = True

            for j in range(min(len(word1), len(word2))):
                if word1[j] != word2[j]:
                    if order_map[word1[j]] > order_map[word2[j]]:
                        return False
                    else:
                        flag = False
                        break

            if flag and len(word1) > len(word2):
                return False
        return True
```

# [0958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [0958. 二叉树的完全性检验 - 力扣](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

## 题目大意

**描述**：给定一个二叉树的根节点 `root`。

**要求**：判断该二叉树是否是一个完全二叉树。

**说明**：

- **完全二叉树**：
- 树的结点数在范围 $[1, 100]$ 内。
- $1 \le Node.val \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png)

```python
输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png)

```python
输入：root = [1,2,3,4,5,null,7]
输出：false
解释：值为 7 的结点没有尽可能靠向左侧。
```

## 解题思路

### 思路 1：广度优先搜索

对于一个完全二叉树，按照「层序遍历」的顺序进行广度优先搜索，在遇到第一个空节点之后，整个完全二叉树的遍历就已结束了。不应该在后续遍历过程中再次出现非空节点。

如果在遍历过程中在遇到第一个空节点之后，又出现了非空节点，则该二叉树不是完全二叉树。

利用这一点，我们可以在广度优先搜索的过程中，维护一个布尔变量 `is_empty` 用于标记是否遇见了空节点。

### 思路 1：代码

```python
class Solution:
    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return False

        queue = collections.deque([root])
        is_empty = False
        while queue:
            size = len(queue)
            for _ in range(size):
                cur = queue.popleft()
                if not cur:
                    is_empty = True
                else:
                    if is_empty:
                        return False
                    queue.append(cur.left)
                    queue.append(cur.right)
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉树的节点数。
- **空间复杂度**：$O(n)$。
# [0959. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [0959. 由斜杠划分区域 - 力扣](https://leetcode.cn/problems/regions-cut-by-slashes/)

## 题目大意

**描述**：在由 $1 \times 1$ 方格组成的 $n \times n$ 网格 $grid$ 中，每个 $1 \times 1$ 方块由 `'/'`、`'\'` 或 `' '` 构成。这些字符会将方块划分为一些共边的区域。

现在给定代表网格的二维数组 $grid$。

**要求**：返回区域的数目。

**说明**：

- 反斜杠字符是转义的，因此 `'\'` 用 `'\\'` 表示。
- $n == grid.length == grid[i].length$。
- $1 \le n \le 30$。
- $grid[i][j]$ 是 `'/'`、`'\'` 或 `' '`。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2018/12/15/1.png)

```python
输入：grid = [" /","/ "]
输出：2
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2018/12/15/4.png)

```python
输入：grid = ["/\\","\\/"]
输出：5
解释：回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。
```

## 解题思路

### 思路 1：并查集

我们把一个 $1 \times 1$ 的单元格分割成逻辑上的 $4$ 个部分，则 `' '`、`'/'`、`'\'`  可以将 $1 \times 1$ 的方格分割为以下三种形态：

![](http://qcdn.itcharge.cn/images/20210827142447.png)

在进行遍历的时候，需要将联通的部分进行合并，并统计出联通的块数。这就需要用到了并查集。

遍历二维数组 $gird$，然后在「单元格内」和「单元格间」进行合并。

现在我们为单元格的每个小三角部分按顺时针方向都编上编号，起始位置为左边。然后单元格间的编号按照从左到右，从上到下的位置进行编号，如下图所示：

![](http://qcdn.itcharge.cn/images/20210827143836.png)

假设当前单元格的起始位置为 $index$，则合并策略如下：

- 如果是单元格内：
  - 如果是空格：合并 $index$、$index + 1$、$index + 2$、$index + 3$。
  - 如果是 `'/'`：合并 $index$ 和 $index + 1$，合并 $index + 2$ 和 $index + 3$。
  - 如果是 `'\'`：合并 $index$ 和 $index + 3$，合并 $index + 1$ 和 $index + 2$。
- 如果是单元格间，则向下向右进行合并：
  - 向下：合并 $index + 3$ 和 $index + 4 * size + 1 $。
  - 向右：合并 $index + 2$ 和 $index + 4$。

最后合并完成之后，统计并查集中连通分量个数即为答案。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        size = len(grid)
        m = 4 * size * size
        union_find = UnionFind(m)
        for i in range(size):
            for j in range(size):
                index = 4 * (i * size + j)
                ch = grid[i][j]
                if ch == '/':
                    union_find.union(index, index + 1)
                    union_find.union(index + 2, index + 3)
                elif ch == '\\':
                    union_find.union(index, index + 3)
                    union_find.union(index + 1, index + 2)
                else:
                    union_find.union(index, index + 1)
                    union_find.union(index + 1, index + 2)
                    union_find.union(index + 2, index + 3)
                if j + 1 < size:
                    union_find.union(index + 2, index + 4)
                if i + 1 < size:
                    union_find.union(index + 3, index + 4 * size + 1)

        return union_find.count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times \alpha(n^2))$，其中 $\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n^2)$。

# [0968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

- 标签：树、深度优先搜索、动态规划、二叉树
- 难度：困难

## 题目链接

- [0968. 监控二叉树 - 力扣](https://leetcode.cn/problems/binary-tree-cameras/)

## 题目大意

给定一个二叉树，需要在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父节点、自身及其直接子节点。

计算监控树的所有节点所需的最小摄像头数量。

- 示例 1：



![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

- 示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

```
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
```

## 解题思路

根据题意可知，一个摄像头的有效范围为 3 层：父节点、自身及其直接子节点。而约是下层的节点就越多，所以摄像头应该优先满足下层节点。可以使用后序遍历的方式遍历二叉树的节点，这样就可以优先遍历叶子节点。

对于每个节点，利用贪心思想，可以确定三种状态：

- 第一种状态：该节点无覆盖
- 第二种状态：该节点已经装上了摄像头
- 第三种状态：该节点已经覆盖

为了让摄像头数量最少，我们要尽量让叶⼦节点的⽗节点安装摄像头，这样才能摄像头的数量最少。对此我们应当分析当前节点和左右两侧子节点的覆盖情况。

先来考虑空节点，空节点应该算作已经覆盖状态。

再来考虑左右两侧子覆盖情况：

- 如果左节点或者右节点都无覆盖，则当前节点需要装上摄像头，答案 res 需要 + 1。
- 如果左节点已经覆盖或者右节点已经装上了摄像头，则当前节点已经覆盖。
- 如果左节点右节点都已经覆盖，则当前节点无覆盖。

根据以上条件就可以写出对应的后序遍历代码。

## 代码

```python
class Solution:
    res = 0
    def traversal(self, cur: TreeNode) -> int:
        if not cur:
            return 3

        left = self.traversal(cur.left)
        right = self.traversal(cur.right)

        if left == 1 or right == 1:
            self.res += 1
            return 2

        if left == 2 or right == 2:
            return 3

        if left == 3 and right == 3:
            return 1
        return -1

    def minCameraCover(self, root: TreeNode) -> int:
        self.res = 0
        if self.traversal(root) == 1:
            self.res += 1
        return self.res
```

# [0973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/)

- 标签：几何、数组、数学、分治、快速选择、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [0973. 最接近原点的 K 个点 - 力扣](https://leetcode.cn/problems/k-closest-points-to-origin/)

## 题目大意

给定一个由由平面上的点组成的列表 `points`，再给定一个整数 `K`。

要求：从中找出 `K` 个距离原点` (0, 0)` 最近的点。（这里，平面上两点之间的距离是欧几里德距离。）可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

## 解题思路

1. 使用二叉堆构建优先队列，优先级为距离原点的距离。此时堆顶元素即为距离原点最近的元素。
2. 将堆顶元素加入到答案数组中，进行出队操作。时间复杂度 $O(log{n})$。
   - 出队操作：交换堆顶元素与末尾元素，将末尾元素已移出堆。继续调整大顶堆。
3. 不断重复第 2 步，直到 `K` 次结束。

## 代码

```python
class Heapq:
    def compare(self, a, b):
        dist_a = a[0] * a[0] + a[1] * a[1]
        dist_b = b[0] * b[0] + b[1] * b[1]
        if dist_a < dist_b:
            return -1
        elif dist_a == dist_b:
            return 0
        else:
            return 1
    # 堆调整方法：调整为小顶堆
    def heapAdjust(self, nums: [int], index: int, end: int):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子结点
            max_index = index
            if self.compare(nums[left], nums[max_index]) == -1:
                max_index = left
            if right <= end and self.compare(nums[right], nums[max_index]) == -1:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            nums[index], nums[max_index] = nums[max_index], nums[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1

    # 将数组构建为二叉堆
    def heapify(self, nums: [int]):
        size = len(nums)
        # (size - 2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((size - 2) // 2, -1, -1):
            # 调用调整堆函数
            self.heapAdjust(nums, i, size - 1)

    # 入队操作
    def heappush(self, nums: list, value):
        nums.append(value)
        size = len(nums)
        i = size - 1
        # 寻找插入位置
        while (i - 1) // 2 >= 0:
            cur_root = (i - 1) // 2
            # value 大于当前根节点，则插入到当前位置
            if self.compare(nums[cur_root], value) == -1:
                break
            # 继续向上查找
            nums[i] = nums[cur_root]
            i = cur_root
        # 找到插入位置或者到达根位置，将其插入
        nums[i] = value

    # 出队操作
    def heappop(self, nums: list) -> int:
        size = len(nums)
        nums[0], nums[-1] = nums[-1], nums[0]
        # 得到最小值（堆顶元素）然后调整堆
        top = nums.pop()
        if size > 0:
            self.heapAdjust(nums, 0, size - 2)

        return top

    # 升序堆排序
    def heapSort(self, nums: [int]):
        self.heapify(nums)
        size = len(nums)
        for i in range(size):
            nums[0], nums[size - i - 1] = nums[size - i - 1], nums[0]
            self.heapAdjust(nums, 0, size - i - 2)
        return nums

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        heap = Heapq()
        queue = []
        for point in points:
            heap.heappush(queue, point)

        res = []
        for i in range(k):
            res.append(heap.heappop(queue))

        return res
```

# [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

- 标签：数组、哈希表、前缀和
- 难度：中等

## 题目链接

- [974. 和可被 K 整除的子数组 - 力扣](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

## 题目大意

给定一个整数数组 `nums` 和一个整数 `k`。

要求：返回其中元素之和可被 `k` 整除的（连续、非空）子数组的数目。

## 解题思路

先考虑暴力计算子数组和，外层两重循环，遍历所有连续子数组，然后最内层再计算一下子数组的和。部分代码如下：

```python
for i in range(len(nums)):
    for j in range(i + 1):
        sum = countSum(i, j)
```

这样下来时间复杂度就是 $O(n^3)$ 了。下一步是想办法降低时间复杂度。

先用一重循环遍历数组，计算出数组 `nums` 中前 i 个元素的和（前缀和），保存到一维数组 `pre_sum` 中，那么对于任意 `[j..i]` 的子数组 的和为 `pre_sum[i] - pre_sum[j - 1]`。这样计算子数组和的时间复杂度降为了 $O(1)$。总体时间复杂度为 $O(n^2)$。

由于我们只关心和为 `k` 出现的次数，不关心具体的解，可以使用哈希表来加速运算。

`pre_sum[i]` 的定义是前 `i` 个元素和，则 `[j..i]` 子数组和可以被 `k` 整除可以转换为：`（pre_sum[i] - pre_sum[j - 1]）% k == 0`。再转换一下：`pre_sum[i] % k == pre_sum[j - 1] % k`。

所以，我们只需要统计满足 `pre_sum[i] % k == pre_sum[j - 1] % k` 条件的组合个数。具体做法如下：

使用 `pre_sum` 变量记录前缀和（代表 `pre_sum[i]`）。使用哈希表 `pre_dic` 记录 `pre_sum[i] % k` 出现的次数。键值对为 `pre_sum[i] : count`。

- 从左到右遍历数组，计算当前前缀和并对 `k`  取余，即 `pre_sum = (pre_sum + nums[i]) % k`。
  - 如果 `pre_sum` 在哈希表中，则答案个数累加上 `pre_dic[pre_sum]`。同时 `pre_sum` 个数累加 1，即 `pre_dic[pre_sum] += 1`。
  - 如果 `pre_sum` 不在哈希表中，则 `pre_sum` 个数记为 1，即 `pre_dic[pre_sum] += 1`。
- 最后输出答案个数。

## 代码

```python
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        pre_sum = 0
        ans = 0
        nums_dict = {0: 1}
        for i in range(len(nums)):
            pre_sum = (pre_sum + nums[i]) % k
            if pre_sum < 0:
                pre_sum += k
            if pre_sum in nums_dict:
                ans += nums_dict[pre_sum]
                nums_dict[pre_sum] += 1
            else:
                nums_dict[pre_sum] = 1
        return ans
```

# [0976. 三角形的最大周长](https://leetcode.cn/problems/largest-perimeter-triangle/)

- 标签：贪心、数组、数学、排序
- 难度：简单

## 题目链接

- [0976. 三角形的最大周长 - 力扣](https://leetcode.cn/problems/largest-perimeter-triangle/)

## 题目大意

**描述**：给定一些由正数（代表长度）组成的数组 `nums`。

**要求**：返回由其中 `3` 个长度组成的、面积不为 `0` 的三角形的最大周长。如果不能形成任何面积不为 `0` 的三角形，则返回 `0`。

**说明**：

- $3 \le nums.length \le 10^4$。
- $1 \le nums[i] \le 10^6$。

**示例**：

- 示例 1：

```python
输入：nums = [2,1,2]
输出：5
解释：长度为 2, 1, 2 的边组成的三角形周长为 5，为最大周长
```

## 解题思路

### 思路 1：

要想三角形的周长最大，则每一条边都要尽可能的长，并且还要满足三角形的边长条件，即 `a + b > c`，其中 `a`、`b`、`c` 分别是三角形的 `3` 条边长。

所以，我们可以先对所有边长进行排序。然后倒序枚举最长边 `nums[i]`，判断前两个边长相加是否大于最长边，即 `nums[i - 2] + nums[i - 1] > nums[i]`。如果满足，则返回 `3` 条边长的和，否则的话继续枚举最长边。

## 代码

### 思路 1 代码：

```python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums) - 1, 1, -1):
            if nums[i - 2] + nums[i - 1] > nums[i]:
                return nums[i - 2] + nums[i - 1] + nums[i]
        return 0
```

# [0977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

- 标签：数组、双指针、排序
- 难度：简单

## 题目链接

- [0977. 有序数组的平方 - 力扣](https://leetcode.cn/problems/squares-of-a-sorted-array/)

## 题目大意

**描述**：给定一个按「非递减顺序」排序的整数数组 $nums$。

**要求**：返回「每个数字的平方」组成的新数组，要求也按「非递减顺序」排序。

**说明**：

- 要求使用时间复杂度为 $O(n)$ 的算法解决本问题。
- $1 \le nums.length \le 10^4$。
- $-10^4 \le nums[i] \le 10^4$。
- $nums$ 已按非递减顺序排序。

**示例**：

- 示例 1：

```python
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

- 示例 2：

```python
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

## 解题思路

### 思路 1：对撞指针

原数组是按「非递减顺序」排序的，可能会存在负数元素。但是无论是否存在负数，数字的平方最大值一定在原数组的两端。题目要求返回的新数组也要按照「非递减顺序」排序。那么，我们可以利用双指针，从两端向中间移动，然后不断将数的平方最大值填入数组。具体做法如下：

- 使用两个指针 $left$、$right$。$left$ 指向数组第一个元素位置，$right$ 指向数组最后一个元素位置。再定义 $index = len(nums) - 1$ 作为答案数组填入顺序的索引值。$res$ 作为答案数组。

- 比较 $nums[left]$ 与 $nums[right]$ 的绝对值大小。大的就是平方最大的的那个数。

  - 如果 $abs(nums[right])$ 更大，则将其填入答案数组对应位置，并令 `right -= 1`。

  - 如果 $abs(nums[left])$ 更大，则将其填入答案数组对应位置，并令 `left += 1`。

  - 令 $index -= 1$。

- 直到 $left == right$，最后将 $nums[left]$ 填入答案数组对应位置。

返回答案数组 $res$。

### 思路 1：代码

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        size = len(nums)
        left, right = 0, size - 1
        index = size - 1
        res = [0 for _ in range(size)]

        while left < right:
            if abs(nums[left]) < abs(nums[right]):
                res[index] = nums[right] * nums[right]
                right -= 1
            else:
                res[index] = nums[left] * nums[left]
                left += 1
            index -= 1
        res[index] = nums[left] * nums[left]

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 中的元素数量。
- **空间复杂度**：$O(1)$，不考虑最终返回值的空间占用。

### 思路 2：排序算法

可以通过各种排序算法来对平方后的数组进行排序。以快速排序为例，具体步骤如下：

1. 遍历数组，将数组中各个元素变为平方项。
2. 从数组中找到一个基准数。
3. 然后将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧，从而把数组拆分为左右两个部分。
4. 再对左右两个部分分别重复第 2、3 步，直到各个部分只有一个数，则排序结束。

### 思路 2：代码

```python
import random

class Solution:
    def randomPartition(self, arr: [int], low: int, high: int):
        i = random.randint(low, high)
        arr[i], arr[high] = arr[high], arr[i]
        return self.partition(arr, low, high)

    def partition(self, arr: [int], low: int, high: int):
        i = low - 1
        pivot = arr[high]

        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1

    def quickSort(self, arr, low, high):
        if low < high:
            pi = self.randomPartition(arr, low, high)
            self.quickSort(arr, low, pi - 1)
            self.quickSort(arr, pi + 1, high)

        return arr

    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            nums[i] = nums[i] * nums[i]

        return self.quickSort(nums, 0, len(nums) - 1)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \log n)$，其中 $n$ 为数组 $nums$ 中的元素数量。
- **空间复杂度**：$O(\log n)$。

# [0978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/)

- 标签：数组、动态规划、滑动窗口
- 难度：中等

## 题目链接

- [0978. 最长湍流子数组 - 力扣](https://leetcode.cn/problems/longest-turbulent-subarray/)

## 题目大意

**描述**：给定一个数组 $arr$。当 $arr$ 的子数组 $arr[i]$，$arr[i + 1]$，$...$， $arr[j]$ 满足下列条件时，我们称其为湍流子数组：

- 如果 $i \le k < j$，当 $k$ 为奇数时， $arr[k] > arr[k + 1]$，且当 $k$ 为偶数时，$arr[k] < arr[k + 1]$；
- 或如果 $i \le k < j$，当 $k$ 为偶数时，$arr[k] > arr[k + 1]$ ，且当 $k$ 为奇数时，$arr[k] < arr[k + 1]$。
- 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

**要求**：返回给定数组 $arr$ 的最大湍流子数组的长度。

**说明**：

- $1 \le arr.length \le 4 \times 10^4$。
- $0 \le arr[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：arr = [9,4,2,10,7,8,8,1,9]
输出：5
解释：arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
```

- 示例 2：

```python
输入：arr = [4,8,12,16]
输出：2
```

## 解题思路

### 思路 1：快慢指针

湍流子数组实际上像波浪一样，比如 $arr[i - 2] > arr[i - 1] < arr[i] > arr[i + 1] < arr[i + 2]$。所以我们可以使用双指针的做法。具体做法如下：

- 使用两个指针 $left$、$right$。$left$ 指向湍流子数组的左端，$right$ 指向湍流子数组的右端。
- 如果 $arr[right - 1] == arr[right]$，则更新 `left = right`，重新开始计算最长湍流子数组大小。
- 如果 $arr[right - 2] < arr[right - 1] < arr[right]$，此时为递增数组，则 $left$ 从 $right - 1$ 开始重新计算最长湍流子数组大小。
- 如果 $arr[right - 2] > arr[right - 1] > arr[right]$，此时为递减数组，则 $left$ 从 $right - 1$ 开始重新计算最长湍流子数组大小。
- 其他情况（即 $arr[right - 2] < arr[right - 1] > arr[right]$ 或 $arr[right - 2] > arr[right - 1] < arr[right]$）时，不用更新 $left$值。
- 更新最大湍流子数组的长度，并向右移动 $right$。直到 $right \ge len(arr)$ 时，返回答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        left, right = 0, 1
        ans = 1

        while right < len(arr):
            if arr[right - 1] == arr[right]:
                left = right
            elif right != 1 and arr[right - 2] < arr[right - 1] and arr[right - 1] < arr[right]:
                left = right - 1
            elif right != 1 and arr[right - 2] > arr[right - 1] and arr[right - 1] > arr[right]:
                left = right - 1
            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $arr$ 中的元素数量。
- **空间复杂度**：$O(1)$。

# [0982. 按位与为零的三元组](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/)

- 标签：位运算、数组、哈希表
- 难度：困难

## 题目链接

- [0982. 按位与为零的三元组 - 力扣](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：返回其中「按位与三元组」的数目。

**说明**：

- **按位与三元组**：由下标 $(i, j, k)$ 组成的三元组，并满足下述全部条件：
  - $0 \le i < nums.length$。
  - $0 \le j < nums.length$。
  - $0 \le k < nums.length$。
  - $nums[i] \text{ \& } nums[j] \text{ \& } nums[k] == 0$ ，其中 $\text{ \& }$ 表示按位与运算符。

- $1 \le nums.length \le 1000$。
- $0 \le nums[i] < 2^{16}$。

**示例**：

- 示例 1：

```python
输入：nums = [2,1,3]
输出：12
解释：可以选出如下 i, j, k 三元组：
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2
```

- 示例 2：

```python
输入：nums = [0,0,0]
输出：27
```

## 解题思路

### 思路 1：枚举

最直接的方法是使用三重循环直接枚举 $(i, j, k)$，然后再判断 $nums[i] \text{ \& } nums[j] \text{ \& } nums[k]$ 是否为 $0$。但是这样做的时间复杂度为 $O(n^3)$。

从题目中可以看出 $nums[i]$ 的值域范围为 $[0, 2^{16}]$，而 $2^{16} = 65536$。所以我们可以按照下面步骤优化时间复杂度：

1. 先使用两重循环枚举 $(i, j)$，计算出 $nums[i] \text{ \& } nums[j]$ 的值，将其存入一个大小为 $2^{16}$ 的数组或者哈希表 $cnts$ 中，并记录每个 $nums[i] \text{ \& } nums[j]$ 值出现的次数。
2. 然后遍历该数组或哈希表，再使用一重循环遍历 $k$，找出所有满足 $nums[k] \text{ \& } x == 0$ 的 $x$，并将其对应数量 $cnts[x]$ 累积到答案 $ans$ 中。
3. 最后返回答案 $ans$ 即可。

### 思路 1：代码

```python
class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        states = 1 << 16
        cnts = [0 for _ in range(states)]

        for num_x in nums:
            for num_y in nums:
                cnts[num_x & num_y] += 1
        
        ans = 0
        for num in nums:
            for x in range(states):
                if num & x == 0:
                    ans += cnts[x]
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 + 2^{16} \times n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(2^{16})$。

### 思路 2：枚举 + 优化

第一步跟思路 1 一样，我们先使用两重循环枚举 $(i, j)$，计算出 $nums[i] \text{ \& } nums[j]$ 的值，将其存入一个大小为 $2^{16}$ 的数组或者哈希表 $cnts$ 中，并记录每个 $nums[i] \text{ \& } nums[j]$ 值出现的次数。

接下来我们对思路 1 中的第二步进行优化，在思路 1 中，我们是通过枚举数组或哈希表的方式得到 $x$ 的，这里我们换一种方法。

使用一重循环遍历 $k$，对于 $nums[k]$，我们先计算出 $nums[k]$ 的补集，即将 $nums[k]$ 与 $2^{16} - 1$（二进制中 $16$ 个 $1$）进行按位异或操作，得到 $nums[k]$ 的补集 $com$。如果 $nums[k] \text{ \& } x == 0$，则 $x$ 一定是 $com$ 的子集。

换句话说，$x$ 中 $1$ 的位置一定与 $nums[k]$ 中 $1$ 的位置不同，如果 $nums[k]$ 中第 $m$ 位为 $1$，则 $x$ 中第 $m$ 位一定为 $0$。

接下来我们通过下面的方式来枚举子集：

1. 定义子集为 $sub$，初始时赋值为 $com$，即：$sub = com$。
2. 令 $sub$ 减 $1$，然后与 $com$ 做按位与操作，得到下一个子集，即：$sub = (sub - 1) \text{ \& } com$。
3. 不断重复第 $2$ 步，直到 $sub$ 为空集时为止。

这种方法能枚举子集的原理是：$sub$ 减 $1$ 会将最低位的 $1$ 改为 $0$，而比这个 $1$ 更低位的 $0$ 都改为了 $1$。此时再与 $com$ 做按位与操作，就会过保留原本高位上的 $1$，滤掉当前最低位的 $1$，并且保留比这个 $1$ 更低位上的原有的 $1$，也就得到嘞下一个子集。

举个例子，比如补集 $com$ 为 $(00010110)_2$：

1. 初始 $sub = (00010110)_2$。
2. 令其减 $1$ 后为 $(00010101)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00010100)_2$，即：$(00010101)_2 \text{ \& } (00010110)_2$）。
3. 令其减 $1$ 后为 $(00010011)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00010010)_2$，即： $(00010011)_2 \text{ \& } (00010110)_2$。
4. 令其减 $1$ 后为 $(00010001)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00010000)_2$，即：$(00010001)_2 \text{ \& } (00010110)_2$。
5. 令其减 $1$ 后为 $(00001111)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00000110)_2$，即：$(00001111)_2 \text{ \& } (00010110)_2$。
6. 令其减 $1$ 后为 $(00000101)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00000100)_2$，即：$(00000101)_2 \text{ \& } (00010110)_2$。
7. 令其减 $1$ 后为 $(00000011)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00000010)_2$，即：$(00000011)_2 \text{ \& } (00010110)_2$。
8. 令其减 $1$ 后为 $(00000001)_2$，然后与 $com$ 做按位与操作，得到下一个子集 $sub = (00000000)_2$，即：$(00000001)_2 \text{ \& } (00010110)_2$。
9. $sub$ 变为了空集。

### 思路 2：代码

```python
class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        states = 1 << 16
        cnts = [0 for _ in range(states)]

        for num_x in nums:
            for num_y in nums:
                cnts[num_x & num_y] += 1
        
        ans = 0
        for num in nums:
            com = num ^ 0xffff			# com: num 的补集
            sub = com					# sub: 子集
            while True:
                ans += cnts[sub]
                if sub == 0:
                    break
                sub = (sub - 1) & com
        
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2 + 2^{16} \times n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(2^{16})$。

## 参考资料

- 【题解】[按位与为零的三元组 - 按位与为零的三元组](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solution/an-wei-yu-wei-ling-de-san-yuan-zu-by-lee-gjud/)
- 【题解】[有技巧的枚举 + 常数优化（Python/Java/C++/Go） - 按位与为零的三元组](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solution/you-ji-qiao-de-mei-ju-chang-shu-you-hua-daxit/)
# [0990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

- 标签：并查集、图、数组、字符串
- 难度：中等

## 题目链接

- [0990. 等式方程的可满足性 - 力扣](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

## 题目大意

**描述**：给定一个由字符串方程组成的数组 `equations`，每个字符串方程 `equations[i]` 的长度为 `4`，有以下两种形式组成：`a==b` 或 `a!=b`。`a` 和 `b` 是小写字母，表示单字母变量名。

**要求**：判断所有的字符串方程是否能同时满足，如果能同时满足，返回 `True`，否则返回 `False`。

**说明**：

- $1 \le equations.length \le 500$。
- $equations[i].length == 4$。
- $equations[i][0]$ 和 $equations[i][3]$ 是小写字母。
- $equations[i][1]$ 要么是 `'='`，要么是 `'!'`。
- `equations[i][2]` 是 `'='`。

**示例**：

- 示例 1：

```python
输入：["a==b","b!=a"]
输出：False
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
```

## 解题思路

### 思路 1：并查集

字符串方程只有 `==` 或者 `!=`，可以考虑将相等的遍历划分到相同集合中，然后再遍历所有不等式方程，看方程的两个变量是否在之前划分的相同集合中，如果在则说明不满足。

这就需要用到并查集，具体操作如下：

- 遍历所有等式方程，将等式两边的单字母变量顶点进行合并。
- 遍历所有不等式方程，检查不等式两边的单字母遍历是不是在一个连通分量中，如果在则返回 `False`，否则继续扫描。如果所有不等式检查都没有矛盾，则返回 `True`。

### 思路 1：并查集代码

```python
class UnionFind:
    def __init__(self, n):                          # 初始化
        self.fa = [i for i in range(n)]             # 每个元素的集合编号初始化为数组 fa 的下标索引
    
    def __find(self, x):                            # 查找元素根节点的集合编号内部实现方法
        while self.fa[x] != x:                      # 递归查找元素的父节点，直到根节点
            self.fa[x] = self.fa[self.fa[x]]        # 隔代压缩优化
            x = self.fa[x]
        return x                                    # 返回元素根节点的集合编号

    def union(self, x, y):                          # 合并操作：令其中一个集合的树根节点指向另一个集合的树根节点
        root_x = self.__find(x)
        root_y = self.__find(y)
        if root_x == root_y:                        # x 和 y 的根节点集合编号相同，说明 x 和 y 已经同属于一个集合
            return False
        
        self.fa[root_x] = root_y                    # x 的根节点连接到 y 的根节点上，成为 y 的根节点的子节点
        return True

    def is_connected(self, x, y):                   # 查询操作：判断 x 和 y 是否同属于一个集合
        return self.__find(x) == self.__find(y)

class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        union_find = UnionFind(26)
        for eqation in equations:
            if eqation[1] == "=":
                index1 = ord(eqation[0]) - 97
                index2 = ord(eqation[3]) - 97
                union_find.union(index1, index2)

        for eqation in equations:
            if eqation[1] == "!":
                index1 = ord(eqation[0]) - 97
                index2 = ord(eqation[3]) - 97
                if union_find.is_connected(index1, index2):
                    return False
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + C \times \log C)$。其中 $n$ 是方程组 $equations$ 中的等式数量。$C$ 是字母变量的数量。本题中变量都是小写字母，即 $C \le 26$。
- **空间复杂度**：$O(C)$。# [0992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

- 标签：数组、哈希表、计数、滑动窗口
- 难度：困难

## 题目链接

- [0992. K 个不同整数的子数组 - 力扣](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

## 题目大意

给定一个正整数数组 `nums`，再给定一个整数 `k`。如果 `nums` 的某个子数组中不同整数的个数恰好为 `k`，则称 `nums` 的这个连续、不一定不同的子数组为「好子数组」。

- 例如，`[1, 2, 3, 1, 2]` 中有 3 个不同的整数：`1`，`2` 以及 `3`。

要求：返回 `nums` 中好子数组的数目。

## 解题思路

这道题转换一下思路会更简单。

恰好包含 `k` 个不同整数的连续子数组数量 = 包含小于等于 `k` 个不同整数的连续子数组数量 - 包含小于等于 `k - 1` 个不同整数的连续子数组数量

可以专门写一个方法计算包含小于等于 `k` 个不同整数的连续子数组数量。

计算包含小于等于 `k` 个不同整数的连续子数组数量的方法具体步骤如下：

用滑动窗口 `windows` 来记录不同的整数个数，`windows` 为哈希表类型。

设定两个指针：`left`、`right`，分别指向滑动窗口的左右边界，保证窗口内不超过 `k` 个不同整数。

- 一开始，`left`、`right` 都指向 `0`。
- 将最右侧整数 `nums[right]` 加入当前窗口 `windows` 中，记录该整数个数。
- 如果该窗口中该整数的个数多于 `k` 个，即 `len(windows) > k`，则不断右移 `left`，缩小滑动窗口长度，并更新窗口中对应整数的个数，直到 `len(windows) <= k`。
- 维护更新包含小于等于 `k` 个不同整数的连续子数组数量。每次累加数量为 `right - left + 1`，表示以 `nums[right]` 为结尾的小于等于 `k` 个不同整数的连续子数组数量。
- 然后右移 `right`，直到 `right >= len(nums)` 结束。
- 返回包含小于等于 `k` 个不同整数的连续子数组数量。

## 代码

```python
class Solution:
    def subarraysMostKDistinct(self, nums, k):
        windows = dict()
        left, right = 0, 0
        ans = 0
        while right < len(nums):
            if nums[right] in windows:
                windows[nums[right]] += 1
            else:
                windows[nums[right]] = 1
            while len(windows) > k:
                windows[nums[left]] -= 1
                if windows[nums[left]] == 0:
                    del windows[nums[left]]
                left += 1
            ans += right - left + 1
            right += 1
        return ans

    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        return self.subarraysMostKDistinct(nums, k) - self.subarraysMostKDistinct(nums, k - 1)
```

# [0993. 二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [0993. 二叉树的堂兄弟节点 - 力扣](https://leetcode.cn/problems/cousins-in-binary-tree/)

## 题目大意

给定一个二叉树，和两个值 x，y。从二叉树中找出 x 和 y 对应的节点 node_x，node_y。如果两个节点是堂兄弟节点，则返回 True，否则返回 False。

- 堂兄弟节点：两个节点的深度相同，父节点不同。

## 解题思路

广度优先搜索或者深度优先搜索都可。以深度优先搜索为例，递归遍历查找节点值为 x，y 的两个节点。在递归的同时，需要传入递归函数当前节点的深度和父节点信息。若找到对应的节点，则保存两节点对应深度和父节点信息。最后判断两个节点是否是深度相同，父节点不同。如果是，则返回 True，不是则返回 False。

## 代码

```python
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        depths = [0, 0]
        parents = [None, None]

        def dfs(node, depth, parent):
            if not node:
                return
            if node.val == x:
                depths[0] = depth
                parents[0] = parent
            elif node.val == y:
                depths[1] = depth
                parents[1] = parent
            dfs(node.left, depth+1, node)
            dfs(node.right, depth+1, node)

        dfs(root, 0, None)
        return depths[0] == depths[1] and parents[0] != parents[1]
```

# [0995. K 连续位的最小翻转次数](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)

- 标签：位运算、队列、数组、前缀和、滑动窗口
- 难度：困难

## 题目链接

- [0995. K 连续位的最小翻转次数 - 力扣](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)

## 题目大意

**描述**：给定一个仅包含 $0$ 和 $1$ 的数组 $nums$，再给定一个整数 $k$。进行一次 $k$ 位翻转包括选择一个长度为 $k$ 的（连续）子数组，同时将子数组中的每个 $0$ 更改为 $1$，而每个 $1$ 更改为 $0$。

**要求**：返回所需的 $k$ 位翻转的最小次数，以便数组没有值为 $0$ 的元素。如果不可能，返回 $-1$。

**说明**：

- **子数组**：数组的连续部分。
- $1 <= nums.length <= 105$。
- $1 <= k <= nums.length$。

**示例**：

- 示例 1：

```python
输入：nums = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```

- 示例 2：

```python
输入：nums = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```

## 解题思路

### 思路 1：滑动窗口

每次需要翻转的起始位置肯定是遇到第一个元素为 $0$ 的位置开始反转，如果能够使得整个数组不存在 $0$，即返回 $ans$ 作为反转次数。

同时我们还可以发现：

- 如果某个元素反转次数为奇数次，元素会由 $0 \rightarrow 1$，$1 \rightarrow 0$。
- 如果某个元素反转次数为偶数次，元素不会发生变化。

每个第 $i$ 位置上的元素只会被前面 $[i - k + 1, i - 1]$ 的元素影响。所以我们只需要知道前面 $k - 1$ 个元素翻转次数的奇偶性就可以了。

同时如果我们知道了前面 $k - 1$ 个元素的翻转次数就可以直接修改 $nums[i]$ 了。

我们使用 $flip\underline{\hspace{0.5em}}count$ 记录第 $i$ 个元素之前 $k - 1$ 个位置总共被反转了多少次，或者 $flip\underline{\hspace{0.5em}}count$ 是大小为 $k - 1$ 的滑动窗口。

- 如果前面第 $k - 1$ 个元素翻转了奇数次，则如果 $nums[i] == 1$，则 $nums[i]$ 也被翻转成了 $0$，需要再翻转 $1$ 次。
- 如果前面第 $k - 1$ 个元素翻转了偶数次，则如果 $nums[i] == 0$，则 $nums[i]$ 也被翻转成为了 $0$，需要再翻转 $1$ 次。

这两句写成判断语句可以写为：`if (flip_count + nums[i]) % 2 == 0:`。

因为 $0 <= nums[i] <= 1$，所以我们可以用 $0$ 和 $1$ 以外的数，比如 $2$ 来标记第 $i$ 个元素发生了翻转，即 `nums[i] = 2`。这样在遍历到第 $i$ 个元素时，如果有 $nums[i - k] == 2$，则说明 $nums[i - k]$ 发生了翻转。同时根据 $flip\underline{\hspace{0.5em}}count$ 和 $nums[i]$ 来判断第 $i$ 位是否需要进行翻转。

整个算法的具体步骤如下：

- 使用 $res$ 记录最小翻转次数。使用 $flip\underline{\hspace{0.5em}}count$ 记录窗口内前 $k - 1 $ 位元素的翻转次数。
- 遍历数组 $nums$，对于第 $i$ 位元素：
  - 如果 $i - k >= 0$，并且 $nums[i - k] == 2$，需要缩小窗口，将翻转次数减一。（此时窗口范围为 $[i - k + 1, i - 1]$）。
  - 如果 $(flip\underline{\hspace{0.5em}}count + nums[i]) \mod 2 == 0$，则说明 $nums[i]$ 还需要再翻转一次，将 $nums[i]$ 标记为 $2$，同时更新窗口内翻转次数 $flip\underline{\hspace{0.5em}}count$ 和答案最小翻转次数 $ans$。
- 遍历完之后，返回 $res$。

### 思路 1：代码

```python
class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = 0
        flip_count = 0
        for i in range(len(nums)):
            if i - k >= 0 and nums[i - k] == 2:
                flip_count -= 1
            if (flip_count + nums[i]) % 2 == 0:
                if i + k > len(nums):
                    return -1
                nums[i] = 2
                flip_count += 1
                ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。

# [0999. 可以被一步捕获的棋子数](https://leetcode.cn/problems/available-captures-for-rook/)

- 标签：数组、矩阵、模拟
- 难度：简单

## 题目链接

- [0999. 可以被一步捕获的棋子数 - 力扣](https://leetcode.cn/problems/available-captures-for-rook/)

## 题目大意

**描述**：在一个 $8 \times 8$ 的棋盘上，有一个白色的车（Rook），用字符 `'R'` 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 `'.'`，`'B'` 和 `'p'` 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

**要求**：你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。

**说明**：

- 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：
  - 棋手选择主动停下来。
  - 棋子因到达棋盘的边缘而停下。
  - 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
  - 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。

- $board.length == board[i].length == 8$
- $board[i][j]$ 可以是 `'R'`，`'.'`，`'B'` 或 `'p'`。
- 只有一个格子上存在 $board[i][j] == 'R'$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG)

```python
输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：在本例中，车能够捕获所有的卒。
```

- 示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG) 

```python
输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：象阻止了车捕获任何卒。
```

## 解题思路

### 思路 1：模拟

1. 双重循环遍历确定白色车的位置 $(pos\underline{\hspace{0.5em}}i,poss\underline{\hspace{0.5em}}j)$。
2. 让车向上、下、左、右四个方向进行移动，直到超出边界 / 碰到白色象 / 碰到卒为止。使用计数器 $cnt$ 记录捕获的卒的数量。
3. 返回答案 $cnt$。

### 思路 1：代码

```Python
class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        pos_i, pos_j = -1, -1
        for i in range(len(board)):
            if pos_i != -1 and pos_j != -1:
                break
            for j in range(len(board[i])):
                if board[i][j] == 'R':
                    pos_i, pos_j = i, j
                    break

        cnt = 0
        for direction in directions:
            setp = 0
            while True:
                new_i = pos_i + setp * direction[0]
                new_j = pos_j + setp * direction[1]
                if new_i < 0 or new_i >= 8 or new_j < 0 or new_j >= 8 or board[new_i][new_j] == 'B':
                    break
                if board[new_i][new_j] == 'p':
                    cnt += 1
                    break
                setp += 1
        
        return cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为棋盘的边长。
- **空间复杂度**：$O(1)$。

# [1000. 合并石头的最低成本](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)

- 标签：数组、动态规划、前缀和
- 难度：困难

## 题目链接

- [1000. 合并石头的最低成本 - 力扣](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)

## 题目大意

**描述**：给定一个代表 $n$ 堆石头的整数数组 $stones$，其中 $stones[i]$ 代表第 $i$ 堆中的石头个数。再给定一个整数 $k$， 每次移动需要将连续的 $k$ 堆石头合并为一堆，而这次移动的成本为这 $k$ 堆中石头的总数。

**要求**：返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，则返回 $-1$。

**说明**：

- $n == stones.length$。
- $1 \le n \le 30$。
- $1 \le stones[i] \le 100$。
- $2 \le k \le 30$。

**示例**：

- 示例 1：

```python
输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
```

- 示例 2：

```python
输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
```

## 解题思路

### 思路 1：动态规划 + 前缀和

每次将 $k$ 堆连续的石头合并成 $1$ 堆，石头堆数就会减少 $k - 1$ 堆。总共有 $n$ 堆石子，则：

1. 当 $(n - 1) \mod (k - 1) == 0$ 时，一定可以经过 $\frac{n - 1}{k - 1}$ 次合并，将 $n$ 堆石头合并为 $1$ 堆。
2. 当 $(n - 1) \mod (k - 1) \ne 0$ 时，则无法将所有的石头合并成一堆。

根据以上情况，我们可以先将无法将所有的石头合并成一堆的情况排除出去，接下来只考虑合法情况。

由于每次合并石头的成本为合并的 $k$ 堆的石子总数，即数组 $stones$ 中长度为 $k$ 的连续子数组和，因此为了快速计算数组 $stones$ 的连续子数组和，我们可以使用「前缀和」的方式，预先计算出「前 $i$ 堆的石子总数」，从而可以在 $O(1)$ 的时间复杂度内得到数组 $stones$ 的连续子数组和。

$k$ 堆石头合并为 $1$ 堆石头的过程，可以看做是长度为 $k$ 的连续子数组合并为长度为 $1$ 的子数组的过程，也可以看做是将长度为 $k$ 的区间合并为长度为 $1$ 的区间。

接下来我们就可以按照「区间 DP 问题」的基本思路来做。

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j][m]$ 表示为：将区间 $[i, j]$ 的石堆合并成 $m$ 堆的最低成本，其中 $m$ 的取值为 $[1,k]$。

###### 3. 状态转移方程

我们将区间 $[i, j]$ 的石堆合并成 $m$ 堆，可以枚举 $i \le n \le j$，将区间 $[i, j]$ 拆分为两个区间 $[i, n]$ 和 $[n + 1, j]$。然后将 $[i, n]$ 中的石头合并为 $1$ 堆，将 $[n + 1, j]$ 中的石头合并成 $m - 1$ 堆。最后将 $1$ 堆石头和 $m - 1$ 堆石头合并成 $1$ 堆，这样就可以将 $[i, j]$ 的石堆合并成 $k$ 堆。则状态转移方程为：$dp[i][j][m] = min_{i \le n < j} \lbrace dp[i][n][1] + dp[n + 1][j][m - 1] \rbrace$。

我们再将区间 $[i, j]$ 的 $k$ 堆石头合并成 $1$ 堆，其成本为 区间 $[i, j]$ 的石堆合并成 $k$ 堆的成本，加上将这 $k$ 堆石头合并成 $1$ 堆的成本，即状态转移方程为：$dp[i][j][1] = dp[i][j][k] + \sum_{t = i}^{t = j} stones[t]$。

###### 4. 初始条件

- 长度为 $1$ 的区间 $[i, i]$ 合并为 $1$ 堆成本为 $0$，即：$dp[i][i][1] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j][m]$ 表示为：将区间 $[i, j]$ 的石堆合并成 $m$ 堆的最低成本，其中 $m$ 的取值为 $[1,k]$。 所以最终结果为 $dp[1][size][1]$，其中 $size$ 为数组 $stones$ 的长度。

### 思路 1：代码

```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        size = len(stones)
        if (size - 1) % (k - 1) != 0:
            return -1

        prefix = [0 for _ in range(size + 1)]
        for i in range(1, size + 1):
            prefix[i] = prefix[i - 1] + stones[i - 1]

        dp = [[[float('inf') for _ in range(k + 1)] for _ in range(size)] for _ in range(size)]

        for i in range(size):
            dp[i][i][1] = 0

        for l in range(2, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                for m in range(2, k + 1):
                    for n in range(i, j, k - 1):
                        dp[i][j][m] = min(dp[i][j][m], dp[i][n][1] + dp[n + 1][j][m - 1])
                dp[i][j][1] = dp[i][j][k] + prefix[j + 1] - prefix[i]

        return dp[0][size - 1][1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3 \times k)$，其中 $n$ 是数组 $stones$ 的长度。
- **空间复杂度**：$O(n^2 \times k)$。

### 思路 2：动态规划 + 状态优化

在思路 1 中，我们使用定义状态 $dp[i][j][m]$ 表示为：将区间 $[i, j]$ 的石堆合并成 $m$ 堆的最低成本，其中 $m$ 的取值为 $[1,k]$。

事实上，对于固定区间 $[i, j]$，初始时堆数为 $j - i + 1$，每次合并都会减少 $k - 1$ 堆，合并到无法合并时的堆数固定为 $(j - i) \mod (k - 1) + 1$。

所以，我们可以直接定义状态 $dp[i][j]$ 表示为：将区间 $[i, j]$ 的石堆合并到无法合并时的最低成本。

具体步骤如下：

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：将区间 $[i, j]$ 的石堆合并到无法合并时的最低成本。

###### 3. 状态转移方程

枚举 $i \le n \le j$，将区间 $[i, j]$ 拆分为两个区间 $[i, n]$ 和 $[n + 1, j]$。然后将区间 $[i, n]$ 合并成 $1$ 堆，$[n + 1, j]$ 合并成 $m$ 堆。

$dp[i][j] = min_{i \le n < j} \lbrace dp[i][n] + dp[n + 1][j] \rbrace$。

如果 $(j - i) \mod (k - 1) == 0$，则说明区间 $[i, j]$ 能狗合并为 1 堆，则加上区间子数组和，即 $dp[i][j] += prefix[j + 1] - prefix[i]$。

###### 4. 初始条件

- 长度为 $1$ 的区间 $[i, i]$ 合并到无法合并时的最低成本为 $0$，即：$dp[i][i] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：将区间 $[i, j]$ 的石堆合并到无法合并时的最低成本。所以最终结果为 $dp[0][size - 1]$，其中 $size$ 为数组 $stones$ 的长度。

### 思路 2：代码

```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        size = len(stones)
        if (size - 1) % (k - 1) != 0:
            return -1

        prefix = [0 for _ in range(size + 1)]
        for i in range(1, size + 1):
            prefix[i] = prefix[i - 1] + stones[i - 1]

        dp = [[float('inf') for _ in range(size)] for _ in range(size)]

        for i in range(size):
            dp[i][i] = 0

        for l in range(2, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                # 遍历每一个可以组成 k 堆石子的分割点 n，每次递增 k - 1 个
                for n in range(i, j, k - 1):
                    # 判断 [i, n] 到 [n + 1, j] 是否比之前花费小
                    dp[i][j] = min(dp[i][j], dp[i][n] + dp[n + 1][j])
                # 如果 [i, j] 能狗合并为 1 堆，则加上区间子数组和
                if (l - 1) % (k - 1) == 0:
                    dp[i][j] += prefix[j + 1] - prefix[i]

        return dp[0][size - 1]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 是数组 $stones$ 的长度。
- **空间复杂度**：$O(n^2)$。

## 参考资料

- 【题解】[一题一解：动态规划（区间 DP）+ 前缀和（清晰题解） - 合并石头的最低成本](https://leetcode.cn/problems/minimum-cost-to-merge-stones/solution/python3javacgo-yi-ti-yi-jie-dong-tai-gui-lr9q/)
# [1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

- 标签：数组、哈希表、字符串
- 难度：简单

## 题目链接

- [1002. 查找共用字符 - 力扣](https://leetcode.cn/problems/find-common-characters/)

## 题目大意

**描述**：给定一个字符串数组 $words$。

**要求**：找出所有在 $words$ 的每个字符串中都出现的公用字符（包括重复字符），并以数组形式返回。可以按照任意顺序返回答案。

**说明**：

- $1 \le words.length \le 100$。
- $1 \le words[i].length \le 100$。
- $words[i]$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：words = ["bella","label","roller"]
输出：["e","l","l"]
```

- 示例 2：

```python
输入：words = ["cool","lock","cook"]
输出：["c","o"]
```

## 解题思路

### 思路 1：哈希表

如果某个字符 $ch$ 在所有字符串中都出现了 $k$ 次以上，则最终答案中需要包含 $k$ 个 $ch$。因此，我们可以使用哈希表 $minfreq[ch]$ 记录字符 $ch$ 在所有字符串中出现的最小次数。具体步骤如下：

1. 定义长度为 $26$ 的哈希表 $minfreq$，初始化所有字符出现次数为无穷大，$minfreq[ch] = float('inf')$。
2. 遍历字符串数组中的所有字符串 $word$，对于字符串 $word$：
   1. 记录 $word$ 中所有字符串的出现次数 $freq[ch]$。
   2. 取 $freq[ch]$ 与 $minfreq[ch]$ 中的较小值更新 $minfreq[ch]$。
3. 遍历完之后，再次遍历 $26$ 个字符，将所有最小出现次数大于零的字符按照出现次数存入答案数组中。
4. 最后将答案数组返回。

### 思路 1：代码

```python
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        minfreq = [float('inf') for _ in range(26)]
        for word in words:
            freq = [0 for _ in range(26)]
            for ch in word:
                freq[ord(ch) - ord('a')] += 1
            for i in range(26):
                minfreq[i] = min(minfreq[i], freq[i])

        res = []
        for i in range(26):
            while minfreq[i]:
                res.append(chr(i + ord('a')))
                minfreq[i] -= 1
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times (|\sum| + m))$，其中 $n$ 为字符串数组 $words$ 的长度，$m$ 为每个字符串的平均长度，$|\sum|$ 为字符集。
- **空间复杂度**：$O(|\sum|)$。

# [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

- 标签：数组、二分查找、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [1004. 最大连续1的个数 III - 力扣](https://leetcode.cn/problems/max-consecutive-ones-iii/)

## 题目大意

**描述**：给定一个由 $0$、$1$ 组成的数组 $nums$，再给定一个整数 $k$。最多可以将 $k$ 个值从 $0$ 变到 $1$。

**要求**：返回仅包含 $1$ 的最长连续子数组的长度。

**说明**：

- $1 \le nums.length \le 10^5$。
- $nums[i]$ 不是 $0$ 就是 $1$。
- $0 \le k \le nums.length$。

**示例**：

- 示例 1：

```python
输入：nums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], K = 2
输出：6
解释：[1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1]
将 nums[5]、nums[10] 从 0 翻转到 1，最长的子数组长度为 6。
```

- 示例 2：

```python
输入：nums = [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], K = 3
输出：10
解释：[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1]
将 nums[4]、nums[5]、nums[9] 从 0 翻转到 1，最长的子数组长度为 10。
```

## 解题思路

### 思路 1：滑动窗口（不定长度）

1. 使用两个指针 $left$、$right$ 指向数组开始位置。使用 $max\underline{\hspace{0.5em}}count$ 来维护仅包含 $1$ 的最长连续子数组的长度。
2. 不断右移 $right$ 指针，扩大滑动窗口范围，并统计窗口内 $0$ 元素的个数。
3. 直到 $0$ 元素的个数超过 $k$ 时将 $left$ 右移，缩小滑动窗口范围，并减小 $0$ 元素的个数，同时维护 $max\underline{\hspace{0.5em}}count$。
4. 最后输出最长连续子数组的长度 $max\underline{\hspace{0.5em}}count$。

### 思路 1：代码

```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        max_count = 0
        zero_count = 0
        left, right = 0, 0
        while right < len(nums):
            if nums[right] == 0:
                zero_count += 1
            right += 1
            if zero_count > k:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            max_count = max(max_count, right - left)
        return max_count
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

- 标签：贪心、数组、排序
- 难度：简单

## 题目链接

- [1005. K 次取反后最大化的数组和 - 力扣](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

## 题目大意

给定一个整数数组 nums 和一个整数 k。只能用下面的方法修改数组：

- 将数组上第 i 个位置上的值取相反数，即将 `nums[i]` 变为 `-nums[i]`。

用这种方式进行 K 次修改（可以多次修改同一个位置 i） 后，返回数组可能的最大和。

## 解题思路

- 先将数组按绝对值大小进行排序
- 从绝对值大的数开始遍历数组，如果 nums[i] < 0，并且 k > 0：
  - 则对 nums[i] 取相反数，并将 k 值 -1。
- 如果最后 k 还有余值，则判断奇偶性：
  - 若 k 为奇数，则将数组绝对值最小的数进行取反。
  - 若 k 为偶数，则说明可将某一位数进行偶数次取反，和原数值一致，则不需要进行操作。
- 最后返回数组和。

## 代码

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        nums.sort(key=lambda x: abs(x), reverse = True)
        for i in range(len(nums)):
            if nums[i] < 0 and k > 0:
                nums[i] *= -1
                k -= 1
        if k % 2 == 1:
            nums[-1] *= -1
        return sum(nums)
```

# [1008. 前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

- 标签：栈、树、二叉搜索树、数组、二叉树、单调栈
- 难度：中等

## 题目链接

- [1008. 前序遍历构造二叉搜索树 - 力扣](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

## 题目大意

给定一棵二叉搜索树的前序遍历结果 `preorder`。

要求：返回与给定前序遍历 `preorder` 相匹配的二叉搜索树的根节点。题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。

## 解题思路

二叉搜索树的中序遍历是升序序列。而题目又给了我们二叉搜索树的前序遍历，那么通过对前序遍历结果的排序，我们也可以得到二叉搜索树的中序遍历结果。这样就能根据二叉树的前序、中序遍历序列构造二叉树了。就变成了了「[0105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」题。

此外，我们还有另一种方法求解。前序遍历的顺序是：根 -> 左 -> 右。并且在二叉搜索树中，左子树的值小于根节点，右子树的值大于根节点。

根据以上性质，我们可以递归地构造二叉搜索树。

首先，以前序遍历的开始位置元素构造为根节点。从开始位置的下一个位置开始，找到序列中第一个大于等于根节点值的位置 `mid`。该位置左侧的值都小于根节点，右侧的值都大于等于根节点。以此位置为中心，递归的构造左子树和右子树。

最后再将根节点进行返回。

## 代码

```python
class Solution:
    def buildTree(self, preorder, start, end):
        if start == end:
            return None
        root = preorder[start]
        mid = start + 1
        while mid < end and preorder[mid] < root:
            mid += 1
        node = TreeNode(root)
        node.left = self.buildTree(preorder, start + 1, mid)
        node.right = self.buildTree(preorder, mid, end)
        return node

    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        return self.buildTree(preorder, 0, len(preorder))
```

# [1009. 十进制整数的反码](https://leetcode.cn/problems/complement-of-base-10-integer/)

- 标签：位运算
- 难度：简单

## 题目链接

- [1009. 十进制整数的反码 - 力扣](https://leetcode.cn/problems/complement-of-base-10-integer/)

## 题目大意

**描述**：给定一个十进制数 $n$。

**要求**：返回其二进制表示的反码对应的十进制整数。

**说明**：

- $0 \le N < 10^9$。

**示例**：

- 示例 1：

```python
输入：5
输出：2
解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。
```

- 示例 2：

```python
输入：7
输出：0
解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。
```

## 解题思路

### 思路 1：模拟

1. 将十进制数 $n$ 转为二进制 $binary$。
2. 遍历二进制 $binary$ 的每一个数位 $digit$。
   1. 如果 $digit$ 为 $0$，则将其转为 $1$，存入答案 $res$ 中。
   2. 如果 $digit$ 为 $1$，则将其转为 $0$，存入答案 $res$ 中。
3. 返回答案 $res$。

### 思路 1：代码

```python
class Solution:
    def bitwiseComplement(self, n: int) -> int:
        binary = ""
        while n:
            binary += str(n % 2)
            n //= 2
        if binary == "":
            binary = "0"
        else:
            binary = binary[::-1]
        res = 0
        for digit in binary:
            if digit == '0':
                res = res * 2 + 1
            else:
                res = res * 2
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(len(n))$，其中 $len(n)$ 为 $n$ 对应二进制的长度。
- **空间复杂度**：$O(1)$。
# [1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [1011. 在 D 天内送达包裹的能力 - 力扣](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

## 题目大意

**描述**：传送带上的包裹必须在 $D$ 天内从一个港口运送到另一个港口。给定所有包裹的重量数组 $weights$，货物必须按照给定的顺序装运。且每天船上装载的重量不会超过船的最大运载重量。

**要求**：求能在 $D$ 天内将所有包裹送达的船的最低运载量。

**说明**：

- $1 \le days \le weights.length \le 5 * 10^4$。
- $1 \le weights[i] \le 500$。

**示例**：

- 示例 1：

```python
输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10
请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
```

- 示例 2：

```python
输入：weights = [3,2,2,4,1,4], days = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
```

## 解题思路

### 思路 1：二分查找

船最小的运载能力，最少也要等于或大于最重的那件包裹，即 $max(weights)$。最多的话，可以一次性将所有包裹运完，即 $sum(weights)$。船的运载能力介于 $[max(weights), sum(weights)]$ 之间。

我们现在要做的就是从这个区间内，找到满足可以在 $D$ 天内运送完所有包裹的最小载重量。

可以通过二分查找的方式，找到满足要求的最小载重量。

### 思路 1：代码

```python
class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        left = max(weights)
        right = sum(weights)

        while left < right:
            mid = (left + right) >> 1
            days = 1
            cur = 0
            for weight in weights:
                if cur + weight > mid:
                    days += 1
                    cur = 0
                cur += weight

            if days <= D:
                right = mid
            else:
                left = mid + 1
        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。二分查找算法的时间复杂度为 $O(\log n)$。
- **空间复杂度**：$O(1)$。只用到了常数空间存放若干变量。

# [1012. 至少有 1 位重复的数字](https://leetcode.cn/problems/numbers-with-repeated-digits/)

- 标签：数学、动态规划
- 难度：困难

## 题目链接

- [1012. 至少有 1 位重复的数字 - 力扣](https://leetcode.cn/problems/numbers-with-repeated-digits/)

## 题目大意

**描述**：给定一个正整数 $n$。

**要求**：返回在 $[1, n]$ 范围内具有至少 $1$ 位重复数字的正整数的个数。

**说明**：

- $1 \le n \le 10^9$。

**示例**：

- 示例 1：

```python
输入：n = 20
输出：1
解释：具有至少 1 位重复数字的正数（<= 20）只有 11。
```

- 示例 2：

```python
输入：n = 100
输出：10
解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100。
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

正向求解在 $[1, n]$ 范围内具有至少 $1$ 位重复数字的正整数的个数不太容易，我们可以反向思考，先求解出在 $[1, n]$ 范围内各位数字都不重复的正整数的个数 $ans$，然后 $n - ans$ 就是题目答案。

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, state, isLimit, isNum):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True, False)` 开始递归。 `dfs(0, 0, True, False)` 表示：
   1. 从位置 $0$ 开始构造。
   2. 初始没有使用数字（即前一位所选数字集合为 $0$）。
   3. 开始时受到数字 $n$ 对应最高位数位的约束。
   4. 开始时没有填写数字。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
   1. 如果 $isNum == True$，说明当前方案符合要求，则返回方案数 $1$。
   2. 如果 $isNum == False$，说明当前方案不符合要求，则返回方案数 $0$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
   1. 根据 $isNum$ 和 $isLimit$ 来决定填当前位数位所能选择的最小数字（$minX$）和所能选择的最大数字（$maxX$），
   2. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
   3. 如果之前没有选择 $d$，即 $d$ 不在之前选择的数字集合 $state$ 中，则方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)`。
      1. `state | (1 << d)` 表示之前选择的数字集合 $state$ 加上 $d$。
      2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位限制和 $pos$ 位限制。
      3. $isNum == True$ 表示 $pos$ 位选择了数字。
6. 最后的方案数为 `n - dfs(0, 0, True, False)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def numDupDigitsAtMostN(self, n: int) -> int:
        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # state: 之前选过的数字集合。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        # isNum: 表示 pos 前面的数位是否填了数字。如果为真，则当前位不可跳过；如果为假，则当前位可跳过。
        def dfs(pos, state, isLimit, isNum):
            if pos == len(s):
                # isNum 为 True，则表示当前方案符合要求
                return int(isNum)
            
            ans = 0
            if not isNum:
                # 如果 isNumb 为 False，则可以跳过当前数位
                ans = dfs(pos + 1, state, False, False)
            
            # 如果前一位没有填写数字，则最小可选择数字为 0，否则最少为 1（不能含有前导 0）。
            minX = 0 if isNum else 1
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                # d 不在选择的数字集合中，即之前没有选择过 d
                if (state >> d) & 1 == 0:
                    ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)
            return ans
    
        return n - dfs(0, 0, True, False)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n \times 10 \times 2^{10})$。
- **空间复杂度**：$O(\log n \times 2^{10})$。

# [1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [1014. 最佳观光组合 - 力扣](https://leetcode.cn/problems/best-sightseeing-pair/)

## 题目大意

给你一个正整数数组 `values`，其中 `values[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离 为 `j - i`。一对景点（`i < j`）组成的观光组合的得分为 `values[i] + values[j] + i - j`，也就是景点的评分之和减去它们两者之间的距离。

要求：返回一对观光景点能取得的最高分。

## 解题思路

求解的是 `ans = max(values[i] + values[j] + i - j)`。对于当前第 `j` 个位置上的元素来说，`values[j] - j` 的值是固定的，求解 `ans` 就是在求解 `values[i] + i` 的最大值。我们使用一个变量 `max_score` 来存储当前第 `j` 个位置元素之前 `values[i] + i` 的最大值。然后遍历数组，求出每一个元素位置之前 `values[i] + i` 的最大值，并找出其中最大的 `ans`。

## 代码

```python
class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        ans = 0
        max_score = values[0]
        for i in range(1, len(values)):
            ans = max(ans, max_score + values[i] - i)
            max_score = max(max_score, values[i] + i)
        return ans
```
# [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [1020. 飞地的数量 - 力扣](https://leetcode.cn/problems/number-of-enclaves/)

## 题目大意

**描述**：给定一个二维数组 `grid`，每个单元格为 `0`（代表海）或 `1`（代表陆地）。我们可以从一个陆地走到另一个陆地上（朝四个方向之一），然后从边界上的陆地离开网络的边界。

**要求**：返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。

**说明**：

- $m == grid.length$。
- $n == grid[i].length$。
- $1 \le m, n \le 500$。
- $grid[i][j]$ 的值为 $0$ 或 $1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg)

```python
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg)

```python
输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：所有 1 都在边界上或可以到达边界。
```

## 解题思路

### 思路 1：深度优先搜索

与四条边界相连的陆地单元是肯定能离开网络边界的。

我们可以先通过深度优先搜索将与四条边界相关的陆地全部变为海（赋值为 `0`）。

然后统计网格中 `1` 的数量，即为答案。

### 思路 1：代码

```python
class Solution:
    directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def dfs(self, grid, i, j):
        rows = len(grid)
        cols = len(grid[0])
        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == 0:
            return
        grid[i][j] = 0

        for direct in self.directs:
            new_i = i + direct[0]
            new_j = j + direct[1]
            self.dfs(grid, new_i, new_j)

    def numEnclaves(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        for i in range(rows):
            if grid[i][0] == 1:
                self.dfs(grid, i, 0)
            if grid[i][cols - 1] == 1:
                self.dfs(grid, i, cols - 1)

        for j in range(cols):
            if grid[0][j] == 1:
                self.dfs(grid, 0, j)
            if grid[rows - 1][j] == 1:
                self.dfs(grid, rows - 1, j)

        ans = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(m \times n)$。# [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)

- 标签：栈、字符串
- 难度：简单

## 题目链接

- [1021. 删除最外层的括号 - 力扣](https://leetcode.cn/problems/remove-outermost-parentheses/)

## 题目大意

**描述**：有效括号字符串为空 `""`、`"("` + $A$ + `")"` 或 $A + B$ ，其中 $A$ 和 $B$ 都是有效的括号字符串，$+$ 代表字符串的连接。

- 例如，`""`，`"()"`，`"(())()"` 和 `"(()(()))"` 都是有效的括号字符串。

如果有效字符串 $s$ 非空，且不存在将其拆分为 $s = A + B$ 的方法，我们称其为原语（primitive），其中 $A$ 和 $B$ 都是非空有效括号字符串。

给定一个非空有效字符串 $s$，考虑将其进行原语化分解，使得：$s = P_1 + P_2 + ... + P_k$，其中 $P_i$ 是有效括号字符串原语。

**要求**：对 $s$ 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 $s$。

**说明**：

- $1 \le s.length \le 10^5$。
- $s[i]$ 为 `'('` 或 `')'`。
- $s$ 是一个有效括号字符串。

**示例**：

- 示例 1：

```python
输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

- 示例 2：

```python
输入：s = "(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```

## 解题思路

### 思路 1：计数遍历

题目要求我们对 $s$ 进行原语化分解，并且删除分解中每个原语字符串的最外层括号。

通过观察可以发现，每个原语其实就是一组有效的括号对（左右括号匹配时），此时我们需要删除这组有效括号对的最外层括号。

我们可以使用一个计数器 $cnt$ 来进行原语化分解，并删除每个原语的最外层括号。

当计数器遇到左括号时，令计数器 $cnt$ 加 $1$，当计数器遇到右括号时，令计数器 $cnt$ 减 $1$。这样当计数器为 $0$ 时表示当前左右括号匹配。

为了删除每个原语的最外层括号，当遇到每个原语最外侧的左括号时（此时 $cnt$ 必然等于 $0$，因为之前字符串为空或者为上一个原语字符串），因为我们不需要最外层的左括号，所以此时我们不需要将其存入答案字符串中。只有当 $cnt > 0$ 时，才将其存入答案字符串中。

同理，当遇到每个原语最外侧的右括号时（此时 $cnt$ 必然等于 $1$，因为之前字符串差一个右括号匹配），因为我们不需要最外层的右括号，所以此时我们不需要将其存入答案字符串中。只有当 $cnt > 1$ 时，才将其存入答案字符串中。

具体步骤如下：

1. 遍历字符串 $s$。
2. 如果遇到 `'('`，判断当前计数器是否大于 $0$：
   1. 如果 $cnt > 0$，则将 `'('` 存入答案字符串中，并令计数器加 $1$，即：`cnt += 1`。
   2. 如果 $cnt == 0$，则令计数器加 $1$，即：`cnt += 1`。
3. 如果遇到 `')'`，判断当前计数器是否大于 $1$：
   1. 如果 $cnt > 1$，则将 `')'` 存入答案字符串中，并令计数器减 $1$，即：`cnt -= 1`。
   2. 如果 $cnt == 1$，则令计数器减 $1$，即：`cnt -= 1`。
4. 遍历完返回答案字符串 $ans$。

### 思路 1：代码

```Python
class Solution:
    def removeOuterParentheses(self, s: str) -> str:
        cnt, ans = 0, ""
        
        for ch in s:
            if ch == '(':
                if cnt > 0:
                    ans += ch
                cnt += 1
            else:
                if cnt > 1:
                    ans += ch
                cnt -= 1
            
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n)$。

# [1023. 驼峰式匹配](https://leetcode.cn/problems/camelcase-matching/)

- 标签：字典树、双指针、字符串、字符串匹配
- 难度：中等

## 题目链接

- [1023. 驼峰式匹配 - 力扣](https://leetcode.cn/problems/camelcase-matching/)

## 题目大意

**描述**：给定待查询列表 `queries`，和模式串 `pattern`。如果我们可以将小写字母（0 个或多个）插入模式串 `pattern` 中间（任意位置）得到待查询项 `queries[i]`，那么待查询项与给定模式串匹配。如果匹配，则对应答案为 `True`，否则为 `False`。

**要求**：将匹配结果存入由布尔值组成的答案列表中，并返回。

**说明**：

- $1 \le queries.length \le 100$。
- $1 \le queries[i].length \le 100$。
- $1 \le pattern.length \le 100$。
- 所有字符串都仅由大写和小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
输出：[true,false,true,true,false]
示例：
"FooBar" 可以这样生成："F" + "oo" + "B" + "ar"。
"FootBall" 可以这样生成："F" + "oot" + "B" + "all".
"FrameBuffer" 可以这样生成："F" + "rame" + "B" + "uffer".
```

- 示例 2：

```python
输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
输出：[true,false,true,false,false]
解释：
"FooBar" 可以这样生成："Fo" + "o" + "Ba" + "r".
"FootBall" 可以这样生成："Fo" + "ot" + "Ba" + "ll".
```

## 解题思路

### 思路 1：字典树

构建一棵字典树，将 `pattern` 存入字典树中。

1. 对于 `queries[i]` 中的每个字符串。逐个字符与 `pattern` 进行匹配。
   1. 如果遇见小写字母，直接跳过。
   2. 如果遇见大写字母，但是不能匹配，返回 `False`。
   3. 如果遇见大写字母，且可以匹配，继续查找。
   4. 如果到达末尾仍然匹配，则返回 `True`。
2. 最后将所有结果存入答案数组中返回。

### 思路 1：代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ord(ch) > 96:
                if ch not in cur.children:
                    continue
            else:
                if ch not in cur.children:
                    return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        trie_tree = Trie()
        trie_tree.insert(pattern)
        res = []
        for query in queries:
            res.append(trie_tree.search(query))
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times |T| + |pattern|)$。其中 $n$ 是待查询项的数目，$|T|$  是最长的待查询项的字符串长度，$|pattern|$ 是字符串 `pattern` 的长度。
- **空间复杂度**：$O(|pattern|)$。

# [1025. 除数博弈](https://leetcode.cn/problems/divisor-game/)

- 标签：脑筋急转弯、数学、动态规划、博弈
- 难度：简单

## 题目链接

- [1025. 除数博弈 - 力扣](https://leetcode.cn/problems/divisor-game/)

## 题目大意

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 `n`。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一 `x`，满足 `0 < x < n` 且 `n % x == 0`。
- 用 `n - x` 替换黑板上的数字 `n` 。
- 如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `False`。假设两个玩家都以最佳状态参与游戏。

## 解题思路

- 如果 `n` 为奇数，则 `n` 的约数必然都是奇数；如果 `n` 为偶数，则 `n` 的约数可能为奇数也可能为偶数。
- 无论 `n` 为奇数还是偶数，都可以选择 `1` 作为约数。
- 无论 `n` 初始为多大的数，游戏到最终只能到 `n == 2` 结束，只要谁先到 `n == 2`，谁就赢得胜利。
- 当初始 `n` 为偶数时，爱丽丝只要一直选 `1`，那么鲍勃必然会一直面临 `n` 为奇数的情况，这样最后爱丽丝肯定能先到 `n == 2`，稳赢。
- 当初始 `n` 为奇数时，因为奇数的约数只能是奇数，奇数 - 奇数 必然是偶数，所以给鲍勃的数一定是偶数，鲍勃只需一直选 `1` 就会稳赢，此时爱丽丝稳输。

所以，当 `n` 为偶数时，爱丽丝稳赢。当 `n` 为奇数时，爱丽丝稳输。

## 代码

```python
class Solution:
    def divisorGame(self, n: int) -> bool:
        return n & 1 == 0
```

# [1028. 从先序遍历还原二叉树](https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/)

- 标签：树、深度优先搜索、字符串、二叉树
- 难度：困难

## 题目链接

- [1028. 从先序遍历还原二叉树 - 力扣](https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/)

## 题目大意

对一棵二叉树进行深度优先搜索。在遍历的过程中，遇到节点，先输出与该节点深度相同数量的短线，再输出该节点的值。如果节点深度为 `D`，则子节点深度为 `D + 1`。根节点的深度为 `0`。如果节点只有一个子节点，则该子节点一定为左子节点。

现在给定深度优先搜索输出的字符串 `traversal`。

要求：还原二叉树，并返回其根节点 `root`。

## 解题思路

用栈存储需要构建子树的节点。并记录下上一节点深度和当前节点深度。

然后遍历深度优先搜索的输出字符串。

- 先将开始部分的数字作为根节点值，构建一个根节点 `root`，并将根节点插入到栈中。
- 如果遇到 `-`，则更新当前节点深度。

- 然后如果遇到数字，则将数字逐位转为整数。并且在最后进行判断。
  - 如果当前节点深度 > 前一节点深度：
    - 将栈顶节点出栈。
    - 构建一个新节点，值为当前整数。将新节点插入到栈顶节点的左子树上。
    - 将当前节点和新节点插入到栈中。
  - 如果当前节点深度 <= 前一节点深度：
    - 将当前节点深度个数的节点从栈中弹出。
    - 构建一个新节点，值为当前整数。并将新节点插入到最后弹出节点的右子树上。
    - 将当前节点和新节点插入到栈中。
- 最后输出根节点 `root`。

## 代码

```python
class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        stack = []

        index, num = 0, 0
        pre_level, cur_level = 0, 0

        size = len(traversal)
        while index < size and traversal[index] != '-':
            num = num * 10 + ord(traversal[index]) - ord('0')
            index += 1

        root = TreeNode(num)
        stack.append(root)

        while index < size:
            if traversal[index] == '-':
                cur_level += 1
                index += 1
            else:
                num = 0
                while index < size and traversal[index] != '-':
                    num = num * 10 + ord(traversal[index]) - ord('0')
                    index += 1

                if cur_level > pre_level:
                    node = stack.pop()
                    node.left = TreeNode(num)
                    stack.append(node)
                    stack.append(node.left)
                    pre_level = cur_level
                    cur_level = 0
                else:
                    while len(stack) > cur_level:
                        stack.pop()
                    node = stack.pop()
                    node.right = TreeNode(num)
                    stack.append(node)
                    stack.append(node.right)
                    pre_level = cur_level
                    cur_level = 0
        return root
```

# [1029. 两地调度](https://leetcode.cn/problems/two-city-scheduling/)

- 标签：贪心、数组、排序
- 难度：中等

## 题目链接

- [1029. 两地调度 - 力扣](https://leetcode.cn/problems/two-city-scheduling/)

## 题目大意

**描述**：公司计划面试 `2 * n` 人。给你一个数组 `costs`，其中 `costs[i] = [aCosti, bCosti]`，表示第 `i` 人飞往 `a` 市的费用为 `aCosti` ，飞往 `b` 市的费用为 `bCosti`。

**要求**：返回将每个人都飞到 `a`、`b` 中某座城市的最低费用，要求每个城市都有 `n` 人抵达。

**说明**：

- $2 * n == costs.length$。
- $2 \le costs.length \le 100$。
- $costs.length$ 为偶数。
- $1 \le aCosti, bCosti \le 1000$。

**示例**：

- 示例 1：

```python
输入：costs = [[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 a 市，费用为 10。
第二个人去 a 市，费用为 30。
第三个人去 b 市，费用为 50。
第四个人去 b 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
```

## 解题思路

### 思路 1：贪心算法

我们先假设所有人都去了城市 `a`。然后令一半的人再去城市 `b`。现在的问题就变成了，让一半的人改变城市去向，从原本的 `a` 城市改成 `b` 城市的最低费用为多少。

已知第 `i` 个人更换去向的费用为「去城市 `b` 的费用 - 去城市 `a` 的费用」。所以我们可以根据「去城市 `b` 的费用 - 去城市 `a` 的费用」对数组 `costs` 进行排序，让前 `n` 个改变方向去城市 `b`，后 `n` 个人去城市 `a`。

最后统计所有人员的费用，将其返回即可。

### 思路 1：贪心算法代码

```python
class Solution:
    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        costs.sort(key=lambda x:x[1] - x[0])
        cost = 0
        size = len(costs) // 2
        for i in range(size):
            cost += costs[i][ 1]
            cost += costs[i + size][0]

        return cost
```
# [1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/)

- 标签：深度优先搜索、广度优先搜索、数组、矩阵
- 难度：中等

## 题目链接

- [1034. 边界着色 - 力扣](https://leetcode.cn/problems/coloring-a-border/)

## 题目大意

给定一个二维整数矩阵 `grid`，其中 `grid[i][j]` 表示矩阵第 `i` 行、第 `j` 列上网格块的颜色值。再给定一个起始位置 `(row, col)`，以及一个目标颜色 `color`。

要求：对起始位置 `(row, col)` 所在的连通分量边界填充颜色为 `color`。并返回最终的二维整数矩阵 `grid`。

- 连通分量：当两个相邻（上下左右四个方向上）网格块的颜色值相同时，它们属于同一连通分量。
- 连通分量边界：当前连通分量最外圈的所有网格块，这些网格块与连通分量的颜色相同，与其他周围网格块颜色不同。边界上的网格块也是连通分量边界。

## 解题思路

深度优先搜索。使用二维数组 `visited` 标记访问过的节点。遍历上、下、左、右四个方向上的点。如果下一个点位置越界，或者当前位置与下一个点位置颜色不一样，则对该节点进行染色。

在遍历的过程中注意使用 `visited` 标记访问过的节点，以免重复遍历。

## 代码

```python
class Solution:
    directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def dfs(self, grid, i, j, origin_color, color, visited):
        rows, cols = len(grid), len(grid[0])

        for direct in self.directs:
            new_i = i + direct[0]
            new_j = j + direct[1]

            # 下一个位置越界，则当前点在边界，对其进行着色
            if new_i < 0 or new_i >= rows or new_j < 0 or new_j >= cols:
                grid[i][j] = color
                continue

            # 如果访问过，则跳过
            if visited[new_i][new_j]:
                continue

            # 如果下一个位置颜色与当前颜色相同，则继续搜索
            if grid[new_i][new_j] == origin_color:
                visited[new_i][new_j] = True
                self.dfs(grid, new_i, new_j, origin_color, color, visited)
            # 下一个位置颜色与当前颜色不同，则当前位置为连通区域边界，对其进行着色
            else:
                grid[i][j] = color


    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        if not grid:
            return grid

        rows, cols = len(grid), len(grid[0])
        visited = [[False for _ in range(cols)] for _ in range(rows)]
        visited[row][col] = True

        self.dfs(grid, row, col, grid[row][col], color, visited)

        return grid
```

# [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [1035. 不相交的线 - 力扣](https://leetcode.cn/problems/uncrossed-lines/)

## 题目大意

有两条独立平行的水平线，按照给定的顺序写下 `nums1` 和 `nums2` 的整数。

现在，我们可以绘制一些直线，只要满足以下要求：

- `nums1[i] == nums2[j]`。
- 绘制的直线不与其他任何直线相交。

例如：![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png)

现在要求：计算出能绘制的最大直线数目。

## 解题思路

动态规划求解。

定义状态 `dp[i][j]` 表示：`nums1` 中前 `i` 个数与 `nums2` 中前 `j` 个数的最大连接数，则：

状态转移方程为：

- 如果 `nums1[i] == nums[j]`，则 `nums1[i]` 与 `nums2[j]` 可连线，此时 `dp[i][j] = dp[i - 1][j - 1] + 1`。
- 如果 `nums1[i] != nums[j]`，则 `nums1[i]` 与 `nums2[j]` 不可连线，此时最大连线数取决于 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的较大值，即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。

最后输出 `dp[size1][size2]` 即可。

## 代码

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        size1 = len(nums1)
        size2 = len(nums2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[size1][size2]
```

# [1037. 有效的回旋镖](https://leetcode.cn/problems/valid-boomerang/)

- 标签：几何、数组、数学
- 难度：简单

## 题目链接

- [1037. 有效的回旋镖 - 力扣](https://leetcode.cn/problems/valid-boomerang/)

## 题目大意

**描述**：给定一个数组 $points$，其中 $points[i] = [xi, yi]$ 表示平面上的一个点。

**要求**：如果这些点构成一个回旋镖，则返回 `True`，否则，则返回 `False`。

**说明**：

- **回旋镖**：定义为一组三个点，这些点各不相同且不在一条直线上。
- $points.length == 3$。
- $points[i].length == 2$。
- $0 \le xi, yi \le 100$。

**示例**：

- 示例 1：

```python
输入：points = [[1,1],[2,3],[3,2]]
输出：True
```

- 示例 2：

```python
输入：points = [[1,1],[2,2],[3,3]]
输出：False
```

## 解题思路

### 思路 1：

设三点坐标为 $A = (x1, y1)$，$B = (x2, y2)$，$C = (x3, y3)$，则向量 $\overrightarrow{AB} = (x2 - x1, y2 - y1)$，$\overrightarrow{BC} = (x3 - x2, y3 - y2)$。

如果三点共线，则应满足：$\overrightarrow{AB} \times \overrightarrow{BC} = (x2 − x1) \times (y3 − y2) - (x3 − x2) \times (y2 − y1) = 0$。

如果三点不共线，则应满足：$\overrightarrow{AB} \times \overrightarrow{BC} = (x2 − x1) \times (y3 − y2) - (x3 − x2) \times (y2 − y1) \ne 0$。

### 思路 1：代码

```python
class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        x1, y1 = points[0]
        x2, y2 = points[1]
        x3, y3 = points[2]
        cross1 = (x2 - x1) * (y3 - y2)
        cross2 = (x3 - x2) * (y2 - y1)
        return cross1 - cross2 != 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。
# [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [1038. 从二叉搜索树到更大和树 - 力扣](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

## 题目大意

给定一棵二叉搜索树（BST）的根节点，且二叉搜索树的节点值各不相同。

要求：将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

## 解题思路

题目要求将每个节点的值修改为原来的节点值加上大于它的节点值之和。已知二叉搜索树的中序遍历可以得到一个升序数组。

题目就可以变为：修改升序数组中每个节点值为末尾元素累加和。由于末尾元素累加和的求和过程和遍历顺序相反，所以我们可以考虑换种思路。

二叉搜索树的中序遍历顺序为：左 -> 根 -> 右，从而可以得到一个升序数组，那么我们将左右反着遍历，即顺序为：右 -> 根 -> 左，就可以得到一个降序数组，这样就可以在遍历的同时求前缀和。

当然我们在计算前缀和的时候，需要用到前一个节点的值，所以需要用变量 `pre` 存储前一节点的值。

## 代码

```python
class Solution:
    pre = 0

    def createBinaryTree(self, root: TreeNode):
        if not root:
            return
        self.createBinaryTree(root.right)
        root.val += self.pre
        self.pre = root.val
        self.createBinaryTree(root.left)

    def bstToGst(self, root: TreeNode) -> TreeNode:
        self.pre = 0
        self.createBinaryTree(root)
        return root
```

# [1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [1039. 多边形三角剖分的最低得分 - 力扣](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

## 题目大意

**描述**：有一个凸的 $n$ 边形，其每个顶点都有一个整数值。给定一个整数数组 $values$，其中 $values[i]$ 是第 $i$ 个顶点的值（即顺时针顺序）。

现在要将 $n$ 边形剖分为 $n - 2$ 个三角形，对于每个三角形，该三角形的值是顶点标记的乘积，$n$ 边形三角剖分的分数是进行三角剖分后所有 $n - 2$ 个三角形的值之和。

**要求**：返回多边形进行三角剖分可以得到的最低分。

**说明**：

- $n == values.length$。
- $3 \le n \le 50$。
- $1 \le values[i] \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/02/25/shape1.jpg)

```python
输入：values = [1,2,3]
输出：6
解释：多边形已经三角化，唯一三角形的分数为 6。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/02/25/shape2.jpg)

```python
输入：values = [3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
```

## 解题思路

### 思路 1：动态规划

对于 $0 \sim n - 1$ 个顶点组成的凸多边形进行三角剖分，我们可以在 $[0, n - 1]$ 中任选 $1$ 个点 $k$，从而将凸多边形划分为：

1. 顶点 $0 \sim k$ 组成的凸多边形。
2. 顶点 $0$、$k$、$n - 1$ 组成的三角形。
3. 顶点 $k \sim n - 1$  组成的凸多边形。

对于顶点 $0$、$k$、$n - 1$ 组成的三角形，我们可以直接计算对应的三角剖分分数为 $values[0] \times values[k] \times values[n - 1]$。

而对于顶点 $0 \sim k$ 组成的凸多边形和顶点 $k \sim n - 1$  组成的凸多边形，我们可以利用递归或者动态规划的思想，定义一个 $dp[i][j]$ 用于计算顶点 $i$ 到顶点 $j$ 组成的多边形三角剖分的最小分数。

具体做法如下：

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：区间 $[i, j]$ 内三角剖分后的最小分数。

###### 3. 状态转移方程

对于区间 $[i, j]$，枚举分割点 $k$，最小分数为 $min(dp[i][k] + dp[k][j] + values[i] \times values[k] \times values[j])$，即：$dp[i][j] = min(dp[i][k] + dp[k][j] + values[i] \times values[k] \times values[j])$。

###### 4. 初始条件

- 默认情况下，所有区间 $[i, j]$ 的最小分数为无穷大。
- 当区间 $[i, j]$ 长度小于 $3$ 时，无法进行三角剖分，其最小分数为 $0$。
- 当区间 $[i, j]$ 长度等于 $3$ 时，其三角剖分的最小分数为 $values[i] * values[i + 1] * values[i + 2]$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：区间 $[i, j]$ 内三角剖分后的最小分数。。 所以最终结果为 $dp[0][size - 1]$。

### 思路 1：代码

```python
class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        size = len(values)
        dp = [[float('inf') for _ in range(size)] for _ in range(size)]
        for l in range(1, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                if l < 3:
                    dp[i][j] = 0
                elif l == 3:
                    dp[i][j] = values[i] * values[i + 1] * values[i + 2]
                else:
                    for k in range(i + 1, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[j] * values[k])

        return dp[0][size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为顶点个数。
- **空间复杂度**：$O(n^2)$。

# [1041. 困于环中的机器人](https://leetcode.cn/problems/robot-bounded-in-circle/)

- 标签：数学、字符串、模拟
- 难度：中等

## 题目链接

- [1041. 困于环中的机器人 - 力扣](https://leetcode.cn/problems/robot-bounded-in-circle/)

## 题目大意

**描述**：在无限的平面上，机器人最初位于 $(0, 0)$ 处，面朝北方。注意:

- 北方向 是 $y$ 轴的正方向。
- 南方向 是 $y$ 轴的负方向。
- 东方向 是 $x$ 轴的正方向。
- 西方向 是 $x$ 轴的负方向。

机器人可以接受下列三条指令之一：

- `"G"`：直走 $1$ 个单位
- `"L"`：左转 $90$ 度
- `"R"`：右转 $90$ 度

给定一个字符串 $instructions$，机器人按顺序执行指令 $instructions$，并一直重复它们。

**要求**：只有在平面中存在环使得机器人永远无法离开时，返回 $True$。否则，返回 $False$。

**说明**：

- $1 \le instructions.length \le 100$。
- $instructions[i]$ 仅包含 `'G'`，`'L'`，`'R'`。

**示例**：

- 示例 1：

```python
输入：instructions = "GGLLGG"
输出：True
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
“L”:逆时针旋转90度。位置:(0,2).方向:西。
“L”:逆时针旋转90度。位置:(0,2)方向:南。
“G”:移动一步。位置:(0,1)方向:南。
“G”:移动一步。位置:(0,0)方向:南。
重复指令，机器人进入循环:(0,0)——>(0,1)——>(0,2)——>(0,1)——>(0,0)。
在此基础上，我们返回 True。
```

- 示例 2：

```python
输入：instructions = "GG"
输出：False
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
重复这些指示，继续朝北前进，不会进入循环。
在此基础上，返回 False。
```

## 解题思路

### 思路 1：模拟

设定初始位置为 $(0, 0)$，初始方向 $direction = 0$，假设按照给定字符串 $instructions$ 执行一遍之后，位于 $(x, y)$ 处，且方向为 $direction$，则可能出现的所有情况为：

1. 方向不变（$direction == 0$），且 $(x, y) == (0, 0)$，则会一直在原点，无法走出去。
2. 方向不变（$direction == 0$），且 $(x, y) \ne (0, 0)$，则可以走出去。
3. 方向相反（$direction == 2$），无论是否产生位移，则再执行 $1$ 遍将会回到原点。
4. 方向逆时针 / 顺时针改变 $90°$（$direction == 1 \text{ or } 3$），无论是否产生位移，则再执行 $3$ 遍将会回到原点。

综上所述，最多模拟 $4$ 次即可知道能否回到原点。

从上面也可以等出结论：如果不产生位移，则一定会回到原点。如果改变方向，同样一定会回到原点。

我们只需要根据以上结论，按照 $instructions$ 执行一遍之后，通过判断是否产生位移和改变方向，即可判断是否一定会回到原点。

### 思路 1：代码

```Python
class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        # 分别代表北、东、南、西
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        x, y = 0, 0
        # 初始方向为北
        direction = 0
        for step in instructions:
            if step == 'G':
                x += directions[direction][0]
                y += directions[direction][1]
            elif step == 'L':
                direction = (direction + 1) % 4
            else:
                direction = (direction + 3) % 4
        
        return (x == 0 and y == 0) or direction != 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $instructions$ 的长度。
- **空间复杂度**：$O(1)$。
# [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

- 标签：栈、字符串
- 难度：简单

## 题目链接

- [1047. 删除字符串中的所有相邻重复项 - 力扣](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

## 题目大意

给定一个全部由小写字母组成的字符串 S，重复的删除相邻且相同的字母，直到相邻字母不再有相同的。

比如 "abbaca"。先删除相邻且相同的字母 "bb"，变为 "aaca"，再删除相邻且相同的字母 "aa"，变为 "ca"，无相邻且相同的字母，即 "ca" 为最终结果。

## 解题思路

跟括号匹配有点类似。我们可以利用「栈」来做这道题。遍历字符串，如果当前字符与栈顶字符相同，则将栈顶所有相同字符删除，否则就将当前字符入栈。

## 代码

```python
class Solution:
    def removeDuplicates(self, S: str) -> str:
        stack = []
        for ch in S:
            if stack and stack[-1] == ch:
                stack.pop()
            else:
                stack.append(ch)
        return "".join(stack)
```

# [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [1049. 最后一块石头的重量 II - 力扣](https://leetcode.cn/problems/last-stone-weight-ii/)

## 题目大意

**描述**：有一堆石头，用整数数组 $stones$ 表示，其中 $stones[i]$ 表示第 $i$​ 块石头的重量。每一回合，从石头中选出任意两块石头，将这两块石头一起粉碎。假设石头的重量分别为 $x$ 和 $y$。且 $x \le y$，则结果如下：

- 如果 $x = y$，则两块石头都会被完全粉碎；
- 如果 $x < y$，则重量为 $x$ 的石头被完全粉碎，而重量为 $y$ 的石头新重量为 $y - x$。

**要求**：最后，最多只会剩下一块石头，返回此石头的最小可能重量。如果没有石头剩下，则返回 $0$。

**说明**：

- $1 \le stones.length \le 30$。
- $1 \le stones[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

- 示例 2：

```python
输入：stones = [31,26,33,21,40]
输出：5
```

## 解题思路

### 思路 1：动态规划

选取两块石头，重新放回去的重量是两块石头的差值绝对值。重新放回去的石头还会进行选取，然后进行粉碎，直到最后只剩一块或者不剩石头。

这个问题其实可以转化为：把一堆石头尽量平均的分成两对，求两堆石头重量差的最小值。

这就和「[0416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)」有点相似。两堆石头的重量要尽可能的接近数组总数量和的一半。

进一步可以变为：「0-1 背包问题」。

1. 假设石头总重量和为 $sum$，将一堆石头放进载重上限为 $sum / 2$ 的背包中，获得的最大价值为 $max\underline{\hspace{0.5em}}weight$（即其中一堆石子的重量）。另一堆石子的重量为 $sum - max\underline{\hspace{0.5em}}weight$。
2. 则两者的差值为 $sum - 2 \times max\underline{\hspace{0.5em}}weight$，即为答案。

###### 1. 划分阶段

按照石头的序号进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：将石头放入载重上限为 $w$ 的背包中可以获得的最大价值。

###### 3. 状态转移方程

$dp[w] = max \lbrace dp[w], dp[w - stones[i - 1]] + stones[i - 1] \rbrace$。

###### 4. 初始条件

- 无论背包载重上限为多少，只要不选择石头，可以获得的最大价值一定是 $0$，即 $dp[w] = 0, 0 \le w \le W$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[w]$ 表示为：将石头放入载重上限为 $w$ 的背包中可以获得的最大价值，即第一堆石头的价值为 $dp[size]$，第二堆石头的价值为 $sum - dp[size]$，最终答案为两者的差值，即 $sum - dp[size] \times 2$。

### 思路 1：代码

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        W = 1500
        size = len(stones)
        dp = [0 for _ in range(W + 1)]
        target = sum(stones) // 2
        for i in range(1, size + 1):
            for w in range(target, stones[i - 1] - 1, -1):
                dp[w] = max(dp[w], dp[w - stones[i - 1]] + stones[i - 1])

        return sum(stones) - dp[target] * 2
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times W)$，其中 $n$ 为数组 $stones$ 的元素个数，$W$ 为数组 $stones$ 中元素和的一半。
- **空间复杂度**：$O(W)$。
# [1051. 高度检查器](https://leetcode.cn/problems/height-checker/)

- 标签：数组、计数排序、排序
- 难度：简单

## 题目链接

- [1051. 高度检查器 - 力扣](https://leetcode.cn/problems/height-checker/)

## 题目大意

**描述**：学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。

排序后的高度情况用整数数组 $expected$ 表示，其中 $expected[i]$ 是预计排在这一行中第 $i$ 位的学生的高度（下标从 $0$ 开始）。

给定一个整数数组 $heights$ ，表示当前学生站位的高度情况。$heights[i]$ 是这一行中第 $i$ 位学生的高度（下标从 $0$ 开始）。

**要求**：返回满足 $heights[i] \ne expected[i]$ 的下标数量 。

**说明**：

- $1 \le heights.length \le 100$。
- $1 \le heights[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：heights = [1,1,4,2,1,3]
输出：3 
解释：
高度：[1,1,4,2,1,3]
预期：[1,1,1,2,3,4]
下标 2 、4 、5 处的学生高度不匹配。
```

- 示例 2：

```python
输入：heights = [5,1,2,3,4]
输出：5
解释：
高度：[5,1,2,3,4]
预期：[1,2,3,4,5]
所有下标的对应学生高度都不匹配。
```

## 解题思路

### 思路 1：排序算法

1. 将数组 $heights$ 复制一份，记为 $expected$。
2. 对数组 $expected$ 进行排序。
3. 排序之后，对比并统计 $heights[i] \ne expected[i]$ 的下标数量，记为 $ans$。
4. 返回 $ans$。

### 思路 1：代码

```Python
class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        expected = sorted(heights)

        ans = 0
        for i in range(len(heights)):
            if expected[i] != heights[i]:
                ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $heights$ 的长度。
- **空间复杂度**：$O(n)$。

### 思路 2：计数排序

题目中 $heights[i]$ 的数据范围为 $[1, 100]$，所以我们可以使用计数排序。

### 思路 2：代码

```python
class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # 待排序数组中最大值元素 heights_max = 100 和最小值元素 heights_min = 1
        heights_min, heights_max = 1, 100
        # 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1
        size = heights_max - heights_min + 1
        counts = [0 for _ in range(size)]
		
        # 统计值为 height 的元素出现的次数
        for height in heights:
            counts[height - heights_min] += 1

        ans = 0
        idx = 0
        # 从小到大遍历 counts 的元素值范围
        for height in range(heights_min, heights_max + 1):
            while counts[height - heights_min]:
                # 对于每个元素值，判断是否与对应位置上的 heights[idx] 相等
                if heights[idx] != height:
                    ans += 1
                idx += 1
                counts[height - heights_min] -= 1
        
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n + k)$，其中 $n$ 为数组 $heights$ 的长度，$k$ 为数组 $heights$ 的值域范围。
- **空间复杂度**：$O(k)$。

# [1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/)

- 标签：数组、滑动窗口
- 难度：中等

## 题目链接

- [1052. 爱生气的书店老板 - 力扣](https://leetcode.cn/problems/grumpy-bookstore-owner/)

## 题目大意

**描述**：书店老板有一家店打算试营业 $len(customers)$ 分钟。每一分钟都有一些顾客 $customers[i]$ 会进入书店，这些顾客会在这一分钟结束后离开。

在某些时候，书店老板会生气。如果书店老板在第 $i$ 分钟生气，则 `grumpy[i] = 1`，如果第 $i$ 分钟不生气，则 `grumpy[i] = 0`。当书店老板生气时，这一分钟的顾客会不满意。当书店老板不生气时，这一分钟的顾客是满意的。

假设老板知道一个秘密技巧，能保证自己连续 $minutes$ 分钟不生气，但只能使用一次。

现在给定代表每分钟进入书店的顾客数量的数组 $customes$，和代表老板生气状态的数组 $grumpy$，以及老板保证连续不生气的分钟数 $minutes$。

**要求**：计算出试营业下来，最多有多少客户能够感到满意。

**说明**：

- $n == customers.length == grumpy.length$。
- $1 \le minutes \le n \le 2 \times 10^4$。
- $0 \le customers[i] \le 1000$。
- $grumpy[i] == 0 \text{ or } 1$。

**示例**：

- 示例 1：

```python
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
输出：16
解释：书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```

- 示例 2：

```python
输入：customers = [1], grumpy = [0], minutes = 1
输出：1
```

## 解题思路

### 思路 1：滑动窗口

固定长度的滑动窗口题目。我们可以维护一个窗口大小为 $minutes$ 的滑动窗口。使用 $window_count$ 记录当前窗口内生气的顾客人数。然后滑动求出窗口中最大顾客数，然后累加上老板未生气时的顾客数，就是答案。具体做法如下：

1. $ans$ 用来维护答案数目。$window\underline{\hspace{0.5em}}count$ 用来维护窗口中生气的顾客人数。
2. $left$ 、$right$ 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
3. 如果书店老板生气，则将这一分钟的顾客数量加入到 $window\underline{\hspace{0.5em}}count$ 中，然后向右移动 $right$。
4. 当窗口元素个数大于 $minutes$ 时，即：$right - left + 1 > count$ 时，如果最左侧边界老板处于生气状态，则向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为小于 $minutes$。
5. 重复 $3 \sim 4$ 步，直到 $right$ 到达数组末尾。
6. 然后累加上老板未生气时的顾客数，最后输出答案。

### 思路 1：代码

```python
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        left = 0
        right = 0
        window_count = 0
        ans = 0

        while right < len(customers):
            if grumpy[right] == 1:
                window_count += customers[right]

            if right - left + 1 > minutes:
                if grumpy[left] == 1:
                    window_count -= customers[left]
                left += 1

            right += 1
            ans = max(ans, window_count)

        for i in range(len(customers)):
            if grumpy[i] == 0:
                ans += customers[i]
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $coustomer$、$grumpy$ 的长度。
- **空间复杂度**：$O(1)$。

# [1065. 字符串的索引对](https://leetcode.cn/problems/index-pairs-of-a-string/)

- 标签：字典树、数组、字符串、排序
- 难度：简单

## 题目链接

- [1065. 字符串的索引对 - 力扣](https://leetcode.cn/problems/index-pairs-of-a-string/)

## 题目大意

给定字符串 `text` 和单词列表 `words`。

要求：在 `text` 中找出所有属于单词列表 `words` 中的单词，并返回该单词在 `text` 中的索引对位置 `[i, j]`。将所有索引对存入列表中返回，并且返回的索引对可以交叉。

## 解题思路

构建字典树，将所有单词存入字典树中。

然后一重循环遍历 `text`，表示从第 `i` 位置开始的字符串 `text[i:]`。然后在字符串前缀中搜索对应的单词，将所有符合要求的单词末尾位置存入列表中，返回所有位置列表。对于列表中每个单词末尾位置 `index` 和 `text` 来说，每个 `[i, i + index]` 都构成了单词在 `text` 中的索引对位置，将其存入答案数组并返回即可。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, text: str) -> list:
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = []
        for i in range(len(text)):
            ch = text[i]
            if ch not in cur.children:
                return res
            cur = cur.children[ch]
            if cur.isEnd:
                res.append(i)

        return res

class Solution:
    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        res = []
        for i in range(len(text)):
            for index in trie_tree.search(text[i:]):
                res.append([i, i + index])
        return res
```

# [1079. 活字印刷](https://leetcode.cn/problems/letter-tile-possibilities/)

- 标签：哈希表、字符串、回溯、计数
- 难度：中等

## 题目链接

- [1079. 活字印刷 - 力扣](https://leetcode.cn/problems/letter-tile-possibilities/)

## 题目大意

**描述**：给定一个代表活字字模的字符串 $tiles$，其中 $tiles[i]$ 表示第 $i$ 个字模上刻的字母。

**要求**：返回你可以印出的非空字母序列的数目。

**说明**：

- 本题中，每个活字字模只能使用一次。
- $1 <= tiles.length <= 7$。
- $tiles$ 由大写英文字母组成。

**示例**：

- 示例 1：

```python
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```

- 示例 2：

```python
输入："AAABBC"
输出：188
```

## 解题思路

### 思路 1：哈希表 + 回溯算法

1. 使用哈希表存储每个字符的个数。
2. 然后依次从哈希表中取出对应字符，统计排列个数，并进行回溯。
3. 如果当前字符个数为 $0$，则不再进行回溯。
4. 回溯之后将状态回退。

### 思路 1：代码

```python
class Solution:
    ans = 0
    def backtrack(self, tile_map):
        for key, value in tile_map.items():
            if value == 0:
                continue
            self.ans += 1
            tile_map[key] -= 1
            self.backtrack(tile_map)
            tile_map[key] += 1

    def numTilePossibilities(self, tiles: str) -> int:
        tile_map = dict()
        for tile in tiles:
            if tile not in tile_map:
                tile_map[tile] = 1
            else:
                tile_map[tile] += 1

        self.backtrack(tile_map)

        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times n!)$，其中 $n$ 表示 $tiles$  的长度最小值。
- **空间复杂度**：$O(n)$。

# [1081. 不同字符的最小子序列](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

- 标签：栈、贪心、字符串、单调栈
- 难度：中等

## 题目链接

- [1081. 不同字符的最小子序列 - 力扣](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：去除字符串中重复的字母，使得每个字母只出现一次。需要保证 **「返回结果的字典序最小（要求不能打乱其他字符的相对位置）」**。

**说明**：

- $1 \le s.length \le 10^4$。
- `s` 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "bcabc"
输出："abc"
```

- 示例 2：

```python
输入：s = "cbacdcbc"
输出："acdb"
```

## 解题思路

### 思路 1：哈希表 + 单调栈

针对题目的三个要求：去重、不能打乱其他字符顺序、字典序最小。我们来一一分析。

1. **去重**：可以通过 **「使用哈希表存储字母出现次数」** 的方式，将每个字母出现的次数统计起来，再遍历一遍，去除重复的字母。
2. **不能打乱其他字符顺序**：按顺序遍历，将非重复的字母存储到答案数组或者栈中，最后再拼接起来，就能保证不打乱其他字符顺序。
3. **字典序最小**：意味着字典序小的字母应该尽可能放在前面。
   1. 对于第 `i` 个字符 `s[i]` 而言，如果第 `0` ~ `i - 1` 之间的某个字符 `s[j]` 在 `s[i]` 之后不再出现了，那么 `s[j]` 必须放到 `s[i]` 之前。
   2. 而如果 `s[j]` 在之后还会出现，并且 `s[j]` 的字典序大于 `s[i]`，我们则可以先舍弃 `s[j]`，把 `s[i]` 尽可能的放到前面。后边再考虑使用 `s[j]` 所对应的字符。


要满足第 3 条需求，我们可以使用 **「单调栈」** 来解决。我们使用单调栈存储 `s[i]` 之前出现的非重复、并且字典序最小的字符序列。整个算法步骤如下：

1. 先遍历一遍字符串，用哈希表 `letter_counts` 统计出每个字母出现的次数。
2. 然后使用单调递减栈保存当前字符之前出现的非重复、并且字典序最小的字符序列。
3. 当遍历到 `s[i]` 时，如果 `s[i]` 没有在栈中出现过：
   1. 比较 `s[i]` 和栈顶元素 `stack[-1]` 的字典序。如果 `s[i]` 的字典序小于栈顶元素 `stack[-1]`，并且栈顶元素之后的出现次数大于 `0`，则将栈顶元素弹出。
   2. 然后继续判断 `s[i]` 和栈顶元素 `stack[-1]`，并且知道栈顶元素出现次数为 `0` 时停止弹出。此时将 `s[i]` 添加到单调栈中。
4. 从哈希表 `letter_counts` 中减去 `s[i]` 出现的次数，继续遍历。
5. 最后将单调栈中的字符依次拼接为答案字符串，并返回。

### 思路 1：代码

```python
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        letter_counts = dict()
        for ch in s:
            if ch in letter_counts:
                letter_counts[ch] += 1
            else:
                letter_counts[ch] = 1

        for ch in s:
            if ch not in stack:
                while stack and ch < stack[-1] and stack[-1] in letter_counts and letter_counts[stack[-1]] > 0:
                    stack.pop()
                stack.append(ch)
            letter_counts[ch] -= 1

        return ''.join(stack)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(|\sum|)$，其中 $\sum$ 为字符集合，$|\sum|$ 为字符种类个数。由于栈中字符不能重复，因此栈中最多有 $|\sum|$ 个字符。

## 参考资料

- 【题解】[去除重复数组 - 去除重复字母 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-shu-zu-by-lu-shi-zhe-sokp/)# [1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

- 标签：数组、双指针
- 难度：简单

## 题目链接

- [1089. 复写零 - 力扣](https://leetcode.cn/problems/duplicate-zeros/)

## 题目大意

**描述**：给定搞一个长度固定的整数数组 $arr$。

**要求**：键改改数组中出现的每一个 $0$ 都复写一遍，并将其余的元素向右平移。

**说明**：

- 注意：不要在超过该数组长度的位置写上元素。请对输入的数组就地进行上述修改，不要从函数返回任何东西。
- $1 \le arr.length \le 10^4$。
- $0 \le arr[i] \le 9$。

**示例**：

- 示例 1：

```python
输入：arr = [1,0,2,3,0,4,5,0]
输出：[1,0,0,2,3,0,0,4]
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
```

- 示例 2：

```python
输入：arr = [1,2,3]
输出：[1,2,3]
解释：调用函数后，输入的数组将被修改为：[1,2,3]
```

## 解题思路

### 思路 1：两次遍历 + 快慢指针

因为数组中出现的 $0$ 需要复写为 $00$，占用空间从一个单位变成两个单位空间，那么右侧必定会有一部分元素丢失。我们可以先遍历一遍数组，找出复写后需要保留的有效数字部分与需要丢失部分的分界点。则从分界点开始，分界点右侧的元素都可以丢失。

我们再次逆序遍历数组，

1. 使用两个指针 $slow$、$fast$，$slow$ 表示当前有效字符位置，$fast$ 表示当前遍历字符位置。一开始 $slow$ 和 $fast$ 都指向数组开始位置。
2. 正序扫描数组：
   1. 如果遇到 $arr[slow] == 0$，则让 $fast$ 指针多走一步。
   2. 然后 $fast$、$slow$ 各自向右移动 $1$ 位，直到 $fast$ 指针移动到数组末尾。此时 $slow$ 左侧数字 $arr[0]... arr[slow - 1]$ 为需要保留的有效数字部分， $arr[slow]...arr[fast - 1]$ 为需要丢失部分。
3. 令 $slow$、$fast$ 分别左移 $1$ 位，此时 $slow$ 指向最后一个有效数字，$fast$ 指向丢失部分的最后一个数字。此时 $fast$ 可能等于 $size - 1$，也可能等于 $size$（比如输入 $[0, 0, 0]$）。
4. 逆序遍历数组：
   1. 将 $slow$ 位置元素移动到 $fast$ 位置。
   2. 如果遇到 $arr[slow] == 0$，则令 $fast$ 减 $1$，然后再复制 $1$ 个 $0$ 到 $fast$ 位置。
   3. 令 $slow$、$fast$ 分别左移 $1$ 位。

### 思路 1：代码

```python
class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        size = len(arr)
        slow, fast = 0, 0
        while fast < size:
            if arr[slow] == 0:
                fast += 1
            slow += 1
            fast += 1
        
        slow -= 1 # slow 指向最后一个有效数字
        fast -= 1 # fast 指向丢失部分的最后一个数字（可能在减 1 之后为 size，比如输入 [0, 0, 0]）

        while slow >= 0:
            if fast < size: # 防止 fast 越界
                arr[fast] = arr[slow] # 将 slow 位置元素移动到 fast 位置
            if arr[slow] == 0 and fast >= 0: # 遇见 0 则复制 0 到 fast - 1 位置
                fast -= 1
                arr[fast] = arr[slow]
            fast -= 1
            slow -= 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $arr$ 中的元素个数。
- **空间复杂度**：$O(1)$。
# [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

- 标签：广度优先搜索、数组、矩阵
- 难度：中等

## 题目链接

- [1091. 二进制矩阵中的最短路径 - 力扣](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

## 题目大意

给定一个 `n * n` 的二进制矩阵 `grid`。 `grid` 中只含有 `0` 或者 `1`。`grid` 中的畅通路径是一条从左上角 `(0, 0)` 位置上到右下角 `(n - 1, n - 1)`位置上的路径。该路径同时满足以下要求：

- 路径途径的所有单元格的值都是 `0`。
- 路径中所有相邻的单元格应该在 `8` 个方向之一上连通（即相邻两单元格之间彼此不同且共享一条边或者一个角）。
- 畅通路径的长度是该路径途径的单元格总数。

要求：计算出矩阵中最短畅通路径的长度。如果不存在这样的路径，返回 `-1`。

## 解题思路

使用广度优先搜索查找最短路径。具体做法如下：

1. 使用队列 `queue` 存放当前节点位置，使用 set 集合 `visited` 存放遍历过的节点位置。使用 `count` 记录最短路径。将起始位置 `(0, 0)` 加入到 `queue` 中，并标记为访问过。
2. 如果队列不为空，则令 `count += 1`，并将队列中的节点位置依次取出。对于每一个节点位置：
   - 先判断是否为右下角节点，即 `(n - 1, n - 1)`。如果是则返回当前最短路径长度 `count`。
   - 如果不是，则继续遍历 `8` 个方向上、没有访问过、并且值为 `0` 的相邻单元格。
   - 将其加入到队列 `queue` 中，并标记为访问过。
3. 重复进行第 2 步骤，直到队列为空时，返回 `-1`。

## 代码

```python
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        if grid[0][0] == 1:
            return -1
        size = len(grid)
        directions = {(1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1)}
        visited = set((0, 0))
        queue = [(0, 0)]
        count = 0
        while queue:
            count += 1
            for _ in range(len(queue)):
                row, col = queue.pop(0)

                if row == size - 1 and col == size - 1:
                    return count
                for direction in directions:
                    new_row = row + direction[0]
                    new_col = col + direction[1]
                    if 0 <= new_row < size and 0 <= new_col < size and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:
                        queue.append((new_row, new_col))
                        visited.add((new_row, new_col))
        return -1
```

# [1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/)

- 标签：数组、二分查找、交互
- 难度：困难

## 题目链接

- [1095. 山脉数组中查找目标值 - 力扣](https://leetcode.cn/problems/find-in-mountain-array/)

## 题目大意

**描述**：给定一个山脉数组 $mountainArr$。

**要求**：返回能够使得 `mountainArr.get(index)` 等于 $target$ 最小的下标 $index$ 值。如果不存在这样的下标 $index$，就请返回 $-1$。

**说明**：

- 山脉数组：满足以下属性的数组：

  - $len(arr) \ge 3$；
  - 存在 $i$（$0 < i < len(arr) - 1$），使得：
    - $arr[0] < arr[1] < ... arr[i-1] < arr[i]$;
    - $arr[i] > arr[i+1] > ... > arr[len(arr) - 1]$。
- 不能直接访问该山脉数组，必须通过 `MountainArray` 接口来获取数据：

  - `MountainArray.get(index)`：会返回数组中索引为 $k$ 的元素（下标从 $0$ 开始）。

  - `MountainArray.length()`：会返回该数组的长度。
- 对 `MountainArray.get` 发起超过 $100$ 次调用的提交将被视为错误答案。
- $3 \le mountain_arr.length() \le 10000$。
- $0 \le target \le 10^9$。
- $0 \le mountain_arr.get(index) \le 10^9$。

**示例**：

- 示例 1：

```python
输入：array = [1,2,3,4,5,3,1], target = 3
输出：2
解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。
```

- 示例 2：

```python
输入：array = [0,1,2,4,2,1], target = 3
输出：-1
解释：3 在数组中没有出现，返回 -1。
```

## 解题思路

### 思路 1：二分查找

因为题目要求不能对 `MountainArray.get` 发起超过 $100$ 次调用。所以遍历数组进行查找是不可行的。

根据山脉数组的性质，我们可以把山脉数组分为两部分：「前半部分的升序数组」和「后半部分的降序数组」。在有序数组中查找目标值可以使用二分查找来减少查找次数。

而山脉的峰顶元素索引也可以通过二分查找来做。所以这道题我们可以分为三步：

1. 通过二分查找找到山脉数组的峰顶元素索引。
2. 通过二分查找在前半部分的升序数组中查找目标元素。
3. 通过二分查找在后半部分的降序数组中查找目标元素。

最后，通过对查找结果的判断来输出最终答案。

### 思路 1：代码

```python
#class MountainArray:
#    def get(self, index: int) -> int:
#    def length(self) -> int:

class Solution:
    def binarySearchPeak(self, mountain_arr) -> int:
        left, right = 0, mountain_arr.length() - 1
        while left < right:
            mid = left + (right - left) // 2
            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):
                left = mid + 1
            else:
                right = mid
        return left

    def binarySearchAscending(self, mountain_arr, left, right, target):
        while left < right:
            mid = left + (right - left) // 2
            if mountain_arr.get(mid) < target:
                left = mid + 1
            else:
                right = mid
        return left if mountain_arr.get(left) == target else -1

    def binarySearchDescending(self, mountain_arr, left, right, target):
        while left < right:
            mid = left + (right - left) // 2
            if mountain_arr.get(mid) > target:
                left = mid + 1
            else:
                right = mid
        return left if mountain_arr.get(left) == target else -1

    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        size = mountain_arr.length()
        peek_i = self.binarySearchPeak(mountain_arr)

        res_left = self.binarySearchAscending(mountain_arr, 0, peek_i, target)
        res_right = self.binarySearchDescending(mountain_arr, peek_i + 1, size - 1, target)
        
        return res_left if res_left != -1 else res_right
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(1)$。
# [1099. 小于 K 的两数之和](https://leetcode.cn/problems/two-sum-less-than-k/)

- 标签：数组、双指针、二分查找、排序
- 难度：简单

## 题目链接

- [1099. 小于 K 的两数之和 - 力扣](https://leetcode.cn/problems/two-sum-less-than-k/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和整数 $k$。 

**要求**：返回最大和 $sum$，满足存在 $i < j$ 使得 $nums[i] + nums[j] = sum$ 且 $sum < k$。如果没有满足此等式的 $i$, $j$ 存在，则返回 $-1$。

**说明**：

- $1 \le nums.length \le 100$。
- $1 \le nums[i] \le 1000$。
- $1 \le k \le 2000$。

**示例**：

- 示例 1：

```python
输入：nums = [34,23,1,24,75,33,54,8], k = 60
输出：58
解释：34 和 24 相加得到 58，58 小于 60，满足题意。
```

- 示例 2：

```python
输入：nums = [10,20,30], k = 15
输出：-1
解释：我们无法找到和小于 15 的两个元素。
```

## 解题思路

### 思路 1：对撞指针

常规暴力枚举时间复杂度为 $O(n^2)$。可以通过双指针降低时间复杂度。具体做法如下：

- 先对数组进行排序（时间复杂度为 $O(n \log n$），使用 $res$ 记录答案，初始赋值为最小值 `float('-inf')`。
- 使用两个指针 $left$、$right$。$left$ 指向第 $0$ 个元素位置，$right$ 指向数组的最后一个元素位置。 
- 计算 $nums[left] + nums[right]$，与 $k$ 进行比较。
  - 如果 $nums[left] + nums[right] \ge k$，则将 $right$ 左移，继续查找。
  - 如果 $nums[left] + nums[rigth] < k$，则将 $left$ 右移，并更新答案值。
- 当 $left == right$ 时，区间搜索完毕，判断 $res$ 是否等于 `float('-inf')`，如果等于，则返回 $-1$，否则返回 $res$。

### 思路 1：代码

```python
class Solution:
    def twoSumLessThanK(self, nums: List[int], k: int) -> int:

        nums.sort()
        res = float('-inf')
        left, right = 0, len(nums) - 1
        while left < right:
            total = nums[left] + nums[right]
            if total >= k:
                right -= 1
            else:
                res = max(res, total)
                left += 1

        return res if res != float('-inf') else -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为数组中元素的个数。
- **空间复杂度**：$O(\log n)$，排序需要 $\log n$ 的栈空间。

# [1100. 长度为 K 的无重复字符子串](https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [1100. 长度为 K 的无重复字符子串 - 力扣](https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/)

## 题目大意

**描述**：给定一个字符串 `s`。

**要求**：找出所有长度为 `k` 且不含重复字符的子串，返回全部满足要求的子串的数目。

**说明**：

- $1 \le s.length \le 10^4$。
- $s$ 中的所有字符均为小写英文字母。
- $1 <= k <= 10^4$。

**示例**：

- 示例 1：

```python
输入：s = "havefunonleetcode", k = 5
输出：6
解释：
这里有 6 个满足题意的子串，分别是：'havef','avefu','vefun','efuno','etcod','tcode'。
```

- 示例 2：

```python
输入：s = "home", K = 5
输出：0
解释：
注意：k 可能会大于 s 的长度。在这种情况下，就无法找到任何长度为 k 的子串。
```

## 解题思路

### 思路 1：滑动窗口

固定长度滑动窗口的题目。维护一个长度为 `k` 的滑动窗口。用 `window_count` 来表示窗口内所有字符个数。可以用字典、数组来实现，也可以直接用 `collections.Counter()` 实现。然后不断向右滑动，然后进行比较。如果窗口内字符无重复，则答案数目 + 1。然后继续滑动。直到末尾时。整个解题步骤具体如下：

1. `window_count` 用来维护窗口中 `2` 对应子串的各个字符数量。
2. `left` 、`right` 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
3. 向右移动 `right`，先将 `k` 个元素填入窗口中。
4. 当窗口元素个数为 `k` 时，即：`right - left + 1 >= k` 时，判断窗口内各个字符数量 `window_count` 是否等于 `k`。
   1. 如果等于，则答案 + 1。
   2. 如果不等于，则向右移动 `left`，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 `k`。
5. 重复 3 ~ 4 步，直到 `right` 到达数组末尾。返回答案。

### 思路 1：代码

```python
import collections

class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        left, right = 0, 0
        window_count = collections.Counter()
        ans = 0

        while right < len(s):
            window_count[s[right]] += 1

            if right - left + 1 >= k:
                if len(window_count) == k:
                    ans += 1
                window_count[s[left]] -= 1
                if window_count[s[left]] == 0:
                    del window_count[s[left]]
                left += 1

            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(|\sum|)$，其中 $\sum$ 是字符集。

# [1103. 分糖果 II](https://leetcode.cn/problems/distribute-candies-to-people/)

- 标签：数学、模拟
- 难度：简单

## 题目链接

- [1103. 分糖果 II - 力扣](https://leetcode.cn/problems/distribute-candies-to-people/)

## 题目大意

**描述**：给定一个整数 $candies$，代表糖果的数量。再给定一个整数 $num\underline{\hspace{0.5em}}people$，代表小朋友的数量。

现在开始分糖果，给第 $1$ 个小朋友分 $1$ 颗糖果，第 $2$ 个小朋友分 $2$ 颗糖果，以此类推，直到最后一个小朋友分 $n$ 颗糖果。

然后回到第 $1$ 个小朋友，给第 $1$ 个小朋友分 $n + 1$ 颗糖果，第 $2$ 个小朋友分 $n + 2$ 颗糖果，一次类推，直到最后一个小朋友分 $n + n$ 颗糖果。

重复上述过程（每次都比上一次多给出 $1$ 颗糖果，当分完第 $n$ 个小朋友时回到第 $1$ 个小朋友），直到我们分完所有的糖果。

> 注意：如果我们手中剩下的糖果数不够（小于等于前一次发的糖果数），则将剩下的糖果全部发给当前的小朋友。

**要求**：返回一个长度为 $num\underline{\hspace{0.5em}}people$、元素之和为 $candies$ 的数组，以表示糖果的最终分发情况（即 $ans[i]$ 表示第 $i$ 个小朋友分到的糖果数）。

**说明**：

- $1 \le candies \le 10^9$。
- $1 \le num\underline{\hspace{0.5em}}people \le 1000$。

**示例**：

- 示例 1：

```python
输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
```

- 示例 2：

```python
输入：candies = 10, num_people = 3
输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
```

## 解题思路

### 思路 1：暴力模拟

不断遍历数组，将对应糖果数分给当前小朋友，直到糖果数为 $0$ 时停止。

### 思路 1：代码

```python
class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        ans = [0 for _ in range(num_people)]
        idx = 0
        while candies:
            ans[idx % num_people] += min(idx + 1, candies)
            candies -= min(idx + 1, candies)
            idx += 1
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(max(\sqrt{m}, n))$，其中 $m$ 为糖果数量，$n$ 为小朋友数量。
- **空间复杂度**：$O(1)$。

# [1108. IP 地址无效化](https://leetcode.cn/problems/defanging-an-ip-address/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1108. IP 地址无效化 - 力扣](https://leetcode.cn/problems/defanging-an-ip-address/)

## 题目大意

**描述**：给定一个有效的 IPv4 的地址 `address`。。

**要求**：返回这个 IP 地址的无效化版本。

**说明**：

- **无效化 IP 地址**：其实就是用 `"[.]"` 代替了每个 `"."`。

**示例**：

- 示例 1：

```python
输入：address = "255.100.50.0"
输出："255[.]100[.]50[.]0"
```

## 解题思路

### 思路 1：字符串替换

依次将字符串 `address` 中的 `"."` 替换为 `"[.]"`。这里为了方便，直接调用了 `replace` 方法。

### 思路 1：字符串替换代码

```python
class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.', '[.]')
```
# [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

- 标签：数组、前缀和
- 难度：中等

## 题目链接

- [1109. 航班预订统计 - 力扣](https://leetcode.cn/problems/corporate-flight-bookings/)

## 题目大意

**描述**：给定整数 `n`，代表 `n` 个航班。再给定一个包含三元组的数组 `bookings`，代表航班预订表。表中第 `i` 条预订记录 $bookings[i] = [first_i, last_i, seats_i]$ 意味着在从 $first_i$ 到 $last_i$ （包含 $first_i$ 和 $last_i$）的 每个航班上预订了 $seats_i$ 个座位。

**要求**：返回一个长度为 `n` 的数组 `answer`，里面元素是每个航班预定的座位总数。

**说明**：

- $1 \le n \le 2 * 10^4$。
- $1 \le bookings.length \le 2 * 10^4$。
- $bookings[i].length == 3$。
- $1 \le first_i \le last_i \le n$。
- $1 \le seats_i \le 10^4$

**示例**：

- 示例 1：

```python
给定 n = 5。初始 answer = [0, 0, 0, 0, 0]

航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25

最终 answer = [10, 55, 45, 25, 25]
```

## 解题思路

### 思路 1：线段树

- 初始化一个长度为 `n`，值全为 `0` 的 `nums` 数组。
- 然后根据 `nums` 数组构建一棵线段树。每个线段树的节点类存储当前区间的左右边界和该区间的和。并且线段树使用延迟标记。
- 然后遍历三元组操作，进行区间累加运算。
- 最后从线段树中查询数组所有元素，返回该数组即可。

这样构建线段树的时间复杂度为 $O(\log n)$，单次区间更新的时间复杂度为 $O(\log n)$，单次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(\log n)$。

### 思路 1 线段树代码：

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = None                        # 区间和问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
    
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间更新接口：将区间为 [q_left, q_right] 上的所有元素值加上 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
        
        
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 单点更新实现方法：将 nums[i] 更改为 val，节点的存储下标为 index
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == right:
            self.tree[index].val = val              # 叶子节点，节点值修改为 val
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖        
            if self.tree[index].lazy_tag is not None:
                self.tree[index].lazy_tag += val    # 将当前节点的延迟标记增加 val
            else:
                self.tree[index].lazy_tag = val     # 将当前节点的延迟标记增加 val
            interval_size = (right - left + 1)      # 当前节点所在区间大小
            self.tree[index].val += val * interval_size  # 当前节点所在区间每个元素值增加 val
            return
        
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return
    
        self.__pushdown(index)                      # 向下更新节点的区间值
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if q_left <= mid:                           # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, left_index)
        if q_right > mid:                           # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(index)
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)

    # 向下更新实现方法：更新下标为 index 的节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, index):
        lazy_tag = self.tree[index].lazy_tag
        if lazy_tag is None: 
            return
        
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        
        if self.tree[left_index].lazy_tag is not None:
            self.tree[left_index].lazy_tag += lazy_tag  # 更新左子节点懒惰标记
        else:
            self.tree[left_index].lazy_tag = lazy_tag
        left_size = (self.tree[left_index].right - self.tree[left_index].left + 1)
        self.tree[left_index].val += lazy_tag * left_size   # 左子节点每个元素值增加 lazy_tag
        
        if self.tree[right_index].lazy_tag is not None:
            self.tree[right_index].lazy_tag += lazy_tag # 更新右子节点懒惰标记
        else:
            self.tree[right_index].lazy_tag = lazy_tag
        right_size = (self.tree[right_index].right - self.tree[right_index].left + 1)
        self.tree[right_index].val += lazy_tag * right_size # 右子节点每个元素值增加 lazy_tag
        
        self.tree[index].lazy_tag = None            # 更新当前节点的懒惰标记


class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        nums = [0 for _ in range(n)]
        self.STree = SegmentTree(nums, lambda x, y: x + y)
        for booking in bookings:
            self.STree.update_interval(booking[0] - 1, booking[1] - 1, booking[2])

        return self.STree.get_nums()
```

# [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

- 标签：树、深度优先搜索、数组、哈希表、二叉树
- 难度：中等

## 题目链接

- [1110. 删点成林 - 力扣](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

## 题目大意

**描述**：给定二叉树的根节点 $root$，树上每个节点都有一个不同的值。

如果节点值在 $to\underline{\hspace{0.5em}}delete$ 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。

**要求**：返回森林中的每棵树。你可以按任意顺序组织答案。

**说明**：

- 树中的节点数最大为 $1000$。
- 每个节点都有一个介于 $1$ 到 $1000$ 之间的值，且各不相同。
- $to\underline{\hspace{0.5em}}delete.length \le 1000$。
- $to\underline{\hspace{0.5em}}delete$ 包含一些从 $1$ 到 $1000$、各不相同的值。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png)

```python
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
```

- 示例 2：

```python
输入：root = [1,2,4,null,3], to_delete = [3]
输出：[[1,2,4]]
```

## 解题思路

### 思路 1：深度优先搜索

将待删除节点数组 $to\underline{\hspace{0.5em}}delete$ 转为集合 $deletes$，则每次能以  $O(1)$ 的时间复杂度判断节点值是否在待删除节点数组中。

如果当前节点值在待删除节点数组中，则删除当前节点后，我们还需要判断其左右子节点是否也在待删除节点数组中。

以此类推，还需要判断左右子节点的左右子节点。。。

因此，我们应该递归遍历处理完所有的左右子树，再判断当前节点的左右子节点是否在待删除节点数组中。如果在，则将其加入到答案数组中。

为此我们可以写一个深度优先搜索算法，具体步骤如下：

1. 如果当前根节点为空，则返回 `None`。
2. 递归遍历处理完当前根节点的左右子树，更新当前节点的左右子树（子节点被删除的情况下需要更新当前根节点的左右子树）。
3. 如果当前根节点值在待删除节点数组中：
   1. 如果当前根节点的左子树没有在被删除节点数组中，将左子树节点加入到答案数组中。
   2. 如果当前根节点的右子树没有在被删除节点数组中，将右子树节点加入到答案数组中。
   3. 返回 `None`，表示当前节点被删除。
4. 如果当前根节点值不在待删除节点数组中：
   1. 返回根节点，表示当前节点没有被删除。

### 思路 1：代码

```Python
class Solution:
    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:
        forest = []
        deletes = set(to_delete)
        def dfs(root):
            if not root:
                return None
            root.left = dfs(root.left)
            root.right = dfs(root.right)

            if root.val in deletes:
                if root.left:
                    forest.append(root.left)
                if root.right:
                    forest.append(root.right)
                return None
            else:
                return root


        if dfs(root):
            forest.append(root)
        return forest
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为二叉树中节点个数。
- **空间复杂度**：$O(n)$。

# [1122. 数组的相对排序](https://leetcode.cn/problems/relative-sort-array/)

- 标签：数组、哈希表、计数排序、排序
- 难度：简单

## 题目链接

- [1122. 数组的相对排序 - 力扣](https://leetcode.cn/problems/relative-sort-array/)

## 题目大意

**描述**：给定两个数组，$arr1$ 和 $arr2$，其中 $arr2$ 中的元素各不相同，$arr2$ 中的每个元素都出现在 $arr1$ 中。

**要求**：对 $arr1$ 中的元素进行排序，使 $arr1$ 中项的相对顺序和 $arr2$ 中的相对顺序相同。未在 $arr2$ 中出现过的元素需要按照升序放在 $arr1$ 的末尾。

**说明**：

- $1 \le arr1.length, arr2.length \le 1000$。
- $0 \le arr1[i], arr2[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
```

- 示例 2：

```python
输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
```

## 解题思路

### 思路 1：计数排序

因为元素值范围在 $[0, 1000]$，所以可以使用计数排序的思路来解题。

1. 使用数组 $count$ 统计 $arr1$ 各个元素个数。
2. 遍历 $arr2$ 数组，将对应元素$num2$ 按照个数 $count[num2]$ 添加到答案数组 $ans$ 中，同时在 $count$ 数组中减去对应个数。
3. 然后在处理 $count$ 中剩余元素，将 $count$ 中大于 $0$ 的元素下标依次添加到答案数组 $ans$ 中。
4. 最后返回答案数组 $ans$。

### 思路 1：代码

```python
class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        # 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min
        arr1_min, arr1_max = min(arr1), max(arr1)
        # 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1
        size = arr1_max - arr1_min + 1
        counts = [0 for _ in range(size)]

        # 统计值为 num 的元素出现的次数
        for num in arr1:
            counts[num - arr1_min] += 1

        res = []
        for num in arr2:
            while counts[num - arr1_min] > 0:
                res.append(num)
                counts[num - arr1_min] -= 1

        for i in range(size):
            while counts[i] > 0:
                num = i + arr1_min
                res.append(num)
                counts[i] -= 1
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n + max(arr_1))$。其中 $m$ 是数组 $arr_1$ 的长度，$n$ 是数组 $arr_2$ 的长度，$max(arr_1)$ 是数组 $arr_1$ 的最大值。
- **空间复杂度**：$O(max(arr_1))$。



# [1136. 并行课程](https://leetcode.cn/problems/parallel-courses/)

- 标签：图、拓扑排序
- 难度：中等

## 题目链接

- [1136. 并行课程 - 力扣](https://leetcode.cn/problems/parallel-courses/)

## 题目大意

有 N 门课程，分别以 1 到 N 进行编号。现在给定一份课程关系表 `relations[i] = [X, Y]`，用以表示课程 `X` 和课程 `Y` 之间的先修关系：课程 `X` 必须在课程 `Y` 之前修完。假设在一个学期里，你可以学习任何数量的课程，但前提是你已经学习了将要学习的这些课程的所有先修课程。

要求：返回学完全部课程所需的最少学期数。如果没有办法做到学完全部这些课程的话，就返回 `-1`。

## 解题思路

拓扑排序。具体解法如下：

1. 使用列表 `edges` 存放课程关系图，并统计每门课程节点的入度，存入入度列表 `indegrees`。使用 `ans` 表示学期数。
2. 借助队列 `queue`，将所有入度为 `0` 的节点入队。
3. 将队列中所有节点依次取出，学期数 +1。对于取出的每个节点：
   1. 对应课程数 -1。
   2. 将该顶点以及该顶点为出发点的所有边的另一个节点入度 -1。如果入度 -1 后的节点入度不为 0，则将其加入队列 `queue`。
4. 重复 3~4 的步骤，直到队列中没有节点。
5. 最后判断剩余课程数是否为 0，如果为 0，则返回 `ans`，否则，返回 `-1`。

## 代码

```python
import collections

class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        indegrees = [0 for _ in range(n + 1)]
        edges = collections.defaultdict(list)
        for x, y in relations:
            edges[x].append(y)
            indegrees[y] += 1
        queue = collections.deque([])
        for i in range(1, n + 1):
            if not indegrees[i]:
                queue.append(i)
        ans = 0

        while queue:
            size = len(queue)
            for i in range(size):
                x = queue.popleft()
                n -= 1
                for y in edges[x]:
                    indegrees[y] -= 1
                    if not indegrees[y]:
                        queue.append(y)
            ans += 1

        return ans if n == 0 else -1
```

# [1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

- 标签：记忆化搜索、数学、动态规划
- 难度：简单

## 题目链接

- [1137. 第 N 个泰波那契数 - 力扣](https://leetcode.cn/problems/n-th-tribonacci-number/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回第 $n$ 个泰波那契数。

**说明**：

- **泰波那契数**：$T_0 = 0, T_1 = 1, T_2 = 1$，且在 $n >= 0$ 的条件下，$T_{n + 3} = T_{n} + T_{n+1} + T_{n+2}$。
- $0 \le n \le 37$。
- 答案保证是一个 32 位整数，即 $answer \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
```

- 示例 2：

```python
输入：n = 25
输出：1389537
```

## 解题思路

### 思路 1：记忆化搜索

1. 问题的状态定义为：第 $n$ 个泰波那契数。其状态转移方程为：$T_0 = 0, T_1 = 1, T_2 = 1$，且在 $n >= 0$ 的条件下，$T_{n + 3} = T_{n} + T_{n+1} + T_{n+2}$。
2. 定义一个长度为 $n + 1$ 数组 `memo` 用于保存一斤个计算过的泰波那契数。
3. 定义递归函数 `my_tribonacci(n, memo)`。
   1. 当 $n = 0$ 或者 $n = 1$，或者 $n = 2$ 时直接返回结果。
   2. 当 $n > 2$ 时，首先检查是否计算过 $T(n)$，即判断 $memo[n]$ 是否等于 $0$。
      1. 如果 $memo[n] \ne 0$，说明已经计算过 $T(n)$，直接返回 $memo[n]$。
      2. 如果 $memo[n] = 0$，说明没有计算过 $T(n)$，则递归调用 `my_tribonacci(n - 3, memo)`、`my_tribonacci(n - 2, memo)`、`my_tribonacci(n - 1, memo)`，并将计算结果存入 $memo[n]$ 中，并返回 $memo[n]$。

### 思路 1：代码

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        # 使用数组保存已经求解过的 T(k) 的结果
        memo = [0 for _ in range(n + 1)]
        return self.my_tribonacci(n, memo)
    
    def my_tribonacci(self, n: int, memo: List[int]) -> int:
        if n == 0:
            return 0
        if n == 1 or n == 2:
            return 1
        
        if memo[n] != 0:
            return memo[n]
        memo[n] = self.my_tribonacci(n - 3, memo) + self.my_tribonacci(n - 2, memo) + self.my_tribonacci(n - 1, memo)
        return memo[n]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：动态规划

###### 1. 划分阶段

我们可以按照整数顺序进行阶段划分，将其划分为整数 $0 \sim n$。

###### 2. 定义状态

定义状态 `dp[i]` 为：第 `i` 个泰波那契数。

###### 3. 状态转移方程

根据题目中所给的泰波那契数的定义：$T_0 = 0, T_1 = 1, T_2 = 1$，且在 $n >= 0$ 的条件下，$T_{n + 3} = T_{n} + T_{n+1} + T_{n+2}$。，则直接得出状态转移方程为 $dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]$（当 $i > 2$ 时）。

###### 4. 初始条件

根据题目中所给的初始条件 $T_0 = 0, T_1 = 1, T_2 = 1$ 确定动态规划的初始条件，即 `dp[0] = 0, dp[1] = 1, dp[2] = 1`。

###### 5. 最终结果

根据状态定义，最终结果为 `dp[n]`，即第 `n` 个泰波那契数为 `dp[n]`。

### 思路 2：代码

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1 or n == 2:
            return 1
        dp = [0 for _ in range(n + 1)]
        dp[1] = dp[2] = 1
        for i in range(3, n + 1):
            dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]
        return dp[n]
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [1143. 最长公共子序列 - 力扣](https://leetcode.cn/problems/longest-common-subsequence/)

## 题目大意

**描述**：给定两个字符串 $text1$ 和 $text2$。

**要求**：返回两个字符串的最长公共子序列的长度。如果不存在公共子序列，则返回 $0$。

**说明**：

- **子序列**：原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
- **公共子序列**：两个字符串所共同拥有的子序列。
- $1 \le text1.length, text2.length \le 1000$。
- $text1$ 和 $text2$ 仅由小写英文字符组成。

**示例**：

- 示例 1：

```python
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```

- 示例 2：

```python
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照两个字符串的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：「以 $text1$ 中前 $i$ 个元素组成的子字符串 $str1$ 」与「以 $text2$ 中前 $j$ 个元素组成的子字符串 $str2$」的最长公共子序列长度为 $dp[i][j]$。

###### 3. 状态转移方程

双重循环遍历字符串 $text1$ 和 $text2$，则状态转移方程为：

1. 如果 $text1[i - 1] = text2[j - 1]$，说明两个子字符串的最后一位是相同的，所以最长公共子序列长度加 $1$。即：$dp[i][j] = dp[i - 1][j - 1] + 1$。
2. 如果 $text1[i - 1] \ne text2[j - 1]$，说明两个子字符串的最后一位是不同的，则 $dp[i][j]$ 需要考虑以下两种情况，取两种情况中最大的那种：$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$。
	1. 「以 $text1$ 中前 $i - 1$ 个元素组成的子字符串 $str1$ 」与「以 $text2$ 中前 $j$ 个元素组成的子字符串 $str2$」的最长公共子序列长度，即 $dp[i - 1][j]$。
	2. 「以 $text1$ 中前 $i$ 个元素组成的子字符串 $str1$ 」与「以 $text2$ 中前 $j - 1$ 个元素组成的子字符串 $str2$」的最长公共子序列长度，即 $dp[i][j - 1]$。

###### 4. 初始条件

1. 当 $i = 0$ 时，$str1$ 表示的是空串，空串与 $str2$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。
2. 当 $j = 0$ 时，$str2$ 表示的是空串，$str1$ 与 空串的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。

###### 5. 最终结果

根据状态定义，最后输出 $dp[sise1][size2]$（即 $text1$ 与 $text2$ 的最长公共子序列长度）即可，其中 $size1$、$size2$ 分别为 $text1$、$text2$ 的字符串长度。

### 思路 1：代码

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        size1 = len(text1)
        size2 = len(text2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[size1][size2]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $text1$、$text2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。
- **空间复杂度**：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。

# [1151. 最少交换次数来组合所有的 1](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/)

- 标签：数组、滑动窗口
- 难度：中等

## 题目链接

- [1151. 最少交换次数来组合所有的 1 - 力扣](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/)

## 题目大意

**描述**：给定一个二进制数组 $data$。

**要求**：通过交换位置，将数组中任何位置上的 $1$ 组合到一起，并返回所有可能中所需的最少交换次数。c 

**说明**：

- $1 \le data.length \le 10^5$。
- $data[i] == 0 \text{ or } 1$。

**示例**：

- 示例 1：

```python
输入: data = [1,0,1,0,1]
输出: 1
解释: 
有三种可能的方法可以把所有的 1 组合在一起：
[1,1,1,0,0]，交换 1 次；
[0,1,1,1,0]，交换 2 次；
[0,0,1,1,1]，交换 1 次。
所以最少的交换次数为 1。
```

- 示例 2：

```python
输入：data = [0,0,0,1,0]
输出：0
解释： 
由于数组中只有一个 1，所以不需要交换。
```

## 解题思路

### 思路 1：滑动窗口

将数组中任何位置上的 $1$ 组合到一起，并要求最少的交换次数。也就是说交换之后，某个连续子数组中全是 $1$，数组其他位置全是 $0$。为此，我们可以维护一个固定长度为 $1$ 的个数的滑动窗口，找到滑动窗口中 $0$ 最少的个数，这样最终交换出去的 $0$ 最少，交换次数也最少。

求最少交换次数，也就是求滑动窗口中最少的 $0$ 的个数。具体做法如下：

1. 统计 $1$ 的个数，并设置为窗口长度 $window\underline{\hspace{0.5em}}size$。使用 $window\underline{\hspace{0.5em}}count$ 维护窗口中 $0$ 的个数。使用 $ans$ 维护窗口中最少的 $0$ 的个数，也可以叫做最少交换次数。
2. 如果 $window\underline{\hspace{0.5em}}size$ 为 $0$，则说明不用交换，直接返回 $0$。
3. 使用两个指针 $left$、$right$。$left$、$right$ 都指向数组的第一个元素，即：`left = 0`，`right = 0`。
4. 如果 $data[right] == 0$，则更新窗口中 $0$ 的个数，即 `window_count += 1`。然后向右移动 $right$。
5. 当窗口元素个数为 $window\underline{\hspace{0.5em}}size$ 时，即：$right - left + 1 \ge window\underline{\hspace{0.5em}}size$ 时，更新窗口中最少的 $0$ 的个数。
6. 然后如果左侧 $data[left] == 0$，则更新窗口中 $0$ 的个数，即 `window_count -= 1`。然后向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $window\underline{\hspace{0.5em}}size$。
7. 重复 4 ~ 6 步，直到 $right$ 到达数组末尾。返回答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def minSwaps(self, data: List[int]) -> int:
        window_size = 0
        for item in data:
            if item == 1:
                window_size += 1
        if window_size == 0:
            return 0

        left, right = 0, 0
        window_count = 0
        ans = float('inf')
        while right < len(data):
            if data[right] == 0:
                window_count += 1

            if right - left + 1 >= window_size:
                ans = min(ans, window_count)
                if data[left] == 0:
                    window_count -= 1
                left += 1
            right += 1
        return ans if ans != float('inf') else 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $data$ 的长度。
- **空间复杂度**：$O(1)$。

# [1155. 掷骰子等于目标和的方法数](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/)

- 标签：动态规划
- 难度：中等

## 题目链接

- [1155. 掷骰子等于目标和的方法数 - 力扣](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/)

## 题目大意

**描述**：有 $n$ 个一样的骰子，每个骰子上都有 $k$ 个面，分别标号为 $1 \sim k$。现在给定三个整数 $n$、$k$ 和 $target$，滚动 $n$ 个骰子。

**要求**：计算出使所有骰子正面朝上的数字和等于 $target$ 的方案数量。

**说明**：

- $1 \le n, k \le 30$。
- $1 \le target \le 1000$。

**示例**：

- 示例 1：

```python
输入：n = 1, k = 6, target = 3
输出：1
解释：你扔一个有 6 个面的骰子。
得到 3 的和只有一种方法。
```

- 示例 2：

```python
输入：n = 2, k = 6, target = 7
输出：6
解释：你扔两个骰子，每个骰子有 6 个面。
得到 7 的和有 6 种方法 1+6 2+5 3+4 4+3 5+2 6+1。
```

## 解题思路

### 思路 1：动态规划

我们可以将这道题转换为「分组背包问题」中求方案总数的问题。将每个骰子看做是一组物品，骰子每一个面上的数值当做是每组物品中的一个物品。这样问题就转换为：用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $target$ 的方案数。

###### 1. 划分阶段

按照总价值 $target$ 进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $w$ 的方案数。

###### 3. 状态转移方程

用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $w$ 的方案数，等于用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $w - d$ 的方案数累积值，其中 $d$ 为当前骰子掷出的价值，即：$dp[w] = dp[w] + dp[w - d]$。

###### 4. 初始条件

- 用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $0$ 的方案数为 $1$。

###### 5. 最终结果

根据我们之前定义的状态， $dp[w]$ 表示为：用 $n$ 个骰子（$n$ 组物品）进行投掷，投掷出总和（总价值）为 $w$ 的方案数。则最终结果为 $dp[target]$。

### 思路 1：代码

```python
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1
        MOD = 10 ** 9 + 7

        # 枚举前 i 组物品
        for i in range(1, n + 1):
            # 逆序枚举背包装载重量
            for w in range(target, -1, -1):
                dp[w] = 0
                # 枚举第 i - 1 组物品能取个数
                for d in range(1, k + 1):
                    if w >= d:
                        dp[w] = (dp[w] + dp[w - d]) % MOD
                        
        return dp[target] % MOD
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times m \times target)$。
- **空间复杂度**：$O(target)$。

# [1161. 最大层内元素和](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [1161. 最大层内元素和 - 力扣](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

## 题目大意

**描述**：给你一个二叉树的根节点 $root$。设根节点位于二叉树的第 $1$ 层，而根节点的子节点位于第 $2$ 层，依此类推。

**要求**：返回层内元素之和最大的那几层（可能只有一层）的层号，并返回其中层号最小的那个。

**说明**：

- 树中的节点数在 $[1, 10^4]$ 范围内。
- $-10^5 \le Node.val \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/capture.jpeg)

```python
输入：root = [1,7,0,7,-8,null,null]
输出：2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
```

- 示例 2：

```python
输入：root = [989,null,10250,98693,-89388,null,null,null,-32127]
输出：2
```

## 解题思路

### 思路 1：二叉树的层序遍历

1. 利用广度优先搜索，在二叉树的层序遍历的基础上，统计每一层节点和，并存入数组 $levels$ 中。
2. 遍历 $levels$ 数组，从 $levels$ 数组中找到最大层和 $max\underline{\hspace{0.5em}}sum$。
3. 再次遍历 $levels$ 数组，找出等于最大层和 $max\underline{\hspace{0.5em}}sum$ 的那一层，并返回该层序号。

### 思路 1：代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        levels = []
        while queue:
            level = 0
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                level += curr.val
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            levels.append(level)
        return levels

    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        levels = self.levelOrder(root)
        max_sum = max(levels)
        for i in range(len(levels)):
            if levels[i] == max_sum:
                return i + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中 $n$ 是二叉树的节点数目。
- **空间复杂度**：$O(n)$。
# [1176. 健身计划评估](https://leetcode.cn/problems/diet-plan-performance/)

- 标签：数组、滑动窗口
- 难度：简单

## 题目链接

- [1176. 健身计划评估 - 力扣](https://leetcode.cn/problems/diet-plan-performance/)

## 题目大意

**描述**：好友给自己制定了一份健身计划。想请你帮他评估一下这份计划是否合理。

给定一个数组 $calories$，其中 $calories[i]$ 代表好友第 $i$ 天需要消耗的卡路里总量。再给定 $lower$ 代表较低消耗的卡路里，$upper$ 代表较高消耗的卡路里。再给定一个整数 $k$，代表连续 $k$ 天。

- 如果你的好友在这一天以及之后连续 $k$ 天内消耗的总卡路里 $T$ 小于 $lower$，则这一天的计划相对糟糕，并失去 $1$ 分。
- 如果你的好友在这一天以及之后连续 $k$ 天内消耗的总卡路里 $T$ 高于 $upper$，则这一天的计划相对优秀，并得到 $1$ 分。
- 如果你的好友在这一天以及之后连续 $k$ 天内消耗的总卡路里 $T$ 大于等于 $lower$，并且小于等于 $upper$，则这份计划普普通通，分值不做变动。

**要求**：输出最后评估的得分情况。

**说明**：

- $1 \le k \le calories.length \le 10^5$。
- $0 \le calories[i] \le 20000$。
- $0 \le lower \le upper$。 

**示例**：

- 示例 1：

```python
输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
输出：0
解释：calories[0], calories[1] < lower 而 calories[3], calories[4] > upper, 总分 = 0.
```

- 示例 2：

```python
输入：calories = [3,2], k = 2, lower = 0, upper = 1
输出：1
解释：calories[0] + calories[1] > upper, 总分 = 1.
```

## 解题思路

### 思路 1：滑动窗口

固定长度为 $k$ 的滑动窗口题目。具体做法如下：

1. $score$ 用来维护得分情况，初始值为 $0$。$window\underline{\hspace{0.5em}}sum$ 用来维护窗口中卡路里总量。
2. $left$ 、$right$ 都指向数组的第一个元素，即：`left = 0`，`right = 0`。
3. 向右移动 $right$，先将 $k$ 个元素填入窗口中。
4. 当窗口元素个数为 $k$ 时，即：$right - left + 1 \ge k$ 时，计算窗口内的卡路里总量，并判断和 $upper$、$lower$ 的关系。同时维护得分情况。
5. 然后向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $k$。
6. 重复 $4 \sim 5$ 步，直到 $right$ 到达数组末尾。

最后输出得分情况 $score$。

### 思路 1：代码

```python
class Solution:
    def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -> int:
        left, right = 0, 0
        window_sum = 0
        score = 0
        while right < len(calories):
            window_sum += calories[right]

            if right - left + 1 >= k:
                if window_sum < lower:
                    score -= 1
                elif window_sum > upper:
                    score += 1
                window_sum -= calories[left]
                left += 1

            right += 1
        return score
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $calories$ 的长度。
- **空间复杂度**：$O(1)$。

# [1184. 公交站间的距离](https://leetcode.cn/problems/distance-between-bus-stops/)

- 标签：数组
- 难度：简单

## 题目链接

- [1184. 公交站间的距离 - 力扣](https://leetcode.cn/problems/distance-between-bus-stops/)

## 题目大意

**描述**：环形公交路线上有 $n$ 个站，序号为 $0 \sim n - 1$。给定一个数组 $distance$ 表示每一对相邻公交站之间的距离，其中 $distance[i]$ 表示编号为 $i$ 的车站与编号为 $(i + 1) \mod n$ 的车站之间的距离。再给定乘客的出发点编号 $start$ 和目的地编号 $destination$。

**要求**：返回乘客从出发点 $start$ 到目的地 $destination$ 之间的最短距离。

**说明**：

- $1 \le n \le 10^4$。
- $distance.length == n$。
- $0 \le start, destination < n$。
- $0 \le distance[i] \le 10^4$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg)

```python
输入：distance = [1,2,3,4], start = 0, destination = 1
输出：1
解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg)

```python
输入：distance = [1,2,3,4], start = 0, destination = 2
输出：3
解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
```

## 解题思路

### 思路 1：简单模拟

1. 因为 $start$ 和 $destination$ 的先后顺序不影响结果，为了方便计算，我们先令 $start \le destination$。
2. 遍历数组 $distance$，计算出 $[start, destination]$ 之间的距离和 $dist$。
3. 计算出环形路线中 $[destination, start]$ 之间的距离和为 $sum(distance) - dist$。
4. 比较 $2 \sim 3$ 中两个距离的大小，将距离最小值作为答案返回。

### 思路 1：代码

```python
class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        start, destination = min(start, destination), max(start, destination)
        dist = 0
        for i in range(len(distance)):
            if start <= i < destination:
                dist += distance[i]
        
        return min(dist, sum(distance) - dist)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)

- 标签：深度优先搜索、广度优先搜索、并查集、哈希表、字符串
- 难度：中等

## 题目链接

- [1202. 交换字符串中的元素 - 力扣](https://leetcode.cn/problems/smallest-string-with-swaps/)

## 题目大意

**描述**：给定一个字符串 `s`，再给定一个数组 `pairs`，其中 `pairs[i] = [a, b]` 表示字符串的第 `a` 个字符可以跟第 `b` 个字符交换。只要满足 `pairs` 中的交换关系，可以任意多次交换字符串中的字符。

**要求**：返回 `s` 经过若干次交换之后，可以变成的字典序最小的字符串。

**说明**：

- $1 \le s.length \le 10^5$。
- $0 \le pairs.length \le 10^5$。
- $0 \le pairs[i][0], pairs[i][1] < s.length$。
- `s` 中只含有小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

- 示例 2：

```python
输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
输出："abcd"
解释：
交换 s[0] 和 s[3], s = "bcad"
交换 s[0] 和 s[2], s = "acbd"
交换 s[1] 和 s[2], s = "abcd"
```

## 解题思路

### 思路 1：并查集

如果第 `a` 个字符可以跟第 `b` 个字符交换，第 `b` 个字符可以跟第 `c` 个字符交换，那么第 `a` 个字符、第 `b` 个字符、第 `c` 个字符之间就可以相互交换。我们可以把可以相互交换的「位置」都放入一个集合中。然后对每个集合中的字符进行排序。然后将其放置回在字符串中原有位置即可。

### 思路 1：代码

```python
import collections

class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        size = len(s)
        union_find = UnionFind(size)
        for pair in pairs:
            union_find.union(pair[0], pair[1])
        mp = collections.defaultdict(list)

        for i, ch in enumerate(s):
            mp[union_find.find(i)].append(ch)

        for vec in mp.values():
            vec.sort(reverse=True)

        ans = []
        for i in range(size):
            x = union_find.find(i)
            ans.append(mp[x][-1])
            mp[x].pop()

        return "".join(ans)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log_2 n + m * \alpha(n))$。其中 $n$ 是字符串的长度，$m$ 为 $pairs$ 的索引对数量，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n)$。# [1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

- 标签：字符串、二分查找、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [1208. 尽可能使字符串相等 - 力扣](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

## 题目大意

**描述**：给定两个长度相同的字符串，$s$ 和 $t$。将 $s$ 中的第 $i$ 个字符变到 $t$ 中的第 $i$ 个字符需要 $| s[i] - t[i] |$ 的开销（开销可能为 $0$），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是 $maxCost$。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

**要求**：如果你可以将 $s$ 的子字符串转化为它在 $t$ 中对应的子字符串，则返回可以转化的最大长度。如果 $s$ 中没有子字符串可以转化成 $t$ 中对应的子字符串，则返回 $0$。

**说明**：

- $1 \le s.length, t.length \le 10^5$。
- $0 \le maxCost \le 10^6$。
- $s$ 和 $t$ 都只含小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。
```

- 示例 2：

```python
输入：s = "abcd", t = "cdef", maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
```

## 解题思路

### 思路 1：滑动窗口

维护一个滑动窗口 $window\underline{\hspace{0.5em}}sum$ 用于记录窗口内的开销总和，保证窗口内的开销总和小于等于 $maxCost$。使用 $ans$ 记录可以转化的最大长度。具体做法如下：

使用两个指针 $left$、$right$。分别指向滑动窗口的左右边界，保证窗口内所有元素转化开销总和小于等于 $maxCost$。

- 先统计出 $s$ 中第 $i$ 个字符变为 $t$ 的第 $i$ 个字符的开销，用数组 $costs$ 保存。
- 一开始，$left$、$right$ 都指向 $0$。
- 将最右侧字符的转变开销填入窗口中，向右移动 $right$。
- 直到窗口内开销总和 $window\underline{\hspace{0.5em}}sum$ 大于 $maxCost$。则不断右移 $left$，缩小窗口长度。直到 $window\underline{\hspace{0.5em}}sum \le maxCost$ 时，更新可以转换的最大长度 $ans$。
- 向右移动 $right$，直到 $right \ge len(s)$ 为止。
- 输出答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        size = len(s)
        costs = [0 for _ in range(size)]
        for i in range(size):
            costs[i] = abs(ord(s[i]) - ord(t[i]))

        left, right = 0, 0
        ans = 0
        window_sum = 0
        while right < size:
            window_sum += costs[right]
            while window_sum > maxCost:
                window_sum -= costs[left]
                left += 1
            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

# [1217. 玩筹码](https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/)

- 标签：贪心、数组、数学
- 难度：简单

## 题目链接

- [1217. 玩筹码 - 力扣](https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/)

## 题目大意

**描述**：给定一个数组 $position$ 代表 $n$ 个筹码的位置，其中 $position[i]$ 代表第 $i$ 个筹码的位置。现在需要把所有筹码移到同一个位置。在一步中，我们可以将第 $i$ 个芯片的位置从 $position[i]$ 改变为:

- $position[i] + 2$ 或 $position[i] - 2$，此时 $cost = 0$；
- $position[i] + 1$ 或 $position[i] - 1$，此时 $cost = 1$。

即移动偶数位长度的代价为 $0$，移动奇数位长度的代价为 $1$。

**要求**：返回将所有筹码移动到同一位置上所需要的 最小代价 。

**说明**：

- $1 \le chips.length \le 100$。
- $1 \le chips[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：position = [2,2,2,3,3]
输出：2
解释：我们可以把位置3的两个芯片移到位置 2。每一步的成本为 1。总成本 = 2。
```

## 解题思路

### 思路 1：贪心算法

题目中移动偶数位长度是不需要代价的，所以奇数位移动到奇数位不需要代价，偶数位移动到偶数位也不需要代价。

则我们可以想将所有偶数位都移动到下标为 $0$ 的位置，奇数位都移动到下标为 $1$ 的位置。

这样，所有的奇数位、偶数位上的人都到相同或相邻位置了。

我们只需要统计一下奇数位和偶数位的数字个数。将少的数移动到多的数上边就是最小代价。

则这道题就可以通过以下步骤求解：

- 遍历数组，统计数组中奇数个数和偶数个数。
- 返回奇数个数和偶数个数中较小的数即为答案。

### 思路 1：贪心算法代码

```python
class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        odd, even = 0, 0
        for p in position:
            if p & 1:
                odd += 1
            else:
                even += 1
        return min(odd, even)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $poition$ 的长度。
- **空间复杂度**：$O(1)$。
# [1220. 统计元音字母序列的数目](https://leetcode.cn/problems/count-vowels-permutation/)

- 标签：动态规划
- 难度：困难

## 题目链接

- [1220. 统计元音字母序列的数目 - 力扣](https://leetcode.cn/problems/count-vowels-permutation/)

## 题目大意

**描述**：给定一个整数 `n`，我们可以按照以下规则生成长度为 `n` 的字符串：

- 字符串中的每个字符都应当是小写元音字母（`'a'`、`'e'`、`'i'`、`'o'`、`'u'`）。
- 每个元音 `'a'` 后面都只能跟着 `'e'`。
- 每个元音 `'e'` 后面只能跟着 `'a'` 或者是 `'i'`。
- 每个元音 `'i'` 后面不能再跟着另一个 `'i'`。
- 每个元音 `'o'` 后面只能跟着 `'i'` 或者是 `'u'`。
- 每个元音 `'u'` 后面只能跟着 `'a'`。

**要求**：统计一下我们可以按上述规则形成多少个长度为 `n` 的字符串。由于答案可能会很大，所以请返回模 $10^9 + 7$ 之后的结果。

**说明**：

- $1 \le n \le 2 * 10^4$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：10
解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
```

## 解题思路

### 思路 1：动态规划

根据题目给定的字符串规则，我们可以将其整理一下：

- 元音字母 `'a'` 前面只能跟着 `'e'`、`'i'`、`'u'`。
- 元音字母 `'e'` 前面只能跟着 `'a'`、`'i'`。
- 元音字母 `'i'` 前面只能跟着 `'e'`、`'o'`。
- 元音字母 `'o'` 前面只能跟着 `'i'`。
- 元音字母 `'u'` 前面只能跟着 `'o'`、`'i'`。

现在我们可以按照字符串的长度以及字符结尾进行阶段划分，并按照上述规则推导状态转移方程。

###### 1. 划分阶段

按照字符串的结尾位置和结尾位置上的字符进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：长度为 `i` 并且以字符 `j` 结尾的字符串数量。这里 $j = 0, 1, 2, 3, 4$ 分别代表元音字母 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`。

###### 3. 状态转移方程

通过上面的字符规则，可以得到状态转移方程为：


$\begin{cases} dp[i][0] = dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4] \cr dp[i][1] = dp[i - 1][0] + dp[i - 1][2] \cr dp[i][2] = dp[i - 1][1] + dp[i - 1][3] \cr dp[i][3] = dp[i - 1][2] \cr dp[i][4] = dp[i - 1][2] + dp[i - 1][3] \end{cases}$

###### 4. 初始条件

- 长度为 `1` 并且以字符 `j` 结尾的字符串数量为 `1`，即 `dp[1][j] = 1`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：长度为 `i` 并且以字符 `j` 结尾的字符串数量。则将 `dp[n]` 行所有列相加，就是长度为 `n` 的字符串数量。

### 思路 1：动态规划代码

```python
class Solution:
    def countVowelPermutation(self, n: int) -> int:
        mod = 10 ** 9 + 7
        dp = [[0 for _ in range(5)] for _ in range(n + 1)]

        for j in range(5):
            dp[1][j] = 1

        for i in range(2, n + 1):
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod
            dp[i][3] = dp[i - 1][2] % mod
            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod

        ans = 0
        for j in range(5):
            ans += dp[n][j] % mod
        ans %= mod
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [1227. 飞机座位分配概率](https://leetcode.cn/problems/airplane-seat-assignment-probability/)

- 标签：脑筋急转弯、数学、动态规划、概率与统计
- 难度：中等

## 题目链接

- [1227. 飞机座位分配概率 - 力扣](https://leetcode.cn/problems/airplane-seat-assignment-probability/)

## 题目大意

**描述**：给定一个整数 $n$，代表 $n$ 位乘客即将登飞机。飞机上刚好有 $n$ 个座位。第一位乘客的票丢了，他随便选择了一个座位坐下。则剩下的乘客将会：

- 如果自己的座位还空着，就坐到自己的座位上。
- 如果自己的座位被占用了，就随机选择其他座位。

**要求**：计算出第 $n$ 位乘客坐在自己座位上的概率是多少。

**说明**：

- $1 \le n \le 10^5$。

**示例**：

- 示例 1：

```python
输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。
```

- 示例 2：

```python
输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
```

## 解题思路

### 思路 1：数学

我们按照乘客的登机顺序为乘客编下号：$1 \sim n$，我们用 $f(n)$ 来表示第 $n$ 位乘客登机时，坐在自己座位上的概率。先从简单的情况开始考虑：

当 $n = 1$ 时：

- 第 $1$ 位乘客只能坐在第 $1$ 个座位上，$f(1) = 1$。

当 $n = 2$ 时：

- 第 $1$ 位乘客有 $\frac{1}{2}$ 的概率选中自己的位置，第 $2$ 位乘客一定能坐到自己的位置上，则第 $2$ 位乘客坐在自己座位上的概率为 $\frac{1}{2} * 1.0$。
- 第 $1$ 位乘客有 $\frac{1}{2}$ 的概率坐在第 $2$ 位乘客的位置上，第 $2$ 位乘客只能坐到第 $1$ 位乘客的位置上，那么第 $2$ 位乘客坐在自己座位上的概率为 $\frac{1}{2} * 0.0$。
- 综上，$f(2) =  \frac{1}{2} * 1.0 + \frac{1}{2} * 0.0 = 0.5$。

当 $n \ge 3$ 时：

- 先来考虑第 $1$ 位乘客登机情况：

  - 第 $1$ 位乘客有 $\frac{1}{n}$ 的概率选择坐在自己位置上，这样第 $1$ 位到第 $n - 1$ 位乘客的座位都不会被占，第 n 位乘客一定能坐到自己位置上。那么第 n 位乘客坐在自己座位上的概率为 $\frac{1}{n} * 1.0$。

  - 第 $1$ 位乘客有 $\frac{1}{n}$ 的概率选择坐在第 $n$ 位乘客的位置上，这样第 $2$ 位到第 $n - 1$ 位乘客的座位都不会被占，第 $n$ 位乘客只能坐到第 $1$ 位乘客的位置上，那么第 $n$ 位乘客坐在自己座位上的概率为 $\frac{1}{n} * 0.0$。

  - 第 $1$ 位乘客有 $\frac{n-2}{n}$ 的概率坐在第 $i$ 号座位上，$2 \le i \le n - 1$，每个座位被选中概率为 $\frac{1}{n}$。这样第 $2$ 位到第 $i - 1$ 位乘客的座位都不会被占。此时第 $i$ 位乘客，会在剩下的 $n - (i - 1)$ 个座位中进行选择：

    - 坐在第 $1$ 位乘客的位置上，这样后面的乘客座位都不会被占，第 $n$ 位乘客一定能坐到自己位置上。

    - 坐在第 $n$ 个乘客的位置上，这样第 $n$ 个乘客肯定无法坐到自己的位置上。

    - 在第 $[i + 1, n - 1]$ 之间找个位置坐。

- 再来考虑第 $i$ 位乘客登机情况：
  - 第 $i$ 为乘客所面临的情况跟第 $1$ 位乘客所面临的情况类似，只不过问题的规模数从 $n$ 减小到了  $n - (i - 1)$。

那么综合上面情况，可以得到 $f(n),(n \ge 3)$ 的递推式：

$\begin{aligned} f(n) & =  \frac{1}{n} * 1.0 + \frac{1}{n} * 0.0 + \frac{1}{n} * \sum_{i = 2}^{n-1} f(n - i + 1) \cr & = \frac{1}{n} (1.0 + \sum_{i = 2}^{n-1} f(n - i + 1)) \end{aligned}$

接下来我们从等式中寻找规律，消去 $\sum_{i = 2}^{n-1} f(n - i + 1)$ 部分。

将 $n$ 换为 $n - 1$，得：

$\begin{aligned} f(n - 1) & =  \frac{1}{n - 1} * 1.0 + \frac{1}{n - 1} * 0.0 + \frac{1}{n - 1} * \sum_{i = 2}^{n-2} f(n - i) \cr & = \frac{1}{n - 1} (1.0 + \sum_{i = 2}^{n-2} f(n - i)) \end{aligned} $

将 $f(n) * n$ 与 $f(n - 1) * (n - 1)$ 进行比较：

$\begin{aligned} f(n) * n & = 1.0 + \sum_{i = 2}^{n-1} f(n - i + 1) & (1) \cr f(n - 1) * (n - 1) & = 1.0 + \sum_{i = 2}^{n-2} f(n - i) & (2) \end{aligned}$

将上述 (1)、(2) 式相减得：

$\begin{aligned} & f(n) * n - f(n - 1) * (n - 1) & \cr = & \sum_{i = 2}^{n-1} f(n - i + 1) - \sum_{i = 2}^{n-2}  f(n - i) \cr = & f(n-1) \end{aligned}$

整理后得：$f(n) = f(n - 1)$。

已知 $f(1) = 1$，$f(2) = 0.5$，因此当 $n \ge 3$ 时，$f(n) = 0.5$。

所以可以得出结论：

$f(n) = \begin{cases} 1.0 & n = 1 \cr 0.5 & n \ge 2  \end{cases}$

### 思路 1：代码

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1.0
        else:
            return 0.5
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。

## 参考资料

- [飞机座位分配概率 - 力扣（LeetCode）](https://leetcode.cn/problems/airplane-seat-assignment-probability/solution/fei-ji-zuo-wei-fen-pei-gai-lu-by-leetcod-gyw4/)

# [1229. 安排会议日程](https://leetcode.cn/problems/meeting-scheduler/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [1229. 安排会议日程 - 力扣](https://leetcode.cn/problems/meeting-scheduler/)

## 题目大意

**描述**：给定两位客户的空闲时间表：$slots1$ 和 $slots2$，再给定会议的预计持续时间 $duration$。

其中 $slots1[i] = [start_i, end_i]$ 表示空闲时间第从 $start_i$ 开始，到 $end_i$ 结束。$slots2$ 也是如此。

**要求**：为他们安排合适的会议时间，如果有合适的会议时间，则返回该时间的起止时刻。如果没有满足要求的会议时间，就请返回一个 空数组。

**说明**：

- **会议时间**：两位客户都有空参加，并且持续时间能够满足预计时间 $duration$ 的最早的时间间隔。
- 题目保证数据有效。同一个人的空闲时间不会出现交叠的情况，也就是说，对于同一个人的两个空闲时间 $[start1, end1]$ 和 $[start2, end2]$，要么 $start1 > end2$，要么 $start2 > end1$。
- $1 \le slots1.length, slots2.length \le 10^4$。
- $slots1[i].length, slots2[i].length == 2$。
- $slots1[i][0] < slots1[i][1]$。
- $slots2[i][0] < slots2[i][1]$。
- $0 \le slots1[i][j], slots2[i][j] \le 10^9$。
- $1 \le duration \le 10^6$。

**示例**：

- 示例 1：

```python
输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
输出：[60,68]
```

- 示例 2：

```python
输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12
输出：[]
```

## 解题思路

### 思路 1：分离双指针

题目保证了同一个人的空闲时间不会出现交叠。那么可以先直接对两个客户的空间时间表按照开始时间从小到大排序。然后使用分离双指针来遍历两个数组，求出重合部分，并判断重合区间是否大于等于 $duration$。具体做法如下：

1. 先对两个数组排序。
2. 然后使用两个指针 $left\underline{\hspace{0.5em}}1$、$left\underline{\hspace{0.5em}}2$。$left\underline{\hspace{0.5em}}1$ 指向第一个数组开始位置，$left\underline{\hspace{0.5em}}2$ 指向第二个数组开始位置。
3. 遍历两个数组。计算当前两个空闲时间区间的重叠范围。
   1. 如果重叠范围大于等于 $duration$，直接返回当前重叠范围开始时间和会议结束时间，即 $[start, start + duration]$，$start$ 为重叠范围开始时间。
   2. 如果第一个客户的空闲结束时间小于第二个客户的空闲结束时间，则令 $left\underline{\hspace{0.5em}}1$ 右移，即 `left_1 += 1`，继续比较重叠范围。
   3. 如果第一个客户的空闲结束时间大于等于第二个客户的空闲结束时间，则令 $left\underline{\hspace{0.5em}}2$ 右移，即 `left_2 += 1`，继续比较重叠范围。
4. 直到 $left\underline{\hspace{0.5em}}1 == len(slots1)$ 或者 $left\underline{\hspace{0.5em}}2 == len(slots2)$ 时跳出循环，返回空数组 $[]$。

### 思路 1：代码

```python
class Solution:
    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:
        slots1.sort()
        slots2.sort()
        size1 = len(slots1)
        size2 = len(slots2)
        left_1, left_2 = 0, 0
        while left_1 < size1 and left_2 < size2:
            start_1, end_1 = slots1[left_1]
            start_2, end_2 = slots2[left_2]
            start = max(start_1, start_2)
            end = min(end_1, end_2)
            if end - start >= duration:
                return [start, start + duration]
            if end_1 < end_2:
                left_1 += 1
            else:
                left_2 += 1
        return []
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n + m \times \log m)$，其中 $n$、$m$ 分别为数组 $slots1$、$slots2$  中的元素个数。
- **空间复杂度**：$O(\log n + \log m)$。

# [1232. 缀点成线](https://leetcode.cn/problems/check-if-it-is-a-straight-line/)

- 标签：几何、数组、数学
- 难度：简单

## 题目链接

- [1232. 缀点成线 - 力扣](https://leetcode.cn/problems/check-if-it-is-a-straight-line/)

## 题目大意

给定一系列的二维坐标点的坐标 `(xi, yi)`，判断这些点是否属于同一条直线。若属于同一条直线，则返回 True，否则返回 False。

## 解题思路

如果根据斜率来判断点是否处于同一条直线，需要处理斜率不存在（无穷大）的情况。我们可以使用叉乘来判断三个点构成的两个向量是否处于同一条直线上。

叉乘原理：

设向量 P 为 `(x1, y1)` 向量，Q 为 `(x2, y2)`，则向量 P、Q 的叉积定义为：$P × Q = x_1y_2 - x_2y_1$，其几何意义表示为如果以向量 P 和向量 Q 为边构成一个平行四边形，那么这两个向量叉乘的模长与这个平行四边形的正面积相等。

![向量叉积](https://img.geek-docs.com/mathematical-basis/linear-algebra/220px-Cross_product_parallelogram.png)

- 如果 `P × Q = 0`，则 P 与 Q 共线，有可能同向，也有可能反向。
- 如果 `P × Q > 0`，则 P 在 Q 的顺时针方向。
- 如果 `P × Q < 0`，则 P 在 Q 的逆时针方向。

具体求解方法：

- 先求出第一个坐标与第二个坐标构成的向量 P。
- 遍历所有坐标，求出所有坐标与第一个坐标构成的向量 Q。
  - 如果 `P × Q ≠ 0`，则返回 False。
- 如果遍历完仍没有发现 `P × Q ≠ 0`，则返回 True。

## 代码

```python
class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x1 = coordinates[1][0] - coordinates[0][0]
        y1 = coordinates[1][1] - coordinates[0][1]

        for i in range(len(coordinates)):
            x2 = coordinates[i][0] - coordinates[0][0]
            y2 = coordinates[i][1] - coordinates[0][1]
            if x1 * y2 != x2 * y1:
                return False
        return True
```

# [1245. 树的直径](https://leetcode.cn/problems/tree-diameter/)

- 标签：树、深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [1245. 树的直径 - 力扣](https://leetcode.cn/problems/tree-diameter/)

## 题目大意

**描述**：给定一个数组 $edges$，用来表示一棵无向树。其中 $edges[i] = [u, v]$ 表示节点 $u$ 和节点 $v$ 之间的双向边。书上的节点编号为 $0 \sim edges.length$，共 $edges.length + 1$ 个节点。

**要求**：求出这棵无向树的直径。

**说明**：

- $0 \le edges.length < 10^4$。
- $edges[i][0] \ne edges[i][1]$。
- $0 \le edges[i][j] \le edges.length$。
- $edges$ 会形成一棵无向树。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/31/1397_example_1.png)

```python
输入：edges = [[0,1],[0,2]]
输出：2
解释：
这棵树上最长的路径是 1 - 0 - 2，边数为 2。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/31/1397_example_2.png)

```python
输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
输出：4
解释： 
这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

对于根节点为 $u$ 的树来说：

1. 如果其最长路径经过根节点 $u$，则：**最长路径长度 = 某子树中的最长路径长度 + 另一子树中的最长路径长度 + 1**。
2. 如果其最长路径不经过根节点 $u$，则：**最长路径长度 = 某个子树中的最长路径长度**。

即：**最长路径长度 = max(某子树中的最长路径长度 + 另一子树中的最长路径长度 + 1，某个子树中的最长路径长度)**。

对此，我们可以使用深度优先搜索递归遍历 $u$ 的所有相邻节点 $v$，并在递归遍历的同时，维护一个全局最大路径和变量 $ans$，以及当前节点 $u$ 的最大路径长度变量 $u\underline{\hspace{0.5em}}len$。

1. 先计算出从相邻节点 $v$ 出发的最长路径长度 $v\underline{\hspace{0.5em}}len$。
2. 更新维护全局最长路径长度为 $self.ans = max(self.ans, \quad u\underline{\hspace{0.5em}}len + v\underline{\hspace{0.5em}}len + 1)$。
3. 更新维护当前节点 $u$ 的最长路径长度为 $u\underline{\hspace{0.5em}}len = max(u\underline{\hspace{0.5em}}len, \quad v\underline{\hspace{0.5em}}len + 1)$。

> 注意：在遍历邻接节点的过程中，为了避免造成重复遍历，我们在使用深度优先搜索时，应过滤掉父节点。

### 思路 1：代码

```python
class Solution:
    def __init__(self):
        self.ans = 0

    def dfs(self, graph, u, fa):
        u_len = 0
        for v in graph[u]:
            if v != fa:
                v_len = self.dfs(graph, v, u)
                self.ans = max(self.ans, u_len + v_len + 1)
                u_len = max(u_len, v_len + 1)
        return u_len

    def treeDiameter(self, edges: List[List[int]]) -> int:
        size = len(edges) + 1

        graph = [[] for _ in range(size)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        self.dfs(graph, 0, -1)
        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为无向树中的节点个数。
- **空间复杂度**：$O(n)$。

# [1247. 交换字符使得字符串相同](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/)

- 标签：贪心、数学、字符串
- 难度：中等

## 题目链接

- [1247. 交换字符使得字符串相同 - 力扣](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/)

## 题目大意

**描述**：给定两个长度相同的字符串 $s1$ 和 $s2$，并且两个字符串中只含有字符 `'x'` 和 `'y'`。现在需要通过「交换字符」的方式使两个字符串相同。

- 每次「交换字符」，需要分别从两个字符串中各选一个字符进行交换。
- 「交换字符」只能发生在两个不同的字符串之间，不能发生在同一个字符串内部。

**要求**：返回使 $s1$ 和 $s2$ 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 $-1$。

**说明**：

- $1 \le s1.length, s2.length \le 1000$。
- $s1$、$ s2$ 只包含 `'x'` 或 `'y'`。

**示例**：

- 示例 1：

```python
输入：s1 = "xy", s2 = "yx"
输出：2
解释：
交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。
交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。
```

## 解题思路

### 思路 1：贪心算法

- 如果 $s1 == s2$，则不需要交换。
- 如果 `s1 = "xx"`，`s2 = "yy"`，则最少需要交换一次，才可以使两个字符串相等。
- 如果 `s1 = "yy"`，`s2 = "xx"`，则最少需要交换一次，才可以使两个字符串相等。
- 如果 `s1 = "xy"`，`s2 = "yx"`，则最少需要交换两次，才可以使两个字符串相等。
- 如果 `s1 = "yx"`，`s2 = "xy"`，则最少需要交换两次，才可以使两个字符串相等。

则可以总结为：

- `"xx"` 与 `"yy"`、`"yy"` 与 `"xx"` 只需要交换一次。
- `"xy"` 与 `"yx"`、`"yx"` 与 `"xy"` 需要交换两次。

我们把这两种情况分别进行统计。

- 当遇到 $s1[i] == s2[i]$ 时直接跳过。
- 当遇到 `s1[i] == 'x'`，`s2[i] == 'y'` 时，则统计数量到变量 $xyCnt$ 中。
- 当遇到 `s1[i] == 'y'`，`s2[i] == 'y'` 时，则统计数量到变量 $yxCnt$ 中。

则最后我们只需要判断 $xyCnt$ 和 $yxCnt$ 的个数即可。

- 如果 $xyCnt + yxCnt$ 是奇数，则说明最终会有一个位置上的两个字符无法通过交换相匹配。
- 如果 $xyCnt + yxCnt$ 是偶数，并且 $xyCnt$ 为偶数，则 $yxCnt$ 也为偶数。则优先交换 `"xx"` 与 `"yy"`、`"yy"` 与 `"xx"`。即每两个 $xyCnt$ 对应一次交换，每两个 $yxCnt$ 对应交换一次，则结果为 $xyCnt \div 2 + yxCnt \div 2$。
- 如果 $xyCnt + yxCnt$ 是偶数，并且 $xyCnt$ 为奇数，则 $yxCnt$ 也为奇数。则优先交换 `"xx"` 与 `"yy"`、`"yy"` 与 `"xx"`。即每两个 $xyCnt$ 对应一次交换，每两个 $yxCnt$ 对应交换一次，则结果为 $xyCnt \div 2 + yxCnt \div 2$。最后还剩一组 `"xy"` 与 `"yx"` 或者 `"yx"` 与 `"xy"`，则再交换一次，则结果为 $xyCnt \div 2 + yxCnt \div 2 + 2$。

以上结果可以统一写成 $xyCnt \div 2 + yxCnt \div 2 + xyCnt \mod 2 \times 2$。

### 思路 1：贪心算法代码

```python
class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        xyCnt, yxCnt = 0, 0
        for i in range(len(s1)):
            if s1[i] == s2[i]:
                continue
            if s1[i] == 'x':
                xyCnt += 1
            else:
                yxCnt += 1

        if (xyCnt + yxCnt) & 1:
            return -1
        return xyCnt // 2 + yxCnt // 2 + (xyCnt % 2 * 2)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串的长度。
- **空间复杂度**：$O(1)$。
# [1253. 重构 2 行二进制矩阵](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/)

- 标签：贪心、数组、矩阵
- 难度：中等

## 题目链接

- [1253. 重构 2 行二进制矩阵 - 力扣](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/)

## 题目大意

**描述**：给定一个 $2$ 行 $n$ 列的二进制数组：

- 矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 $0$ 就是 $1$。
- 第 $0$ 行的元素之和为 $upper$。
- 第 $1$ 行的元素之和为 $lowe$r。
- 第 $i$ 列（从 $0$ 开始编号）的元素之和为 $colsum[i]$，$colsum$ 是一个长度为 $n$ 的整数数组。

**要求**：你需要利用 $upper$，$lower$ 和 $colsum$ 来重构这个矩阵，并以二维整数数组的形式返回它。

**说明**：

- 如果有多个不同的答案，那么任意一个都可以通过本题。
- 如果不存在符合要求的答案，就请返回一个空的二维数组。
- $1 \le colsum.length \le 10^5$。
- $0 \le upper, lower \le colsum.length$。
- $0 \le colsum[i] \le 2$。

**示例**：

- 示例 1：

```python
输入：upper = 2, lower = 1, colsum = [1,1,1]
输出：[[1,1,0],[0,0,1]]
解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。
```

- 示例 2：

```python
输入：upper = 2, lower = 3, colsum = [2,2,1,1]
输出：[]
```

## 解题思路

### 思路 1：贪心算法

1. 先构建一个 $2 \times n$ 的答案数组 $ans$，其中 $ans[0]$ 表示矩阵的第 $0$ 行，$ans[1]$ 表示矩阵的第 $1$​ 行。
2. 遍历数组 $colsum$，对于当前列的和 $colsum[i]$ 来说：
   1. 如果 $colsum[i] == 2$，则需要将 $ans[0][i]$ 和 $ans[1][i]$ 都置为 $1$，此时 $upper$ 和 $lower$ 各自减去 $1$。
   2. 如果 $colsum[i] == 1$，则需要将 $ans[0][i]$ 置为 $1$ 或将 $ans[1][i]$ 置为 $1$。我们优先使用元素和多的那一项。
      1. 如果 $upper > lower$，则优先使用 $upper$，将 $ans[0][i]$ 置为 $1$，并且令 $upper$ 减去 $1$。
      2. 如果 $upper \le lower$，则优先使用 $lower$，将 $ans[1][i]$ 置为 $1$，并且令 $lower$ 减去 $1$。
   3. 如果 $colsum[i] == 0$，则需要将 $ans[0][i]$ 和 $ans[1][i]$ 都置为 $0$。
3. 在遍历过程中，如果出现 $upper < 0$ 或者 $lower < 0$，则说明无法构造出满足要求的矩阵，则直接返回空数组。
4. 遍历结束后，如果 $upper$ 和 $lower$ 都为 $0$，则返回答案数组 $ans$；否则返回空数组。

### 思路 1：代码

```Python
class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        size = len(colsum)
        ans = [[0 for _ in range(size)] for _ in range(2)]

        for i in range(size):
            if colsum[i] == 2:
                ans[0][i] = ans[1][i] = 1
                upper -= 1
                lower -= 1
            elif colsum[i] == 1:
                if upper > lower:
                    ans[0][i] = 1
                    upper -= 1
                else:
                    ans[1][i] = 1
                    lower -= 1
            if upper < 0 or lower < 0:
                return []
        if lower != 0 or upper != 0:
            return []
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [1254. 统计封闭岛屿的数目 - 力扣](https://leetcode.cn/problems/number-of-closed-islands/)

## 题目大意

**描述**：给定一个二维矩阵 `grid`，每个位置要么是陆地（记号为 `0`）要么是水域（记号为 `1`）。

我们从一块陆地出发，每次可以往上下左右 `4` 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为「封闭岛屿」。

**要求**：返回封闭岛屿的数目。

**说明**：

- $1 \le grid.length, grid[0].length \le 100$。
- $0 \le grid[i][j] \le 1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png)

```python
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png)

```python
输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
```

## 解题思路

### 思路 1：深度优先搜索

1. 从 `grid[i][j] == 0` 的位置出发，使用深度优先搜索的方法遍历上下左右四个方向上相邻区域情况。
   1. 如果上下左右都是 `grid[i][j] == 1`，则返回 `True`。
   2. 如果有一个以上方向的 `grid[i][j] == 0`，则返回 `False`。
   3. 遍历之后将当前陆地位置置为 `1`，表示该位置已经遍历过了。
2. 最后统计出上下左右都满足 `grid[i][j] == 1` 的情况数量，即为答案。

### 思路 1：代码

```python
class Solution:
    directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def dfs(self, grid, i, j):
        n, m = len(grid), len(grid[0])
        if i < 0 or i >= n or j < 0 or j >= m:
            return False
        if grid[i][j] == 1:
            return True
        grid[i][j] = 1

        res = True
        for direct in self.directs:
            new_i = i + direct[0]
            new_j = j + direct[1]
            if not self.dfs(grid, new_i, new_j):
                res = False
        return res

    def closedIsland(self, grid: List[List[int]]) -> int:
        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0 and self.dfs(grid, i, j):
                    res += 1

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 和 $n$ 分别为行数和列数。
- **空间复杂度**：$O(m \times n)$。# [1261. 在受污染的二叉树中查找元素](https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/)

- 标签：树、深度优先搜索、广度优先搜索、设计、哈希表、二叉树
- 难度：中等

## 题目链接

- [1261. 在受污染的二叉树中查找元素 - 力扣](https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/)

## 题目大意

**描述**：给出一满足下属规则的二叉树的根节点 $root$：

1. $root.val == 0$。
2. 如果 $node.val == x$ 且 $node.left \ne None$，那么 $node.left.val == 2 \times x + 1$。
3. 如果 $node.val == x$ 且 $node.right \ne None$，那么 $node.left.val == 2 \times x + 2$​。

现在这个二叉树受到「污染」，所有的 $node.val$ 都变成了 $-1$。

**要求**：请你先还原二叉树，然后实现 `FindElements` 类：

- `FindElements(TreeNode* root)` 用受污染的二叉树初始化对象，你需要先把它还原。
- `bool find(int target)` 判断目标值 $target$ 是否存在于还原后的二叉树中并返回结果。

**说明**：

- $node.val == -1$
- 二叉树的高度不超过 $20$。
- 节点的总数在 $[1, 10^4]$ 之间。
- 调用 `find()` 的总次数在 $[1, 10^4]$ 之间。
- $0 \le target \le 10^6$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1.jpg)

```python
输入：
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
输出：
[null,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4.jpg)

```python
输入：
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：
[null,true,true,false]
解释：
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
```

## 解题思路

### 思路 1：哈希表 + 深度优先搜索

1. 从根节点开始进行还原。
2. 然后使用深度优先搜索的方式，依次递归还原左右两个孩子节点。
3. 递归还原的同时，将还原之后的所有节点值，存入集合 $val\underline{\hspace{0.5em}}set$ 中。

这样就可以在 $O(1)$ 的时间复杂度内判断目标值 $target$ 是否在还原后的二叉树中了。

### 思路 1：代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class FindElements:

    def __init__(self, root: Optional[TreeNode]):
        self.val_set = set()
        def dfs(node, val):
            if not node:
                return
            self.val_set.add(val)
            dfs(node.left, val * 2 + 1)
            dfs(node.right, val * 2 + 2)
        
        dfs(root, 0)


    def find(self, target: int) -> bool:
        return target in self.val_set



# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)
```

### 思路 1：复杂度分析

- **时间复杂度**：还原二叉树：$O(n)$，其中 $n$ 为二叉树中的节点个数。查找目标值：$O(1)$。
- **空间复杂度**：$O(n)$。

# [1266. 访问所有点的最小时间](https://leetcode.cn/problems/minimum-time-visiting-all-points/)

- 标签：几何、数组、数学
- 难度：简单

## 题目链接

- [1266. 访问所有点的最小时间 - 力扣](https://leetcode.cn/problems/minimum-time-visiting-all-points/)

## 题目大意

**描述**：给定 $n$ 个点的整数坐标数组 $points$。其中 $points[i] = [xi, yi]$，表示第 $i$ 个点坐标为 $(xi, yi)$。可以按照以下规则在平面上移动：

1. 每一秒内，可以：
   1. 沿着水平方向移动一个单位长度。
   2. 沿着竖直方向移动一个单位长度。
   3. 沿着对角线移动 $\sqrt 2$ 个单位长度（可看做在一秒内沿着水平方向和竖直方向各移动一个单位长度）。
2. 必须按照坐标数组 $points$ 中的顺序来访问这些点。
3. 在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。

**要求**：计算出访问这些点需要的最小时间（以秒为单位）。

**说明**：

- $points.length == n$。
- $1 \le n \le 100$。
- $points[i].length == 2$。
- $-1000 \le points[i][0], points[i][1] \le 1000$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png)

```python
输入：points = [[1,1],[3,4],[-1,0]]
输出：7
解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
从 [1,1] 到 [3,4] 需要 3 秒 
从 [3,4] 到 [-1,0] 需要 4 秒
一共需要 7 秒
```

```python
输入：points = [[3,2],[-2,2]]
输出：5
```

## 解题思路

### 思路 1：数学

根据题意，每一秒可以沿着水平方向移动一个单位长度、或者沿着竖直方向移动一个单位长度、或者沿着对角线移动 $\sqrt 2$ 个单位长度。而沿着对角线移动 $\sqrt 2$ 个单位长度可以看做是先沿着水平方向移动一个单位长度，又沿着竖直方向移动一个单位长度，算是一秒走了两步距离。

现在假设从 A 点（坐标为 $(x1, y1)$）移动到 B 点（坐标为 $(x2, y2)$）。

那么从 A 点移动到 B 点如果要想得到最小时间，我们应该计算出沿着水平方向走的距离为 $dx = |x2 - x1|$，沿着竖直方向走的距离为 $dy = |y2 - y1|$。

然后比较沿着水平方向的移动距离和沿着竖直方向的移动距离。

- 如果 $dx > dy$，则我们可以先沿着对角线移动 $dy$ 次，再水平移动 $dx - dy$ 次，总共 $dx$ 次。
- 如果 $dx == dy$，则我们可以直接沿着对角线移动 $dx$ 次，总共 $dx$ 次。
- 如果 $dx < dy$，则我们可以先沿着对角线移动 $dx$ 次，再水平移动 $dy - dx$ 次，，总共 $dy$ 次。

根据上面观察可以发现：最小时间取决于「走的步数较多的那个方向所走的步数」，即 $max(dx, dy)$。

根据题目要求，需要按照坐标数组 $points$ 中的顺序来访问这些点，则我们需要按顺序遍历整个数组，计算出相邻点之间的 $max(dx, dy)$，将其累加到答案中。

最后将答案输出即可。

### 思路 1：代码

```python
class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
        ans = 0
        x1, y1 = points[0]
        for point in points:
            x2, y2 = point
            ans += max(abs(x2 - x1), abs(y2 - y1))
            x1, y1 = point
        
        return ans    
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [1268. 搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

- 标签：字典树、数组、字符串
- 难度：中等

## 题目链接

- [1268. 搜索推荐系统 - 力扣](https://leetcode.cn/problems/search-suggestions-system/)

## 题目大意

给定一个产品数组 `products` 和一个字符串 `searchWord` ，`products`  数组中每个产品都是一个字符串。

要求：设计一个推荐系统，在依次输入单词 `searchWord` 的每一个字母后，推荐 `products` 数组中前缀与 `searchWord` 相同的最多三个产品（如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个）。

- 请你以二维列表的形式，返回在输入 `searchWord` 每个字母后相应的推荐产品的列表。

## 解题思路

先将产品数组按字典序排序。

然后使用字典树结构存储每个产品，并在字典树中维护一个数组，用于表示当前前缀所对应的产品列表（只保存最多 3 个产品）。

在查询的时候，将不同前缀所对应的产品列表加入到答案数组中。

最后输出答案数组。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.words = list()


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
            if len(cur.words) < 3:
                cur.words.append(word)
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = []
        flag = False
        for ch in word:
            if flag or ch not in cur.children:
                res.append([])
                flag = True
            else:
                cur = cur.children[ch]
                res.append(cur.words)

        return res

class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()
        trie_tree = Trie()
        for product in products:
            trie_tree.insert(product)

        return trie_tree.search(searchWord)
```

# [1281. 整数的各位积和之差](https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/)

- 标签：数学
- 难度：简单

## 题目链接

- [1281. 整数的各位积和之差 - 力扣](https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/)

## 题目大意

**描述**：给定一个整数 `n`。

**要求**：计算并返回该整数「各位数字之积」与「各位数字之和」的差。

**说明**：

- $1 <= n <= 10^5$。

**示例**：

- 示例 1：

```python
输入：n = 234
输出：15

解释：
各位数之积 2 * 3 * 4 = 24 
各位数之和 2 + 3 + 4 = 9 
结果 24 - 9 = 15
```

## 解题思路

### 思路 1：数学

- 通过取模运算得到 `n` 的最后一位，即 `n %= 10`。
- 然后去除  `n`  的最后一位，及`n //= 10`。
- 一次求出各位数字之积与各位数字之和，并返回其差值。

### 思路 1：数学代码

```python
class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        product = 1
        total = 0
        while n:
            digit = n % 10
            product *= digit
            total += digit
            n //= 10
        return product - total
```

# [1296. 划分数组为连续数字的集合](https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/)

- 标签：贪心、数组、哈希表、排序
- 难度：中等

## 题目链接

- [1296. 划分数组为连续数字的集合 - 力扣](https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/)

## 题目大意

**描述**：给定一个整数数组 `nums` 和一个正整数 `k`。

**要求**：判断是否可以把这个数组划分成一些由 `k` 个连续数字组成的集合。如果可以，则返回 `True`；否则，返回 `False`。

**说明**：

- $1 \le k \le nums.length \le 10^5$。
- $1 \le nums[i] \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,3,4,4,5,6], k = 4
输出：True
解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。
```

## 解题思路

### 思路 1：哈希表 + 排序

1. 使用哈希表存储每个数出现的次数。
2. 将哈希表中每个键从小到大排序。
3. 从哈希表中最小的数开始，以它作为当前连续数字的开头，然后依次判断连续的 `k` 个数是否在哈希表中，如果在的话，则将哈希表中对应数的数量减 `1`。不在的话，说明无法满足题目要求，直接返回 `False`。
4. 重复执行 2 ~ 3 步，直到哈希表为空。最后返回 `True`。

### 思路 1：哈希表 + 排序代码

```python
class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        hand_map = collections.defaultdict(int)
        for i in range(len(nums)):
            hand_map[nums[i]] += 1
        for key in sorted(hand_map.keys()):
            value = hand_map[key]
            if value == 0:
                continue
            count = 0
            for i in range(k):
                hand_map[key + count] -= value
                if hand_map[key + count] < 0:
                    return False
                count += 1
        return True
```
# [1300. 转变数组后最接近目标值的数组和](https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/)

- 标签：数组、二分查找、排序
- 难度：中等

## 题目链接

- [1300. 转变数组后最接近目标值的数组和 - 力扣](https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/)

## 题目大意

**描述**：给定一个整数数组 $arr$ 和一个目标值 $target$。

**要求**：返回一个整数 $value$，使得将数组中所有大于 $value$ 的值变成 $value$ 后，数组的和最接近 $target$（最接近表示两者之差的绝对值最小）。如果有多种使得和最接近 $target$ 的方案，请你返回这些整数中的最小值。

**说明**：

- 答案 $value$ 不一定是 $arr$ 中的数字。
- $1 \le arr.length \le 10^4$。
- $1 \le arr[i], target \le 10^5$。

**示例**：

- 示例 1：

```python
输入：arr = [4,9,3], target = 10
输出：3
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。
```

- 示例 2：

```python
输入：arr = [60864,25176,27249,21296,20204], target = 56803
输出：11361
```

## 解题思路

### 思路 1：二分查找

题目可以理解为：在 $[0, max(arr)]$ 的区间中，查找一个值 $value$。使得「转变后的数组和」与 $target$ 最接近。

- 转变规则：将数组中大于 $value$ 的值变为 $value$。

在 $[0, max(arr)]$ 的区间中，查找一个值 $value$ 可以使用二分查找答案的方式减少时间复杂度。但是这个最接近 $target$ 应该怎么理解，或者说怎么衡量接近程度。

最接近 $target$ 的肯定是数组和等于 $target$ 的时候。不过更可能是出现数组和恰好比 $target$ 大一点，或数组和恰好比 $target$ 小一点。我们可以将 $target$ 上下两个值相对应的数组和与 $target$ 进行比较，输出差值更小的那一个 $value$。

在根据查找的值 $value$ 计算数组和时，也可以通过二分查找方法查找出数组刚好大于等于 $value$ 元素下标。还可以根据事先处理过的前缀和数组，快速得到转变后的数组和。

最后输出使得数组和与 $target$ 差值更小的 $value$。

整个算法步骤如下：

- 先对数组排序，并计算数组的前缀和 $pre\underline{\hspace{0.5em}}sum$。
- 通过二分查找在 $[0, arr[-1]]$ 中查找使得转变后数组和刚好大于等于 $target$ 的值 $value$。
- 计算 $value$ 对应的数组和 $sum\underline{\hspace{0.5em}}1$，以及 $value - 1$ 对应的数组和 $sum\underline{\hspace{0.5em}}2$。并分别计算与 $target$ 的差值 $diff\underline{\hspace{0.5em}}1$、$diff\underline{\hspace{0.5em}}2$。
- 输出差值小的那个值。

### 思路 1：代码

```python
class Solution:
    # 计算 value 对应的转变后的数组
    def calc_sum(self, arr, value, pre_sum):
        size = len(arr)
        left, right = 0, size - 1
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < value:
                left = mid + 1
            else:
                right = mid

        return pre_sum[left] + (size - left) * value

    # 查找使得转变后的数组和刚好大于等于 target 的 value
    def binarySearchValue(self, arr, target, pre_sum):
        left, right = 0, arr[-1]
        while left < right:
            mid = left + (right - left) // 2
            if self.calc_sum(arr, mid, pre_sum) < target:
                left = mid + 1
            else:
                right = mid
        return left

    def findBestValue(self, arr: List[int], target: int) -> int:
        size = len(arr)
        arr.sort()
        pre_sum = [0 for _ in range(size + 1)]

        for i in range(size):
            pre_sum[i + 1] = pre_sum[i] + arr[i]

        value = self.binarySearchValue(arr, target, pre_sum)

        sum_1 = self.calc_sum(arr, value, pre_sum)
        sum_2 = self.calc_sum(arr, value - 1, pre_sum)
        diff_1 = abs(sum_1 - target)
        diff_2 = abs(sum_2 - target)

        return value if diff_1 < diff_2 else value - 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O((n + k) \times \log n)$。其中 $n$ 是数组 $arr$ 的长度，$k$ 是数组 $arr$ 中的最大值。
- **空间复杂度**：$O(n)$。

# [1305. 两棵二叉搜索树中的所有元素](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树、排序
- 难度：中等

## 题目链接

- [1305. 两棵二叉搜索树中的所有元素 - 力扣](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)

## 题目大意

**描述**：给定两棵二叉搜索树的根节点 $root1$ 和 $root2$。

**要求**：返回一个列表，其中包含两棵树中所有整数并按升序排序。

**说明**：

- 每棵树的节点数在 $[0, 5000]$ 范围内。
- $-10^5 \le Node.val \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png)

```python
输入：root1 = [2,1,4], root2 = [1,0,3]
输出：[0,1,1,2,3,4]
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png)

```python
输入：root1 = [1,null,8], root2 = [8,1]
输出：[1,1,8,8]
```

## 解题思路

### 思路 1：二叉树的中序遍历 + 快慢指针

根据二叉搜索树的特性，如果我们以中序遍历的方式遍历整个二叉搜索树时，就会得到一个有序递增列表。我们按照这样的方式分别对两个二叉搜索树进行中序遍历，就得到了两个有序数组，那么问题就变成了：两个有序数组的合并问题。

两个有序数组的合并可以参考归并排序中的归并过程，使用快慢指针将两个有序数组合并为一个有序数组。

具体步骤如下：

1. 分别使用中序遍历的方式遍历两个二叉搜索树，得到两个有序数组 $nums1$、$nums2$。
2. 使用两个指针 $index1$、$index2$ 分别指向两个有序数组的开始位置。
3. 比较两个指针指向的元素，将两个有序数组中较小元素依次存入结果数组 $nums$ 中，并将指针移动到下一个位置。
4. 重复步骤 $3$，直到某一指针到达数组末尾。
5. 将另一个数组中的剩余元素依次存入结果数组 $nums$ 中。
6. 返回结果数组 $nums$。

### 思路 1：代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)

        inorder(root)
        return res
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        nums1 = self.inorderTraversal(root1)
        nums2 = self.inorderTraversal(root2)
        nums = []
        index1, index2 = 0, 0
        while index1 < len(nums1) and index2 < len(nums2):
            if nums1[index1] < nums2[index2]:
                nums.append(nums1[index1])
                index1 += 1
            else:
                nums.append(nums2[index2])
                index2 += 1
        
        while index1 < len(nums1):
            nums.append(nums1[index1])
            index1 += 1
    
        while index2 < len(nums2):
            nums.append(nums2[index2])
            index2 += 1
        
        return nums
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m)$，其中 $n$ 和 $m$ 分别为两棵二叉搜索树的节点个数。
- **空间复杂度**：$O(n + m)$。
# [1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/)

- 标签：位运算、数组、前缀和
- 难度：中等

## 题目链接

- [1310. 子数组异或查询 - 力扣](https://leetcode.cn/problems/xor-queries-of-a-subarray/)

## 题目大意

**描述**：给定一个正整数数组 `arr`，再给定一个对应的查询数组 `queries`，其中 `queries[i] = [Li, Ri]`。

**要求**：对于每个查询 `queries[i]`，要求计算从 `Li` 到 `Ri` 的异或值（即 `arr[Li] ^ arr[Li+1] ^ ... ^ arr[Ri]`）作为本次查询的结果。并返回一个包含给定查询 `queries` 所有结果的数组。

**说明**：

- $1 \le arr.length \le 3 * 10^4$。
- $1 \le arr[i] \le 10^9$。
- $1 \le queries.length \le 3 * 10^4$。
- $queries[i].length == 2$。
- $0 \le queries[i][0] \le queries[i][1] < arr.length$。

**示例**：

- 示例 1：

```python
输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8] 
解释

数组中元素的二进制表示形式是：
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 

查询的 XOR 值为：
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
```

## 解题思路

### 思路 1：线段树

- 使用数组 `res` 作为答案数组，用于存放每个查询的结果值。
- 根据 `nums` 数组构建一棵线段树。
- 然后遍历查询数组 `queries`。对于每个查询 `queries[i]`，在线段树中查询对应区间的异或值，将其结果存入答案数组 `res` 中。
- 返回答案数组 `res` 即可。

这样构建线段树的时间复杂度为 $O(\log n)$，单次区间查询的时间复杂度为 $O(\log n)$。总体时间复杂度为 $O(k * \log n)$，其中 $k$ 是查询次数。

### 思路 1：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = None                        # 区间和问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
    
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间更新接口：将区间为 [q_left, q_right] 上的所有元素值加上 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
        
        
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)


class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
        self.STree = SegmentTree(arr, lambda x, y: (x ^ y))
        res = []
        for query in queries:
            ans = self.STree.query_interval(query[0], query[1])
            res.append(ans)
        return res
```
# [1313. 解压缩编码列表](https://leetcode.cn/problems/decompress-run-length-encoded-list/)

- 标签：数组
- 难度：简单

## 题目链接

- [1313. 解压缩编码列表 - 力扣](https://leetcode.cn/problems/decompress-run-length-encoded-list/)

## 题目大意

**描述**：给定一个以行程长度编码压缩的整数列表 $nums$。

考虑每对相邻的两个元素 $[freq, val] = [nums[2 \times i], nums[2 \times i + 1]]$ （其中 $i \ge 0$ ），每一对都表示解压后子列表中有 $freq$ 个值为 $val$ 的元素，你需要从左到右连接所有子列表以生成解压后的列表。

**要求**：返回解压后的列表。

**说明**：

- $2 \le nums.length \le 100$。
- $nums.length \mod 2 == 0$。
- $1 \le nums[i] \le 100$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。
```

- 示例 2：

```python
输入：nums = [1,1,2,3]
输出：[1,3,3]
```

## 解题思路

### 思路 1：模拟

1. 以步长为 $2$，遍历数组 $nums$。
2. 对于遍历到的元素 $nums[i]$、$nnums[i + 1]$，将 $nums[i]$ 个 $nums[i + 1]$ 存入答案数组中。
3. 返回答案数组。

### 思路 1：代码

```Python
class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(0, len(nums), 2):
            cnts = nums[i]
            for cnt in range(cnts):
                res.append(nums[i + 1])
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + s)$，其中 $n$ 为数组 $nums$ 的长度，$s$ 是数组 $nums$  中所有偶数下标对应元素之和。
- **空间复杂度**：$O(s)$。

# [1317. 将整数转换为两个无零整数的和](https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/)

- 标签：数学
- 难度：简单

## 题目链接

- [1317. 将整数转换为两个无零整数的和 - 力扣](https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回一个由两个整数组成的列表 $[A, B]$，满足：

- $A$ 和 $B$ 都是无零整数。
- $A + B = n$。

**说明**：

- **无零整数**：十进制表示中不含任何 $0$ 的正整数。
- 题目数据保证至少一个有效的解决方案。
- 如果存在多个有效解决方案，可以返回其中任意一个。
- $2 \le n \le 10^4$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：[1,1]
解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0。
```

- 示例 2：

```python
输入：n = 11
输出：[2,9]
```

## 解题思路

### 思路 1：枚举

1. 由于给定的 $n$ 范围为 $[1, 10000]$，比较小，我们可以直接在 $[1, n)$ 的范围内枚举 $A$，并通过 $n - A$ 得到 $B$。
2. 在判断 $A$ 和 $B$ 中是否都不包含 $0$。如果都不包含 $0$，则返回 $[A, B]$。

### 思路 1：代码

```python
class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        for A in range(1, n):
            B = n - A
            if '0' not in str(A) and '0' not in str(B):
                return [A, B]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

# [1319. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [1319. 连通网络的操作次数 - 力扣](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)

## 题目大意

**描述**：$n$ 台计算机通过网线连接成一个网络，计算机的编号从 $0$ 到 $n - 1$。线缆用 $comnnections$ 表示，其中 $connections[i] = [a, b]$ 表示连接了计算机 $a$ 和 $b$。

给定这个计算机网络的初始布线 $connections$，可以拔除任意两台直接相连的计算机之间的网线，并用这根网线连接任意一对未直接连接的计算机。

**要求**：计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 $-1$。

**说明**：

- $1 \le n \le 10^5$。
- $1 \le connections.length \le min( \frac{n \times (n-1)}{2}, 10^5)$。
- $connections[i].length == 2$。
- $0 \le connections[i][0], connections[i][1] < n$。
- $connections[i][0] != connections[i][1]$。
- 没有重复的连接。
- 两台计算机不会通过多条线缆连接。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png)

```python
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png)

```python
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2
```

## 解题思路

### 思路 1：并查集

$n$ 台计算机至少需要 $n - 1$ 根线才能进行连接，如果网线的数量少于 $n - 1$，那么就不可能将其连接。接下来计算最少操作次数。

把 $n$ 台计算机看做是 $n$ 个节点，每条网线看做是一条无向边。维护两个变量：多余电线数 $removeCount$、需要电线数 $needConnectCount$。初始 $removeCount = 1, needConnectCount = n - 1$。

遍历网线数组，将相连的节点 $a$ 和 $b$ 利用并查集加入到一个集合中（调用 `union` 操作）。

- 如果 $a$ 和 $b$ 已经在同一个集合中，说明该连接线多余，多余电线数加 $1$。
- 如果 $a$ 和 $b$ 不在一个集合中，则将其合并，则 $a$ 和 $b$ 之间不再需要用额外的电线连接了，所以需要电线数减 $1$。

最后，判断多余的电线数是否满足需要电线数，不满足返回 $-1$，如果满足，则返回需要电线数。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return False
        self.parent[root_x] = root_y
        return True

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        union_find = UnionFind(n)
        removeCount = 0
        needConnectCount = n - 1
        for connection in connections:
            if union_find.union(connection[0], connection[1]):
                needConnectCount -= 1
            else:
                removeCount += 1

        if removeCount < needConnectCount:
            return -1
        return needConnectCount
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times \alpha(n))$，其中 $m$ 是数组 $connections$ 的长度，$\alpha$ 是反 `Ackerman` 函数。
- **空间复杂度**：$O(n)$。

# [1324. 竖直打印单词](https://leetcode.cn/problems/print-words-vertically/)

- 标签：数组、字符串、模拟
- 难度：中等

## 题目链接

- [1324. 竖直打印单词 - 力扣](https://leetcode.cn/problems/print-words-vertically/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：按照单词在 $s$ 中出现顺序将它们全部竖直返回。

**说明**：

- 单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。
- 每个单词只能放在一列上，每一列中也只能有一个单词。
- $1 \le s.length \le 200$。
- $s$ 仅含大写英文字母。
- 题目数据保证两个单词之间只有一个空格。

**示例**：

- 示例 1：

```python
输入：s = "HOW ARE YOU"
输出：["HAY","ORO","WEU"]
解释：每个单词都应该竖直打印。 
 "HAY"
 "ORO"
 "WEU"
```

- 示例 2：

```python
输入：s = "TO BE OR NOT TO BE"
输出：["TBONTB","OEROOE","   T"]
解释：题目允许使用空格补位，但不允许输出末尾出现空格。
"TBONTB"
"OEROOE"
"   T"
```

## 解题思路

### 思路 1：模拟

1. 将字符串 $s$ 按空格分割为单词数组 $words$。
2. 计算出单词数组 $words$ 中单词的最大长度 $max\underline{\hspace{0.5em}}len$。
3. 第一重循环遍历竖直单词的每个单词位置 $i$，第二重循环遍历当前第 $j$ 个单词。
   1. 如果当前单词没有第 $i$ 个字符（当前单词的长度超过了单词位置 $i$），则将空格插入到竖直单词中。
   2. 如果当前单词有第 $i$ 个字符，泽讲当前单词的第 $i$ 个字符插入到竖直单词中。
4. 第二重循环遍历完，将竖直单词去除尾随空格，并加入到答案数组中。
5. 第一重循环遍历完，则返回答案数组。

### 思路 1：代码

```Python
class Solution:
    def printVertically(self, s: str) -> List[str]:
        words = s.split(' ')
        max_len = 0
        for word in words:
            max_len = max(len(word), max_len)

        res = []
        for i in range(max_len):
            ans = ""
            for j in range(len(words)):
                if i + 1 > len(words[j]):
                    ans += ' '
                else:
                    ans += words[j][i]
            res.append(ans.rstrip())
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times max(|word|))$，其中 $n$ 为字符串 $s$ 中的单词个数，$max(|word|)$ 是最长的单词长度。。
- **空间复杂度**：$O(n \times max(|word|))$。

- [1338. 数组大小减半](https://leetcode.cn/problems/reduce-array-size-to-the-half/)

- 标签：贪心、数组、哈希表、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [1338. 数组大小减半 - 力扣](https://leetcode.cn/problems/reduce-array-size-to-the-half/)

## 题目大意

**描述**：给定过一个整数数组 $arr$。你可以从中选出一个整数集合，并在数组 $arr$ 删除所有整数集合对应的数。

**要求**：返回至少能删除数组中的一半整数的整数集合的最小大小。

**说明**：

- $1 \le arr.length \le 10^5$。
- $arr.length$ 为偶数。
- $1 \le arr[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：arr = [3,3,3,3,5,5,5,2,2,7]
输出：2
解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。
大小为 2 的可行集合有 {3,5},{3,2},{5,2}。
选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。
```

- 示例 2：

```python
输入：arr = [7,7,7,7,7,7]
输出：1
解释：我们只能选择集合 {7}，结果数组为空。
```

## 解题思路

### 思路 1：贪心算法

对于选出的整数集合中每一个数 $x$ 来说，我们会删除数组 $arr$ 中所有值为 $x$ 的整数。

因为题目要求我们选出的整数集合最小，所以在每一次选择整数 $x$ 加入整数集合时，我们都应该选择数组 $arr$ 中出现次数最多的数。

因此，我们可以统计出数组 $arr$ 中每个整数的出现次数，用哈希表存储，并依照出现次数进行降序排序。

然后，依次选择出现次数最多的数进行删除，并统计个数，直到删除了至少一半的数时停止。

最后，将统计个数作为答案返回。

### 思路 1：代码

```Python
class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        cnts = Counter(arr)
        ans, cnt = 0, 0
        for num, freq in cnts.most_common():
            cnt += freq
            ans += 1
            if cnt * 2 >= len(arr):
                break

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $arr$ 的长度。
- **空间复杂度**：$O(n)$。

# [1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

- 标签：数组、滑动窗口
- 难度：中等

## 题目链接

- [1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

## 题目大意

**描述**：给定一个整数数组 $arr$ 和两个整数 $k$ 和 $threshold$。

**要求**：返回长度为 $k$ 且平均值大于等于 $threshold$ 的子数组数目。

**说明**：

- $1 \le arr.length \le 10^5$。
- $1 \le arr[i] \le 10^4$。
- $1 \le k \le arr.length$。
- $0 \le threshold \le 10^4$。

**示例**：

- 示例 1：

```python
输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
输出：3
解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
```

- 示例 2：

```python
输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
输出：6
解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
```

## 解题思路

### 思路 1：滑动窗口（固定长度）

这道题目是典型的固定窗口大小的滑动窗口题目。窗口大小为 `k`。具体做法如下：

1. `ans` 用来维护答案数目。`window_sum` 用来维护窗口中元素的和。
2. `left` 、`right` 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
3. 向右移动 `right`，先将 `k` 个元素填入窗口中。
4. 当窗口元素个数为 `k` 时，即：`right - left + 1 >= k` 时，判断窗口内的元素和平均值是否大于等于阈值 `threshold`。
   1. 如果满足，则答案数目 + 1。
   2. 然后向右移动 `left`，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 `k`。
5. 重复 3 ~ 4 步，直到 `right` 到达数组末尾。
6. 最后输出答案数目。

### 思路 1：代码

```python
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        left = 0
        right = 0
        window_sum = 0
        ans = 0

        while right < len(arr):
            window_sum += arr[right]
            
            if right - left + 1 >= k:
                if window_sum >= k * threshold:
                    ans += 1
                window_sum -= arr[left]
                left += 1

            right += 1

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [1344. 时钟指针的夹角](https://leetcode.cn/problems/angle-between-hands-of-a-clock/)

- 标签：数学
- 难度：中等

## 题目链接

- [1344. 时钟指针的夹角 - 力扣](https://leetcode.cn/problems/angle-between-hands-of-a-clock/)

## 题目大意

**描述**：给定两个数 $hour$ 和 $minutes$。

**要求**：请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（$60$ 单位制）。

**说明**：

- $1 \le hour \le 12$。
- $0 \le minutes \le 59$。
- 与标准答案误差在 $10^{-5}$ 以内的结果都被视为正确结果。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_1_1673.png)

```python
输入：hour = 12, minutes = 30
输出：165
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_2_1673.png)

```python
输入：hour = 3, minutes = 30
输出；75
```

## 解题思路

### 思路 1：数学

1. 我们以 $00:00$ 为基准，分别计算出分针与 $00:00$ 中垂线的夹角，以及时针与 $00:00$ 中垂线的夹角。
2. 然后计算出两者差值的绝对值 $diff$。当前差值可能为较小的角（小于 $180°$ 的角），也可能为较大的角（大于等于 $180°$ 的角）。
3. 将差值的绝对值 $diff$ 与 $360 - diff$ 进行比较，取较小值作为答案。

### 思路 1：代码

```Python
class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        mins_angle = 6 * minutes
        hours_angle = (hour % 12 + minutes / 60) * 30

        diff = abs(hours_angle - mins_angle)
        return min(diff, 360 - diff)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。

# [1347. 制造字母异位词的最小步骤数](https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/)

- 标签：哈希表、字符串、计数
- 难度：中等

## 题目链接

- [1347. 制造字母异位词的最小步骤数 - 力扣](https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/)

## 题目大意

**描述**：给定两个长度相等的字符串 $s$ 和 $t$。每一个步骤中，你可以选择将 $t$ 中任一个字符替换为另一个字符。

**要求**：返回使 $t$ 成为 $s$ 的字母异位词的最小步骤数。

**说明**：

- **字母异位词**：指字母相同，但排列不同（也可能相同）的字符串。
- $1 \le s.length \le 50000$。
- $s.length == t.length$。
- $s$ 和 $t$ 只包含小写英文字母。

**示例**：

- 示例 1：

```python
输出：s = "bab", t = "aba"
输出：1
提示：用 'b' 替换 t 中的第一个 'a'，t = "bba" 是 s 的一个字母异位词。
```

- 示例 2：

```python
输出：s = "leetcode", t = "practice"
输出：5
提示：用合适的字符替换 t 中的 'p', 'r', 'a', 'i' 和 'c'，使 t 变成 s 的字母异位词。
```

## 解题思路

### 思路 1：哈希表

题目要求使 $t$ 成为 $s$ 的字母异位词，则只需要 $t$ 和 $s$ 对应的每种字符数量相一致即可，无需考虑字符位置。

因为每一次转换都会减少一个字符，并增加另一个字符。

1. 我们使用两个哈希表 $cnts\underline{\hspace{0.5em}}s$、$cnts\underline{\hspace{0.5em}}t$ 分别对 $t$ 和 $s$ 中的字符进行计数，并求出两者的交集。
2. 遍历交集中的字符种类，以及对应的字符数量。
3. 对于当前字符 $key$，如果当前字符串 $s$ 中的字符 $key$ 的数量小于字符串 $t$ 中字符 $key$ 的数量，即 $cnts\underline{\hspace{0.5em}}s[key] < cnts\underline{\hspace{0.5em}}t[key]$。则 $s$ 中需要补齐的字符数量就是需要的最小步数，将其累加到答案中。
4.  遍历完返回答案。

### 思路 1：代码

```Python
class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnts_s, cnts_t = Counter(s), Counter(t)
        cnts = cnts_s | cnts_t

        ans = 0
        for key, cnt in cnts.items():
            if cnts_s[key] < cnts_t[key]:
                ans += cnts_t[key] - cnts_s[key]

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$，其中 $m$、$n$ 分别为字符串 $s$、$t$ 的长度。
- **空间复杂度**：$O(|\sum|)$，其中 $\sum$ 是字符集，本题中 $| \sum | = 26$。

# [1349. 参加考试的最大学生数](https://leetcode.cn/problems/maximum-students-taking-exam/)

- 标签：位运算、数组、动态规划、状态压缩、矩阵
- 难度：困难

## 题目链接

- [1349. 参加考试的最大学生数 - 力扣](https://leetcode.cn/problems/maximum-students-taking-exam/)

## 题目大意

**描述**：给定一个 $m \times n$ 大小的矩阵 $seats$ 表示教室中的座位分布，其中如果座位是坏的（不可用），就用 `'#'` 表示，如果座位是好的，就用 `'.'` 表示。

学生可以看到左侧、右侧、左上方、右上方这四个方向上紧邻他的学生答卷，但是看不到直接坐在他前面或者后面的学生答卷。

**要求**：计算并返回该考场可以容纳的一期参加考试且无法作弊的最大学生人数。

**说明**：

- 学生必须坐在状况良好的座位上。
- $seats$ 只包含字符 `'.'` 和 `'#'`。
- $m == seats.length$。
- $n == seats[i].length$。
- $1 \le m \le 8$。
- $1 \le n \le 8$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png)

```python
输入：seats = [["#",".","#","#",".","#"],
              [".","#","#","#","#","."],
              ["#",".","#","#",".","#"]]
输出：4
解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。
```

- 示例 2：

```python
输入：seats = [[".","#"],
              ["#","#"],
              ["#","."],
              ["#","#"],
              [".","#"]]
输出：3
解释：让所有学生坐在可用的座位上。
```

## 解题思路

### 思路 1：状态压缩 DP

题目中给定的 $m$、$n$ 范围为 $1 \le m, n \le 8$，每一排最多有 $8$ 个座位，那么我们可以使用一个 $8$ 位长度的二进制数来表示当前排座位的选择情况（也就是「状态压缩」的方式）。

同时从题目中可以看出，当前排的座位与当前行左侧、右侧座位有关，并且也与上一排中左上方、右上方的座位有关，则我们可以使用一个二维数组来表示状态。其中第一维度为排数，第二维度为当前排的座位选择情况。

具体做法如下：

###### 1. 划分阶段

按照排数、当前排的座位选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][state]$ 表示为：前 $i$ 排，并且最后一排座位选择状态为 $state$ 时，可以参加考试的最大学生数。

###### 3. 状态转移方程

因为学生可以看到左侧、右侧、左上方、右上方这四个方向上紧邻他的学生答卷，所以对于当前排的某个座位来说，其左侧、右侧、左上方、右上方都不应有人坐。我们可以根据当前排的座位选取状态 $cur\underline{\hspace{0.5em}}state$，并通过枚举的方式，找出符合要求的上一排座位选取状态 $pre\underline{\hspace{0.5em}}state$，并计算出当前排座位选择个数，即 $f(cur\underline{\hspace{0.5em}}state)$，则状态转移方程为：

 $dp[i][state] = \max \lbrace dp[i - 1][pre\underline{\hspace{0.5em}}state] \rbrace  + f(state)$ 

因为所给座位中还有坏座位（不可用）的情况，我们可以使用一个 $8$ 位的二进制数 $bad\underline{\hspace{0.5em}}seat$ 来表示当前排的坏座位情况，如果 $cur\underline{\hspace{0.5em}}state  \text{ \& } bad\underline{\hspace{0.5em}}seat == 1$，则说明当前状态下，选择了坏椅子，则可直接跳过这种状态。

我们还可以通过 $cur\underline{\hspace{0.5em}}state  \text{ \& }  (cur\underline{\hspace{0.5em}}state \text{ <}\text{< } 1)$ 和 $cur\underline{\hspace{0.5em}}state \& (cur\underline{\hspace{0.5em}}state \text{ >}\text{> } 1)$ 来判断当前排选择状态下，左右相邻座位上是否有人，如果有人，则可直接跳过这种状态。

同理，我们还可以通过 $cur\underline{\hspace{0.5em}}state  \text{ \& } (pre\underline{\hspace{0.5em}}state \text{ <}\text{< } 1)$ 和 $cur\underline{\hspace{0.5em}}state \text{ \& } (pre\underline{\hspace{0.5em}}state \text{ >}\text{> } 1)$ 来判断当前排选择状态下，上一行左上、右上相邻座位上是否有人，如果有人，则可直接跳过这种状态。

###### 4. 初始条件

- 默认情况下，前 $0$ 排所有选择状态下，可以参加考试的最大学生数为 $0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][state]$ 表示为：前 $i$ 排，并且最后一排座位选择状态为 $state$ 时，可以参加考试的最大学生数。 所以最终结果为最后一排 $dp[rows]$ 中的最大值。

### 思路 1：代码

```python
class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        rows, cols = len(seats), len(seats[0])
        states = 1 << cols
        dp = [[0 for _ in range(states)] for _ in range(rows + 1)]

        for i in range(1, rows + 1):                    # 模拟 1 ~ rows 排分配座位
            bad_seat = 0                                # 当前排的坏座位情况
            for j in range(cols):
                if seats[i - 1][j] == '#':              # 记录坏座位情况
                    bad_seat |= 1 << j

            for cur_state in range(states):             # 枚举当前排的座位选取状态
                if cur_state & bad_seat:                # 当前排的座位选择了换座位，跳过
                    continue
                if cur_state & (cur_state << 1):        # 当前排左侧座位有人，跳过
                    continue
                if cur_state & (cur_state >> 1):        # 当前排右侧座位有人，跳过
                    continue

                count = bin(cur_state).count('1')       # 计算当前排最多可以坐多少人
                for pre_state in range(states):         # 枚举前一排情况
                    if cur_state & (pre_state << 1):    # 左上座位有人，跳过
                        continue
                    if cur_state & (pre_state >> 1):    # 右上座位有人，跳过
                        continue
                    # dp[i][cur_state] 取自上一排分配情况为 pre_state 的最大值 + 当前排最多可以坐的人数
                    dp[i][cur_state] = max(dp[i][cur_state], dp[i - 1][pre_state] + count)

        return max(dp[rows])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times 2^{2n})$，其中 $m$、$n$ 分别为所给矩阵的行数、列数。
- **空间复杂度**：$O(m \times 2^n)$。

# [1358. 包含所有三种字符的子字符串数目](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [1358. 包含所有三种字符的子字符串数目 - 力扣](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)

## 题目大意

给你一个字符串 `s` ，`s` 只包含三种字符 `a`, `b` 和 `c`。

请你返回 `a`，`b` 和 `c` 都至少出现过一次的子字符串数目。

## 解题思路

只要找到首个 `a`、`b`、`c` 同时存在的子字符串，则在该子字符串后面追加字符构成的新字符串还是满足题意的。假设该子串末尾字母的位置为 `i`，则以此字符串构建的新字符串有 `len(s) - i`个。所以题目可以转换为找出 `a`、`b`、`c` 同时存在的最短子串，并记录所有满足题意的字符串数量。具体做法如下：

用滑动窗口 `window` 来记录各个字符个数，`window` 为哈希表类型。用 `ans` 来维护 `a`，`b` 和 `c` 都至少出现过一次的子字符串数目。

设定两个指针：`left`、`right`，分别指向滑动窗口的左右边界，保证窗口中不超过 `k` 种字符。

- 一开始，`left`、`right` 都指向 `0`。
- 将最右侧字符 `s[right]` 加入当前窗口 `window_counts` 中，记录该字符个数，向右移动 `right`。
- 如果该窗口中字符的种数大于等于 `3` 种，即 `len(window) >= 3`，则累积答案个数为 `len(s) - right`，并不断右移 `left`，缩小滑动窗口长度，并更新窗口中对应字符的个数，直到 `len(window) < 3`。
- 然后继续右移 `right`，直到 `right >= len(nums)` 结束。
- 输出答案 `ans`。

## 代码

```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        window = dict()
        ans = 0
        left, right = 0, 0

        while right < len(s):
            if s[right] in window:
                window[s[right]] += 1
            else:
                window[s[right]] = 1

            while len(window) >= 3:
                ans += len(s) - right
                window[s[left]] -= 1
                if window[s[left]] == 0:
                    del window[s[left]]
                left += 1
            right += 1
        return ans
```

# [1362. 最接近的因数](https://leetcode.cn/problems/closest-divisors/)

- 标签：数学
- 难度：中等

## 题目链接

- [1362. 最接近的因数 - 力扣](https://leetcode.cn/problems/closest-divisors/)

## 题目大意

**描述**：给定一个整数 $num$。

**要求**：找出同时满足下面全部要求的两个整数：

- 两数乘积等于 $num + 1$ 或 $num + 2$。
- 以绝对差进行度量，两数大小最接近。

你可以按照任意顺序返回这两个整数。

**说明**：

- $1 \le num \le 10^9$。

**示例**：

- 示例 1：

```python
输入：num = 8
输出：[3,3]
解释：对于 num + 1 = 9，最接近的两个因数是 3 & 3；对于 num + 2 = 10, 最接近的两个因数是 2 & 5，因此返回 3 & 3。
```

- 示例 2：

```python
输入：num = 123
输出：[5,25]
```

## 解题思路

### 思路 1：数学

对于整数的任意一个范围在 $[\sqrt{n}, n]$ 的因数而言，一定存在一个范围在 $[1, \sqrt{n}]$ 的因数与其对应。因此，我们在遍历整数因数时，我们只需遍历 $[1, \sqrt{n}]$ 范围内的因数即可。

则这道题的具体解题步骤如下：

1. 对于整数 $num + 1$、从 $\sqrt{num + 1}$ 的位置开始，到 $1$ 为止，以递减的顺序在 $[1, \sqrt{num + 1}]$ 范围内找到最接近的小因数 $a1$，并根据 $num // a1$ 获得另一个因数 $a2$。
2. 用同样的方式，对于整数 $num + 2$、从 $\sqrt{num + 2}$ 的位置开始，到 $1$ 为止，以递减的顺序在 $[1, \sqrt{num + 2}]$ 范围内找到最接近的小因数 $b1$，并根据 $num // b1$ 获得另一个因数 $b2$。
3. 判断 $abs(a1 - a2)$ 与 $abs(b1 - b2)$ 的大小，返回差值绝对值较小的一对因子数作为答案。

### 思路 1：代码

```Python
class Solution:
    def disassemble(self, num):
        for i in range(int(sqrt(num) + 1), 1, -1):
            if num % i == 0:
                return (i, num // i)
        return (1, num)

    def closestDivisors(self, num: int) -> List[int]:
        a1, a2 = self.disassemble(num + 1)
        b1, b2 = self.disassemble(num + 2)
        if abs(a1 - a2) <= abs(b1 - b2):
            return [a1, a2]
        return [b1, b2]
```

### 思路 1：复杂度分析

- **时间复杂度**：$(\sqrt{n})$。
- **空间复杂度**：$O(1)$。

# [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)

- 标签：栈、设计、数组
- 难度：中等

## 题目链接

- [1381. 设计一个支持增量操作的栈 - 力扣](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)

## 题目大意

**要求**：设计一个支持对其元素进行增量操作的栈。

实现自定义栈类 $CustomStack$：

- `CustomStack(int maxSize)`：用 $maxSize$ 初始化对象，$maxSize$ 是栈中最多能容纳的元素数量。
- `void push(int x)`：如果栈还未增长到 $maxSize$，就将 $x$ 添加到栈顶。
- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 $-1$。
- `void inc(int k, int val)`：栈底的 $k$ 个元素的值都增加 $val$。如果栈中元素总数小于 $k$，则栈中的所有元素都增加 $val$。

**说明**：

- $1 \le maxSize, x, k \le 1000$。
- $0 \le val \le 100$。
- 每种方法 `increment`，`push` 以及 `pop` 分别最多调用 $1000$ 次。

**示例**：

- 示例 1：

```python
输入：
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
输出：
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
解释：
CustomStack stk = new CustomStack(3); // 栈是空的 []
stk.push(1);                          // 栈变为 [1]
stk.push(2);                          // 栈变为 [1, 2]
stk.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]
stk.push(2);                          // 栈变为 [1, 2]
stk.push(3);                          // 栈变为 [1, 2, 3]
stk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4
stk.increment(5, 100);                // 栈变为 [101, 102, 103]
stk.increment(2, 100);                // 栈变为 [201, 202, 103]
stk.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]
stk.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]
stk.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []
stk.pop();                            // 返回 -1 --> 栈为空，返回 -1
```

## 解题思路

### 思路 1：模拟

1. 初始化：
   1. 使用空数组 $stack$ 用于表示栈。
   2. 使用 $size$ 用于表示当前栈中元素个数，
   3. 使用 $maxSize$ 用于表示栈中允许的最大元素个数。
   4. 使用另一个空数组 $increments$ 用于增量操作。
2. `push(x)` 操作：
   1. 判断当前元素个数与栈中允许的最大元素个数关系。
   2. 如果当前元素个数小于栈中允许的最大元素个数，则：
      1. 将 $x$ 添加到数组 $stack$ 中，即：`self.stack.append(x)`。
      2. 当前元素个数加 $1$，即：`self.size += 1`。
      3. 将 $0$ 添加到增量数组 $increments$  中，即：`self.increments.append(0)`。
3. `increment(k, val)` 操作：
   1. 如果增量数组不为空，则取 $k$ 与元素个数 `self.size` 的较小值，令增量数组对应位置加上 `val`（等 `pop()` 操作时，再计算出准确值）。
4. `pop()` 操作：
   1. 如果当前元素个数为 $0$，则直接返回 $-1$。
   2. 如果当前元素个数大于等于 $2$，则更新弹出元素后的增量数组（保证剩余元素弹出时能够正确计算出），即：`self.increments[-2] += self.increments[-1]`
   3. 令元素个数减 $1$，即：`self.size -= 1`。
   4. 弹出数组 $stack$ 中的栈顶元素和增量数组 $increments$ 中的栈顶元素，令其相加，即为弹出元素值，将其返回。

### 思路 1：代码

```python
class CustomStack:

    def __init__(self, maxSize: int):
        self.maxSize = maxSize
        self.stack = []
        self.increments = []
        self.size = 0


    def push(self, x: int) -> None:
        if self.size < self.maxSize:
            self.stack.append(x)
            self.increments.append(0)
            self.size += 1


    def pop(self) -> int:
        if self.size == 0:
            return -1
        if self.size >= 2:
            self.increments[-2] += self.increments[-1]
        self.size -= 1
        
        val = self.stack.pop() + self.increments.pop()
        return val


    def increment(self, k: int, val: int) -> None:
        if self.increments:
            self.increments[min(k, self.size) - 1] += val



# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

### 思路 1：复杂度分析

- **时间复杂度**：初始化、`push` 操作、`pop` 操作、`increment` 操作的时间复杂度为 $O(1)$。
- **空间复杂度**：$O(maxSize)$。
# [1400. 构造 K 个回文字符串](https://leetcode.cn/problems/construct-k-palindrome-strings/)

- 标签：贪心、哈希表、字符串、计数
- 难度：中等

## 题目链接

- [1400. 构造 K 个回文字符串 - 力扣](https://leetcode.cn/problems/construct-k-palindrome-strings/)

## 题目大意

**描述**：给定一个字符串 $s$ 和一个整数 $k$。

**要求**：用 $s$ 字符串中所有字符构造 $k$ 个非空回文串。如果可以用 $s$ 中所有字符构造 $k$ 个回文字符串，那么请你返回 `True`，否则返回 `False`。

**说明**：

- $1 \le s.length \le 10^5$。
- $s$ 中所有字符都是小写英文字母。
- $1 \le k \le 10^5$。

**示例**：

- 示例 1：

```python
输入：s = "annabelle", k = 2
输出：True
解释：可以用 s 中所有字符构造 2 个回文字符串。
一些可行的构造方案包括："anna" + "elble"，"anbna" + "elle"，"anellena" + "b"
```

## 解题思路

### 思路 1：贪心算法

- 用字符串 $s$ 中所有字符构造回文串最多可以构造 $len(s)$ 个（将每个字符当做一个回文串）。所以如果 $len(s) < k$，则说明字符数量不够，无法构成 $k$ 个回文串，直接返回 `False`。
- 如果 $len(s) == k$，则可以直接使用单个字符构建回文串，直接返回 `True`。
- 如果 $len(s) > k$，则需要判断一下字符串 $s$ 中每个字符的个数。因为当字符是偶数个时，可以直接构造成回文串。所以我们只需要考虑个数为奇数的字符即可。如果个位为奇数的字符种类小于等于 $k$，则说明可以构造 $k$ 个回文串，返回 `True`。如果个位为奇数的字符种类大于 $k$，则说明无法构造 $k$ 个回文串，返回 `Fasle`。

### 思路 1：贪心算法代码

```python
import collections

class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        size = len(s)
        if size < k:
            return False
        if size == k:
            return True
        letter_dict = dict()
        for i in range(size):
            if s[i] in letter_dict:
                letter_dict[s[i]] += 1
            else:
                letter_dict[s[i]] = 1

        odd = 0
        for key in letter_dict:
            if letter_dict[key] % 2 == 1:
               odd += 1
        return odd <= k
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + |\sum|)$，其中 $n$ 为字符串 $s$ 的长度，$\sum$ 是字符集，本题中 $|\sum| = 26$。
- **空间复杂度**：$O(|\sum|)$。
# [1408. 数组中的字符串匹配](https://leetcode.cn/problems/string-matching-in-an-array/)

- 标签：数组、字符串、字符串匹配
- 难度：简单

## 题目链接

- [1408. 数组中的字符串匹配 - 力扣](https://leetcode.cn/problems/string-matching-in-an-array/)

## 题目大意

**描述**：给定一个字符串数组 `words`，数组中的每个字符串都可以看作是一个单词。如果可以删除 `words[j]` 最左侧和最右侧的若干字符得到 `word[i]`，那么字符串 `words[i]` 就是 `words[j]` 的一个子字符串。

**要求**：按任意顺序返回 `words` 中是其他单词的子字符串的所有单词。

**说明**：

- $1 \le words.length \le 100$。
- $1 \le words[i].length \le 30$
- `words[i]` 仅包含小写英文字母。
- 题目数据保证每个 `words[i]` 都是独一无二的。

**示例**：

- 示例 1：

```python
输入：words = ["mass","as","hero","superhero"]
输出：["as","hero"]
解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。此外，["hero","as"] 也是有效的答案。
```

## 解题思路

### 思路 1：KMP 算法

1. 先按照字符串长度从小到大排序，使用数组 `res` 保存答案。
2. 使用两重循环遍历，对于 `words[i]` 和 `words[j]`，使用 `KMP` 匹配算法，如果 `wrods[j]` 包含 `words[i]`，则将其加入到答案数组中，并跳出最里层循环。
3. 返回答案数组 `res`。

### 思路 1：代码

```python
class Solution:
    # 生成 next 数组
    # next[j] 表示下标 j 之前的模式串 p 中，最长相等前后缀的长度
    def generateNext(self, p: str):
        m = len(p)
        next = [0 for _ in range(m)]                # 初始化数组元素全部为 0
        
        left = 0                                    # left 表示前缀串开始所在的下标位置
        for right in range(1, m):                   # right 表示后缀串开始所在的下标位置
            while left > 0 and p[left] != p[right]: # 匹配不成功, left 进行回退, left == 0 时停止回退
                left = next[left - 1]               # left 进行回退操作
            if p[left] == p[right]:                 # 匹配成功，找到相同的前后缀，先让 left += 1，此时 left 为前缀长度
                left += 1
            next[right] = left                      # 记录前缀长度，更新 next[right], 结束本次循环, right += 1

        return next

    # KMP 匹配算法，T 为文本串，p 为模式串
    def kmp(self, T: str, p: str) -> int:
        n, m = len(T), len(p)
        
        next = self.generateNext(p)                      # 生成 next 数组
        
        j = 0                                       # j 为模式串中当前匹配的位置
        for i in range(n):                          # i 为文本串中当前匹配的位置
            while j > 0 and T[i] != p[j]:           # 如果模式串前缀匹配不成功, 将模式串进行回退, j == 0 时停止回退
                j = next[j - 1]
            if T[i] == p[j]:                        # 当前模式串前缀匹配成功，令 j += 1，继续匹配
                j += 1
            if j == m:                              # 当前模式串完全匹配成功，返回匹配开始位置
                return i - j + 1
        return -1                                   # 匹配失败，返回 -1
        
    def stringMatching(self, words: List[str]) -> List[str]:
        words.sort(key=lambda x:len(x))

        res = []
        for i in range(len(words) - 1):
            for j in range(i + 1, len(words)):
                if self.kmp(words[j], words[i]) != -1:
                    res.append(words[i])           
                    break
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times m)$，其中字符串数组长度为 $n$，字符串数组中最长字符串长度为 $m$。
- **空间复杂度**：$O(m)$。
# [1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1422. 分割字符串的最大得分 - 力扣](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)

## 题目大意

**描述**：给定一个由若干 $0$ 和 $1$ 组成的字符串。将字符串分割成两个非空子字符串的得分为：左子字符串中 $0$ 的数量 + 右子字符串中 $1$ 的数量。

**要求**：计算并返回该字符串分割成两个非空子字符串（即左子字符串和右子字符串）所能获得的最大得分。

**说明**：

- $2 \le s.length \le 500$。
- 字符串 $s$ 仅由字符 $0$ 和 $1$ 组成。

**示例**：

- 示例 1：

```python
输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
```

- 示例 2：

```python
输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
```

## 解题思路

### 思路 1：前缀和

1. 遍历字符串 $s$，使用前缀和数组来记录每个前缀子字符串中 $1$ 的个数。
2. 再次遍历字符串 $s$，枚举每个分割点，利用前缀和数组计算出当前分割出的左子字符串中 $1$ 的个数与右子字符串中 $0$ 的个数，并计算当前得分，然后更新最大得分。
3. 返回最大得分作为答案。

### 思路 1：代码

```python
class Solution:
    def maxScore(self, s: str) -> int:
        size = len(s)
        one_cnts = [0 for _ in range(size + 1)]

        for i in range(1, size + 1):
            if s[i - 1] == '1':
                one_cnts[i] = one_cnts[i - 1] + 1
            else:
                one_cnts[i] = one_cnts[i - 1]

        ans = 0
        for i in range(1, size):
            left_score = i - one_cnts[i]
            right_score = one_cnts[size] - one_cnts[i]
            ans = max(ans, left_score + right_score)
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n)$。
# [1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

- 标签：数组、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [1423. 可获得的最大点数 - 力扣](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

## 题目大意

**描述**：将卡牌排成一行，给定每张卡片的点数数组 $cardPoints$，其中 $cardPoints[i]$ 表示第 $i$ 张卡牌对应点数。

每次行动，可以从行的开头或者末尾拿一张卡牌，最终保证正好拿到了 $k$ 张卡牌。所得点数就是你拿到手中的所有卡牌的点数之和。

现在给定一个整数数组 $cardPoints$ 和整数 $k$。

**要求**：返回可以获得的最大点数。

**说明**：

- $1 \le cardPoints.length \le 10^5$。
- $1 \le cardPoints[i] \le 10^4$
- $1 \le k \le cardPoints.length$。

**示例**：

- 示例 1：

```python
输入：cardPoints = [1,2,3,4,5,6,1], k = 3
输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12。
```

- 示例 2：

```python
输入：cardPoints = [2,2,2], k = 2
输出：4
解释：无论你拿起哪两张卡牌，可获得的点数总是 4。
```

## 解题思路

### 思路 1：滑动窗口

可以用固定长度的滑动窗口来做。

由于只能从开头或末尾位置拿 $k$ 张牌，则最后剩下的肯定是连续的 $len(cardPoints) - k$ 张牌。要求求出 $k$ 张牌可以获得的最大收益，我们可以反向先求出连续 $len(cardPoints) - k$ 张牌的最小点数。则答案为 $sum(cardPoints) - min\underline{\hspace{0.5em}}sum$。维护一个固定长度为 $len(cardPoints) - k$ 的滑动窗口，求最小和。具体做法如下：

1. $window\underline{\hspace{0.5em}}sum$ 用来维护窗口内的元素和，初始值为 $0$。$min\underline{\hspace{0.5em}}sum$ 用来维护滑动窗口元素的最小和。初始值为 $sum(cardPoints)$。滑动窗口的长度为 $window\underline{\hspace{0.5em}}size$，值为 $len(cardPoints) - k$。
2. 使用双指针 $left$、$right$。$left$ 、$right$ 都指向序列的第一个元素，即：`left = 0`，`right = 0`。
3. 向右移动 $right$，先将 $window\underline{\hspace{0.5em}}size$ 个元素填入窗口中。
4. 当窗口元素个数为 $window\underline{\hspace{0.5em}}size$ 时，即：$right - left + 1 \ge window\underline{\hspace{0.5em}}size$ 时，计算窗口内的元素和，并维护子数组最小和 $min\underline{\hspace{0.5em}}sum$。
5. 然后向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $k$。
6. 重复 4 ~ 5 步，直到 $right$ 到达数组末尾。
7. 最后输出 $sum(cardPoints) - min\underline{\hspace{0.5em}}sum$ 即为答案。

注意：如果 $window\underline{\hspace{0.5em}}size$ 为 $0$ 时需要特殊判断，此时答案为数组和 $sum(cardPoints)$。

### 思路 1：代码

```python
class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        window_size = len(cardPoints) - k
        window_sum = 0
        cards_sum = sum(cardPoints)
        min_sum = cards_sum

        left, right = 0, 0
        if window_size == 0:
            return cards_sum

        while right < len(cardPoints):
            window_sum += cardPoints[right]

            if right - left + 1 >= window_size:
                min_sum = min(window_sum, min_sum)
                window_sum -= cardPoints[left]
                left += 1

            right += 1

        return cards_sum - min_sum
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $cardPoints$ 中的元素数量。
- **空间复杂度**：$O(1)$。

# [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

- 标签：队列、数组、有序集合、滑动窗口、单调队列、堆（优先队列）
- 难度：中等

## 题目链接

- [1438. 绝对差不超过限制的最长连续子数组 - 力扣](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

## 题目大意

给定一个整数数组 `nums`，和一个表示限制的整数 `limit`。

要求：返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 `limit`。

如果不存在满足条件的子数组，则返回 `0`。

## 解题思路

求最长连续子数组，可以使用滑动窗口来解决。这道题目的难点在于如何维护滑动窗口内的最大值和最小值的差值。遍历滑动窗口求最大值和最小值，每次计算的时间复杂度为 $O(k)$，时间复杂度过高。考虑使用特殊的数据结构来降低时间复杂度。可以使用堆（优先队列）来解决。这里使用 `Python` 中 `heapq` 实现。具体做法如下：

- 使用 `left`、`right` 两个指针，分别指向滑动窗口的左右边界，保证窗口中最大值和最小值的差值不超过 `limit`。
- 一开始，`left`、`right` 都指向 `0`。
- 向右移动 `right`，将最右侧元素加入当前窗口和大顶堆、小顶堆中。
- 如果大顶堆堆顶元素和小顶堆堆顶元素大于 `limit`，则不断右移 `left`，缩小滑动窗口长度，并更新窗口内的大顶堆、小顶堆。
- 如果大顶堆堆顶元素和小顶堆堆顶元素小于等于 `limit`，则更新最长连续子数组长度。
- 然后继续右移 `right`，直到 `right >= len(nums)` 结束。
- 输出答案。

## 代码

```python
import heapq

class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        size = len(nums)
        heap_max = []
        heap_min = []

        ans = 0
        left, right = 0, 0
        while right < size:
            heapq.heappush(heap_max, [-nums[right], right])
            heapq.heappush(heap_min, [nums[right], right])

            while -heap_max[0][0] - heap_min[0][0] > limit:
                while heap_min[0][1] <= left:
                    heapq.heappop(heap_min)
                while heap_max[0][1] <= left:
                    heapq.heappop(heap_max)
                left += 1
            ans = max(ans, right - left + 1)
            right += 1

        return ans
```

# [1446. 连续字符](https://leetcode.cn/problems/consecutive-characters/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1446. 连续字符 - 力扣](https://leetcode.cn/problems/consecutive-characters/)

## 题目大意

给你一个字符串 `s` ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。

要求：返回字符串的能量。

注意：

- `1 <= s.length <= 500`
- `s` 只包含小写英文字母。

## 解题思路

使用 `count` 统计连续不重复子串的长度，使用 `ans` 记录最长连续不重复子串的长度。

## 代码

```python
class Solution:
    def maxPower(self, s: str) -> int:
        ans = 1
        count = 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                count += 1
            else:
                count = 1
            ans = max(ans, count)
        return ans
```

# [1447. 最简分数](https://leetcode.cn/problems/simplified-fractions/)

- 标签：数学、字符串、数论
- 难度：中等

## 题目链接

- [1447. 最简分数 - 力扣](https://leetcode.cn/problems/simplified-fractions/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回所有 $0$ 到 $1$ 之间（不包括 $0$ 和 $1$）满足分母小于等于 $n$ 的最简分数。分数可以以任意顺序返回。

**说明**：

- $1 \le n \le 100$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：["1/2"]
解释："1/2" 是唯一一个分母小于等于 2 的最简分数。
```

- 示例 2：

```python
输入：n = 4
输出：["1/2","1/3","1/4","2/3","3/4"]
解释："2/4" 不是最简分数，因为它可以化简为 "1/2"。
```

## 解题思路

### 思路 1：数学

如果分子和分母的最大公约数为 $1$ 时，则当前分数为最简分数。

而 $n$ 的数据范围为 $(1, 100)$。因此我们可以使用两重遍历，分别枚举分子和分母，然后通过判断分子和分母是否为最大公约数，来确定当前分数是否为最简分数。

### 思路 1：代码

```python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        res = []

        for i in range(1, n):
            for j in range(i + 1, n + 1):
                if math.gcd(i, j) == 1:
                    res.append(str(i) + "/" + str(j))

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2 \times \log n)$。
- **空间复杂度**：$O(1)$。

# [1449. 数位成本和为目标值的最大数字](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [1449. 数位成本和为目标值的最大数字 - 力扣](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/)

## 题目大意

**描述**：给定一个整数数组 $cost$ 和一个整数 $target$。现在从 `""` 开始，不断通过以下规则得到一个新的整数：

1. 给当前结果添加一个数位（$i + 1$）的成本为 $cost[i]$（$cost$ 数组下标从 $0$ 开始）。
2. 总成本必须恰好等于 $target$。
3. 添加的数位中没有数字 $0$。

**要求**：找到按照上述规则可以得到的最大整数。

**说明**：

- 由于答案可能会很大，请你以字符串形式返回。
- 如果按照上述要求无法得到任何整数，请你返回 `"0"`。
- $cost.length == 9$。
- $1 \le cost[i] \le 5000$。
- $1 \le target \le 5000$。

**示例**：

- 示例 1：

```python
输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
输出："7772"
解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
 数字     成本
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
```

- 示例 2：

```python
输入：cost = [7,6,5,5,5,6,8,7,8], target = 12
输出："85"
解释：添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12。
 数字     成本
  1  ->   7
  2  ->   6
  3  ->   5
  4  ->   5
  5  ->   5
  6  ->   6
  7  ->   8
  8  ->   7
  9  ->   8
```

## 解题思路

把每个数位（$1 \sim 9$）看做是一件物品，$cost[i]$ 看做是物品的重量，一共有无数件物品可以使用，$target$ 看做是背包的载重上限，得到的最大整数可以看做是背包的最大价值。那么问题就变为了「完全背包问题」中的「恰好装满背包的最大价值问题」。

因为答案可能会很大，要求以字符串形式返回。这里我们可以直接令 $dp[w]$ 为字符串形式，然后定义一个 `def maxInt(a, b):`  方法用于判断两个字符串代表的数字大小。

### 思路 1：动态规划

###### 1. 划分阶段

按照背包载重上限进行阶段划分。

###### 2. 定义状态

定义状态 $dp[w]$ 表示为：将物品装入一个最多能装重量为 $w$ 的背包中，恰好装满背包的情况下，能装入背包的最大整数。

###### 3. 状态转移方程

$dp[w] = maxInt(dp[w], str(i) + dp[w - cost[i - 1]])$

###### 4. 初始条件

1. 只有载重上限为 $0$ 的背包，在不放入物品时，能够恰好装满背包（有合法解），此时背包所含物品的最大价值为空字符串，即 `dp[0] = ""`。
2. 其他载重上限下的背包，在放入物品的时，都不能恰好装满背包（都没有合法解），此时背包所含物品的最大价值属于未定义状态，值为自定义字符 `"#"`，即 ，`dp[w] = "#"`，$0 \le w \le target$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[w]$ 表示为：将物品装入一个最多能装重量为 $w$ 的背包中，恰好装满背包的情况下，能装入背包的最大价值总和。 所以最终结果为 $dp[target]$。

### 思路 1：代码

```python
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        def maxInt(a, b):
            if len(a) == len(b):
                return max(a, b)
            if len(a) > len(b):
                return a
            return b

        size = len(cost)
        dp = ["#" for _ in range(target + 1)]
        dp[0] = ""

        for i in range(1, size + 1):
            for w in range(cost[i - 1], target + 1):
                if dp[w - cost[i - 1]] != "#":
                    dp[w] = maxInt(dp[w], str(i) + dp[w - cost[i - 1]])
        if dp[target] == "#":
            return "0"
        return dp[target]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times target)$，其中 $n$ 为数组 $cost$ 的元素个数，$target$ 为所给整数。
- **空间复杂度**：$O(target)$。
# [1450. 在既定时间做作业的学生人数](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/)

- 标签：数组
- 难度：简单

## 题目链接

- [1450. 在既定时间做作业的学生人数 - 力扣](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/)

## 题目大意

**描述**：给你两个长度相等的整数数组，一个表示开始时间的数组 $startTime$ ，另一个表示结束时间的数组 $endTime$。再给定一个整数 $queryTime$ 作为查询时间。已知第 $i$ 名学生在 $startTime[i]$ 时开始写作业并于 $endTime[i]$ 时完成作业。

**要求**：返回在查询时间 $queryTime$ 时正在做作业的学生人数。即能够使 $queryTime$ 处于区间 $[startTime[i], endTime[i]]$ 的学生人数。

**说明**：

- $startTime.length == endTime.length$。
- $1\le startTime.length \le 100$。
- $1 \le startTime[i] \le endTime[i] \le 1000$。
- $1 \le queryTime \le 1000$。

**示例**：

- 示例 1：

```python
输入：startTime = [4], endTime = [4], queryTime = 4
输出：1
解释：在查询时间只有一名学生在做作业。
```

## 解题思路

### 思路 1：枚举算法

- 维护一个用于统计在查询时间 $queryTime$ 时正在做作业的学生人数的变量 $cnt$。然后遍历所有学生的开始时间和结束时间。
- 如果 $queryTime$ 在区间 $[startTime[i], endTime[i]]$ 之间，即 $startTime[i] <= queryTime <= endTime[i]$，则令 $cnt$ 加 $1$。
- 遍历完输出统计人数 $cnt$。

### 思路 1：枚举算法代码

```python
class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        cnt = 0
        size = len(startTime)
        for i in range(size):
            if startTime[i] <= queryTime <= endTime[i]:
                cnt += 1
        return cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组中的元素个数。
- **空间复杂度**：$O(1)$。

### 思路 2：线段树

- 因为 $1 \le startTime[i] \le endTime[i] \le 1000$，所以我们可以维护一个区间为 $[0, 1000]$ 的线段树，初始化所有区间值都为 $0$。
- 然后遍历所有学生的开始时间和结束时间，并将区间 $[startTime[i], endTime[i]]$ 值加 $1$。
- 在线段树中查询 $queryTime$ 对应的单点区间 $[queryTime, queryTime]$ 的最大值为多少。

### 思路 2：线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, val=0):
        self.left = -1                              # 区间左边界
        self.right = -1                             # 区间右边界
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = None                        # 区间和问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, nums, function):
        self.size = len(nums)
        self.tree = [SegTreeNode() for _ in range(4 * self.size)]  # 维护 SegTreeNode 数组
        self.nums = nums                            # 原始数据
        self.function = function                    # function 是一个函数，左右区间的聚合方法
        if self.size > 0:
            self.__build(0, 0, self.size - 1)
    
    # 单点更新接口：将 nums[i] 更改为 val
    def update_point(self, i, val):
        self.nums[i] = val
        self.__update_point(i, val, 0)
    
    # 区间更新接口：将区间为 [q_left, q_right] 上的所有元素值加上 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, 0)
        
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, 0)
    
    # 获取 nums 数组接口：返回 nums 数组
    def get_nums(self):
        for i in range(self.size):
            self.nums[i] = self.query_interval(i, i)
        return self.nums
        
        
    # 以下为内部实现方法
    
    # 构建线段树实现方法：节点的存储下标为 index，节点的区间为 [left, right]
    def __build(self, index, left, right):
        self.tree[index].left = left
        self.tree[index].right = right
        if left == right:                           # 叶子节点，节点值为对应位置的元素值
            self.tree[index].val = self.nums[left]
            return
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.__build(left_index, left, mid)         # 递归创建左子树
        self.__build(right_index, mid + 1, right)   # 递归创建右子树
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 单点更新实现方法：将 nums[i] 更改为 val，节点的存储下标为 index
    def __update_point(self, i, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left == right:
            self.tree[index].val = val              # 叶子节点，节点值修改为 val
            return
        
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if i <= mid:                                # 在左子树中更新节点值
            self.__update_point(i, val, left_index)
        else:                                       # 在右子树中更新节点值
            self.__update_point(i, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖        
            if self.tree[index].lazy_tag is not None:
                self.tree[index].lazy_tag += val    # 将当前节点的延迟标记增加 val
            else:
                self.tree[index].lazy_tag = val     # 将当前节点的延迟标记增加 val
            interval_size = (right - left + 1)      # 当前节点所在区间大小
            self.tree[index].val += val * interval_size  # 当前节点所在区间每个元素值增加 val
            return
        
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return
    
        self.__pushdown(index)                      # 向下更新节点的区间值
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        if q_left <= mid:                           # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, left_index)
        if q_right > mid:                           # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, right_index)
        
        self.__pushup(index)                        # 向上更新节点的区间值
    
    # 区间查询实现方法：在线段树中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, index):
        left = self.tree[index].left
        right = self.tree[index].right
        
        if left >= q_left and right <= q_right:     # 节点所在区间被 [q_left, q_right] 所覆盖
            return self.tree[index].val             # 直接返回节点值
        if right < q_left or left > q_right:        # 节点所在区间与 [q_left, q_right] 无关
            return 0
    
        self.__pushdown(index)
    
        mid = left + (right - left) // 2            # 左右节点划分点
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= mid:                           # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, left_index)
        if q_right > mid:                           # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, right_index)
        
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新下标为 index 的节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, index):
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        self.tree[index].val = self.function(self.tree[left_index].val, self.tree[right_index].val)

    # 向下更新实现方法：更新下标为 index 的节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, index):
        lazy_tag = self.tree[index].lazy_tag
        if lazy_tag is None: 
            return
        
        left_index = index * 2 + 1                  # 左子节点的存储下标
        right_index = index * 2 + 2                 # 右子节点的存储下标
        
        if self.tree[left_index].lazy_tag is not None:
            self.tree[left_index].lazy_tag += lazy_tag  # 更新左子节点懒惰标记
        else:
            self.tree[left_index].lazy_tag = lazy_tag
        left_size = (self.tree[left_index].right - self.tree[left_index].left + 1)
        self.tree[left_index].val += lazy_tag * left_size   # 左子节点每个元素值增加 lazy_tag
        
        if self.tree[right_index].lazy_tag is not None:
            self.tree[right_index].lazy_tag += lazy_tag # 更新右子节点懒惰标记
        else:
            self.tree[right_index].lazy_tag = lazy_tag
        right_size = (self.tree[right_index].right - self.tree[right_index].left + 1)
        self.tree[right_index].val += lazy_tag * right_size # 右子节点每个元素值增加 lazy_tag
        
        self.tree[index].lazy_tag = None            # 更新当前节点的懒惰标记


class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        nums = [0 for _ in range(1010)]
        self.STree = SegmentTree(nums, lambda x, y: max(x, y))
        size = len(startTime)
        for i in range(size):
            self.STree.update_interval(startTime[i], endTime[i], 1)

        return self.STree.query_interval(queryTime, queryTime)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组元素的个数。
- **空间复杂度**：$O(n)$。

### 思路 3：树状数组

- 因为 $1 \le startTime[i] \le endTime[i] \le 1000$，所以我们可以维护一个区间为 $[0, 1000]$ 的树状数组。
- 注意：
  - 树状数组中 $update(self, index, delta):$ 指的是将对应元素 $nums[index] $ 加上 $delta$。
  - $query(self, index):$ 指的是 $index$ 位置之前的元素和，即前缀和。
- 然后遍历所有学生的开始时间和结束时间，将树状数组上 $startTime[i]$ 的值增加 $1$，再将树状数组上$endTime[i]$ 的值减少 $1$。
- 则查询 $queryTime$ 位置的前缀和即为答案。

### 思路 3：树状数组代码

```python
class BinaryIndexTree:

    def __init__(self, n):
        self.size = n
        self.tree = [0 for _ in range(n + 1)]

    def lowbit(self, index):
        return index & (-index)

    def update(self, index, delta):
        while index <= self.size:
            self.tree[index] += delta
            index += self.lowbit(index)

    def query(self, index):
        res = 0
        while index > 0:
            res += self.tree[index]
            index -= self.lowbit(index)
        return res

class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        bit = BinaryIndexTree(1010)
        size = len(startTime)
        for i in range(size):
            bit.update(startTime[i], 1)
            bit.update(endTime[i] + 1, -1)
        return bit.query(queryTime)
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组元素的个数。
- **空间复杂度**：$O(n)$。
# [1451. 重新排列句子中的单词](https://leetcode.cn/problems/rearrange-words-in-a-sentence/)

- 标签：字符串、排序
- 难度：中等

## 题目链接

- [1451. 重新排列句子中的单词 - 力扣](https://leetcode.cn/problems/rearrange-words-in-a-sentence/)

## 题目大意

**描述**：「句子」是一个用空格分隔单词的字符串。给定一个满足下述格式的句子 $text$:

- 句子的首字母大写。
- $text$ 中的每个单词都用单个空格分隔。

**要求**：重新排列 $text$ 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。

请同样按上述格式返回新的句子。

**说明**：

- $text$ 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。
- $1 \le text.length \le 10^5$。

**示例**：

- 示例 1：

```python
输入：text = "Leetcode is cool"
输出："Is cool leetcode"
解释：句子中共有 3 个单词，长度为 8 的 "Leetcode" ，长度为 2 的 "is" 以及长度为 4 的 "cool"。
输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。
```

- 示例 2：

```python
输入：text = "Keep calm and code on"
输出："On and keep calm code"
解释：输出的排序情况如下：
"On" 2 个字母。
"and" 3 个字母。
"keep" 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。
"calm" 4 个字母。
"code" 4 个字母。
```

## 解题思路

### 思路 1：模拟

1. 将 $text$ 按照 `" "` 进行分割为单词数组 $words$。
2. 将单词数组按照「单词长度」进行升序排序。
3. 将单词数组用 `" "` 连接起来，并将首字母转为大写字母，其他字母转为小写字母，将结果存入答案字符串 $ans$ 中。
4. 返回答案字符串 $ans$。

### 思路 1：代码

```Python
class Solution:
    def arrangeWords(self, text: str) -> str:
        words = text.split(' ')
        words.sort(key=lambda word:len(word))
        ans = " ".join(words).capitalize()

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为字符串 $text$ 的长度。
- **空间复杂度**：$O(n)$。

# [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)

- 标签：字符串、滑动窗口
- 难度：中等

## 题目链接

- [1456. 定长子串中元音的最大数目 - 力扣](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)

## 题目大意

**描述**：给定字符串 $s$ 和整数 $k$。

**要求**：返回字符串 $s$ 中长度为 $k$ 的单个子字符串中可能包含的最大元音字母数。

**说明**：

- 英文中的元音字母为（$a$, $e$, $i$, $o$, $u$）。
- $1 <= s.length <= 10^5$。
- $s$ 由小写英文字母组成。
- $1 <= k <= s.length$。

**示例**：

- 示例 1：

```python
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
```

- 示例 2：

```python
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
```

## 解题思路

### 思路 1：滑动窗口

固定长度的滑动窗口题目。维护一个长度为 $k$ 的窗口，并统计滑动窗口中最大元音字母数。具体做法如下：

1. $ans$ 用来维护长度为 $k$ 的单个字符串中最大元音字母数。$window\underline{\hspace{0.5em}}count$ 用来维护窗口中元音字母数。集合 $vowel\underline{\hspace{0.5em}}set$ 用来存储元音字母。
2. $left$ 、$right$ 都指向字符串 $s$ 的第一个元素，即：$left = 0$，$right = 0$。
3. 判断 $s[right]$ 是否在元音字母集合中，如果在则用 $window\underline{\hspace{0.5em}}count$ 进行计数。
4. 当窗口元素个数为 $k$ 时，即：$right - left + 1 \ge k$ 时，更新 $ans$。然后判断 $s[left]$ 是否为元音字母，如果是则 `window_count -= 1`，并向右移动 $left$，从而缩小窗口长度，即 `left += 1`，使得窗口大小始终保持为 $k$。
5. 重复 $3 \sim 4$ 步，直到 $right$ 到达数组末尾。
6. 最后输出 $ans$。

### 思路 1：代码

```python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        left, right = 0, 0
        ans = 0
        window_count = 0
        vowel_set = ('a','e','i','o','u')

        while right < len(s):
            if s[right] in vowel_set:
                window_count += 1

            if right - left + 1 >= k:
                ans = max(ans, window_count)
                if s[left] in vowel_set:
                    window_count -= 1
                left += 1

            right += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(1)$。

# [1476. 子矩形查询](https://leetcode.cn/problems/subrectangle-queries/)

- 标签：设计、数组、矩阵
- 难度：中等

## 题目链接

- [1476. 子矩形查询 - 力扣](https://leetcode.cn/problems/subrectangle-queries/)

## 题目大意

**要求**：实现一个类 SubrectangleQueries，它的构造函数的参数是一个 $rows \times cols $的矩形（这里用整数矩阵表示），并支持以下两种操作：

1. `updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)`：用 $newValue$ 更新以 $(row1,col1)$ 为左上角且以 $(row2,col2)$ 为右下角的子矩形。

2. `getValue(int row, int col)`：返回矩形中坐标 (row,col) 的当前值。

**说明**：

- 最多有 $500$ 次 `updateSubrectangle` 和 `getValue` 操作。
- $1 <= rows, cols <= 100$。
- $rows == rectangle.length$。
- $cols == rectangle[i].length$。
- $0 <= row1 <= row2 < rows$。
- $0 <= col1 <= col2 < cols$。
- $1 <= newValue, rectangle[i][j] <= 10^9$。
- $0 <= row < rows$。
- $0 <= col < cols$。

**示例**：

- 示例 1：

```python
输入：
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
输出：
[null,1,null,5,5,null,10,5]
解释：
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// 初始的 (4x3) 矩形如下：
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // 返回 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// 此次更新后矩形变为：
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // 返回 5
subrectangleQueries.getValue(3, 1); // 返回 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// 此次更新后矩形变为：
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // 返回 10
subrectangleQueries.getValue(0, 2); // 返回 5
```

- 示例 2：

```python
输入：
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
输出：
[null,1,null,100,100,null,20]
解释：
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // 返回 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // 返回 100
subrectangleQueries.getValue(2, 2); // 返回 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // 返回 20

```

## 解题思路

### 思路 1：暴力

矩形最大为 $row \times col == 100 \times 100$，则每次更新最多需要更新 $10000$ 个值，更新次数最多为 $500$ 次。

用暴力更新的方法最多需要更新 $5000000$ 次，我们可以尝试一下用暴力更新的方法解决本题（提交后发现可以通过）。

### 思路 1：代码

```Python
class SubrectangleQueries:

    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle


    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        for row in range(row1, row2 + 1):
            for col in range(col1, col2 + 1):
                self.rectangle[row][col] = newValue


    def getValue(self, row: int, col: int) -> int:
        return self.rectangle[row][col]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(row \times col \times 500)$。
- **空间复杂度**：$O(row \times col)$。
# [1480. 一维数组的动态和](https://leetcode.cn/problems/running-sum-of-1d-array/)

- 标签：数组、前缀和
- 难度：简单

## 题目链接

- [1480. 一维数组的动态和 - 力扣](https://leetcode.cn/problems/running-sum-of-1d-array/)

## 题目大意

**描述**：给定一个数组 $nums$。

**要求**：返回数组 $nums$ 的动态和。

**说明**：

- **动态和**：数组前 $i$ 项元素和构成的数组，计算公式为 $runningSum[i] = \sum_{x = 0}^{x = i}(nums[i])$。
- $1 \le nums.length \le 1000$。
- $-10^6 \le nums[i] \le 10^6$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4]。
```

- 示例 2：

```python
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]。
```

## 解题思路

### 思路 1：递推

根据动态和的公式 $runningSum[i] = \sum_{x = 0}^{x = i}(nums[i])$，可以推导出：

$runningSum = \begin{cases} nums[0], & i = 0 \cr runningSum[i - 1] + nums[i], & i > 0\end{cases}$

则解决过程如下：

1. 新建一个长度等于 $nums$ 的数组 $res$ 用于存放答案。
2. 初始化 $res[0] = nums[0]$。
3. 从下标 $1$ 开始遍历数组 $nums$，递推更新 $res$，即：`res[i] = res[i - 1] + nums[i]`。
4. 遍历结束，返回 $res$ 作为答案。

### 思路 1：代码

```python
class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        size = len(nums)
        res = [0 for _ in range(size)]
        for i in range(size):
            if i == 0:
                res[i] = nums[i]
            else:
                res[i] = res[i - 1] + nums[i]
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(n)$。不算上则空间复杂度为 $O(1)$。

# [1482. 制作 m 束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [1482. 制作 m 束花所需的最少天数 - 力扣](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

## 题目大意

**描述**：给定一个整数数组 $bloomDay$，以及两个整数 $m$ 和 $k$。$bloomDay$ 代表花朵盛开的时间，$bloomDay[i]$ 表示第 $i$ 朵花的盛开时间。盛开后就可以用于一束花中。

现在需要制作 $m$ 束花。制作花束时，需要使用花园中相邻的 $k$ 朵花 。

**要求**：返回从花园中摘 $m$ 束花需要等待的最少的天数。如果不能摘到 $m$ 束花则返回 $-1$。

**说明**：

- $bloomDay.length == n$。
- $1 \le n \le 10^5$。
- $1 \le bloomDay[i] \le 10^9$。
- $1 \le m \le 10^6$。
- $1 \le k \le n$。

**示例**：

- 示例 1：

```python
输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
```

- 示例 2：

```python
输入：bloomDay = [1,10,3,10,2], m = 3, k = 2
输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1。
```

## 解题思路

### 思路 1：二分查找算法

这道题跟「[0875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)」、「[1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)」有点相似。

根据题目可知：

- 制作花束最少使用时间跟花朵开花最短时间有关系，即 $min(bloomDay)$。
- 制作花束最多使用时间跟花朵开花最长时间有关系，即 $max(bloomDay)$。
- 则制作花束所需要的天数就变成了一个区间 $[min(bloomDay), max(bloomDay)]$。

那么，我们就可以根据这个区间，利用二分查找算法找到一个符合题意的最少天数。而判断某个天数下能否摘到 $m$ 束花则可以写个方法判断。具体步骤如下：

-  遍历数组 $bloomDay$。
   - 如果 $bloomDay[i] \le days$。就将花朵数量加 $1$。
     - 当能摘的花朵数等于 $k$ 时，能摘的花束数目加 $1$，花朵数量置为 $0$。
   - 如果 $bloomDay[i] > days$。就将花朵数置为 $0$。
-  最后判断能摘的花束数目是否大于等于 $m$。

整个算法的步骤如下：

- 如果 $m \times k > len(bloomDay)$，说明无法满足要求，直接返回 $-1$。
- 使用两个指针 $left$、$right$。令 $left$ 指向 $min(bloomDay)$，$right$ 指向 $max(bloomDay)$。代表待查找区间为 $[left, right]$。
- 取两个节点中心位置 $mid$，判断是否能在 $mid$ 天制作 $m$ 束花。
  - 如果不能，则将区间 $[left, mid]$ 排除掉，继续在区间 $[mid + 1, right]$ 中查找。
  - 如果能，说明天数还可以继续减少，则继续在区间 $[left, mid]$ 中查找。
- 当 $left == right$ 时跳出循环，返回 $left$。

### 思路 1：代码

```python
class Solution:
    def canMake(self, bloomDay, days, m, k):
        count = 0
        flower = 0
        for i in range(len(bloomDay)):
            if bloomDay[i] <= days:
                flower += 1
                if flower == k:
                    count += 1
                    flower = 0
            else:
                flower = 0
        return count >= m

    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if m > len(bloomDay) / k:
            return -1

        left, right = min(bloomDay), max(bloomDay)

        while left < right:
            mid = left + (right - left) // 2
            if not self.canMake(bloomDay, mid, m, k):
                left = mid + 1
            else:
                right = mid

        return left
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log (max(bloomDay) - min(bloomDay)))$。
- **空间复杂度**：$O(1)$。

## 参考资料

- 【题解】[【赤小豆】为什么是二分法，思路及模板 python - 制作 m 束花所需的最少天数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/solution/chi-xiao-dou-python-wei-shi-yao-shi-er-f-24p7/)

# [1486. 数组异或操作](https://leetcode.cn/problems/xor-operation-in-an-array/)

- 标签：位运算、数学
- 难度：简单

## 题目链接

- [1486. 数组异或操作 - 力扣](https://leetcode.cn/problems/xor-operation-in-an-array/)

## 题目大意

给定两个整数 n、start。数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）。n 为数组长度。返回数组 nums 中所有元素按位异或（XOR）后得到的结果。

## 解题思路

### 1. 模拟

直接按照题目要求模拟即可。

### 2. 规律

- $x \oplus x = 0$；
- $x \oplus y = y \oplus x$（交换律）；
- $(x \oplus y) \oplus z = x \oplus (y \oplus z)$（结合律）；
- $x \oplus y \oplus y = x$（自反性）；
- $\forall i \in Z$，有 $4i \oplus (4i+1) \oplus (4i+2) \oplus (4i+3) = 0$；
- $\forall i \in Z$，有 $2i \oplus (2i+1) = 1$；
- $\forall i \in Z$，有 $2i \oplus 1 = 2i+1$。

本题中计算的是 $start \oplus (start + 2) \oplus (start + 4) \oplus (start + 6) \oplus … \oplus (start+(2*(n-1)))$。

可以看出，若 start 为奇数，则 $start+2, start + 4, …, start + (2 \times(n - 1))$ 都为奇数。若 start 为偶数，则 $start + 2, start + 4, …, start + (2 \times(n - 1))$ 都为偶数。则它们对应二进制的最低位相同，则我们可以将最低位提取处理单独处理。从而将公式转换一下。

令 $s = \frac{start}{2}$，则等式变为 $(s) \oplus (s+1) \oplus (s+2) \oplus (s+3) \oplus … \oplus (s+(n-1)) * 2 + e$，e 表示运算结果的最低位。

根据自反性，$(s) \oplus (s+1) \oplus (s+2) \oplus (s+3) \oplus … \oplus (s+(n-1)) = \\ (1 \oplus 2 \oplus … \oplus (s-1)) \oplus (1 \oplus 2 \oplus … \oplus (s-1) \oplus (s) \oplus (s+1) \oplus … \oplus (s+(n-1)))$

例如： $3 \oplus 4 \oplus 5 \oplus 6 \oplus 7 = (1 \oplus 2) \oplus (1 \oplus 2 \oplus 3 \oplus 4 \oplus 5 \oplus 6 \oplus7)$

就变为了计算前 n 项序列的异或值。假设我们定义一个函数 sumXor(x) 用于计算前 n 项数的异或结果，通过观察可得出：

$sumXor(x) = \begin{cases} \begin{array} \ x, & x = 4i, k \in Z \cr (x-1) \oplus x, & x = 4i+1, k \in Z \cr (x-2) \oplus (x-1) \oplus x, & x = 4i+2, k \in Z \cr (x-3) \oplus (x-2) \oplus (x-3) \oplus x, & x = 4i+3, k \in Z \end{array} \end{cases}$

继续化简得：

$sumXor(x) = \begin{cases} \begin{array} \ x, & x = 4i, k \in Z \cr 1, & x = 4i+1, k \in Z \cr x+1, & x = 4i+2, k \in Z \cr 0, & x = 4i+3, k \in Z \end{array} \end{cases}$

则最终结果为 $sumXor(s-1) \oplus sumXor(s+n-1) * 2 + e$。

下面还有最后一位 e 的计算。

- 若 start 为偶数，则最后一位 e 为 0。
- 若 start 为奇数，最后一位 e 跟 n 有关，若 n 为奇数，则最后一位 e 为 1，若 n 为偶数，则最后一位 e 为 0。

总结下来就是 `e = start & n & 1`。

## 代码

1. 模拟

```python
class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        ans = 0
        for i in range(n):
            ans ^= (start + i * 2)
        return ans
```

2. 规律

```python
class Solution:
    def sumXor(self, x):
        if x % 4 == 0:
            return x
        if x % 4 == 1:
            return 1
        if x % 4 == 2:
            return x + 1
        return 0
    def xorOperation(self, n: int, start: int) -> int:
        s = start >> 1
        e = n & start & 1
        ans = self.sumXor(s-1) ^ self.sumXor(s + n - 1)
        return ans << 1 | e
```

# [1491. 去掉最低工资和最高工资后的工资平均值](https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/)

- 标签：数组、排序
- 难度：简单

## 题目链接

- [1491. 去掉最低工资和最高工资后的工资平均值 - 力扣](https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/)

## 题目大意

**描述**：给定一个整数数组 `salary`，数组中的每一个数都是唯一的，其中 `salary[i]` 是第 `i` 个员工的工资。

**要求**：返回去掉最低工资和最高工资之后，剩下员工工资的平均值。

**说明**：

- $3 \le salary.length \le 100$。
- $10^3 \le salary[i] \le 10^6$。
- $salary[i]$ 是唯一的。
- 与真实值误差在 $10^{-5}$ 以内的结果都将视为正确答案。

**示例**：

- 示例 1：

```python
给定 salary = [1000,2000,3000]
输出 2000.00000
解释 最低工资为 1000，最高工资为 3000，去除最低工资和最高工资之后，剩下员工工资的平均值为 2000 / 1 = 2000
```

## 解题思路

### 思路 1：

因为给定 $salary.length \ge 3$，并且 $salary[i]$ 是唯一的，所以无需考虑最低工资和最高工资是同一个。接下来就是按照题意模拟过程：

- 计算出最小工资为 `min_s`，即 `min_s = min(salary)`。
- 计算出最大工资为 `max_s`，即 `max_s = max(salary)`。
- 计算出所有工资和之后再减去最小工资和最大工资，即 `total = sum(salary) - min_s - max_s`。
- 求剩下工资的平均值，并返回，即 `return total / (len(salary) - 2)`。

## 代码

### 思路 1 代码：

```python
class Solution:
    def average(self, salary: List[int]) -> float:
        min_s, max_s = min(salary), max(salary)
        total = sum(salary) - min_s - max_s
        return total / (len(salary) - 2)
```

# [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

- 标签：数组、动态规划、滑动窗口
- 难度：中等

## 题目链接

- [1493. 删掉一个元素以后全为 1 的最长子数组 - 力扣](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

## 题目大意

**描述**：给定一个二进制数组 $nums$，需要从数组中删掉一个元素。

**要求**：返回最长的且只包含 $1$ 的非空子数组的长度。如果不存在这样的子数组，请返回 $0$。

**说明**：

- $1 \le nums.length \le 10^5$。
- $nums[i]$ 要么是 $0$ 要么是 $1$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1。
```

- 示例 2：

```python
输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1]。
```

## 解题思路

### 思路 1：滑动窗口

维护一个元素值为 $0$ 的元素数量少于 $1$ 个的滑动窗口。则答案为滑动窗口长度减去窗口内 $0$ 的个数求最大值。具体做法如下：

设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口 $0$ 的个数小于 $1$ 个。使用 $window\underline{\hspace{0.5em}}count$ 记录窗口中 $0$ 的个数，使用 $ans$ 记录删除一个元素后，最长的只包含 $1$ 的非空子数组长度。

- 一开始，$left$、$right$ 都指向 $0$。

- 如果最右侧元素等于 $0$，则 `window_count += 1` 。

- 如果 $window\underline{\hspace{0.5em}}count > 1$ ，则不断右移 $left$，缩小滑动窗口长度。并更新当前窗口中 $0$ 的个数，直到 $window\underline{\hspace{0.5em}}count \le 1$。
- 更新答案值，然后向右移动 $right$，直到 $right \ge len(nums)$ 结束。
- 输出答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left, right = 0, 0
        window_count = 0
        ans = 0

        while right < len(nums):
            if nums[right] == 0:
                window_count += 1

            while window_count > 1:
                if nums[left] == 0:
                    window_count -= 1
                left += 1
            ans = max(ans, right - left + 1 - window_count)
            right += 1

        if ans == len(nums):
            return len(nums) - 1
        else:
            return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。

# [1496. 判断路径是否相交](https://leetcode.cn/problems/path-crossing/)

- 标签：哈希表、字符串
- 难度：简单

## 题目链接

- [1496. 判断路径是否相交 - 力扣](https://leetcode.cn/problems/path-crossing/)

## 题目大意

**描述**：给定一个字符串 $path$，其中 $path[i]$ 的值可以是 `'N'`、`'S'`、`'E'` 或者 `'W'`，分别表示向北、向南、向东、向西移动一个单位。

你从二维平面上的原点 $(0, 0)$ 处开始出发，按 $path$ 所指示的路径行走。

**要求**：如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 $True$；否则，返回 $False$。

**说明**：

- $1 \le path.length \le 10^4$。
- $path[i]$ 为 `'N'`、`'S'`、`'E'` 或 `'W'`。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123929-pm.png)

```python
输入：path = "NES"
输出：false 
解释：该路径没有在任何位置相交。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123843-pm.png)

```python
输入：path = "NESWW"
输出：true
解释：该路径经过原点两次。
```

## 解题思路

### 思路 1：哈希表 + 模拟

1. 使用哈希表将 `'N'`、`'S'`、`'E'`、`'W'` 对应横纵坐标轴上的改变表示出来。
2. 使用集合 $visited$ 存储走过的坐标元组。
3. 遍历 $path$，按照 $path$ 所指示的路径模拟行走，并将所走过的坐标使用 $visited$ 存储起来。
4. 如果在 $visited$ 遇到已经走过的坐标，则返回 $True$。
5. 如果遍历完仍未发现已经走过的坐标，则返回 $False$。

### 思路 1：代码

```Python
class Solution:
    def isPathCrossing(self, path: str) -> bool:
        directions = {
            "N" : (-1, 0),
            "S" : (1, 0),
            "W" : (0, -1),
            "E" : (0, 1),
        }

        x, y = 0, 0
        
        visited = set()
        visited.add((x, y))
        
        for ch in path:
            x += directions[ch][0]
            y += directions[ch][1]
            if (x, y) in visited:
                return True
            visited.add((x, y))
        
        return False
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $path$ 的长度。
- **空间复杂度**：$O(n)$。

# [1502. 判断能否形成等差数列](https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/)

- 标签：数组、排序
- 难度：简单

## 题目链接

- [1502. 判断能否形成等差数列 - 力扣](https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/)

## 题目大意

**描述**：给定一个数字数组 `arr`。如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数序就称为等差数列。

**要求**：如果数组 `arr` 通过重新排列可以形成等差数列，则返回 `True`；否则返回 `False`。

**说明**：

- $2 \le arr.length \le 1000$
- $-10^6 \le arr[i] \le 10^6$

**示例**：

- 示例 1：

```python
输入：arr = [3,5,1]
输出：True
解释：数组重新排序后得到 [1,3,5] 或者 [5,3,1]，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。
```

## 解题思路

### 思路 1：

- 如果数组元素个数小于等于 `2`，则数组肯定可以形成等差数列，直接返回 `True`。
- 对数组进行排序。
- 从下标为 `2` 的元素开始，遍历相邻的 `3` 个元素 `arr[i]` 、`arr[i - 1]`、`arr[i - 2]`。判断 `arr[i] - arr[i - 1]` 是否等于 `arr[i - 1] - arr[i - 2]`。如果不等于，则数组无法形成等差数列，返回 `False`。
- 如果遍历完数组，则说明数组可以形成等差数列，返回 `True`。

## 代码

### 思路 1 代码：

```python
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        size = len(arr)
        if size <= 2:
            return True

        arr.sort()
        for i in range(2, size):
            if arr[i] - arr[i - 1] != arr[i - 1] - arr[i - 2]:
                return False
        return True
```

# [1507. 转变日期格式](https://leetcode.cn/problems/reformat-date/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1507. 转变日期格式 - 力扣](https://leetcode.cn/problems/reformat-date/)

## 题目大意

**描述**：给定一个字符串 $date$，它的格式为 `Day Month Year` ，其中：

- $Day$ 是集合 `{"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}` 中的一个元素。
- $Month$ 是集合 `{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}` 中的一个元素。
- $Year$ 的范围在 $[1900, 2100]$ 之间。

**要求**：将字符串转变为 `YYYY-MM-DD` 的格式，其中：

- $YYYY$ 表示 $4$ 位的年份。
- $MM$ 表示 $2$ 位的月份。
- $DD$ 表示 $2$ 位的天数。

**说明**：

- 给定日期保证是合法的，所以不需要处理异常输入。

**示例**：

- 示例 1：

```python
输入：date = "20th Oct 2052"
输出："2052-10-20"
```

- 示例 2：

```python
输入：date = "6th Jun 1933"
输出："1933-06-06"
```

## 解题思路

### 思路 1：模拟

1. 将字符串分割为三部分，分别按照以下规则得到日、月、年：
   1. 日：去掉末尾两位英文字母，将其转为整型数字，并且进行补零操作，使其宽度为 $2$。
   2. 月：使用哈希表将其映射为对应两位数字。
   3. 年：直接赋值。
2. 将得到的年、月、日使用 `"-"` 进行链接并返回。

### 思路 1：代码

```python
class Solution:
    def reformatDate(self, date: str) -> str:
        months = {
            "Jan" : "01", "Feb" : "02", "Mar" : "03", "Apr" : "04", "May" : "05", "Jun" : "06", 
            "Jul" : "07", "Aug" : "08", "Sep" : "09", "Oct" : "10", "Nov" : "11", "Dec" : "12"
        }
        date_list = date.split(' ')
        day = "{:0>2d}".format(int(date_list[0][: -2]))
        month = months[date_list[1]]
        year = date_list[2]
        return year + "-" + month + "-" + day
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。

# [1523. 在区间范围内统计奇数数目](https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/)

- 标签：数学
- 难度：简单

## 题目链接

- [1523. 在区间范围内统计奇数数目 - 力扣](https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/)

## 题目大意

**描述**：给定两个非负整数 `low` 和 `high`。

**要求**：返回 `low` 与 `high` 之间（包括二者）的奇数数目。

**说明**：

- $0 \le low \le high \le 10^9$。

**示例**：

- 示例 1：

```python
输入：low = 3, high = 7
输出：3
解释：3 到 7 之间奇数数字为 [3,5,7]
```

## 解题思路

### 思路 1：

暴力枚举 `[low, high]` 之间的奇数可能会超时。我们可以通过公式直接计算出 `[0, low - 1]` 之间的奇数个数和 `[0, high]` 之间的奇数个数，然后将两者相减即为答案。

计算奇数个数的公式为：$pre(x) = \lfloor \frac{x + 1}{2} \rfloor$。

## 代码

### 思路 1 代码：

```python
class Solution:
    def pre(self, val):
        return (val + 1) >> 1

    def countOdds(self, low: int, high: int) -> int:
        return self.pre(high) - self.pre(low - 1)
```

# [1534. 统计好三元组](https://leetcode.cn/problems/count-good-triplets/)

- 标签：数组、枚举
- 难度：简单

## 题目链接

- [1534. 统计好三元组 - 力扣](https://leetcode.cn/problems/count-good-triplets/)

## 题目大意

**描述**：给定一个整数数组 $arr$，以及 $a$、$b$、$c$ 三个整数。

**要求**：统计其中好三元组的数量。

**说明**：

- **好三元组**：如果三元组（$arr[i]$、$arr[j]$、$arr[k]$）满足下列全部条件，则认为它是一个好三元组。
  - $0 \le i < j < k < arr.length$。
  - $| arr[i] - arr[j] | \le a$。
  - $| arr[j] - arr[k] | \le b$。
  - $| arr[i] - arr[k] | \le c$。

- $3 \le arr.length \le 100$。
- $0 \le arr[i] \le 1000$。
- $0 \le a, b, c \le 1000$。

**示例**：

- 示例 1：

```python
输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
输出：4
解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]。
```

- 示例 2：

```python
输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1
输出：0
解释：不存在满足所有条件的三元组。
```

## 解题思路

### 思路 1：枚举

- 使用三重循环依次枚举所有的 $(i, j, k)$，判断对应 $arr[i]$、$arr[j]$、$arr[k]$ 是否满足条件。
- 然后统计出所有满足条件的三元组的数量。

### 思路 1：代码

```python
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        size = len(arr)
        ans = 0
        
        for i in range(size):
            for j in range(i + 1, size):
                for k in range(j + 1, size):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        ans += 1
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 是数组 $arr$ 的长度。
- **空间复杂度**：$O(1)$。

### 思路 2：枚举优化 + 前缀和

我们可以先通过二重循环遍历二元组 $(j, k)$，找出所有满足 $| arr[j] - arr[k] | \le b$ 的二元组。

然后在 $| arr[j] - arr[k] | \le b$ 的条件下，我们需要找到满足以下要求的 $arr[i]$ 数量：

1. $i < j$。
2. $| arr[i] - arr[j] | \le a$。
3. $| arr[i] - arr[k] | \le c$。
4. $0 \le arr[i] \le 1000$。

其中 $2$、$3$ 去除绝对值之后可变为：

1. $arr[j] - a \le arr[i] \le arr[j] + a$。
2. $arr[k] - c \le arr[i] \le arr[k] + c$。

将这两个条件再结合第 $4$ 个条件综合一下就变为：$max(0, arr[j] - a, arr[k] - c) \le arr[i] \le min(arr[j] + a, arr[k] + c, 1000)$。

假如定义 $left = max(0, arr[j] - a, arr[k] - c)$，$right = min(arr[j] + a, arr[k] + c, 1000)$。

现在问题就转变了如何快速获取在值域区间 $[left, right]$ 中，有多少个 $arr[i]$。

我们可以利用前缀和数组，先计算出 $[0, 1000]$ 范围中，满足 $arr[i] < num$ 的元素个数，即为 $prefix\underline{\hspace{0.5em}}cnts[num]$。

然后对于区间 $[left, right]$，通过 $prefix\underline{\hspace{0.5em}}cnts[right] - prefix\underline{\hspace{0.5em}}cnts[left - 1]$ 即可快速求解出区间 $[left, right]$ 内 $arr[i]$ 的个数。

因为 $i < j < k$，所以我们可以在每次 $j$ 向右移动一位的时候，更新 $arr[j]$ 对应的前缀和数组，保证枚举到 $j$ 时，$prefix\underline{\hspace{0.5em}}cnts$ 存储对应元素值的个数足够正确。

### 思路 2：代码

```python
class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        size = len(arr)
        ans = 0
        prefix_cnts = [0 for _ in range(1010)]

        for j in range(size):
            for k in range(j + 1, size):
                if abs(arr[j] - arr[k]) <= b:
                    left_j, right_j = arr[j] - a, arr[j] + a
                    left_k, right_k = arr[k] - c, arr[k] + c
                    left, right = max(0, left_j, left_k), min(1000, right_j, right_k)
                    if left <= right:
                        if left == 0:
                            ans += prefix_cnts[right]
                        else:
                            ans += prefix_cnts[right] - prefix_cnts[left - 1]

            for k in range(arr[j], 1001):
                prefix_cnts[k] += 1
        
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n^2 + n \times S)$，其中 $n$ 是数组 $arr$ 的长度，$S$ 为数组的值域上限。
- **空间复杂度**：$O(S)$。

# [1547. 切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

- 标签：数组、动态规划、排序
- 难度：困难

## 题目链接

- [1547. 切棍子的最小成本 - 力扣](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

## 题目大意

**描述**：给定一个整数 $n$，代表一根长度为 $n$ 个单位的木根，木棍从 $0 \sim n$ 标记了若干位置。例如，长度为 $6$ 的棍子可以标记如下：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg)

再给定一个整数数组 $cuts$，其中 $cuts[i]$ 表示需要将棍子切开的位置。

我们可以按照顺序完成切割，也可以根据需要更改切割顺序。

每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是所有次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根小木棍的长度和就是切割前木棍的长度）。

**要求**：返回切棍子的最小总成本。

**说明**：

- $2 \le n \le 10^6$。
- $1 \le cuts.length \le min(n - 1, 100)$。
- $1 \le cuts[i] \le n - 1$。
- $cuts$ 数组中的所有整数都互不相同。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg)

```python
输入：n = 7, cuts = [1,3,4,5]
输出：16
解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示。
第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg)

- 示例 2：

```python
输入：n = 9, cuts = [5,6,1,4,2]
输出：22
解释：如果按给定的顺序切割，则总成本为 25。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。
```

## 解题思路

### 思路 1：动态规划

我们可以预先在数组 $cuts$ 种添加位置 $0$ 和位置 $n$，然后对数组 $cuts$ 进行排序。这样待切割的木棍就对应了数组中连续元素构成的「区间」。

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：切割区间为 $[i, j]$ 上的小木棍的最小成本。

###### 3. 状态转移方程

假设位置 $i$ 与位置 $j$ 之间最后一个切割的位置为 $k$，则 $dp[i][j]$ 取决与由 $k$ 作为切割点分割出的两个区间 $[i, k]$ 与 $[k, j]$ 上的最小成本 + 切割位置 $k$ 所带来的成本。

而切割位置 $k$ 所带来的成本是这段区间所代表的小木棍的长度，即 $cuts[j] - cuts[i]$。

则状态转移方程为：$dp[i][j] = min \lbrace dp[i][k] + dp[k][j] + cuts[j] - cuts[i] \rbrace, \quad i < k < j$

###### 4. 初始条件

- 相邻位置之间没有切割点，不需要切割，最小成本为 $0$，即 $dp[i - 1][i] = 0$。
- 其余位置默认为最小成本为一个极大值，即 $dp[i][j] = \infty, \quad i + 1 \ne j$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：切割区间为 $[i, j]$ 上的小木棍的最小成本。 所以最终结果为 $dp[0][size - 1]$。

### 思路 1：代码

```python
class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts.append(0)
        cuts.append(n)
        cuts.sort()
        
        size = len(cuts)
        dp = [[float('inf') for _ in range(size)] for _ in range(size)]
        for i in range(1, size):
            dp[i - 1][i] = 0

        for l in range(3, size + 1):        # 枚举区间长度
            for i in range(size):           # 枚举区间起点
                j = i + l - 1               # 根据起点和长度得到终点                            
                if j >= size:      
                    continue
                dp[i][j] = float('inf')
                for k in range(i + 1, j):   # 枚举区间分割点
                    # 状态转移方程，计算合并区间后的最优值
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])
        return dp[0][size - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m^3)$，其中 $m$ 为数组 $cuts$ 的元素个数。
- **空间复杂度**：$O(m^2)$。
# [1551. 使数组中所有元素相等的最小操作数](https://leetcode.cn/problems/minimum-operations-to-make-array-equal/)

- 标签：数学
- 难度：中等

## 题目链接

- [1551. 使数组中所有元素相等的最小操作数 - 力扣](https://leetcode.cn/problems/minimum-operations-to-make-array-equal/)

## 题目大意

**描述**：存在一个长度为 $n$ 的数组 $arr$，其中 $arr[i] = (2 \times i) + 1$，$(0 \le i < n)$。

在一次操作中，我们可以选出两个下标，记作 $x$ 和 $y$（$0 \le x, y < n$），并使 $arr[x]$ 减去 $1$，$arr[y]$ 加上 $1$）。最终目标是使数组中所有元素都相等。

现在给定一个整数 $n$，即数组 $arr$ 的长度。

**要求**：返回使数组 $arr$ 中所有元素相等所需要的最小操作数。

**说明**：

- 题目测试用例将会保证：在执行若干步操作后，数组中的所有元素最终可以全部相等。
- $1 \le n \le 10^4$。

**示例**：

- 示例 1：

```python
输入：n = 3
输出：2
解释：arr = [1, 3, 5]
第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4]
第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3]
```

- 示例 2：

```python
输入：n = 6
输出：9
```

## 解题思路

### 思路 1：贪心

通过观察可以发现，数组中所有元素构成了一个等差数列，为了使所有元素相等，在每一次操作中，尽可能让较小值增大，让较大值减小，直到到达平均值为止，这样才能得到最小操作次数。

在一次操作中，我们可以同时让第 $i$ 个元素增大与第 $n - 1 - i$ 个元素减小。这样，我们只需要统计出数组前半部分元素变化幅度即可。

### 思路 1：代码

```python
class Solution:
    def minOperations(self, n: int) -> int:
        ans = 0
        for i in range(n // 2):
            ans += n - 1 - 2 * i
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：贪心 + 优化

数组前半部分元素变化幅度的计算可以看做是一个等差数列求和，所以我们可以直接根据高斯求和公式求出结果。

$\lbrace n - 1 + [n - 1 - 2 * (n \div 2 - 1)]\rbrace \times (n \div 2) \div 2 = n \times n \div 4$

### 思路 2：代码

```python
class Solution:
    def minOperations(self, n: int) -> int:
        return n * n // 4
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。
# [1556. 千位分隔数](https://leetcode.cn/problems/thousand-separator/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1556. 千位分隔数 - 力扣](https://leetcode.cn/problems/thousand-separator/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：每隔三位田间点（即 `"."` 符号）作为千位分隔符，并将结果以字符串格式返回。

**说明**：

- $0 \le n \le 2^{31}$。

**示例**：

- 示例 1：

```python
输入：n = 987
输出："987"
```

- 示例 2：

```python
输入：n = 123456789
输出："123.456.789"
```

## 解题思路

### 思路 1：模拟

1. 使用字符串变量 $ans$ 用于存储答案，使用一个计数器 $idx$ 来记录当前位数的个数。
2. 将 $n$ 转为字符串 $s$ 后，从低位向高位遍历。
3. 将当前数字 $s[i]$ 存入 $ans$ 中，计数器加 $1$，当计数器为 $3$ 的整数倍并且当前数字位不是最高位时，将 `"."` 存入 $ans$ 中。
4. 遍历完成后，将 $ans$ 翻转后返回。

### 思路 1：代码

```python
class Solution:
    def thousandSeparator(self, n: int) -> str:
        s = str(n)
        ans = ""

        idx = 0
        for i in range(len(s) - 1, -1, -1):
            ans += s[i]
            idx += 1
            if idx % 3 == 0 and i != 0:
                ans += "."

        return ''.join(reversed(ans))
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。

# [1561. 你可以获得的最大硬币数目](https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/)

- 标签：贪心、数组、数学、博弈、排序
- 难度：中等

## 题目链接

- [1561. 你可以获得的最大硬币数目 - 力扣](https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/)

## 题目大意

有 `3*n` 堆数目不一的硬币，三个人按照下面的规则分硬币：

- 每一轮选出任意 3 堆硬币。
- Alice 拿走硬币数量最多的那一堆。
- 我们自己拿走硬币数量第二多的那一堆。
- Bob 拿走最后一堆。
- 重复这个过程，直到没有更多硬币。

现在给定一个整数数组 `piles`，代表 `3*n` 堆硬币，其中 `piles[i]` 表示第 `i` 堆中硬币的数目。

## 解题思路

每次 `3` 堆，总共取 `n` 次。Bob 每次总是选择最少的一堆，所以最终 Bob 得到 `3*n` 堆中最少的 `n` 堆才能使得另外两个人获得更多。所以先对硬币堆进行排序。Bob 拿走最少的 `n` 堆。我们接着分剩下的 `2*n` 堆。

按照大小顺序，每次都选取硬币数目最多的两堆， Alice 取得较大的一堆，我们取较小的一堆。

然后继续在剩余堆中选取硬币数目最多的两堆，同样 Alice 取得较大的一堆，我们取较小的一堆。

只有这样才能在满足规则的情况下，使我们所获得硬币数最多。

最后统计我们所获取的硬币数，并返回结果。

## 代码

```python
class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort()
        ans = 0
        for i in range(len(piles) // 3, len(piles), 2):
            ans += piles[i]
        return ans
```

# [1567. 乘积为正数的最长子数组长度](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/)

- 标签：贪心、数组、动态规划
- 难度：中等

## 题目链接

- [1567. 乘积为正数的最长子数组长度 - 力扣](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/)

## 题目大意

给定一个整数数组 `nums`。

要求：求出乘积为正数的最长子数组的长度。

- 子数组：是由原数组中零个或者更多个连续数字组成的数组。

## 解题思路

使用动态规划来做。使用数组 `pos` 表示以下标 `i` 结尾的乘积为正数的最长子数组长度。使用数组 `neg` 表示以下标 `i` 结尾的乘积为负数的最长子数组长度。

- 先初始化 `pos[0]`、`neg[0]`。
  - 如果 `nums[0] == 0`，则 `pos[0] = 0, neg[0] = 0`。
  - 如果 `nums[0] > 0`，则 `pos[0] = 1, neg[0] = 0`。
  - 如果 `nums[0] < 0`，则 `pos[0] = 0, neg[0] = 1`。

- 然后从下标 `1` 开始递推遍历数组 `nums`，对于 `nums[i - 1]` 和 `nums[i]`：

  - 如果 `nums[i - 1] == 0`，显然有 `pos[i] = 0`，`neg[i] = 0`。表示：以`i` 结尾的乘积为正数的最长子数组长度为 `0`，以`i` 结尾的乘积为负数数的最长子数组长度也为 `0`。

  - 如果 `nums[i - 1] > 0`，则 `pos[i] = pos[i - 1] + 1`。而 `neg[i]` 需要进行判断，如果 `neg[i - 1] > 0`，则再乘以当前 `nums[i]` 后仍为负数，此时长度 +1，即 `neg[i] = neg[i - 1] + 1 `。而如果 `neg[i - 1] == 0`，则 `neg[i] = 0`。

  - 如果 `nums[i - 1] < 0`，则 `pos[i]` 需要进行判断，如果 `neg[i - 1] > 0`，再乘以当前 `nums[i]` 后变为正数，此时长度 +1，即 `pos[i] = neg[i - 1] + 1`。而如果 `neg[i - 1] = 0`，则 `pos[i] = 0`。
  - 更新 `ans` 答案为 `pos[i]` 最大值。

- 最后输出答案 `ans`。

## 代码

```python
class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        size = len(nums)
        pos = [0 for _ in range(size + 1)]
        neg = [0 for _ in range(size + 1)]

        if nums[0] == 0:
            pos[0], neg[0] = 0, 0
        elif nums[0] > 0:
            pos[0], neg[0] = 1, 0
        else:
            pos[0], neg[0] = 0, 1

        ans = pos[0]
        for i in range(1, size):
            if nums[i] == 0:
                pos[i] = 0
                neg[i] = 0
            elif nums[i] > 0:
                pos[i] = pos[i - 1] + 1
                neg[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0
            elif nums[i] < 0:
                pos[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0
                neg[i] = pos[i - 1] + 1
            ans = max(ans, pos[i])
        return ans
```

## 参考资料

- 【题解】[递推就完事了，巨好理解~ - 乘积为正数的最长子数组长度 - 力扣](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solution/di-tui-jiu-wan-shi-liao-ju-hao-li-jie-by-time-limi/)
# [1582. 二进制矩阵中的特殊位置](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/)

- 标签：数组、矩阵
- 难度：简单

## 题目链接

- [1582. 二进制矩阵中的特殊位置 - 力扣](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/)

## 题目大意

**描述**：给定一个 $m \times n$ 的二进制矩阵 $mat$。

**要求**：返回矩阵 $mat$ 中特殊位置的数量。

**说明**：

- **特殊位置**：如果位置 $(i, j)$ 满足 $mat[i][j] == 1$ 并且行 $i$ 与列 $j$ 中的所有其他元素都是 $0$（行和列的下标从 $0$ 开始计数），那么它被称为特殊位置。
- $m == mat.length$。
- $n == mat[i].length$。
- $1 \le m, n \le 100$。
- $mat[i][j]$ 是 $0$ 或 $1$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/12/23/special1.jpg)

```python
输入：mat = [[1,0,0],[0,0,1],[1,0,0]]
输出：1
解释：位置 (1, 2) 是一个特殊位置，因为 mat[1][2] == 1 且第 1 行和第 2 列的其他所有元素都是 0。
```

- 示例 2：

![img](https://assets.leetcode.com/uploads/2021/12/24/special-grid.jpg)

```python
输入：mat = [[1,0,0],[0,1,0],[0,0,1]]
输出：3
解释：位置 (0, 0)，(1, 1) 和 (2, 2) 都是特殊位置。
```

## 解题思路

### 思路 1：模拟

1. 按照行、列遍历二位数组 $mat$。
2. 使用数组 $row\underline{\hspace{0.5em}}cnts$、$col\underline{\hspace{0.5em}}cnts$ 分别记录每行和每列所含 $1$ 的个数。
3. 再次按照行、列遍历二维数组 $mat$。
4. 统计满足 $mat[row][col] == 1$ 并且 $row\underline{\hspace{0.5em}}cnts[row] == col\underline{\hspace{0.5em}}cnts[col] == 1$ 的位置个数。 
5. 返回答案。

### 思路 1：代码

```Python
class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        rows, cols = len(mat), len(mat[0])
        row_cnts = [0 for _ in range(rows)]
        col_cnts = [0 for _ in range(cols)]

        for row in range(rows):
            for col in range(cols):
                row_cnts[row] += mat[row][col]
                col_cnts[col] += mat[row][col]

        ans = 0
        for row in range(rows):
            for col in range(cols):
                if mat[row][col] == 1 and row_cnts[row] == 1 and col_cnts[col] == 1:
                    ans += 1
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$、$n$ 分别为数组 $mat$ 的行数和列数。
- **空间复杂度**：$O(m + n)$。

# [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

- 标签：并查集、图、数组、最小生成树
- 难度：中等

## 题目链接

- [1584. 连接所有点的最小费用 - 力扣](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

## 题目大意

**描述**：给定一个 $points$ 数组，表示 2D 平面上的一些点，其中 $points[i] = [x_i, y_i]$。

链接点 $[x_i, y_i]$ 和点 $[x_j, y_j]$ 的费用为它们之间的 **曼哈顿距离**：$|x_i - x_j| + |y_i - y_j|$。其中 $|val|$ 表示 $val$ 的绝对值。

**要求**：返回将所有点连接的最小总费用。

**说明**：

- 只有任意两点之间有且仅有一条简单路径时，才认为所有点都已连接。
- $1 \le points.length \le 1000$。
- $-10^6 \le x_i, y_i \le 10^6$。
- 所有点 $(x_i, y_i)$ 两两不同。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/08/26/d.png)

![](https://assets.leetcode.com/uploads/2020/08/26/c.png)

```python
输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
输出：20
解释：我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。
注意到任意两个点之间只有唯一一条路径互相到达。
```

- 示例 2：

```python
输入：points = [[3,12],[-2,5],[-4,1]]
输出：18
```

## 解题思路

将所有点之间的费用看作是边，则所有点和边可以看作是一个无向图。每两个点之间都存在一条无向边，边的权重为两个点之间的曼哈顿距离。将所有点连接的最小总费用，其实就是求无向图的最小生成树。对此我们可以使用 Prim 算法或者 Kruskal 算法。

### 思路 1：Prim 算法

每次选择最短边来扩展最小生成树，从而保证生成树的总权重最小。算法通过不断扩展小生成树的顶点集合 $MST$，逐步构建出最小生成树。

### 思路 1：代码

```Python
class Solution:
    def distance(self, point1, point2):
        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

    def Prim(self, points, start):
        size = len(points)
        vis = set()
        dis = [float('inf') for _ in range(size)]

        ans = 0                     # 最小生成树的边权值
        dis[start] = 0              # 起始位置到起始位置的边权值初始化为 0

        for i in range(1, size):
            dis[i] = self.distance(points[start], points[i])
        vis.add(start)

        for _ in range(size - 1):       # 进行 n 轮迭代
            min_dis = float('inf')
            min_dis_i = -1
            for i in range(size):
                if i not in vis and dis[i] < min_dis:
                    min_dis = dis[i]
                    min_dis_i = i
            if min_dis_i == -1:
                return -1

            ans += min_dis
            vis.add(min_dis_i)
            

            for i in range(size):
                if i not in vis:
                    dis[i] = min(dis[i], self.distance(points[i], points[min_dis_i]))

        return ans

    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        return self.Prim(points, 0)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n^2)$。

### 思路 2：Kruskal 算法

通过依次选择权重最小的边并判断其两个端点是否连接在同一集合中，从而逐步构建最小生成树。这个过程保证了最终生成的树是无环的，并且总权重最小。

### 思路 2：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)
    

class Solution:
    def Kruskal(self, edges, size):
        union_find = UnionFind(size)
        
        edges.sort(key=lambda x: x[2])
        
        ans, cnt = 0, 0
        for x, y, dist in edges:
            if union_find.is_connected(x, y):
                continue
            ans += dist
            cnt += 1
            union_find.union(x, y)
            if cnt == size - 1:
                return ans
        return ans
    
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        size = len(points)
        edges = []
        for i in range(size):
            xi, yi = points[i]
            for j in range(i + 1, size):
                xj, yj = points[j]
                dist = abs(xi - xj) + abs(yi - yj)
                edges.append([i, j, dist])
                
        ans = self.Kruskal(edges, size)
        return ans

```

### 思路 2：复杂度分析

- **时间复杂度**：$O(m \times \log(n))$。其中 $m$ 为边数，$n$ 为节点数，本题中 $m = n^2$。
- **空间复杂度**：$O(n^2)$。

# [1593. 拆分字符串使唯一子字符串的数目最大](https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/)

- 标签：哈希表、字符串、回溯
- 难度：中等

## 题目链接

- [1593. 拆分字符串使唯一子字符串的数目最大 - 力扣](https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/)

## 题目大意

**描述**：给定一个字符串 $s$。将字符串 $s$ 拆分后可以得到若干非空子字符串，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是唯一的 。

**要求**：拆分该字符串，并返回拆分后唯一子字符串的最大数目。

**说明**：

- 子字符串是字符串中的一个连续字符序列。
- $1 \le s.length \le 16$。
- $s$ 仅包含小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "ababccc"
输出：5
解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。
```

- 示例 2：

```python
输入：s = "aba"
输出：2
解释：一种最大拆分方法为 ['a', 'ba']。
```

## 解题思路

### 思路 1：回溯算法

维护一个全局变量 $ans$ 用于记录拆分后唯一子字符串的最大数目。并使用集合 $s\underline{\hspace{0.5em}}set$ 记录不重复的子串。

- 从下标为 $0$ 开头的子串回溯。
- 对于下标为 $index$ 开头的子串，我们可以在 $index + 1$ 开始到 $len(s) - 1$ 的位置上，分别进行子串拆分，将子串拆分为 $s[index: i + 1]$。

- 如果当前子串不在 $s\underline{\hspace{0.5em}}set$ 中，则将其存入 $s\underline{\hspace{0.5em}}set$ 中，然后记录当前拆分子串个数，并从 $i + 1$ 的位置进行下一层递归拆分。然后在拆分完，对子串进行回退操作。
- 如果拆到字符串 $s$ 的末尾，则记录并更新 $ans$。
- 在开始位置还可以进行以下剪枝：如果剩余字符个数 + 当前子串个数 <= 当前拆分后子字符串的最大数目，则直接返回。

最后输出 $ans$。

### 思路 1：代码

```python
class Solution:
    ans = 0
    def backtrack(self, s, index, count, s_set):
        if len(s) - index + count <= self.ans:
            return 
        if index >= len(s):
            self.ans = max(self.ans, count)
            return

        for i in range(index, len(s)):
            sub_s = s[index: i + 1]
            if sub_s not in s_set:
                s_set.add(sub_s)
                self.backtrack(s, i + 1, count + 1, s_set)
                s_set.remove(sub_s)


    def maxUniqueSplit(self, s: str) -> int:
        s_set = set()
        self.ans = 0
        self.backtrack(s, 0, 0, s_set)
        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为字符串的长度。
- **空间复杂度**：$O(n)$。

# [1595. 连通两组点的最小成本](https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/)

- 标签：位运算、数组、动态规划、状态压缩、矩阵
- 难度：困难

## 题目链接

- [1595. 连通两组点的最小成本 - 力扣](https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/)

## 题目大意

**描述**：有两组点，其中一组中有 $size_1$ 个点，第二组中有 $size_2$ 个点，且 $size_1 \ge size_2$。现在给定一个大小为 $size_1 \times size_2$ 的二维数组 $cost$ 用于表示两组点任意两点之间的链接成本。其中 $cost[i][j]$ 表示第一组中第 $i$ 个点与第二组中第 $j$ 个点的链接成本。

如果两个组中每个点都与另一个组中的一个或多个点连接，则称这两组点是连通的。 

**要求**：返回连通两组点所需的最小成本。

**说明**：

- $size_1 == cost.length$。
- $size_2 == cost[i].length$。
- $1 \le size_1, size_2 \le 12$。
- $size_1 \ge size_2$。
- $0 \le cost[i][j] \le 100$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex1.jpg)

```python
输入：cost = [[15, 96], [36, 2]]
输出：17
解释：连通两组点的最佳方法是：
1--A
2--B
总成本为 17。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex2.jpg)

```python
输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
输出：4
解释：连通两组点的最佳方法是：
1--A
2--B
2--C
3--A
最小成本为 4。
请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。
```

## 解题思路

### 思路 1：状压 DP



### 思路 1：代码

```python
class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        states = 1 << n
        dp = [[float('inf') for _ in range(states)] for _ in range(m + 1)]
        dp[0][0] = 0
        for i in range(1, m + 1):
            for state in range(states):
                for j in range(n):
                    dp[i][state | (1 << j)] = min(dp[i][state | (1 << j)], dp[i - 1][state] + cost[i - 1][j], dp[i][state] + cost[i - 1][j])

        return dp[m][states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

# [1603. 设计停车系统](https://leetcode.cn/problems/design-parking-system/)

- 标签：设计、计数、模拟
- 难度：简单

## 题目链接

- [1603. 设计停车系统 - 力扣](https://leetcode.cn/problems/design-parking-system/)

## 题目大意

给一个停车场设计一个停车系统。停车场总共有三种尺寸的车位：大、中、小，每种尺寸的车位分别有固定数目。

现在要求实现 `ParkingSystem` 类：

-  `ParkingSystem(big, medium, small)`：初始化 ParkingSystem 类，三个参数分别对应三种尺寸车位的数目。
- `addCar(carType) -> bool:`：检测是否有 `carType` 对应的停车位，如果有，则将车停入车位，并返回 `True`，否则返回 `False`。

## 解题思路

使用不同成员变量存放车位数目。并根据给定操作进行判断。

## 代码

```python
class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.park = [0, big, medium, small]

    def addCar(self, carType: int) -> bool:
        if self.park[carType] == 0:
            return False
        self.park[carType] -= 1
        return True
```

# [1605. 给定行和列的和求可行矩阵](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)

- 标签：贪心、数组、矩阵
- 难度：中等

## 题目链接

- [1605. 给定行和列的和求可行矩阵 - 力扣](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)

## 题目大意

**描述**：给你两个非负整数数组 `rowSum` 和 `colSum` ，其中 `rowSum[i]` 是二维矩阵中第 `i` 行元素的和，`colSum[j]` 是第 `j` 列元素的和。换句话说，我们不知道矩阵里的每个元素，只知道每一行的和，以及每一列的和。

**要求**：找到并返回一个大小为 `rowSum.length * colSum.length` 的任意非负整数矩阵，且该矩阵满足 `rowSum` 和 `colSum` 的要求。

**说明**：

- 返回任意一个满足题目要求的二维矩阵即可，题目保证存在至少一个可行矩阵。
- $1 \le rowSum.length, colSum.length \le 500$。
- $0 \le rowSum[i], colSum[i] \le 10^8$。
- $sum(rows) == sum(columns)$。

**示例**：

- 示例 1：

```python
输入：rowSum = [3,8], colSum = [4,7]
输出：[[3,0],
        [1,7]]

解释
第 0 行：3 + 0 = 3 == rowSum[0]
第 1 行：1 + 7 = 8 == rowSum[1]
第 0 列：3 + 1 = 4 == colSum[0]
第 1 列：0 + 7 = 7 == colSum[1]
行和列的和都满足题目要求，且所有矩阵元素都是非负的。
另一个可行的矩阵为   [[1,2],
                   [3,5]]
```

## 解题思路

### 思路 1：贪心算法

题目要求找出一个满足要求的非负整数矩阵，矩阵中元素值可以为 `0`。所以我们可以尽可能将大的值填入前面的行和列中，然后剩余位置用 `0` 补齐即可。具体做法如下：

1. 使用二维数组 `board` 来保存答案，初始情况下，`board` 中元素全部赋值为 `0`。
2. 遍历二维数组的每一行，每一列。当前位置下的值为当前行的和与当前列的和的较小值，即 `board[row][col] = min(rowSum[row], colSum[col])`。
3. 更新当前行的和，将当前行的和减去 `board[row][col]`。
4. 更新当前列的和，将当前列的和减去 `board[row][col]`。
5. 遍历完返回二维数组 `board`。

### 思路 1：贪心算法代码

```python
class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        rows, cols = len(rowSum), len(colSum)
        board = [[0 for _ in range(cols)] for _ in range(rows)]
        for row in range(rows):
            for col in range(cols):
                board[row][col] = min(rowSum[row], colSum[col])
                rowSum[row] -= board[row][col]
                colSum[col] -= board[row][col]
        return board
```
# [1614. 括号的最大嵌套深度](https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/)

- 标签：栈、字符串
- 难度：简单

## 题目链接

- [1614. 括号的最大嵌套深度 - 力扣](https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/)

## 题目大意

**描述**：给你一个有效括号字符串 $s$。

**要求**：返回该字符串 $s$ 的嵌套深度 。

**说明**：

- 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
  - 字符串是一个空字符串 `""`，或者是一个不为 `"("` 或 `")"` 的单字符。
  - 字符串可以写为 $AB$（$A$ 与 B 字符串连接），其中 $A$ 和 $B$ 都是有效括号字符串 。
  - 字符串可以写为 ($A$)，其中 $A$ 是一个有效括号字符串。

- 类似地，可以定义任何有效括号字符串 $s$ 的 嵌套深度 $depth(s)$：

  - `depth("") = 0`。
  - `depth(C) = 0`，其中 $C$ 是单个字符的字符串，且该字符不是 `"("` 或者 `")"`。
  - `depth(A + B) = max(depth(A), depth(B))`，其中 $A$ 和 $B$ 都是 有效括号字符串。
  - `depth("(" + A + ")") = 1 + depth(A)`，其中 A 是一个 有效括号字符串。
- $1 \le s.length \le 100$。
- $s$ 由数字 $0 \sim 9$ 和字符 `'+'`、`'-'`、`'*'`、`'/'`、`'('`、`')'` 组成。
- 题目数据保证括号表达式 $s$ 是有效的括号表达式。

**示例**：

- 示例 1：

```python
输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
```

- 示例 2：

```python
输入：s = "(1)+((2))+(((3)))"
输出：3
```

## 解题思路

### 思路 1：模拟

我们可以使用栈来进行模拟括号匹配。遍历字符串 $s$，如果遇到左括号，则将其入栈，如果遇到右括号，则弹出栈中的左括号，与当前右括号进行匹配。在整个过程中栈的大小的最大值，就是我们要求的 $s$ 的嵌套深度，其实也是求最大的连续左括号的数量（跳过普通字符，并且与右括号匹配后）。具体步骤如下：

1. 使用 $ans$ 记录最大的连续左括号数量，使用 $cnt$ 记录当前栈中左括号的数量。
2. 遍历字符串 $s$：
   1. 如果遇到左括号，则令 $cnt$ 加 $1$。
   2. 如果遇到右括号，则令 $cnt$ 减 $1$。
   3. 将 $cnt$ 与答案进行比较，更新最大的连续左括号数量。
3. 遍历完字符串 $s$，返回答案 $ans$。

### 思路 1：代码

```Python
class Solution:
    def maxDepth(self, s: str) -> int:
        ans, cnt = 0, 0
        for ch in s:
            if ch == '(':
                cnt += 1
            elif ch == ')':
                cnt -= 1
            ans = max(ans, cnt)

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(1)$。

# [1617. 统计子树中城市之间最大距离](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/)

- 标签：位运算、树、动态规划、状态压缩、枚举
- 难度：困难

## 题目链接

- [1617. 统计子树中城市之间最大距离 - 力扣](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/)

## 题目大意

**描述**：给定一个整数 $n$，代表 $n$ 个城市，城市编号为 $1 \sim n$。同时给定一个大小为 $n - 1$ 的数组 $edges$，其中 $edges[i] = [u_i, v_i]$ 表示城市 $u_i$ 和 $v_i$ 之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵树。

**要求**：返回一个大小为 $n - 1$ 的数组，其中第 $i$ 个元素（下标从 $1$ 开始）是城市间距离恰好等于 $i$ 的子树数目。

**说明**：

- **两个城市间距离**：定义为它们之间需要经过的边的数目。
- **一棵子树**：城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。
- $2 \le n \le 15$。
- $edges.length == n - 1$。
- $edges[i].length == 2$。
- $1 \le u_i, v_i \le n$。
- 题目保证 $(ui, vi)$ 所表示的边互不相同。

**示例**：

- 示例 1：

```python
输入：n = 4, edges = [[1,2],[2,3],[2,4]]
输出：[3,4,0]
解释：
子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。
子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。
不存在城市间最大距离为 3 的子树。
```

- 示例 2：

```python
输入：n = 2, edges = [[1,2]]
输出：[1]
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

因为题目中给定 $n$ 的范围为 $2 \le n \le 15$，范围比较小，我们可以通过类似「[0078. 子集](https://leetcode.cn/problems/subsets/)」中二进制枚举的方式，得到所有子树的子集。

而对于一个确定的子树来说，求子树中两个城市间距离就是在求子树的直径，这就跟 [「1245. 树的直径」](https://leetcode.cn/problems/tree-diameter/) 和 [「2246. 相邻字符不同的最长路径」](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/) 一样了。

那么这道题的思路就变成了：

1. 通过二进制枚举的方式，得到所有子树。
2. 对于当前子树，通过树形 DP + 深度优先搜索的方式，计算出当前子树的直径。
3. 统计所有子树直径中经过的不同边数个数，将其放入答案数组中。

### 思路 1：代码

```python
class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]                              # 建图
        for u, v in edges:
            graph[u - 1].append(v - 1)
            graph[v - 1].append(u - 1)

        def dfs(mask, u):
            nonlocal visited, diameter
            visited |= 1 << u                                       # 标记 u 访问过
            u_len = 0                                               # u 节点的最大路径长度
            for v in graph[u]:                                      # 遍历 u 节点的相邻节点
                if (visited >> v) & 1 == 0 and mask >> v & 1:       # v 没有访问过，且在子集中
                    v_len = dfs(mask, v)                            # 相邻节点的最大路径长度
                    diameter = max(diameter, u_len + v_len + 1)     # 维护最大路径长度
                    u_len = max(u_len, v_len + 1)                   # 更新 u 节点的最大路径长度
            return u_len
        
        ans = [0 for _ in range(n - 1)]

        for mask in range(3, 1 << n):                               # 二进制枚举子集
            if mask & (mask - 1) == 0:                              # 子集至少需要两个点
                continue
            visited = 0
            diameter = 0
            u = mask.bit_length() - 1        
            dfs(mask, u)                                            # 在子集 mask 中递归求树的直径
            if visited == mask:
                ans[diameter - 1] += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为给定的城市数目。
- **空间复杂度**：$O(n)$。
# [1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、二分查找、矩阵、堆（优先队列）
- 难度：中等

## 题目链接

- [1631. 最小体力消耗路径 - 力扣](https://leetcode.cn/problems/path-with-minimum-effort/)

## 题目大意

**描述**：给定一个 $rows \times cols$ 大小的二维数组 $heights$，其中 $heights[i][j]$ 表示为位置 $(i, j)$ 的高度。

现在要从左上角 $(0, 0)$ 位置出发，经过方格的一些点，到达右下角 $(n - 1, n - 1)$  位置上。其中所经过路径的花费为「这条路径上所有相邻位置的最大高度差绝对值」。

**要求**：计算从 $(0, 0)$ 位置到 $(n - 1, n - 1)$  的最优路径的花费。

**说明**：

- **最优路径**：路径上「所有相邻位置最大高度差绝对值」最小的那条路径。
- $rows == heights.length$。
- $columns == heights[i].length$。
- $1 \le rows, columns \le 100$。
- $1 \le heights[i][j] \le 10^6$。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png)

```python
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3。
```

- 示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png)

```python
输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。
```

## 解题思路

### 思路 1：并查集

将整个网络抽象为一个无向图，每个点与相邻的点（上下左右）之间都存在一条无向边，边的权重为两个点之间的高度差绝对值。

我们要找到左上角到右下角的最优路径，可以遍历所有的点，将所有的边存储到数组中，每条边的存储格式为 $[x, y, h]$，意思是编号 $x$ 的点和编号为 $y$ 的点之间的权重为 $h$。

然后按照权重从小到大的顺序，对所有边进行排序。

再按照权重大小遍历所有边，将其依次加入并查集中。并且每次都需要判断 $(0, 0)$ 点和 $(n - 1, n - 1)$ 点是否连通。

如果连通，则该边的权重即为答案。

### 思路 1：代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        row_size = len(heights)
        col_size = len(heights[0])
        size = row_size * col_size
        edges = []
        for row in range(row_size):
            for col in range(col_size):
                if row < row_size - 1:
                    x = row * col_size + col
                    y = (row + 1) * col_size + col
                    h = abs(heights[row][col] - heights[row + 1][col])
                    edges.append([x, y, h])
                if col < col_size - 1:
                    x = row * col_size + col
                    y = row * col_size + col + 1
                    h = abs(heights[row][col] - heights[row][col + 1])
                    edges.append([x, y, h])

        edges.sort(key=lambda x: x[2])

        union_find = UnionFind(size)

        for edge in edges:
            x, y, h = edge[0], edge[1], edge[2]
            union_find.union(x, y)
            if union_find.is_connected(0, size - 1):
                return h
        return 0
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n \times \alpha(m \times n))$，其中 $\alpha$ 是反 Ackerman 函数。
- **空间复杂度**：$O(m \times n)$。

# [1641. 统计字典序元音字符串的数目](https://leetcode.cn/problems/count-sorted-vowel-strings/)

- 标签：数学、动态规划、组合数学
- 难度：中等

## 题目链接

- [1641. 统计字典序元音字符串的数目 - 力扣](https://leetcode.cn/problems/count-sorted-vowel-strings/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回长度为 $n$、仅由原音（$a$、$e$、$i$、$o$、$u$）组成且按字典序排序的字符串数量。

**说明**：

- 字符串 $a$ 按字典序排列需要满足：对于所有有效的 $i$，$s[i]$ 在字母表中的位置总是与 $s[i + 1]$ 相同或在 $s[i+1] $之前。
- $1 \le n \le 50$。

**示例**：

- 示例 1：

```python
输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 ["a","e","i","o","u"]
```

- 示例 2：

```python
输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]
注意，"ea" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
```

## 解题思路

### 思路 1：组和数学

题目要求按照字典序排列，则如果确定了每个元音的出现次数可以确定一个序列。

对于长度为 $n$ 的序列，$a$、$e$、$i$、$o$、$u$ 出现次数加起来为 $n$ 次，且顺序为  $a…a \rightarrow e…e \rightarrow i…i  \rightarrow o…o  \rightarrow u…u$。

我们可以看作是将 $n$ 分隔成了 $5$ 份，每一份对应一个原音字母的数量。

我们可以使用「隔板法」的方式，看作有 $n$ 个球，$4$ 个板子，将 $n$ 个球分隔成 $5$ 份。

则一共有 $n + 4$ 个位置可以放板子，总共需要放 $4$ 个板子，则答案为 $C_{n + 4}^4$，其中 $C$ 为组和数。

### 思路 1：代码

```Python
class Solution:
    def countVowelStrings(self, n: int) -> int:
        return comb(n + 4, 4)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(| \sum |)$，其中 $\sum$ 为字符集，本题中 $| \sum | = 5$ 。
- **空间复杂度**：$O(1)$。

# [1646. 获取生成数组中的最大值](https://leetcode.cn/problems/get-maximum-in-generated-array/)

- 标签：数组、动态规划、模拟
- 难度：简单

## 题目链接

- [1646. 获取生成数组中的最大值 - 力扣](https://leetcode.cn/problems/get-maximum-in-generated-array/)

## 题目大意

**描述**：给定一个整数 $n$，按照下述规则生成一个长度为 $n + 1$ 的数组 $nums$：

- $nums[0] = 0$。
- $nums[1] = 1$。
- 当 $2 \le 2 \times i \le n$ 时，$nums[2 \times i] = nums[i]$。
- 当 $2 \le 2 \times i + 1 \le n$ 时，$nums[2 \times i + 1] = nums[i] + nums[i + 1]$。

**要求**：返回生成数组 $nums$ 中的最大值。

**说明**：

- $0 \le n \le 100$。

**示例**：

- 示例 1：

```python
输入：n = 7
输出：3
解释：根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
```

- 示例 2：

```python
输入：n = 2
输出：1
解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
```

## 解题思路

### 思路 1：模拟

1. 按照题目要求，定义一个长度为 $n + 1$ 的数组 $nums$。
2. 按照规则模拟生成对应的 $nums$ 数组元素。
3. 求出数组 $nums$ 中最大值，并作为答案返回。

### 思路 1：代码

```python
class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        if n <= 1:
            return n
            
        nums = [0 for _ in range(n + 1)]
        nums[1] = 1

        for i in range(n):
            if 2 * i <= n:
                nums[2 * i] = nums[i]
            if 2 * i + 1 <= n:
                nums[2 * i + 1] = nums[i] + nums[i + 1]

        ans = max(nums)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [1647. 字符频次唯一的最小删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/)

- 标签：贪心、哈希表、字符串、排序
- 难度：中等

## 题目链接

- [1647. 字符频次唯一的最小删除次数 - 力扣](https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/)

## 题目大意

**描述**：给定一个字符串 $s$。

**要求**：返回使 $s$ 成为优质字符串需要删除的最小字符数。

**说明**：

- **频次**：指的是该字符在字符串中的出现次数。例如，在字符串 `"aab"` 中，`'a'` 的频次是 $2$，而 `'b'` 的频次是 $1$。
- **优质字符串**：如果字符串 $s$ 中不存在两个不同字符频次相同的情况，就称 $s$ 是优质字符串。
- $1 \le s.length \le 10^5$。
- $s$ 仅含小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "aab"
输出：0
解释：s 已经是优质字符串。
```

- 示例 2：

```python
输入：s = "aaabbbcc"
输出：2
解释：可以删除两个 'b' , 得到优质字符串 "aaabcc" 。
另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 "aaabbc"。
```

## 解题思路

### 思路 1：贪心算法 + 哈希表

1. 使用哈希表 $cnts$ 统计每字符串中每个字符出现次数。
2. 然后使用集合 $s\underline{\hspace{0.5em}}set$ 保存不同的出现次数。
3. 遍历哈希表中所偶出现次数：
   1. 如果当前出现次数不在集合 $s\underline{\hspace{0.5em}}set$ 中，则将该次数添加到集合 $s\underline{\hspace{0.5em}}set$ 中。
   2. 如果当前出现次数在集合 $s\underline{\hspace{0.5em}}set$ 中，则不断减少该次数，直到该次数不在集合 $s\underline{\hspace{0.5em}}set$ 中停止，将次数添加到集合 $s\underline{\hspace{0.5em}}set$ 中，同时将减少次数累加到答案 $ans$ 中。
4. 遍历完哈希表后返回答案 $ans$。

### 思路 1：代码

```Python
class Solution:
    def minDeletions(self, s: str) -> int:
        cnts = Counter(s)
        s_set = set()

        ans = 0
        for key, value in cnts.items():
            while value > 0 and value in s_set:
                value -= 1
                ans += 1
            s_set.add(value)
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [1657. 确定两个字符串是否接近](https://leetcode.cn/problems/determine-if-two-strings-are-close/)

- 标签：哈希表、字符串、排序
- 难度：中等

## 题目链接

- [1657. 确定两个字符串是否接近 - 力扣](https://leetcode.cn/problems/determine-if-two-strings-are-close/)

## 题目大意

**描述**：如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：

- 操作 1：交换任意两个现有字符。
  - 例如，`abcde` -> `aecdb`。
- 操作 2：将一个 现有 字符的每次出现转换为另一个现有字符，并对另一个字符执行相同的操作。
  - 例如，`aacabb` -> `bbcbaa`（所有 `a` 转化为 `b`，而所有的 `b` 转换为 `a` ）。

给定两个字符串，$word1$ 和 $word2$。

**要求**：如果 $word1$ 和 $word2$ 接近 ，就返回 $True$；否则，返回 $False$。

**说明**：

- $1 \le word1.length, word2.length \le 10^5$。
- $word1$ 和 $word2$ 仅包含小写英文字母。

**示例**：

- 示例 1：

```python
输入：word1 = "abc", word2 = "bca"
输出：True
解释：2 次操作从 word1 获得 word2 。
执行操作 1："abc" -> "acb"
执行操作 1："acb" -> "bca"
```

- 示例 2：

```python
输入：word1 = "a", word2 = "aa"
输出：False
解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。
```

## 解题思路

### 思路 1：模拟

无论是操作 1，还是操作 2，只是对字符位置进行交换，而不会产生或者删除字符。

则我们只需要检查两个字符串的字符种类以及每种字符的个数是否相同即可。

具体步骤如下：

1. 分别使用哈希表 $cnts1$、$cnts2$ 统计每个字符串中的字符种类，每种字符的个数。
2. 判断两者的字符种类是否相等，并且判断每种字符的个数是否相同。
3. 如果字符种类相同，且每种字符的个数完全相同，则返回 $True$，否则，返回 $False$。

### 思路 1：代码

```Python
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        cnts1 = Counter(word1)
        cnts2 = Counter(word2)

        return cnts1.keys() == cnts2.keys() and sorted(cnts1.values()) == sorted(cnts2.values())
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(max(n1, n2) + |\sum| \times \log | \sum |)$，其中 $n1$、$n2$ 分别为字符串 $word1$、$word2$ 的长度，$\sum$ 为字符集，本题中 $| \sum | = 26$。
- **空间复杂度**：$O(| \sum |)$。

# [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

- 标签：数组、哈希表、二分查找、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [1658. 将 x 减到 0 的最小操作数 - 力扣](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $x$ 。每一次操作时，你应当移除数组 $nums$ 最左边或最右边的元素，然后从 $x$ 中减去该元素的值。请注意，需要修改数组以供接下来的操作使用。

**要求**：如果可以将 $x$ 恰好减到 $0$，返回最小操作数；否则，返回 $-1$。

**说明**：

- $1 \le nums.length \le 10^5$。
- $1 \le nums[i] \le 10^4$。
- $1 \le x \le 10^9$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,4,2,3], x = 5
输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0。
```

- 示例 2：

```python
输入：nums = [3,2,20,1,1,3], x = 10
输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0。
```

## 解题思路

### 思路 1：滑动窗口

将 $x$ 减到 $0$ 的最小操作数可以转换为求和等于 $sum(nums) - x$ 的最长连续子数组长度。我们可以维护一个区间和为 $sum(nums) - x$ 的滑动窗口，求出最长的窗口长度。具体做法如下：

令 `target = sum(nums) - x`，使用 $max\underline{\hspace{0.5em}}len$ 维护和等于 $target$ 的最长连续子数组长度。然后用滑动窗口 $window\underline{\hspace{0.5em}}sum$ 来记录连续子数组的和，设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口中的和刚好等于 $target$。

- 一开始，$left$、$right$ 都指向 $0$。
- 向右移动 $right$，将最右侧元素加入当前窗口和 $window\underline{\hspace{0.5em}}sum$ 中。
- 如果 $window\underline{\hspace{0.5em}}sum > target$，则不断右移 $left$，缩小滑动窗口长度，并更新窗口和的最小值，直到 $window\underline{\hspace{0.5em}}sum \le target$。
- 如果 $window\underline{\hspace{0.5em}}sum == target$，则更新最长连续子数组长度。
- 然后继续右移 $right$，直到 $right \ge len(nums)$ 结束。
- 输出 $len(nums) - max\underline{\hspace{0.5em}}len$ 作为答案。
- 注意判断题目中的特殊情况。

### 思路 1：代码

```python
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        target = sum(nums) - x
        size = len(nums)
        if target < 0:
            return -1
        if target == 0:
            return size
        left, right = 0, 0
        window_sum = 0
        max_len = float('-inf')

        while right < size:
            window_sum += nums[right]

            while window_sum > target:
                window_sum -= nums[left]
                left += 1
            if window_sum == target:
                max_len = max(max_len, right - left + 1)
            right += 1
        return len(nums) - max_len if max_len != float('-inf') else -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。

# [1672. 最富有客户的资产总量](https://leetcode.cn/problems/richest-customer-wealth/)

- 标签：数组、矩阵
- 难度：简单

## 题目链接

- [1672. 最富有客户的资产总量 - 力扣](https://leetcode.cn/problems/richest-customer-wealth/)

## 题目大意

**描述**：给定一个 $m \times n$ 的整数网格 $accounts$，其中 $accounts[i][j]$ 是第 $i$ 位客户在第 $j$ 家银行托管的资产数量。

**要求**：返回最富有客户所拥有的资产总量。

**说明**：

- 客户的资产总量：指的是他们在各家银行托管的资产数量之和。
- 最富有客户：资产总量最大的客户。
- $m == accounts.length$。
- $n == accounts[i].length$。
- $1 \le m, n \le 50$。
- $1 \le accounts[i][j] \le 100$。

**示例**：

- 示例 1：

```python
输入：accounts = [[1,2,3],[3,2,1]]
输出：6
解释：
第 1 位客户的资产总量 = 1 + 2 + 3 = 6
第 2 位客户的资产总量 = 3 + 2 + 1 = 6
两位客户都是最富有的，资产总量都是 6 ，所以返回 6。
```

- 示例 2：

```python
输入：accounts = [[1,5],[7,3],[3,5]]
输出：10
解释：
第 1 位客户的资产总量 = 6
第 2 位客户的资产总量 = 10 
第 3 位客户的资产总量 = 8
第 2 位客户是最富有的，资产总量是 10，随意返回 10。
```

## 解题思路

### 思路 1：直接模拟

1. 使用变量 $max\underline{\hspace{0.5em}}ans$ 存储最富有客户所拥有的资产总量。
2. 遍历所有客户，对于当前客户 $accounts[i]$，统计其拥有的资产总量。
3. 将当前客户的资产总量与 $max\underline{\hspace{0.5em}}ans$ 进行比较，如果大于 $max\underline{\hspace{0.5em}}ans$，则更新 $max\underline{\hspace{0.5em}}ans$ 的值。
4. 遍历完所有客户，最终返回 $max\underline{\hspace{0.5em}}ans$ 作为结果。

### 思路 1：代码

```python
class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        max_ans = 0
        for i in range(len(accounts)):
            total = 0
            for j in range(len(accounts[i])):
                total += accounts[i][j]
            if total > max_ans:
                max_ans = total
        return max_ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 和 $n$ 分别为二维数组 $accounts$ 的行数和列数。两重循环遍历的时间复杂度为 $O(m * n)$ 。
- **空间复杂度**：$O(1)$。
# [1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/)

- 标签：数组、哈希表、滑动窗口
- 难度：中等

## 题目链接

- [1695. 删除子数组的最大得分 - 力扣](https://leetcode.cn/problems/maximum-erasure-value/)

## 题目大意

**描述**：给定一个正整数数组 $nums$，从中删除一个含有若干不同元素的子数组。删除子数组的「得分」就是子数组各元素之和 。

**要求**：返回只删除一个子数组可获得的最大得分。

**说明**：

- **子数组**：如果数组 $b$ 是数组 $a$ 的一个连续子序列，即如果它等于 $a[l],a[l+1],...,a[r]$ ，那么它就是 $a$ 的一个子数组。
- $1 \le nums.length \le 10^5$。
- $1 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [4,2,4,5,6]
输出：17
解释：最优子数组是 [2,4,5,6]
```

- 示例 2：

```python
输入：nums = [5,2,1,2,5,2,1,2,5]
输出：8
解释：最优子数组是 [5,2,1] 或 [1,2,5]
```

## 解题思路

### 思路 1：滑动窗口

题目要求的是含有不同元素的连续子数组最大和，我们可以用滑动窗口来做，维护一个不包含重复元素的滑动窗口，计算最大的窗口和。具体方法如下：

- 用滑动窗口 $window$ 来记录不重复的元素个数，$window$ 为哈希表类型。用 $window\underline{\hspace{0.5em}}sum$ 来记录窗口内子数组元素和，$ans$ 用来维护最大子数组和。设定两个指针：$left$、$right$，分别指向滑动窗口的左右边界，保证窗口中没有重复元素。

- 一开始，$left$、$right$ 都指向 $0$。
- 将最右侧数组元素 $nums[right]$ 加入当前窗口 $window$ 中，记录该元素个数。
- 如果该窗口中该元素的个数多于 $1$ 个，即 $window[s[right]] > 1$，则不断右移 $left$，缩小滑动窗口长度，并更新窗口中对应元素的个数，直到 $window[s[right]] \le 1$。
- 维护更新无重复元素的最大子数组和。然后右移 $right$，直到 $right \ge len(nums)$ 结束。
- 输出无重复元素的最大子数组和。

### 思路 1：代码

```python
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        window_sum = 0
        left, right = 0, 0
        window = dict()
        ans = 0
        while right < len(nums):
            window_sum += nums[right]
            if nums[right] not in window:
                window[nums[right]] = 1
            else:
                window[nums[right]] += 1

            while window[nums[right]] > 1:
                window[nums[left]] -= 1
                window_sum -= nums[left]
                left += 1
            ans = max(ans, window_sum)
            right += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。

# [1698. 字符串的不同子字符串个数](https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/)

- 标签：字典树、字符串、后缀数组、哈希函数、滚动哈希
- 难度：中等

## 题目链接

- [1698. 字符串的不同子字符串个数 - 力扣](https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/)

## 题目大意

给定一个字符串 `s`。

要求：返回 `s` 的不同子字符串的个数。

注意：字符串的「子字符串」是由原字符串删除开头若干个字符（可能是 0 个）并删除结尾若干个字符（可能是 0 个）形成的字符串。

## 解题思路

构建一颗字典树。分别将原字符串删除开头若干个字符的子字符串依次插入到字典树中。

每次插入过程中碰到字典树中没有的字符节点时，说明此时插入的字符串可作为新的子字符串。

我们可以通过统计插入过程中新建字符节点的次数的方式来获取不同子字符串的个数。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> int:
        """
        Inserts a word into the trie.
        """
        cur = self
        cnt = 0
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
                cnt += 1
            cur = cur.children[ch]
        cur.isEnd = True
        return cnt


class Solution:
    def countDistinct(self, s: str) -> int:
        trie_tree = Trie()
        cnt = 0
        for i in range(len(s)):
            cnt += trie_tree.insert(s[i:])
        return cnt
```

# [1710. 卡车上的最大单元数](https://leetcode.cn/problems/maximum-units-on-a-truck/)

- 标签：贪心、数组、排序
- 难度：简单

## 题目链接

- [1710. 卡车上的最大单元数 - 力扣](https://leetcode.cn/problems/maximum-units-on-a-truck/)

## 题目大意

**描述**：现在需要将一些箱子装在一辆卡车上。给定一个二维数组 $boxTypes$，其中 $boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]$。

$numberOfBoxesi$ 是类型 $i$ 的箱子的数量。$numberOfUnitsPerBoxi$ 是类型 $i$ 的每个箱子可以装载的单元数量。

再给定一个整数 $truckSize$ 表示一辆卡车上可以装载箱子的最大数量。只要箱子数量不超过 $truckSize$，你就可以选择任意箱子装到卡车上。

**要求**：返回卡车可以装载的最大单元数量。

**说明**：

- $1 \le boxTypes.length \le 1000$。
- $1 \le numberOfBoxesi, numberOfUnitsPerBoxi \le 1000$。
- $1 \le truckSize \le 106$。

**示例**：

- 示例 1：

```python
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
输出：8
解释
箱子的情况如下：
- 1 个第一类的箱子，里面含 3 个单元。
- 2 个第二类的箱子，每个里面含 2 个单元。
- 3 个第三类的箱子，每个里面含 1 个单元。
可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。
单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8
```

- 示例 2：

```python
输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
输出：91
```

## 解题思路

### 思路 1：贪心算法

题目中，一辆卡车上可以装载箱子的最大数量是固定的（$truckSize$），那么如果想要使卡车上装载的单元数量最大，就应该优先选取装载单元数量多的箱子。

所以，从贪心算法的角度来考虑，我们应该按照每个箱子可以装载的单元数量对数组 $boxTypes$ 从大到小排序。然后优先选取装载单元数量多的箱子。 

下面我们使用贪心算法三步走的方法解决这道题。

1. **转换问题**：将原问题转变为，在 $truckSize$ 的限制下，当选取完装载单元数量最多的箱子 $box$ 之后，再解决剩下箱子（$truckSize - box[0]$）的选择问题（子问题）。
2. **贪心选择性质**：对于当前 $truckSize$，优先选取装载单元数量最多的箱子。
3. **最优子结构性质**：在上面的贪心策略下，当前 $truckSize$ 的贪心选择 + 剩下箱子的子问题最优解，就是全局最优解。也就是说在贪心选择的方案下，能够使得卡车可以装载的单元数量达到最大。

使用贪心算法的解决步骤描述如下：

1. 对数组 $boxTypes$ 按照每个箱子可以装载的单元数量从大到小排序。使用变量 $res$ 记录卡车可以装载的最大单元数量。
2. 遍历数组 $boxTypes$，对于当前种类的箱子 $box$：
   1. 如果 $truckSize > box[0]$，说明当前种类箱子可以全部装载。则答案数量加上该种箱子的单元总数，即 $box[0] \times box[1]$，并且最大数量 $truckSize$ 减去装载的箱子数。
   2. 如果 $truckSize \le box[0]$，说明当前种类箱子只能部分装载。则答案数量加上 $truckSize \times box[1]$，并跳出循环。
3. 最后返回答案 $res$。

### 思路 1：代码

```python
class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        boxTypes.sort(key=lambda x:x[1], reverse=True)
        res = 0
        for box in boxTypes:
            if truckSize > box[0]:
                res += box[0] * box[1]
                truckSize -= box[0]
            else:
                res += truckSize * box[1]
                break
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 是数组 $boxTypes$ 的长度。
- **空间复杂度**：$O(\log n)$。
# [1716. 计算力扣银行的钱](https://leetcode.cn/problems/calculate-money-in-leetcode-bank/)

- 标签：数学
- 难度：简单

## 题目链接

- [1716. 计算力扣银行的钱 - 力扣](https://leetcode.cn/problems/calculate-money-in-leetcode-bank/)

## 题目大意

**描述**：Hercy 每天都往力扣银行里存钱。

最开始，他在周一的时候存入 $1$ 块钱。从周二到周日，他每天都比前一天多存入 $1$ 块钱。在接下来的每个周一，他都会比前一个周一多存入 $1$ 块钱。

给定一个整数 $n$。

**要求**：计算在第 $n$ 天结束的时候，Hercy 在力扣银行中总共存了多少块钱。

**说明**：

- $1 \le n \le 1000$。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：10
解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10。
```

- 示例 2：

```python
输入：n = 10
输出：37
解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。
```

## 解题思路

### 思路 1：暴力模拟

1. 记录当前周 $week$ 和当前周的当前天数 $day$。
2. 按照题目要求，每天增加 $1$ 块钱，每周一比上周一增加 $1$ 块钱。这样，每天存钱数为 $week + day - 1$。
3. 将每天存的钱数累加起来即为答案。

### 思路 1：代码

```python
class Solution:
    def totalMoney(self, n: int) -> int:
        weak, day = 1, 1
        ans = 0
        for i in range(n):
            ans += weak + day - 1
            day += 1
            if day == 8:
                day = 1
                weak += 1
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

### 思路 2：等差数列计算优化

每周一比上周一增加 $1$ 块钱，则每周七天存钱总数比上一周多 $7$ 块钱。所以每周存的钱数是一个等差数列。我们可以通过高斯求和公式求出所有整周存的钱数，再计算出剩下天数存的钱数，两者相加即为答案。

### 思路 2：代码

```python
class Solution:
    def totalMoney(self, n: int) -> int:
        week_cnt = n // 7
        weak_first_money = (1 + 7) * 7 // 2
        weak_last_money = weak_first_money + 7 * (week_cnt - 1)
        week_ans =  (weak_first_money + weak_last_money) * week_cnt // 2

        day_cnt = n % 7
        day_first_money = 1 + week_cnt
        day_last_money = day_first_money + day_cnt - 1
        day_ans = (day_first_money + day_last_money) * day_cnt // 2
        
        return week_ans + day_ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。
# [1720. 解码异或后的数组](https://leetcode.cn/problems/decode-xored-array/)

- 标签：位运算、数组
- 难度：简单

## 题目链接

- [1720. 解码异或后的数组 - 力扣](https://leetcode.cn/problems/decode-xored-array/)

## 题目大意

n 个非负整数构成数组 arr，经过编码后变为长度为 n-1 的整数数组 encoded，其中 `encoded[i] = arr[i] XOR arr[i+1]`。例如 arr = [1, 0, 2, 1] 经过编码后变为 encoded = [1, 2, 3]。

现在给定编码后的数组 encoded 和原数组 arr 的第一个元素 arr[0]。要求返回原数组 arr。

## 解题思路

首先要了解异或的性质：

- 异或运算满足交换律和结合律。
  - 交换律：`a^b = b^a`
  - 结合律：`(a^b)^c = a^(b^c)`
- 任何整数和自身做异或运算结果都为 0，即 `x^x = 0`。
- 任何整数和 0 做异或运算结果都为其本身，即 `x^0 = 0`。

已知当 $1 \le i \le n$ 时，有 `encoded[i-1] = arr[i-1] XOR arr[i]`。两边同时「异或」上 arr[i-1]。得：

- `encoded[i-1] XOR arr[i-1] = arr[i-1] XOR arr[i] XOR arr[i-1]`
- `encoded[i-1] XOR arr[i-1] = arr[i] XOR 0`
- `encoded[i-1] XOR arr[i-1] = arr[i]`

所以就可以根据所得结论 `arr[i] = encoded[i-1] XOR arr[i-1]` 模拟得出原数组 arr。

## 代码

```python
class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        n = len(encoded) + 1
        arr = [0] * n
        arr[0] = first
        for i in range(1, n):
            arr[i] = encoded[i-1] ^ arr[i-1]
        return arr
```

# [1726. 同积元组](https://leetcode.cn/problems/tuple-with-same-product/)

- 标签：数组、哈希表
- 难度：中等

## 题目链接

- [1726. 同积元组 - 力扣](https://leetcode.cn/problems/tuple-with-same-product/)

## 题目大意

**描述**：给定一个由不同正整数组成的数组 $nums$。

**要求**：返回满足 $a \times b = c \times d$ 的元组 $(a, b, c, d)$ 的数量。其中 $a$、$b$、$c$ 和 $d$ 都是 $nums$ 中的元素，且 $a \ne b \ne c \ne d$。

**说明**：

- $1 \le nums.length \le 1000$。
- $1 \le nums[i] \le 10^4$。
- $nums$ 中的所有元素互不相同。

**示例**：

- 示例 1：

```python
输入：nums = [2,3,4,6]
输出：8
解释：存在 8 个满足题意的元组：
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
```

- 示例 2：

```python
输入：nums = [1,2,4,5,10]
输出：16
解释：存在 16 个满足题意的元组：
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
```

## 解题思路

### 思路 1：哈希表 + 数学

1. 二重循环遍历数组 $nums$，使用哈希表 $cnts$ 记录下所有不同 $nums[i] \times nums[j]$ 的结果。
2. 因为满足 $a \times b = c \times d$ 的元组 $(a, b, c, d)$ 可以按照不同顺序进行组和，所以对于 $x$ 个 $nums[i] \times nums[j]$，就有 $C_x^2$ 种组和方法。
3. 遍历哈希表 $cnts$ 中所有值 $value$，将不同组和的方法数累积到答案 $ans$ 中。
4. 遍历完返回答案 $ans$。

### 思路 1：代码

```Python
class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        cnts = Counter()
        size = len(nums)
        for i in range(size):
            for j in range(i + 1, size):
                product = nums[i] * nums[j]
                cnts[product] += 1
        
        ans = 0
        for key, value in cnts.items():
            ans += value * (value - 1) * 4
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 表示数组 $nums$ 的长度。
- **空间复杂度**：$O(n^2)$。

# [1736. 替换隐藏数字得到的最晚时间](https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/)

- 标签：贪心、字符串
- 难度：简单

## 题目链接

- [1736. 替换隐藏数字得到的最晚时间 - 力扣](https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/)

## 题目大意

**描述**：给定一个字符串 $time$，格式为 `hh:mm`（小时：分钟），其中某几位数字被隐藏（用 `?` 表示）。

**要求**：替换 $time$ 中隐藏的数字，返回你可以得到的最晚有效时间。

**说明**：

- **有效时间**： `00:00` 到 `23:59` 之间的所有时间，包括 `00:00` 和 `23:59`。
- $time$ 的格式为 `hh:mm`。
- 题目数据保证你可以由输入的字符串生成有效的时间。

**示例**：

- 示例 1：

```python
输入：time = "2?:?0"
输出："23:50"
解释：以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50。
```

- 示例 2：

```python
输入：time = "0?:3?"
输出："09:39"
```

## 解题思路

### 思路 1：贪心算法

为了使有效时间尽可能晚，我们可以从高位到低位依次枚举所有符号为 `?` 的字符。在保证时间有效的前提下，每一位上取最大值，并进行保存。具体步骤如下：

- 如果第 $1$ 位为 `?`：
  - 如果第 $2$ 位已经确定，并且范围在 $[4, 9]$ 中间，则第 $1$ 位最大为 $1$；
  - 否则第 $1$ 位最大为 $2$。
- 如果第 $2$ 位为 `?`：
  - 如果第 $1$ 位上值为 $2$，则第 $2$ 位最大可以为 $3$；
  - 否则第 $2$ 位最大为 $9$。
- 如果第 $3$ 位为 `?`：
  - 第 $3$ 位最大可以为 $5$。
- 如果第 $4$ 位为 `?`：
  - 第 $4$ 位最大可以为 $9$。

### 思路 1：代码

```python
class Solution:
    def maximumTime(self, time: str) -> str:
        time_list = list(time)
        if time_list[0] == '?':
            if '4' <= time_list[1] <= '9':
                time_list[0] = '1'
            else:
                time_list[0] = '2'

        if time_list[1] == '?':
            if time_list[0] == '2':
                time_list[1] = '3'
            else:
                time_list[1] = '9'

        if time_list[3] == '?':
            time_list[3] = '5'
        
        if time_list[4] == '?':
            time_list[4] = '9'
            
        return "".join(time_list)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。

# [1742. 盒子中小球的最大数量](https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/)

- 标签：哈希表、数学、计数
- 难度：简单

## 题目链接

- [1742. 盒子中小球的最大数量 - 力扣](https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/)

## 题目大意

**描述**：给定两个整数 $lowLimit$ 和 $highLimt$，代表 $n$ 个小球的编号（包括 $lowLimit$ 和 $highLimit$，即 $n == highLimit = lowLimit + 1$）。另外有无限个盒子。

现在的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 $321$ 的小球应当放入编号 $3 + 2 + 1 = 6$ 的盒子，而编号 $10$ 的小球应当放入编号 $1 + 0 = 1$ 的盒子。

**要求**：返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。

**说明**：

- $1 \le lowLimit \le highLimit \le 10^5$。

**示例**：

- 示例 1：

```python
输入：lowLimit = 1, highLimit = 10
输出：2
解释：
盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：2 1 1 1 1 1 1 1 1 0  0  ...
编号 1 的盒子放有最多小球，小球数量为 2。
```

- 示例 2：

```python
输入：lowLimit = 5, highLimit = 15
输出：2
解释：
盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...
小球数量：1 1 1 1 2 2 1 1 1 0  0  ...
编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2。
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $lowLimit$、$highLimit$ 转为字符串 $s1$、$s2$，并将 $s1$ 补上前导 $0$，令其与 $s2$ 长度一致。定义递归函数 `def dfs(pos, remainTotal, isMaxLimit, isMinLimit):` 表示构造第 $pos$ 位及之后剩余数位和为 $remainTotal$ 的合法方案数。

因为数据范围为 $[1, 10^5]$，对应数位和范围为 $[1, 45]$。因此我们可以枚举所有的数位和，并递归调用 `dfs(i, remainTotal, isMaxLimit, isMinLimit)`，求出不同数位和对应的方案数，并求出最大方案数。

接下来按照如下步骤进行递归。

1. 从 `dfs(0, i, True, True)` 开始递归。 `dfs(0, i, True, True)` 表示：
	1. 从位置 $0$ 开始构造。
	2. 剩余数位和为 $i$。
	3. 开始时当前数位最大值受到最高位数位的约束。
	4. 开始时当前数位最小值受到最高位数位的约束。

2. 如果剩余数位和小于 $0$，说明当前方案不符合要求，则返回方案数 $0$。

3. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
	1. 如果剩余数位和 $remainTotal$ 等于 $0$，说明当前方案符合要求，则返回方案数 $1$。
	2. 如果剩余数位和 $remainTotal$ 不等于 $0$，说明当前方案不符合要求，则返回方案数 $0$。

4. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
5. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
6. 根据 $isMaxLimit$ 和 $isMinLimit$ 来决定填当前位数位所能选择的最小数字（$minX$）和所能选择的最大数字（$maxX$）。

7. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
8. 方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, remainTotal - d, isMaxLimit and d == maxX, isMinLimit and d == minX)`。
	1. `remainTotal - d` 表示当前剩余数位和减去 $d$。
	2. `isMaxLimit and d == maxX` 表示 $pos + 1$ 位最大值受到之前 $pos$ 位限制。
	3. `isMinLimit and d == maxX` 表示 $pos + 1$ 位最小值受到之前 $pos$ 位限制。
9. 最后返回所有 `dfs(0, i, True, True)` 中最大的方案数即可。

### 思路 1：代码

```python
class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        s1, s2 = str(lowLimit), str(highLimit)

        m, n = len(s1), len(s2)
        if m < n:
            s1 = '0' * (n - m) + s1
        
        @cache
        # pos: 第 pos 个数位
        # remainTotal: 表示剩余数位和
        # isMaxLimit: 表示是否受到上限选择限制。如果为真，则第 pos 位填入数字最多为 s2[pos]；如果为假，则最大可为 9。
        # isMinLimit: 表示是否受到下限选择限制。如果为真，则第 pos 位填入数字最小为 s1[pos]；如果为假，则最小可为 0。
        def dfs(pos, remainTotal, isMaxLimit, isMinLimit):
            if remainTotal < 0:
                return 0
            if pos == n:
                # remainTotal 为 0，则表示当前方案符合要求
                return int(remainTotal == 0)
            
            ans = 0
            # 如果前一位没有填写数字，或受到选择限制，则最小可选择数字为 s1[pos]，否则最少为 0（可以含有前导 0）。
            minX = int(s1[pos]) if isMinLimit else 0
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s2[pos]) if isMaxLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                ans += dfs(pos + 1, remainTotal - d, isMaxLimit and d == maxX, isMinLimit and d == minX)
            return ans

        ans = 0
        for i in range(46):
            ans = max(ans, dfs(0, i, True, True))
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n \times 45)$。
- **空间复杂度**：$O(\log n)$。
# [1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [1749. 任意子数组和的绝对值的最大值 - 力扣](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：找出 $nums$ 中「和的绝对值」最大的任意子数组（可能为空），并返回最大值。

**说明**：

- **子数组 $[nums_l, nums_{l+1}, ..., nums_{r-1}, nums_{r}]$ 的和的绝对值**：$abs(nums_l + nums_{l+1} + ... + nums_{r-1} + nums_{r})$。
- $abs(x)$ 定义如下：
  - 如果 $x$ 是负整数，那么 $abs(x) = -x$。
  - 如果 $x$ 是非负整数，那么 $abs(x) = x$。

- $1 \le nums.length \le 10^5$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1,-3,2,3,-4]
输出：5
解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5。
```

- 示例 2：

```python
输入：nums = [2,-5,1,-4,3,-2]
输出：8
解释：子数组 [-5,1,-4] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8。
```

## 解题思路

### 思路 1：动态规划

子数组和的绝对值的最大值，可能来自于「连续子数组的最大和」，也可能来自于「连续子数组的最小和」。

而求解「连续子数组的最大和」，我们可以参考「[0053. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)」的做法，使用一个变量 $mmax$ 来表示以第 $i$ 个数结尾的连续子数组的最大和。使用另一个变量 $mmin$ 来表示以第 $i$ 个数结尾的连续子数组的最小和。然后取两者绝对值的最大值为答案 $ans$。

具体步骤如下：

1. 遍历数组 $nums$，对于当前元素 $nums[i]$：
   1. 如果 $mmax < 0$，则「第 $i - 1$ 个数结尾的连续子数组的最大和」+「第 $i$  个数的值」<「第 $i$ 个数的值」，所以 $mmax$ 应取「第 $i$ 个数的值」，即：$mmax = nums[i]$。
   2. 如果 $mmax \ge 0$ ，则「第 $i - 1$ 个数结尾的连续子数组的最大和」 +「第 $i$  个数的值」 >= 第 $i$ 个数的值，所以 $mmax$ 应取「第 $i - 1$ 个数结尾的连续子数组的最大和」 +「第 $i$  个数的值」，即：$mmax = mmax + nums[i]$。
   3. 如果 $mmin > 0$，则「第 $i - 1$ 个数结尾的连续子数组的最大和」+「第 $i$  个数的值」>「第 $i$ 个数的值」，所以 $mmax$ 应取「第 $i$ 个数的值」，即：$mmax = nums[i]$。
   4. 如果 $mmin \le 0$ ，则「第 $i - 1$ 个数结尾的连续子数组的最大和」 +「第 $i$  个数的值」 <= 第 $i$ 个数的值，所以 $mmax$ 应取「第 $i - 1$ 个数结尾的连续子数组的最大和」 +「第 $i$  个数的值」，即：$mmin = mmin + nums[i]$。
   5. 维护答案 $ans$，将 $mmax$ 和 $mmin$ 绝对值的最大值与 $ans$ 进行比较，并更新 $ans$。
2. 遍历完返回答案 $ans$。

### 思路 1：代码

```python
class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        ans = 0
        mmax, mmin = 0, 0
        for num in nums:
            mmax = max(mmax, 0) + num
            mmin = min(mmin, 0) + num
            ans = max(ans, mmax, -mmin)

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [1763. 最长的美好子字符串](https://leetcode.cn/problems/longest-nice-substring/)

- 标签：位运算、哈希表、字符串、分治、滑动窗口
- 难度：简单

## 题目链接

- [1763. 最长的美好子字符串 - 力扣](https://leetcode.cn/problems/longest-nice-substring/)

## 题目大意

**描述**： 给定一个字符串 $s$。

**要求**：返回 $s$ 最长的美好子字符串。 

**说明**：

- **美好字符串**：当一个字符串 $s$ 包含的每一种字母的大写和小写形式同时出现在 $s$ 中，就称这个字符串 $s$ 是美好字符串。
- $1 \le s.length \le 100$。

**示例**：

- 示例 1：

```python
输入：s = "YazaAay"
输出："aAa"
解释："aAa" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。
"aAa" 是最长的美好子字符串。
```

- 示例 2：

```python
输入：s = "Bb"
输出："Bb"
解释："Bb" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。
```

## 解题思路

### 思路 1：枚举

字符串 $s$ 的范围为 $[1, 100]$，长度较小，我们可以枚举所有的子串，判断该子串是否为美好字符串。

由于大小写英文字母各有 $26$ 位，则我们可以利用二进制来标记某字符是否在子串中出现过，我们使用 $lower$ 标记子串中出现过的小写字母，使用 $upper$ 标记子串中出现过的大写字母。如果满足 $lower == upper$，则说明该子串为美好字符串。

具体解法步骤如下：

1. 使用二重循环遍历字符串。对于子串 $s[i]…s[j]$，使用 $lower$ 标记子串中出现过的小写字母，使用 $upper$ 标记子串中出现过的大写字母。
2. 如果 $s[j]$ 为小写字母，则 $lower$ 对应位置标记为出现过该小写字母，即：`lower |= 1 << (ord(s[j]) - ord('a'))`。
3. 如果 $s[j]$ 为大写字母，则 $upper$ 对应位置标记为出现过该小写字母，即：`upper |= 1 << (ord(s[j]) - ord('A'))`。
4. 判断当前子串对应 $lower$ 和 $upper$ 是否相等，如果相等，并且子串长度大于记录的最长美好字符串长度，则更新最长美好字符串长度。
5. 遍历完返回记录的最长美好字符串长度。

### 思路 1：代码

```Python
class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        size = len(s)
        max_pos, max_len = 0, 0
        for i in range(size):
            lower, upper = 0, 0
            for j in range(i, size):
                if s[j].islower():
                    lower |= 1 << (ord(s[j]) - ord('a'))
                else:
                    upper |= 1 << (ord(s[j]) - ord('A'))
                if lower == upper and j - i + 1 > max_len:
                    max_len = j - i + 1
                    max_pos = i
        return s[max_pos: max_pos + max_len]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(1)$。

# [1779. 找到最近的有相同 X 或 Y 坐标的点](https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/)

- 标签：数组
- 难度：简单

## 题目链接

- [1779. 找到最近的有相同 X 或 Y 坐标的点 - 力扣](https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/)

## 题目大意

**描述**：给定两个整数 `x` 和 `y`，表示笛卡尔坐标系下的 `(x, y)` 点。再给定一个数组 `points`，其中 `points[i] = [ai, bi]`，表示在 `(ai, bi)` 处有一个点。当一个点与 `(x, y)` 拥有相同的 `x` 坐标或者拥有相同的 `y` 坐标时，我们称这个点是有效的。

**要求**：返回数组中距离 `(x, y)` 点出曼哈顿距离最近的有效点在 `points` 中的下标位置。如果有多个最近的有效点，则返回下标最小的一个。如果没有有效点，则返回 `-1`。

**说明**：

- **曼哈顿距离**：`(x1, y1)` 和 `(x2, y2)` 之间的曼哈顿距离为 `abs(x1 - x2) + abs(y1 - y2)` 。
- $1 \le points.length \le 10^4$。
- $points[i].length == 2$。
- $1 \le x, y, ai, bi \le 10^4$。

**示例**：

- 示例 1：

```python
输入：x = 3, y = 4, points = [[1, 2], [3, 1], [2, 4], [2, 3], [4, 4]]
输出：2
解释：在所有点中 [3, 1]、[2, 4]、[4, 4] 为有效点。其中 [2, 4]、[4, 4] 距离 [3, 4] 曼哈顿距离最近，都为 1。[2, 4] 下标最小，所以返回 2。
```

## 解题思路

### 思路 1：

- 使用 `min_dist` 记录下有效点中最近的曼哈顿距离，初始化为 `float('inf')`。使用 `min_index` 记录下符合要求的最小下标。
- 遍历 `points` 数组，遇到有效点之后计算一下当前有效点与 `(x, y)` 的曼哈顿距离，并判断更新一下有效点中最近的曼哈顿距离 `min_dist` 和符合要求的最小下标 `min_index`。
- 遍历完之后，判断一下 `min_dist` 是否等于 `float('inf')`。如果等于，说明没有找到有效点，则返回 `-1`。如果不等于，则返回符合要求的最小下标 `min_index`。

## 代码

### 思路 1 代码：

```python
class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        min_dist = float('inf')
        min_index = 0
        for i in range(len(points)):
            if points[i][0] == x or points[i][1] == y:
                dist = abs(points[i][0] - x) + abs(points[i][1] - y)
                if dist < min_dist:
                    min_dist = dist
                    min_index = i

        if min_dist == float('inf'):
            return -1
        return min_index
```

# [1790. 仅执行一次字符串交换能否使两个字符串相等](https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/)

- 标签：哈希表、字符串、计数
- 难度：简单

## 题目链接

- [1790. 仅执行一次字符串交换能否使两个字符串相等 - 力扣](https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/)

## 题目大意

**描述**：给定两个长度相等的字符串 `s1` 和 `s2`。

已知一次「字符串交换操作」步骤如下：选出某个字符串中的两个下标（不一定要相同），并交换这两个下标所对应的字符。

**要求**：如果对其中一个字符串执行最多一次字符串交换可以使两个字符串相等，则返回 `True`；否则返回 `False`。

**说明**：

- $1 \le s1.length, s2.length \le 100$。
- $s1.length == s2.length$。
- `s1` 和 `s2` 仅由小写英文字母组成。

**示例**：

- 示例 1：

```python
给定：s1 = "bank", s2 = "kanb"
输出：True
解释：交换 s1 中的第一个和最后一个字符可以得到 "kanb"，与 s2 相同
```

## 解题思路

### 思路 1：

- 用一个变量 `diff_cnt` 记录两个字符串中对应位置上出现不同字符的次数。用 `c1`、`c2` 记录第一次出现不同字符时两个字符串对应位置上的字符。
- 遍历两个字符串，对于第 `i` 个位置的字符 `s1[i]` 和 `s2[i]`：
  - 如果 `s1[i] == s2[i]`，继续判断下一个位置。
  - 如果 `s1[i] != s2[i]`，则出现不同字符的次数加 `1`。
  - 如果出现不同字符的次数等于 `1`，则记录第一次出现不同字符时两个字符串对应位置上的字符。
  - 如果出现不同字符的次数等于 `2`，则判断第一次出现不同字符时两个字符串对应位置上的字符与当前位置字符交换之后是否相等。如果不等，则说明交换之后 `s1` 和 `s2` 不相等，返回 `False`。如果相等，则继续判断下一个位置。
  - 如果出现不同字符的次数超过 `2`，则不符合最多一次字符串交换的要求，返回 `False`。
- 如果遍历完，出现不同字符的次数为 `0` 或者 `2`，为 `0` 说明无需交换，本身 `s1` 和 `s2` 就是相等的，为 `2` 说明交换一次字符串之后  `s1` 和 `s2`  相等，此时返回 `True`。否则返回 `False`。

## 代码

### 思路 1 代码：

```python
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        size = len(s1)
        diff_cnt = 0
        c1, c2 = None, None
        for i in range(size):
            if s1[i] == s2[i]:
                continue
            diff_cnt += 1
            if diff_cnt == 1:
                c1 = s1[i]
                c2 = s2[i]
            elif diff_cnt == 2:
                if c1 != s2[i] or c2 != s1[i]:
                    return False
            else:
                return False

        return diff_cnt == 0 or diff_cnt == 2
```

# [1791. 找出星型图的中心节点](https://leetcode.cn/problems/find-center-of-star-graph/)

- 标签：图
- 难度：简单

## 题目链接

- [1791. 找出星型图的中心节点 - 力扣](https://leetcode.cn/problems/find-center-of-star-graph/)

## 题目大意

**描述**：有一个无向的行型图，由 $n$ 个编号 $1 \sim n$  的节点组成。星型图有一个中心节点，并且恰好有 $n - 1$ 条边将中心节点与其他每个节点连接起来。

给定一个二维整数数组 $edges$，其中 $edges[i] = [u_i, v_i]$ 表示节点 $u_i$ 与节点 $v_i$ 之间存在一条边。

**要求**：找出并返回该星型图的中心节点。

**说明**：

- $3 \le n \le 10^5$。
- $edges.length == n - 1$。
- $edges[i].length == 2$。
- $1 \le ui, vi \le n$。
- $ui \ne vi$。
- 题目数据给出的 $edges$ 表示一个有效的星型图。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png)

```python
输入：edges = [[1,2],[2,3],[4,2]]
输出：2
解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。
```

- 示例 2：

```python
输入：edges = [[1,2],[5,1],[1,3],[1,4]]
输出：1
```

## 解题思路

### 思路 1：求度数

根据题意可知：中心节点恰好有 $n - 1$ 条边将中心节点与其他每个节点连接起来，那么中心节点的度数一定为 $n - 1$。则我们可以遍历边集数组 $edges$，统计出每个节点 $u$ 的度数 $degrees[u]$。最后返回度数为 $n - 1$ 的节点编号。

### 思路 1：代码

```python
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        n = len(edges) + 1
        degrees = collections.Counter()

        for u, v in edges:
            degrees[u] += 1
            degrees[v] += 1

        for i in range(1, n + 1):
            if degrees[i] == n - 1:
                return i
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [1822. 数组元素积的符号](https://leetcode.cn/problems/sign-of-the-product-of-an-array/)

- 标签：数组、数学
- 难度：简单

## 题目链接

- [1822. 数组元素积的符号 - 力扣](https://leetcode.cn/problems/sign-of-the-product-of-an-array/)

## 题目大意

**描述**：已知函数 `signFunc(x)` 会根据 `x` 的正负返回特定值：

- 如果 `x` 是正数，返回 `1`。
- 如果 `x` 是负数，返回 `-1`。
- 如果 `x` 等于 `0`，返回 `0`。

现在给定一个整数数组 `nums`。令 `product` 为数组 `nums` 中所有元素值的乘积。

**要求**：返回 `signFun(product)` 的值。

**说明**：

- $1 \le nums.length \le 1000$。
- $-100 \le nums[i] \le 100$。

**示例**：

- 示例 1：

```python
输入 nums = [-1,-2,-3,-4,3,2,1]
输出 1
解释 数组中所有值的乘积是 144，且 signFunc(144) = 1
```

## 解题思路

### 思路 1：

题目要求的是数组所有值乘积的正负性，但是我们没必要将所有数乘起来再判断正负性。只需要统计出数组中负数的个数，再加以判断即可。

- 使用变量 `minus_count` 记录数组中负数个数。
- 然后遍历数组 `nums`，对于当前元素 `num`：
  - 如果为 `0`，则最终乘积肯定为 `0`，直接返回 `0`。
  - 如果小于 `0`，负数个数加 `1`。
- 最终统计出数组中负数的个数为 `minus_count`。
- 如果 `minus_count` 是 `2` 的倍数，则说明最终乘积为正数，返回 `1`。
- 如果 `minus_count` 不是 `2` 的倍数，则说明最终乘积为负数，返回 `-1`。

## 代码

### 思路 1 代码：

```python
class Solution:
    def arraySign(self, nums: List[int]) -> int:
        minus_count = 0
        for num in nums:
            if num < 0:
                minus_count += 1
            elif num == 0:
                return 0

        if minus_count % 2 == 0:
            return 1
        else:
            return -1
```

# [1827. 最少操作使数组递增](https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/)

- 标签：贪心、数组
- 难度：简单

## 题目链接

- [1827. 最少操作使数组递增 - 力扣](https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/)

## 题目大意

**描述**：给定一个整数数组 $nums$（下标从 $0$ 开始）。每一次操作中，你可以选择数组中的一个元素，并将它增加 $1$。

- 比方说，如果 $nums = [1,2,3]$，你可以选择增加 $nums[1]$ 得到 $nums = [1,3,3]$。

**要求**：请你返回使 $nums$ 严格递增的最少操作次数。

**说明**：

- 我们称数组 $nums$ 是严格递增的，当它满足对于所有的 $0 \le i < nums.length - 1$ 都有 $nums[i] < nums[i + 1]$。一个长度为 $1$ 的数组是严格递增的一种特殊情况。
- $1 \le nums.length \le 5000$。
- $1 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,1]
输出：3
解释：你可以进行如下操作：
1) 增加 nums[2] ，数组变为 [1,1,2]。
2) 增加 nums[1] ，数组变为 [1,2,2]。
3) 增加 nums[2] ，数组变为 [1,2,3]。
```

- 示例 2：

```python
输入：nums = [1,5,2,4,1]
输出：14
```

## 解题思路

### 思路 1：贪心算法

题目要求使 $nums$ 严格递增的最少操作次数。当遇到 $nums[i - 1] \ge nums[i]$ 时，我们应该在满足要求的同时，尽可能使得操作次数最少，则 $nums[i]$ 应增加到 $nums[i - 1] + 1$ 时，此时操作次数最少，并且满足 $nums[i - 1] < nums[i]$。

具体操作步骤如下：

1. 从左到右依次遍历数组元素。
2. 如果遇到 $nums[i - 1] \ge nums[i]$ 时：
   1. 本次增加的最少操作次数为 $nums[i - 1] + 1 - nums[i]$，将其计入答案中。
   2. 将 $nums[i]$ 变为 $nums[i - 1] + 1$。
3. 遍历完返回答案 $ans$。

### 思路 1：代码

```Python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(1, len(nums)):
            if nums[i - 1] >= nums[i]:
                ans += nums[i - 1] + 1 - nums[i]
                nums[i] = nums[i - 1] + 1
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。
# [1833. 雪糕的最大数量](https://leetcode.cn/problems/maximum-ice-cream-bars/)

- 标签：贪心、数组、排序
- 难度：中等

## 题目链接

- [1833. 雪糕的最大数量 - 力扣](https://leetcode.cn/problems/maximum-ice-cream-bars/)

## 题目大意

**描述**：给定一个数组 $costs$ 表示不同雪糕的定价，其中 $costs[i]$ 表示第 $i$ 支雪糕的定价。再给定一个整数 $coins$ 表示 Tony 一共有的现金数量。

**要求**：计算并返回 Tony 用 $coins$ 现金能够买到的雪糕的最大数量。

**说明**：

- $costs.length == n$。
- $1 \le n \le 10^5$。
- $1 \le costs[i] \le 10^5$。
- $1 \le coins \le 10^8$。

**示例**：

- 示例 1：

```python
输入：costs = [1,3,2,4,1], coins = 7
输出：4
解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7
```

- 示例 2：

```python
输入：costs = [10,6,8,7,7,8], coins = 5
输出：0
解释：Tony 没有足够的钱买任何一支雪糕。
```

## 解题思路

### 思路 1：排序 + 贪心

贪心思路，如果想尽可能买到多的雪糕，就应该优先选择价格便宜的雪糕。具体步骤如下：

1. 对数组 $costs$ 进行排序。
2. 按照雪糕价格从低到高开始买雪糕，并记录下购买雪糕的数量，知道现有钱买不起雪糕为止。
3. 输出购买雪糕的数量作为答案。

### 思路 1：代码

```python
class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        costs.sort()
        ans = 0
        for cost in costs:
            if coins >= cost:
                ans += 1
                coins -= cost
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log_2n)$。
- **空间复杂度**：$O(1)$。


# [1844. 将所有数字用字符替换](https://leetcode.cn/problems/replace-all-digits-with-characters/)

- 标签：字符串
- 难度：简单

## 题目链接

- [1844. 将所有数字用字符替换 - 力扣](https://leetcode.cn/problems/replace-all-digits-with-characters/)

## 题目大意

**描述**：给定一个下标从 $0$ 开始的字符串 $s$。字符串 $s$ 的偶数下标处为小写英文字母，奇数下标处为数字。

定义一个函数 `shift(c, x)`，其中 $c$ 是一个字符且 $x$ 是一个数字，函数返回字母表中 $c$ 后边第 $x$ 个字符。

- 比如，`shift('a', 5) = 'f'`，`shift('x', 0) = 'x'`。

对于每个奇数下标 $i$，我们需要将数字 $s[i]$ 用 `shift(s[i - 1], s[i])` 替换。

**要求**：替换字符串 $s$ 中所有数字以后，将字符串 $s$ 返回。

**说明**：

- 题目保证 `shift(s[i - 1], s[i])` 不会超过 `'z'`。
- $1 \le s.length \le 100$。
- $s$ 只包含小写英文字母和数字。
- 对所有奇数下标处的 $i$，满足 `shift(s[i - 1], s[i]) <= 'z'` 。

**示例**：

- 示例 1：

```python
输入：s = "a1c1e1"
输出："abcdef"
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('c',1) = 'd'
- s[5] -> shift('e',1) = 'f'
```

- 示例 2：

```python
输入：s = "a1b2c3d4e"
输出："abbdcfdhe"
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('b',2) = 'd'
- s[5] -> shift('c',3) = 'f'
- s[7] -> shift('d',4) = 'h'
```

## 解题思路

### 思路 1：模拟

1. 先定义一个 `shift(ch, x)` 用于替换 `s[i]`。
2. 将字符串转为字符串列表，定义为 $res$。
3. 以两个字符为一组遍历字符串，对 $res[i]$ 进行修改。
4. 将字符串列表连接起来，作为答案返回。

### 思路 1：代码

```python
class Solution:
    def replaceDigits(self, s: str) -> str:
        def shift(ch, x):
            return chr(ord(ch) + x) 
        
        res = list(s)
        for i in range(1, len(s), 2):
            res[i] = shift(res[i - 1], int(res[i]))
        
        return "".join(res)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

# [1858. 包含所有前缀的最长单词](https://leetcode.cn/problems/longest-word-with-all-prefixes/)

- 标签：深度优先搜索、字典树
- 难度：中等

## 题目链接

- [1858. 包含所有前缀的最长单词 - 力扣](https://leetcode.cn/problems/longest-word-with-all-prefixes/)

## 题目大意

给定一个字符串数组 `words`。

要求：找出 `words` 中所有前缀从都在 `words` 中的最长字符串。如果存在多个符合条件相同长度的字符串，则输出字典序中最小的字符串。如果不存在这样的字符串，返回 `' '`。

- 例如：令 `words = ["a", "app", "ap"]`。字符串 `"app"` 含前缀 `"ap"` 和 `"a"` ，都在 `words` 中。

## 解题思路

使用字典树存储所有单词，再将字典中单词按照长度从大到小、字典序从小到大排序。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]
            if not cur.isEnd:
                return False
        return True


class Solution:
    def longestWord(self, words: List[str]) -> str:
        tire_tree = Trie()
        for word in words:
            tire_tree.insert(word)
        words.sort(key=lambda x:(-len(x), x))
        for word in words:
            if tire_tree.search(word):
                return word
        return ''
```

# [1859. 将句子排序](https://leetcode.cn/problems/sorting-the-sentence/)

- 标签：字符串、排序
- 难度：简单

## 题目链接

- [1859. 将句子排序 - 力扣](https://leetcode.cn/problems/sorting-the-sentence/)

## 题目大意

**描述**：给定一个句子 $s$，句子中包含的单词不超过 $9$ 个。并且句子 $s$ 中每个单词末尾添加了「从 $1$ 开始的单词位置索引」，并且将句子中所有单词打乱顺序。

举个例子，句子 `"This is a sentence"` 可以被打乱顺序得到 `"sentence4 a3 is2 This1"` 或者 `"is2 sentence4 This1 a3"` 。

**要求**：重新构造并得到原本顺序的句子。

**说明**：

- **一个句子**：指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。
- $2 \le s.length \le 200$。
- $s$ 只包含小写和大写英文字母、空格以及从 $1$ 到 $9$ 的数字。
- $s$ 中单词数目为 $1$ 到 $9$ 个。
- $s$ 中的单词由单个空格分隔。
- $s$ 不包含任何前导或者后缀空格。

**示例**：

- 示例 1：

```python
输入：s = "is2 sentence4 This1 a3"
输出："This is a sentence"
解释：将 s 中的单词按照初始位置排序，得到 "This1 is2 a3 sentence4" ，然后删除数字。
```

- 示例 2：

```python
输入：s = "Myself2 Me1 I4 and3"
输出："Me Myself and I"
解释：将 s 中的单词按照初始位置排序，得到 "Me1 Myself2 and3 I4" ，然后删除数字。
```

## 解题思路

### 思路 1：模拟

1. 将句子 $s$ 按照空格分隔成数组 $s\underline{\hspace{0.5em}}list$。
2. 遍历数组 $s\underline{\hspace{0.5em}}list$ 中的单词：
   1. 从单词中分割出对应单词索引 $idx$ 和对应单词 $word$。
   2. 将单词 $word$ 存入答案数组 $res$ 对应位置 $idx - 1$ 上，即：$res[int(idx) - 1] = word$。
3. 将答案数组用空格拼接成句子字符串，并返回。

### 思路 1：代码

```python
class Solution:
    def sortSentence(self, s: str) -> str:
        s_list = s.split()
        size = len(s_list)
        res = ["" for _ in range(size)]
        for sub in s_list:
            idx = ""
            word = ""
            for ch in sub:
                if '1' <= ch <= '9':
                    idx += ch
                else:
                    word += ch
            res[int(idx) - 1] = word

        return " ".join(res)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m)$，其中 $m$ 为给定句子 $s$ 的长度。
- **空间复杂度**：$O(m)$。

# [1876. 长度为三且各字符不同的子字符串](https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/)

- 标签：哈希表、字符串、计数、滑动窗口
- 难度：简单

## 题目链接

- [1876. 长度为三且各字符不同的子字符串 - 力扣](https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/)

## 题目大意

**描述**：给定搞一个字符串 $s$。

**要求**：返回 $s$ 中长度为 $3$ 的好子字符串的数量。如果相同的好子字符串出现多次，则每一次都应该被记入答案之中。

**说明**：

- **子字符串**：指的是一个字符串中连续的字符序列。
- **好子字符串**：如果一个字符串中不含有任何重复字符，则称这个字符串为好子字符串。
- $1 \le s.length \le 100$。
- $s$ 只包含小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "xyzzaz"
输出：1
解释：总共有 4 个长度为 3 的子字符串："xyz"，"yzz"，"zza" 和 "zaz" 。
唯一的长度为 3 的好子字符串是 "xyz" 。
```

- 示例 2：

```python
输入：s = "aababcabc"
输出：4
解释：总共有 7 个长度为 3 的子字符串："aab"，"aba"，"bab"，"abc"，"bca"，"cab" 和 "abc" 。
好子字符串包括 "abc"，"bca"，"cab" 和 "abc" 。
```

## 解题思路

### 思路 1：模拟

1. 遍历字符串 $s$ 中长度为 3 的子字符串。
2. 判断子字符串中的字符是否有重复。如果没有重复，则答案进行计数。
3. 遍历完输出答案。

### 思路 1：代码

```python
class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        ans = 0
        for i in range(2, len(s)):
            if s[i - 2] != s[i - 1] and s[i - 1] != s[i] and s[i - 2] != s[i]:
                ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。# [1877. 数组中最大数对和的最小值](https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/)

- 标签：贪心、数组、双指针、排序
- 难度：中等

## 题目链接

- [1877. 数组中最大数对和的最小值 - 力扣](https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/)

## 题目大意

**描述**：一个数对 $(a, b)$ 的数对和等于 $a + b$。最大数对和是一个数对数组中最大的数对和。

- 比如，如果我们有数对 $(1, 5)$，$(2, 3)$ 和 $(4, 4)$，最大数对和为 $max(1 + 5, 2 + 3, 4 + 4) = max(6, 5, 8) = 8$。

给定一个长度为偶数 $n$ 的数组 $nums$，现在将 $nums$ 中的元素分为 $n / 2$ 个数对，使得：

- $nums$ 中每个元素恰好在一个数对中。
- 最大数对和的值最小。

**要求**：在最优数对划分的方案下，返回最小的最大数对和。

**说明**：

- $n == nums.length$。
- $2 \le n \le 10^5$。
- $n$ 是偶数。
- $1 \le nums[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：nums = [3,5,2,3]
输出：7
解释：数组中的元素可以分为数对 (3,3) 和 (5,2)。
最大数对和为 max(3+3, 5+2) = max(6, 7) = 7。
```

- 示例 2：

```python
输入：nums = [3,5,4,2,4,6]
输出：8
解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2)。
最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8。
```

## 解题思路

### 思路 1：排序 + 贪心

为了使最大数对和的值尽可能的小，我们应该尽可能的让数组中最大值与最小值组成一对，次大值与次小值组成一对。而其他任何方案都会使得最大数对和的值更大。

那么，我们可以先将数组进行排序，然后首尾依次进行组对，并计算这种方案下的最大数对和即为答案。

### 思路 1：代码

```python
class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        ans, size = 0, len(nums)
        for i in range(len(nums) // 2):
            ans = max(ans, nums[i] + nums[size - 1 - i])
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(\log n)$。

# [1879. 两个数组最小的异或值之和](https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/)

- 标签：位运算、数组、动态规划、状态压缩
- 难度：困难

## 题目链接

- [1879. 两个数组最小的异或值之和 - 力扣](https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/)

## 题目大意

**描述**：给定两个整数数组 $nums1$ 和 $nums2$，两个数组长度都为 $n$。

**要求**：将 $nums2$ 中的元素重新排列，使得两个数组的异或值之和最小。并返回重新排列之后的异或值之和。

**说明**：

- **两个数组的异或值之和**：$(nums1[0] \oplus nums2[0]) + (nums1[1] \oplus nums2[1]) + ... + (nums1[n - 1] \oplus nums2[n - 1])$（下标从 $0$ 开始）。
- 举个例子，$[1, 2, 3]$ 和 $[3,2,1]$ 的异或值之和 等于 $(1 \oplus 3) + (2 \oplus 2) + (3 \oplus 1) + (3 \oplus 1) = 2 + 0 + 2 = 4$。
- $n == nums1.length$。
- $n == nums2.length$。
- $1 \le n \le 14$。
- $0 \le nums1[i], nums2[i] \le 10^7$。

**示例**：

- 示例 1：

```python
输入：nums1 = [1,2], nums2 = [2,3]
输出：2
解释：将 nums2 重新排列得到 [3,2] 。
异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2。
```

- 示例 2：

```python
输入：nums1 = [1,0,3], nums2 = [5,3,4]
输出：8
解释：将 nums2 重新排列得到 [5,4,3] 。
异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8。
```

## 解题思路

### 思路 1：状态压缩 DP

由于数组 $nums2$ 可以重新排列，所以我们可以将数组 $nums1$ 中的元素顺序固定，然后将数组 $nums1$ 中第 $i$ 个元素与数组 $nums2$ 中所有还没被选择的元素进行组合，找到异或值之和最小的组合。

同时因为两个数组长度 $n$ 的大小范围只有 $[1, 14]$，所以我们可以采用「状态压缩」的方式来表示 $nums2$ 中当前元素的选择情况。

「状态压缩」指的是使用一个 $n$ 位的二进制数 $state$ 来表示排列中数的选取情况。

如果二进制数 $state$ 的第 $i$ 位为 $1$，说明数组 $nums2$ 第 $i$ 个元素在该状态中被选取。反之，如果该二进制的第 $i$ 位为 $0$，说明数组 $nums2$ 中第 $i$ 个元素在该状态中没有被选取。

举个例子：

1. $nums2 = \lbrace 1, 2, 3, 4 \rbrace$，$state = (1001)_2$，表示选择了第 $1$ 个元素和第 $4$ 个元素，也就是 $1$、$4$。
2. $nums2 = \lbrace 1, 2, 3, 4, 5, 6 \rbrace$，$state = (011010)_2$，表示选择了第 $2$ 个元素、第 $4$ 个元素、第 $5$ 个元素，也就是  $2$、$4$、$5$。

这样，我们就可以通过动态规划的方式来解决这道题。

###### 1. 划分阶段

按照数组 $nums$ 中元素选择情况进行阶段划分。

###### 2. 定义状态

定义当前数组 $nums2$ 中元素选择状态为 $state$，$state$ 对应选择的元素个数为 $count(state)$。

则可以定义状态 $dp[state]$ 表示为：当前数组 $nums2$ 中元素选择状态为 $state$，并且选择了 $nums1$ 中前 $count(state)$ 个元素的情况下，可以组成的最小异或值之和。

###### 3. 状态转移方程

对于当前状态 $dp[state]$，肯定是从比 $state$ 少选一个元素的状态中递推而来。我们可以枚举少选一个元素的状态，找到可以组成的异或值之和最小值，赋值给 $dp[state]$。

举个例子 $nums2 = \lbrace 1, 2, 3, 4 \rbrace$，$state = (1001)_2$，表示选择了第 $1$ 个元素和第 $4$ 个元素，也就是 $1$、$4$。那么 $state$ 只能从 $(1000)_2$ 和 $(0001)_2$ 这两个状态转移而来，我们只需要枚举这两种状态，并求出转移过来的异或值之和最小值。

即状态转移方程为：$dp[state] = min(dp[state], \quad dp[state \oplus (1 \text{ <}\text{< } i)] + (nums1[i] \oplus nums2[one\underline{\hspace{0.5em}}cnt - 1]))$，其中 $state$ 第 $i$ 位一定为 $1$，$one\underline{\hspace{0.5em}}cnt$ 为 $state$ 中 $1$ 的个数。

###### 4. 初始条件

- 既然是求最小值，不妨将所有状态初始为最大值。
- 未选择任何数时，异或值之和为 $0$，所以初始化 $dp[0] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当前数组 $nums2$ 中元素选择状态为 $state$，并且选择了 $nums1$ 中前 $count(state)$ 个元素的情况下，可以组成的最小异或值之和。 所以最终结果为 $dp[states - 1]$，其中 $states = 1 \text{ <}\text{< } n$。

### 思路 1：代码

```python
class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        ans = float('inf')
        size = len(nums1)
        states = 1 << size

        dp = [float('inf') for _ in range(states)]
        dp[0] = 0
        for state in range(states):
            one_cnt = bin(state).count('1')
            for i in range(size):
                if (state >> i) & 1:
                    dp[state] = min(dp[state], dp[state ^ (1 << i)] + (nums1[i] ^ nums2[one_cnt - 1]))
        
        return dp[states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n \times n)$，其中 $n$ 是数组 $nums1$、$nums2$ 的长度。
- **空间复杂度**：$O(2^n)$。

# [1893. 检查是否区域内所有整数都被覆盖](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/)

- 标签：数组、哈希表、前缀和
- 难度：简单

## 题目链接

- [1893. 检查是否区域内所有整数都被覆盖 - 力扣](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/)

## 题目大意

**描述**：给定一个二维整数数组 $ranges$ 和两个整数 $left$ 和 $right$。每个 $ranges[i] = [start_i, end_i]$ 表示一个从 $start_i$ 到 $end_i$ 的 闭区间 。

**要求**：如果闭区间 $[left, right]$ 内每个整数都被 $ranges$ 中至少一个区间覆盖，那么请你返回 $True$ ，否则返回 $False$。

**说明**：

- $1 \le ranges.length \le 50$。
- $1 \le start_i \le end_i \le 50$。
- $1 \le left \le right \le 50$。

**示例**：

- 示例 1：

```python
输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
输出：True
解释：2 到 5 的每个整数都被覆盖了：
- 2 被第一个区间覆盖。
- 3 和 4 被第二个区间覆盖。
- 5 被第三个区间覆盖。
```

- 示例 2：

```python
输入：ranges = [[1,10],[10,20]], left = 21, right = 21
输出：False
解释：21 没有被任何一个区间覆盖。
```

## 解题思路

### 思路 1：暴力

区间的范围为 $[1, 50]$，所以我们可以使用一个长度为 $51$ 的标志数组 $flags$ 用于标记区间内的所有整数。

1. 遍历数组 $ranges$ 中的所有区间 $[l, r]$。
2. 对于区间 $[l, r]$ 和区间 $[left, right]$，将两区间相交部分标记为 $True$。
3. 遍历区间 $[left, right]$ 上的所有整数，判断对应标志位是否为 $False$。
4. 如果对应标志位出现 $False$，则返回 $False$。
5. 如果遍历完所有标志位都为 $True$，则返回 $True$。

### 思路 1：代码

```Python
class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        flags = [False for _ in range(51)]
        for l, r in ranges:
            for i in range(max(l, left), min(r, right) + 1):
                flags[i] = True
            
        for i in range(left, right + 1):
            if not flags[i]:
                return False
        
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(50 \times n)$。
- **空间复杂度**：$O(50)$。
# [1897. 重新分配字符使所有字符串都相等](https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/)

- 标签：哈希表、字符串、计数
- 难度：简单

## 题目链接

- [1897. 重新分配字符使所有字符串都相等 - 力扣](https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/)

## 题目大意

**描述**：给定一个字符串数组 $words$（下标从 $0$ 开始计数）。

在一步操作中，需先选出两个 不同 下标 $i$ 和 $j$，其中 $words[i]$ 是一个非空字符串，接着将 $words[i]$ 中的任一字符移动到 $words[j]$ 中的 任一 位置上。

**要求**：如果执行任意步操作可以使 $words$ 中的每个字符串都相等，返回 $True$；否则，返回 $False$。

**说明**：

- $1 <= words.length <= 100$。
- $1 <= words[i].length <= 100$
- $words[i]$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：words = ["abc","aabc","bc"]
输出：true
解释：将 words[1] 中的第一个 'a' 移动到 words[2] 的最前面。
使 words[1] = "abc" 且 words[2] = "abc"。
所有字符串都等于 "abc" ，所以返回 True。
```

- 示例 2：

```python
输入：words = ["ab","a"]
输出：False
解释：执行操作无法使所有字符串都相等。
```

## 解题思路

### 思路 1：哈希表

如果通过重新分配字符能够使所有字符串都相等，则所有字符串的字符需要满足：

1. 每个字符串中字符种类相同，
2. 每个字符串中各种字符的个数相同。

则我们可以使用哈希表来统计字符串中字符种类及个数。具体步骤如下：

1. 遍历单词数组 $words$ 中的所有单词 $word$。
2. 遍历所有单词 $word$ 中的所有字符 $ch$。
3. 使用哈希表 $cnts$ 统计字符种类及个数。
4. 如果所有字符个数都是单词个数的倍数，则说明通过重新分配字符能够使所有字符串都相等，则返回 $True$。
5. 否则返回 $False$。

### 思路 1：代码

```Python
class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        size = len(words)
        cnts = Counter()
        for word in words:
            for ch in word:
                cnts[ch] += 1

        return all(value % size == 0 for key, value in cnts.items())
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(s + |\sum|)$，其中 $s$ 为数组 $words$ 中所有单词的长度之和，$\sum$ 是字符集，本题中 $|\sum| = 26$。
- **空间复杂度**：$O(|\sum|)$。
# [1903. 字符串中的最大奇数](https://leetcode.cn/problems/largest-odd-number-in-string/)

- 标签：贪心、数学、字符串
- 难度：简单

## 题目链接

- [1903. 字符串中的最大奇数 - 力扣](https://leetcode.cn/problems/largest-odd-number-in-string/)

## 题目大意

**描述**：给定一个字符串 $num$，表示一个大整数。

**要求**：在字符串 $num$ 的所有非空子字符串中找出值最大的奇数，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 `""`。

**说明**：

- **子字符串**：指的是字符串中一个连续的字符序列。
- $1 \le num.length \le 10^5$
- $num$ 仅由数字组成且不含前导零。

**示例**：

- 示例 1：

```python
输入：num = "52"
输出："5"
解释：非空子字符串仅有 "5"、"2" 和 "52" 。"5" 是其中唯一的奇数。
```

- 示例 2：

```python
输入：num = "4206"
输出：""
解释：在 "4206" 中不存在奇数。
```

## 解题思路

### 思路 1：贪心算法

如果某个数 $x$ 为奇数，则 $x$ 末尾位上的数字一定为奇数。那么我们只需要在末尾为奇数的字符串中考虑最大的奇数即可。显而易见的是，最大的奇数一定是长度最长的那个。所以我们只需要逆序遍历字符串，找到第一个奇数，从整个字符串开始位置到该奇数位置所代表的整数，就是最大的奇数。具体步骤如下：

1. 逆序遍历字符串 $s$。
2. 找到第一个奇数位置 $i$，则 $num[0: i + 1]$ 为最大的奇数，将其作为答案返回。

### 思路 1：代码

```python
class Solution:
    def largestOddNumber(self, num: str) -> str:
        for i in range(len(num) - 1, -1, -1):
            if int(num[i]) % 2 == 1:
                return num[0: i + 1]
        return ""
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。
# [1921. 消灭怪物的最大数量](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/)

- 标签：贪心、数组、排序
- 难度：中等

## 题目链接

- [1921. 消灭怪物的最大数量 - 力扣](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/)

## 题目大意

**描述**：你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给定一个下标从 $0$ 开始且大小为 $n$ 的整数数组 $dist$，其中 $dist[i]$ 是第 $i$ 个怪物与城市的初始距离（单位：米）。

怪物以恒定的速度走向城市。每个怪物的速度都以一个长度为 $n$ 的整数数组 $speed$ 表示，其中 $speed[i]$ 是第 $i$ 个怪物的速度（单位：千米/分）。

你有一种武器，一旦充满电，就可以消灭 一个 怪物。但是，武器需要 一分钟 才能充电。武器在游戏开始时是充满电的状态，怪物从 第 $0$ 分钟时开始移动。

一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰好 在某一分钟开始时到达城市（距离表示为 $0$），这也会被视为输掉 游戏，在你可以使用武器之前，游戏就会结束。

**要求**：返回在你输掉游戏前可以消灭的怪物的最大数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  $n$。

**说明**：

- 

**示例**：

- 示例 1：

```python
输入：dist = [1,3,4], speed = [1,1,1]
输出：3
解释：
第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,2,3]，你消灭了第二个怪物。
第 3 分钟开始时，怪物的距离是 [X,X,2]，你消灭了第三个怪物。
所有 3 个怪物都可以被消灭。
```

- 示例 2：

```python
输入：dist = [1,1,2,3], speed = [1,1,1,1]
输出：1
解释：
第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。
第 1 分钟开始时，怪物的距离是 [X,0,1,2]，所以你输掉了游戏。
你只能消灭 1 个怪物。
```

## 解题思路

### 思路 1：排序 + 贪心算法

对于第 $i$ 个怪物，最晚可被消灭的时间为 $times[i] = \lfloor \frac{dist[i] - 1}{speed[i]} \rfloor$。我们可以根据以上公式，将所有怪物最晚可被消灭时间存入数组 $times$ 中，然后对 $times$ 进行升序排序。

然后遍历数组 $times$，对于第 $i$ 个怪物：

1. 如果 $times[i] < i$，则说明第 $i$ 个怪物无法被消灭，直接返回 $i$ 即可。
2. 如果 $times[i] \ge i$，则说明第 $i$ 个怪物可以被消灭，继续向下遍历。

如果遍历完数组 $times$，则说明所有怪物都可以被消灭，则返回 $n$。

### 思路 1：代码

```Python
class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        times = []
        for d, s in zip(dist, speed):
            time = (d - 1) // s
            times.append(time)
        times.sort()

        size = len(times)
        for i in range(size):
            if times[i] < i:
                return i

        return size
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $dist$ 的长度。
- **空间复杂度**：$O(n)$。

# [1925. 统计平方和三元组的数目](https://leetcode.cn/problems/count-square-sum-triples/)

- 标签：数学、枚举
- 难度：简单

## 题目链接

- [1925. 统计平方和三元组的数目 - 力扣](https://leetcode.cn/problems/count-square-sum-triples/)

## 题目大意

**描述**：给你一个整数 $n$。

**要求**：请你返回满足 $1 \le a, b, c \le n$ 的平方和三元组的数目。

**说明**：

- **平方和三元组**：指的是满足 $a^2 + b^2 = c^2$ 的整数三元组 $(a, b, c)$。
- $1 \le n \le 250$。

**示例**：

- 示例 1：

```python
输入 n = 5
输出 2
解释 平方和三元组为 (3,4,5) 和 (4,3,5)。
```

- 示例 2：

```python
输入：n = 10
输出：4
解释：平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10)。
```

## 解题思路

### 思路 1：枚举算法

我们可以在 $[1, n]$ 区间中枚举整数三元组 $(a, b, c)$ 中的 $a$ 和 $b$。然后判断 $a^2 + b^2$ 是否小于等于 $n$，并且是完全平方数。

在遍历枚举的同时，我们维护一个用于统计平方和三元组数目的变量 `cnt`。如果符合要求，则将计数 `cnt` 加 $1$。最终，我们返回该数目作为答案。

利用枚举算法统计平方和三元组数目的时间复杂度为 $O(n^2)$。

- 注意：在计算中，为了防止浮点数造成的误差，并且两个相邻的完全平方正数之间的距离一定大于 $1$，所以我们可以用 $\sqrt{a^2 + b^2 + 1}$ 来代替 $\sqrt{a^2 + b^2}$。

### 思路 1：代码

```python
class Solution:
    def countTriples(self, n: int) -> int:
        cnt = 0
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                c = int(sqrt(a * a + b * b + 1))
                if c <= n and a * a + b * b == c * c:
                    cnt += 1
        return cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。
# [1929. 数组串联](https://leetcode.cn/problems/concatenation-of-array/)

- 标签：数组
- 难度：简单

## 题目链接

- [1929. 数组串联 - 力扣](https://leetcode.cn/problems/concatenation-of-array/)

## 题目大意

**描述**：给定一个长度为 $n$ 的整数数组 $nums$。

**要求**：构建一个长度为 $2 \times n$ 的答案数组 $ans$，答案数组下标从 $0$ 开始计数 ，对于所有 $0 \le i < n$ 的 $i$ ，满足下述所有要求：

- $ans[i] == nums[i]$。
- $ans[i + n] == nums[i]$。

具体而言，$ans$ 由两个 $nums$ 数组「串联」形成。

**说明**：

- $n == nums.length$。
- $1 \le n \le 1000$。
- $1 \le nums[i] \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,1]
输出：[1,2,1,1,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
```

- 示例 2：

```python
输入：nums = [1,3,2,1]
输出：[1,3,2,1,1,3,2,1]
解释：数组 ans 按下述方式形成：
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
```

## 解题思路

### 思路 1：按要求模拟

1. 定义一个数组变量（列表）$ans$ 作为答案数组。
2. 然后按顺序遍历两次数组 $nums$ 中的元素，并依次添加到 $ans$ 的尾部。最后返回 $ans$。

### 思路 1：代码

```python
class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            ans.append(num)
        for num in nums:
            ans.append(num)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(n)$。不算上则空间复杂度为 $O(1)$。

### 思路 2：利用运算符

Python 中可以直接利用 `+` 号运算符将两个列表快速进行串联。即 `return nums + nums`。

### 思路 2：代码

```python
class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums + nums
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。如果算上答案数组的空间占用，则空间复杂度为 $O(n)$。不算上则空间复杂度为 $O(1)$。
# [1930. 长度为 3 的不同回文子序列](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)

- 标签：哈希表、字符串、前缀和
- 难度：中等

## 题目链接

- [1930. 长度为 3 的不同回文子序列 - 力扣](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)

## 题目大意

**描述**：给定一个人字符串 $s$。

**要求**：返回 $s$ 中长度为 $s$ 的不同回文子序列的个数。即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。

**说明**：

- **回文**：指正着读和反着读一样的字符串。
- **子序列**：由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。
  - 例如，`"ace"` 是 `"abcde"` 的一个子序列。

- $3 \le s.length \le 10^5$。
- $s$ 仅由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "aabca"
输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- "aba" ("aabca" 的子序列)
- "aaa" ("aabca" 的子序列)
- "aca" ("aabca" 的子序列)
```

- 示例 2：

```python
输入：s = "bbcbaba"
输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- "bbb" ("bbcbaba" 的子序列)
- "bcb" ("bbcbaba" 的子序列)
- "bab" ("bbcbaba" 的子序列)
- "aba" ("bbcbaba" 的子序列)
```

## 解题思路

### 思路 1：枚举 + 哈希表

字符集只包含 $26$ 个小写字母，所以我们可以枚举这 $26$ 个小写字母。

对于每个小写字母，使用对撞双指针，找到字符串 $s$ 首尾两侧与小写字母相同的最左位置和最右位置。

如果两个位置不同，则我们可以将两个位置中间不重复的字符当作是长度为 $3$ 的子序列最中间的那个字符。

则我们可以统计出两个位置中间不重复字符的个数，将其累加到答案中。

遍历完，返回答案。

### 思路 1：代码

```Python
class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        size = len(s)
        ans = 0

        for i in range(26):
            left, right = 0, size - 1
            
            while left < size and ord(s[left]) - ord('a') != i:
                left += 1
            
            while right >= 0 and ord(s[right]) - ord('a') != i:
                right -= 1

            if right - left < 2:
                continue

            char_set = set()
            for j in range(left + 1, right):
                char_set.add(s[j])
            ans += len(char_set)
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$n \times | \sum | + | \sum |^2$，其中 $n$ 为字符串 $s$ 的长度，$\sum$ 为字符集，本题中 $| \sum | = 26$。
- **空间复杂度**：$O(| \sum |)$。
# [1936. 新增的最少台阶数](https://leetcode.cn/problems/add-minimum-number-of-rungs/)

- 标签：贪心、数组
- 难度：中等

## 题目链接

- [1936. 新增的最少台阶数 - 力扣](https://leetcode.cn/problems/add-minimum-number-of-rungs/)

## 题目大意

**描述**：给定一个严格递增的整数数组 $rungs$，用于表示梯子上每一台阶的高度。当前你正站在高度为 $0$ 的地板上，并打算爬到最后一个台阶。

另给定一个整数 $dist$。每次移动中，你可以到达下一个距离当前位置（地板或台阶）不超过 $dist$ 高度的台阶。当前，你也可以在任何正整数高度插入尚不存在的新台阶。

**要求**：返回爬到最后一阶时必须添加到梯子上的最少台阶数。

**说明**：

- 

**示例**：

- 示例 1：

```python
输入：rungs = [1,3,5,10], dist = 2
输出：2
解释：
现在无法到达最后一阶。
在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。
```

- 示例 2：

```python
输入：rungs = [3,4,6,7], dist = 2
输出：1
解释：
现在无法从地板到达梯子的第一阶。 
在高度为 1 的位置增设新的台阶，以爬上梯子。 
梯子在高度为 [1,3,4,6,7] 的位置上有台阶。
```

## 解题思路

### 思路 1：贪心算法 + 模拟

1. 遍历梯子的每一层台阶。
2. 计算每一层台阶与上一层台阶之间的差值 $diff$。
3. 每层最少需要新增的台阶数为 $\lfloor \frac{diff - 1}{dist} \rfloor$，将其计入答案 $ans$ 中。
4. 遍历完返回答案。

### 思路 1：代码

```Python
class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        ans, cur = 0, 0
        for h in rungs:
            diff = h - cur
            ans += (diff - 1) // dist
            cur = h
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $rungs$ 的长度。
- **空间复杂度**：$O(1)$。

# [1941. 检查是否所有字符出现次数相同](https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/)

- 标签：哈希表、字符串、计数
- 难度：简单

## 题目链接

- [1941. 检查是否所有字符出现次数相同 - 力扣](https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/)

## 题目大意

**描述**：给定一个字符串 $s$。如果 $s$ 中出现过的所有字符的出现次数相同，那么我们称字符串 $s$ 是「好字符串」。

**要求**：如果 $s$ 是一个好字符串，则返回 `True`，否则返回 `False`。

**说明**：

- $1 \le s.length \le 1000$。
- $s$ 只包含小写英文字母。

**示例**：

- 示例 1：

```python
输入：s = "abacbc"
输出：true
解释：s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。
```

- 示例 2：

```python
输入：s = "aaabb"
输出：false
解释：s 中出现过的字符为 'a' 和 'b' 。
'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。
```

## 解题思路

### 思路 1：哈希表

1. 使用哈希表记录字符串 $s$ 中每个字符的频数。
2. 然后遍历哈希表中的键值对，检测每个字符的频数是否相等。
3. 如果发现频数不相等，则直接返回 `False`。
4. 如果检查完发现所有频数都相等，则返回 `True`。

### 思路 1：代码

```python
class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        counter = Counter(s)
        flag = -1
        for key in counter:
            if flag == -1:
                flag = counter[key]
            else:
                if flag != counter[key]:
                    return False
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。
# [1947. 最大兼容性评分和](https://leetcode.cn/problems/maximum-compatibility-score-sum/)

- 标签：位运算、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目链接

- [1947. 最大兼容性评分和 - 力扣](https://leetcode.cn/problems/maximum-compatibility-score-sum/)

## 题目大意

**描述**：有一份由 $n$ 个问题组成的调查问卷，每个问题的答案只有 $0$ 或 $1$。将这份调查问卷分发给 $m$ 名学生和 $m$ 名老师，学生和老师的编号都是 $0 \sim m - 1$。现在给定一个二维整数数组 $students$ 表示 $m$ 名学生给出的答案，其中 $studuents[i][j]$ 表示第 $i$ 名学生第 $j$ 个问题给出的答案。再给定一个二维整数数组 $mentors$ 表示 $m$ 名老师给出的答案，其中 $mentors[i][j]$ 表示第 $i$ 名导师第 $j$ 个问题给出的答案。

每个学生要和一名导师互相配对。配对的学生和导师之间的兼容性评分等于学生和导师答案相同的次数。

- 例如，学生答案为 $[1, 0, 1]$，而导师答案为 $[0, 0, 1]$，那么他们的兼容性评分为 $2$，因为只有第 $2$ 个和第 $3$ 个答案相同。

**要求**：找出最优的学生与导师的配对方案，以最大程度上提高所有学生和导师的兼容性评分和。然后返回可以得到的最大兼容性评分和。

**说明**：

- $m == students.length == mentors.length$。
- $n == students[i].length == mentors[j].length$。
- $1 \le m, n \le 8$。
- $students[i][k]$ 为 $0$ 或 $1$。
- $mentors[j][k]$ 为 $0$ 或 $1$。

**示例**：

- 示例 1：

```python
输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
输出：8
解释：按下述方式分配学生和导师：
- 学生 0 分配给导师 2 ，兼容性评分为 3。
- 学生 1 分配给导师 0 ，兼容性评分为 2。
- 学生 2 分配给导师 1 ，兼容性评分为 3。
最大兼容性评分和为 3 + 2 + 3 = 8。
```

- 示例 2：

```python
输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
输出：0
解释：任意学生与导师配对的兼容性评分都是 0。
```

## 解题思路

### 思路 1：状压 DP

因为 $m$、$n$ 的范围都是 $[1, 8]$，所以我们可以使用「状态压缩」的方式来表示学生的分配情况。即使用一个 $m$ 位长度的二进制数 $state$ 来表示每一位老师是否被分配了学生。如果 $state$ 的第 $i$ 位为 $1$，表示第 $i$ 位老师被分配了学生，如果 $state$ 的第 $i$ 位为 $0$，则表示第 $i$ 位老师没有分配到学生。

这样，我们就可以通过动态规划的方式来解决这道题。

###### 1. 划分阶段

按照学生的分配情况进行阶段划分。

###### 2. 定义状态

定义当前学生的分配情况为 $state$，$state$ 中包含 $count(state)$ 个 $1$，表示有 $count(state)$ 个老师被分配了学生。

则可以定义状态 $dp[state]$ 表示为：当前老师被分配学生的状态为 $state$，其中有 $count(state)$ 个老师被分配了学生的情况下，可以得到的最大兼容性评分和。

###### 3. 状态转移方程

对于当前状态 $state$，肯定是从比 $state$ 少选一个老师被分配的状态中递推而来。我们可以枚举少选一个元素的状态，找到可以得到的最大兼容性评分和，赋值给 $dp[state]$。

即状态转移方程为：$dp[state] = max(dp[state], \quad dp[state \oplus (1 \text{ <}\text{< } i)] + score[i][one\underline{\hspace{0.5em}}cnt - 1])$，其中：

1. $state$ 第 $i$ 位一定为 $1$。
2. $state \oplus (1 \text{ <}\text{< } i)$ 为比 $state$ 少选一个元素的状态。
3. $scores[i][one\underline{\hspace{0.5em}}cnt - 1]$ 为第 $i$ 名老师分配到第 $one\underline{\hspace{0.5em}}cnt - 1$ 名学生的兼容性评分。

关于每位老师与每位同学之间的兼容性评分，我们可以事先通过一个 $m \times m \times n$ 的三重循环计算得出，并且存入到 $m \times m$ 大小的二维矩阵 $scores$ 中。

###### 4. 初始条件

- 初始每个老师都没有分配到学生的状态下，可以得到的最兼容性评分和为 $0$，即 $dp[0] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当前老师被分配学生的状态为 $state$，其中有 $count(state)$ 个老师被分配了学生的情况下，可以得到的最大兼容性评分和。所以最终结果为 $dp[states - 1]$，其中 $states = 1 \text{ <}\text{< } m$。

### 思路 1：代码

```python
class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        m, n = len(students), len(students[0])
        scores = [[0 for _ in range(m)] for _ in range(m)]

        for i in range(m):
            for j in range(m):
                for k in range(n):
                    scores[i][j] += (students[i][k] == mentors[j][k])

        states = 1 << m
        dp = [0 for _ in range(states)]

        for state in range(states):
            one_cnt = bin(state).count('1')
            for i in range(m):
                if (state >> i) & 1:
                    dp[state] = max(dp[state], dp[state ^ (1 << i)] + scores[i][one_cnt - 1])
        return dp[states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m^2 \times n + m \times 2^m)$。
- **空间复杂度**：$O(2^m)$。

# [1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

- 标签：数组、排序、滑动窗口
- 难度：简单

## 题目链接

- [1984. 学生分数的最小差值 - 力扣](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

## 题目大意

**描述**：给定一个下标从 $0$ 开始的整数数组 $nums$，其中 $nums[i]$ 表示第 $i$ 名学生的分数。另给定一个整数 $k$。

**要求**：从数组中选出任意 $k$ 名学生的分数，使这 $k$ 个分数间最高分和最低分的差值达到最小化。返回可能的最小差值 。

**说明**：

- $1 \le k \le nums.length \le 1000$。
- $0 \le nums[i] \le 10^5$。

**示例**：

- 示例 1：

```python
输入：nums = [90], k = 1
输出：0
解释：选出 1 名学生的分数，仅有 1 种方法：
- [90] 最高分和最低分之间的差值是 90 - 90 = 0
可能的最小差值是 0
```

- 示例 2：

```python
输入：nums = [9,4,1,7], k = 2
输出：2
解释：选出 2 名学生的分数，有 6 种方法：
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8
- [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2
- [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3
- [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3
- [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6
可能的最小差值是 2
```

## 解题思路

### 思路 1：排序 + 滑动窗口

如果想要最小化选择的 $k$ 名学生中最高分与最低分的差值，我们应该在排序后的数组中连续选择 $k$ 名学生。这是因为如果将连续 $k$ 名学生中的某位学生替换成不连续的学生，其最高分 / 最低分一定会发生变化，并且一定会使最高分变得最高 / 最低分变得最低。从而导致差值增大。

因此，最优方案一定是在排序后的数组中连续选择 $k$ 名学生中的所有情况中的其中一种。

这样，我们可以先对数组 $nums$ 进行升序排序。然后使用一个固定长度为 $k$ 的滑动窗口计算连续选择 $k$ 名学生的最高分与最低分的差值。并记录下最小的差值 $ans$，最后作为答案并返回结果。

### 思路 1：代码

```Python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = float('inf')
        for i in range(k - 1, len(nums)):
            ans = min(ans, nums[i] - nums[i - k + 1])

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$，其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(1)$。

### 思路 2：

### 思路 2：代码

```python
```

### 思路 2：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

# [1986. 完成任务的最少工作时间段](https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)

- 标签：位运算、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目链接

- [1986. 完成任务的最少工作时间段 - 力扣](https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)

## 题目大意

**描述**：给定一个整数数组 $tasks$ 代表需要完成的任务。 其中 $tasks[i]$ 表示第 $i$ 个任务需要花费的时长（单位为小时）。再给定一个整数 $sessionTime$，代表在一个工作时段中，最多可以连续工作的小时数。在连续工作至多 $sessionTime$ 小时后，需要进行休息。

现在需要按照如下条件完成给定任务：

1. 如果你在某一个时间段开始一个任务，你需要在同一个时间段完成它。
2. 完成一个任务后，你可以立马开始一个新的任务。
3. 你可以按任意顺序完成任务。

**要求**：按照上述要求，返回完成所有任务所需要的最少数目的工作时间段。

**说明**：

- $n == tasks.length$。
- $1 \le n \le 14$。
- $1 \le tasks[i] \le 10$。
- $max(tasks[i]) \le sessionTime \le 15$。

**示例**：

- 示例 1：

```python
输入：tasks = [1,2,3], sessionTime = 3
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。
- 第二个工作时间段：完成第三个任务，花费 3 小时。
```

- 示例 2：

```python
输入：tasks = [3,1,3,1,1], sessionTime = 8
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。
- 第二个工作时间段，完成最后一个任务，花费 1 小时。
```

## 解题思路

### 思路 1：状压 DP

### 思路 1：代码

```python
class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        size = len(tasks)
        states = 1 << size
        
        prefix_sum = [0 for _ in range(states)]
        for state in range(states):
            for i in range(size):
                if (state >> i) & 1:
                    prefix_sum[state] = prefix_sum[state ^ (1 << i)] + tasks[i]
                    break
        
        dp = [float('inf') for _ in range(states)]
        dp[0] = 0
        for state in range(states):
            sub = state
            while sub > 0:
                if prefix_sum[sub] <= sessionTime:
                    dp[state] = min(dp[state], dp[state ^ sub] + 1)
                sub = (sub - 1) & state

        return dp[states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

# [1991. 找到数组的中间位置](https://leetcode.cn/problems/find-the-middle-index-in-array/)

- 标签：数组、前缀和
- 难度：简单

## 题目链接

- [1991. 找到数组的中间位置 - 力扣](https://leetcode.cn/problems/find-the-middle-index-in-array/)

## 题目大意

**描述**：给定一个下标从 $0$ 开始的整数数组 $nums$。

**要求**：返回最左边的中间位置 $middleIndex$（也就是所有可能中间位置下标做小的一个）。如果找不到这样的中间位置，则返回 $-1$。

**说明**：

- **中间位置 $middleIndex$**：满足 $nums[0] + nums[1] + … + nums[middleIndex - 1] == nums[middleIndex + 1] + nums[middleIndex + 2] + … + nums[nums.length - 1]$ 的数组下标。
- 如果 $middleIndex == 0$，左边部分的和定义为 $0$。类似的，如果 $middleIndex == nums.length - 1$，右边部分的和定义为 $0$。

**示例**：

- 示例 1：

```python
输入：nums = [2,3,-1,8,4]
输出：3
解释：
下标 3 之前的数字和为：2 + 3 + -1 = 4
下标 3 之后的数字和为：4 = 4
```

- 示例 2：

```python
输入：nums = [1,-1,4]
输出：2
解释：
下标 2 之前的数字和为：1 + -1 = 0
下标 2 之后的数字和为：0
```

## 解题思路

### 思路 1：前缀和

1. 先遍历一遍数组，求出数组中全部元素和为 $total$。
2. 再遍历一遍数组，使用变量 $prefix\underline{\hspace{0.5em}}sum$ 为前 $i$ 个元素和。
3. 当遍历到第 $i$ 个元素时，其数组左侧元素之和为 $prefix\underline{\hspace{0.5em}}sum$，右侧元素和为 $total - prefix\underline{\hspace{0.5em}}sum - nums[i]$。
   1. 如果左右元素之和相等，即 $prefix\underline{\hspace{0.5em}}sum == total - prefix\underline{\hspace{0.5em}}sum - nums[i]$（$2 \times prefix\underline{\hspace{0.5em}}sum + nums[i] == total$） 时，$i$ 为中间位置。此时返回 $i$。
   2. 如果不满足，则继续累加当前元素到 $prefix\underline{\hspace{0.5em}}sum$ 中，继续向后遍历。
4. 如果找不到符合要求的中间位置，则返回 $-1$。

### 思路 1：代码

```python
class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        total = sum(nums)

        prefix_sum = 0
        for i in range(len(nums)):
            if 2 * prefix_sum + nums[i] == total:
                return i
            prefix_sum += nums[i]
        
        return -1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

# [1994. 好子集的数目](https://leetcode.cn/problems/the-number-of-good-subsets/)

- 标签：位运算、数组、数学、动态规划、状态压缩
- 难度：困难

## 题目链接

- [1994. 好子集的数目 - 力扣](https://leetcode.cn/problems/the-number-of-good-subsets/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：返回 $nums$ 中不同的好子集的数目对 $10^9 + 7$ 取余的结果。

**说明**：

- **子集**：通过删除 $nums$ 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
  
- **好子集**：如果 $nums$ 的一个子集中，所有元素的乘积可以表示为一个或多个互不相同的质数的乘积，那么我们称它为好子集。
  - 比如，如果 $nums = [1, 2, 3, 4]$：
    - $[2, 3]$，$[1, 2, 3]$ 和 $[1, 3]$ 是好子集，乘积分别为 $6 = 2 \times 3$ ，$6 = 2 \times 3$ 和 $3 = 3$。
    - $[1, 4]$ 和 $[4]$ 不是好子集，因为乘积分别为 $4 = 2 \times 2$ 和 $4 = 2 \times 2$。

- $1 \le nums.length \le 10^5$。
- $1 \le nums[i] \le 30$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3，可以表示为质数 3 的乘积。
- [2]：乘积为 2，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3，可以表示为质数 3 的乘积。
```

- 示例 2：

```python
输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3，可以表示为质数 3 的乘积。
- [15]：乘积为 15，可以表示为互不相同质数 3 和 5 的乘积。
```

## 解题思路

### 思路 1：状态压缩 DP

根据题意可以看出：

1. 虽然 $nums$ 的长度是 $[1, 10^5]$，但是其值域范围只有 $[1, 30]$，则我们可以将 $[1, 30]$ 的数分为 $3$ 类：
   1. 质数：$[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]$（共 $10$ 个数）。由于好子集的乘积拆解后的质因子只能包含这 $10$ 个，我们可以使用一个数组 $primes$ 记录下这 $10$ 个质数，将好子集的乘积拆解为质因子后，每个 $primes[i]$ 最多出现一次。
   2. 非质数：$[4, 6, 8, 9, 10, 12, 14, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]$。非质数肯定不会出现在好子集的乘积拆解后的质因子中。
   3. 特殊的数：$[1]$。对于一个好子集而言，无论向中间添加多少个 $1$，得到的新子集仍是好子集。
2. 分类完成后，由于 $[1, 30]$ 中只有 $10$ 个质数，因此我们可以使用一个长度为 $10$ 的二进制数  $state$ 来表示 $primes$ 中质因数的选择情况。其中，如果 $state$ 第 $i$ 位为 $1$，则说明第 $i$ 个质因数 $primes[i]$ 被使用过；如果 $state$ 第 $i$ 位为 $0$，则说明第 $i$ 个质因数 $primes[i]$ 没有被使用过。
3. 题目规定值相同，但是下标不同的子集视为不同子集，那么我们可先统计出 $nums$ 中每个数 $nums[i]$ 的出现次数，将其存入 $cnts$ 数组中，其中 $cnts[num]$ 表示 $num$ 出现的次数。这样在统计方案时，直接计算出 $num$ 的方案数，再乘以 $cnts[num]$ 即可。

接下来，我们就可以使用「动态规划」的方式来解决这道题目了。

###### 1. 划分阶段

按照质因数的选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[state]$ 表示为：当质因数选择的情况为 $state$ 时，好子集的数目。

###### 3. 状态转移方程

对于 $nums$ 中的每个数 $num$，其对应出现次数为 $cnt$。我们可以通过试除法，将 $num$ 分解为不同的质因数，并使用「状态压缩」的方式，用一个二进制数 $cur\underline{\hspace{0.5em}}state$ 来表示当前数 $num$ 中使用了哪些质因数。然后枚举所有状态，找到与 $cur\underline{\hspace{0.5em}}state$ 不冲突的状态 $state$（也就是除了 $cur\underline{\hspace{0.5em}}state$ 中选择的质因数外，选择的其他质因数情况，比如 $cur\underline{\hspace{0.5em}}state$ 选择了 $2$ 和 $5$，则枚举不选择 $2$ 和 $5$ 的状态）。

此时，状态转移方程为：$dp[state | cur\underline{\hspace{0.5em}}state] = \sum (dp[state] \times cnt) \mod MOD , \quad state \text{ \& } cur\underline{\hspace{0.5em}}state == 0$

###### 4. 初始条件

- 当 $state == 0$，所选质因数为空时，空集为好子集，则 $dp[0] = 1$。同时，对于一个好子集而言，无论向中间添加多少个 $1$，得到的新子集仍是好子集，所以对于空集来说，可以对应出 $2^{cnts[1]}$ 个方案，则最终 $dp[0] = 2^{cnts[1]}$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当质因数的选择的情况为 $state$ 时，好子集的数目。 所以最终结果为所有状态下的好子集数目累积和。所以我们可以枚举所有状态，并记录下所有好子集的数目和，就是最终结果。

### 思路 1：代码

```python
class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cnts = Counter(nums)
        dp = [0 for _ in range(1 << len(primes))]
        dp[0] = pow(2, cnts[1], MOD)            # 计算 1
		
        # num 分解质因数
        for num, cnt in cnts.items():           # 遍历 nums 中所有数及其频数
            if num == 1:                        # 跳过 1
                continue
                
            flag = True                         # 检查 num 的质因数是否都不超过 1
            cur_num = num                       
            cur_state = 0
            for i, prime in enumerate(primes):  # 对 num 进行试除
                cur_cnt = 0
                while cur_num % prime == 0:
                    cur_cnt += 1
                    cur_state |= 1 << i
                    cur_num //= prime
                if cur_cnt > 1:                 # 当前质因数超过 1，则 num 不能添加到子集中，跳过
                    flag = False
                    break
            if not flag:
                continue
            
            for state in range(1 << len(primes)):
                if state & cur_state == 0:      # 只有当前选择状态与前一状态不冲突时，才能进行动态转移
                    dp[state | cur_state] = (dp[state | cur_state] + dp[state] * cnt) % MOD
            
        ans = 0                                 # 统计所有非空集合的方案数
        for i in range(1, 1 << len(primes)):
            ans = (ans + dp[i]) % MOD

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n + m \times 2^p)$，其中 $n$ 为数组 $nums$ 的元素个数，$m$ 为 $nums$ 的最大值，$p$ 为 $[1, 30]$ 中的质数个数。
- **空间复杂度**：$O(2^p)$。
# [2011. 执行操作后的变量值](https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/)

- 标签：数组、字符串、模拟
- 难度：简单

## 题目链接

- [2011. 执行操作后的变量值 - 力扣](https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/)

## 题目大意

存在一种支持 `4` 种操作和 `1` 个变量 `X` 的编程语言：

- `++X` 和 `x++` 使得变量 `X` 值加 `1`。
- `--X` 和 `X--` 使得变脸 `X ` 值减 `1`。

`X` 的初始值是 `0`。现在给定一个字符串数组 `operations`，这是由操作组成的一个列表。

要求：返回执行所有操作后，`X` 的最终值。

## 解题思路

思路很简单，初始答案 `res` 赋值为 `0`。

然后遍历操作列表 `operations`，判断每一个操作 `operation` 的符号。如果操作中含有 `+`，则让答案加 `1`，否则，则让答案减 `1`。最后输出答案。

## 代码

```python
def finalValueAfterOperations(self, operations):
        """
        :type operations: List[str]
        :rtype: int
        """
        res = 0

        for opration in operations:
            res += 1 if '+' in opration else -1

        return res
```

# [2023. 连接后等于目标字符串的字符串对](https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)

- 标签：数组、字符串
- 难度：中等

## 题目链接

- [2023. 连接后等于目标字符串的字符串对 - 力扣](https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)

## 题目大意

**描述**：给定一个数字字符串数组 `nums` 和一个数字字符串 `target`。

**要求**：返回 `nums[i] + nums[j]` （两个字符串连接，其中 `i != j`）结果等于 `target` 的下标 `(i, j)` 的数目。

**说明**：

- $2 \le nums.length \le 100$。
- $1 \le nums[i].length \le 100$。
- $2 \le target.length \le 100$。
- `nums[i]` 和 `target` 只包含数字。
- `nums[i]` 和 `target` 不含有任何前导 $0$。

**示例**：

- 示例 1：

```python
输入：nums = ["777","7","77","77"], target = "7777"
输出：4
解释：符合要求的下标对包括：
- (0, 1)："777" + "7"
- (1, 0)："7" + "777"
- (2, 3)："77" + "77"
- (3, 2)："77" + "77"
```

- 示例 2：

```python
输入：nums = ["123","4","12","34"], target = "1234"
输出：2
解释：符合要求的下标对包括
- (0, 1)："123" + "4"
- (2, 3)："12" + "34"
```

## 解题思路

### 思路 1：暴力枚举

1. 双重循环遍历所有的 `i` 和 `j`，满足 `i != j` 并且 `nums[i] + nums[j] == target` 时，记入到答案数目中。
2. 遍历完，返回答案数目。

### 思路 1：代码

```python
class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        res = 0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if i != j and nums[i] + nums[j] == target:
                    res += 1
        
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(1)$。

### 思路 2：哈希表

1. 使用哈希表记录字符串数组 `nums` 中所有数字字符串的数量。
2. 遍历哈希表中的键 `num`。
3. 将 `target` 根据 `num` 的长度分为前缀 `prefix` 和 `suffix`。
4. 如果 `num` 等于 `prefix`，则判断后缀 `suffix` 是否在哈希表中，如果在哈希表中，则说明 `prefix` 和 `suffix` 能够拼接为 `target`。
   1. 如果 `num` 等于 `suffix`，此时 `perfix == suffix`，则答案数目累积为 `table[prefix] * (table[suffix] - 1)`。
   2. 如果 `num` 不等于 `suffix`，则答案数目累积为 `table[prefix] * table[suffix]`。
5. 最后输出答案数目。

### 思路 2：代码

```python
class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        res = 0
        table = collections.defaultdict(int)
        for num in nums:
            table[num] += 1

        for num in table:
            size = len(num)
            prefix, suffix = target[ :size], target[size: ]
            if num == prefix and suffix in table:
                if num == suffix:
                    res += table[prefix] * (table[suffix] - 1)
                else:
                    res += table[prefix] * table[suffix]
        
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。# [2050. 并行课程 III](https://leetcode.cn/problems/parallel-courses-iii/)

- 标签：图、拓扑排序、数组、动态规划
- 难度：困难

## 题目链接

- [2050. 并行课程 III - 力扣](https://leetcode.cn/problems/parallel-courses-iii/)

## 题目大意

**描述**：给定一个整数 $n$，表示有 $n$ 节课，课程编号为 $1 \sim n$。

再给定一个二维整数数组 $relations$，其中 $relations[j] = [prevCourse_j, nextCourse_j]$，表示课程 $prevCourse_j$ 必须在课程 $nextCourse_j$ 之前完成（先修课的关系）。

再给定一个下标从 $0$ 开始的整数数组 $time$，其中 $time[i]$ 表示完成第 $(i + 1)$ 门课程需要花费的月份数。

现在根据以下规则计算完成所有课程所需要的最少月份数：

- 如果一门课的所有先修课都已经完成，则可以在任意时间开始这门课程。
- 可以同时上任意门课程。

**要求**：返回完成所有课程所需要的最少月份数。

**说明**：

- $1 \le n \le 5 * 10^4$。
- $0 \le relations.length \le min(n * (n - 1) / 2, 5 \times 10^4)$。
- $relations[j].length == 2$。
- $1 \le prevCourse_j, nextCourse_j \le n$。
- $prevCourse_j != nextCourse_j$。
- 所有的先修课程对 $[prevCourse_j, nextCourse_j]$ 都是互不相同的。
- $time.length == n$。
- $1 \le time[i] \le 10^4$。
- 先修课程图是一个有向无环图。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/10/07/ex1.png)

```python
输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
输出：8
解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。
你可以在月份 0 同时开始课程 1 和 2 。
课程 1 花费 3 个月，课程 2 花费 2 个月。
所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/10/07/ex2.png)

```python
输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
输出：12
解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。
你可以在月份 0 同时开始课程 1 ，2 和 3 。
在月份 1，2 和 3 分别完成这三门课程。
课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。
课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。
所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。
```

## 解题思路

### 思路 1：拓扑排序 + 动态规划

1. 使用邻接表 $graph$ 存放课程关系图，并统计每门课程节点的入度，存入入度列表 $indegrees$。定义 $dp[i]$ 为完成第 $i$ 门课程所需要的最少月份数。使用 $ans$ 表示完成所有课程所需要的最少月份数。
2. 借助队列 $queue$，将所有入度为 $0$ 的节点入队。
3. 将队列中入度为 $0$ 的节点依次取出。对于取出的每个节点 $u$：
   1. 遍历该节点的相邻节点 $v$，更新相邻节点 $v$ 所需要的最少月份数，即：$dp[v] = max(dp[v], dp[u] + time[v - 1])$。
   2. 更新完成所有课程所需要的最少月份数 $ans$，即：$ans = max(ans, dp[v])$。
   3. 相邻节点 $v$ 的入度减 $1$，如果入度减 $1$ 后的节点入度为 0，则将其加入队列 $queue$。
4. 重复 $3$ 的步骤，直到队列中没有节点。
5. 最后返回 $ans$。

### 思路 1：代码

```python
class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = [[] for _ in range(n + 1)]
        indegrees = [0 for _ in range(n + 1)]

        for u, v in relations:
            graph[u].append(v)
            indegrees[v] += 1

        queue = collections.deque()
        dp = [0 for _ in range(n + 1)]

        ans = 0
        for i in range(1, n + 1):
            if indegrees[i] == 0:
                queue.append(i)
                dp[i] = time[i - 1]
                ans = max(ans, time[i - 1])

        while queue:
            u = queue.popleft()
            for v in graph[u]:
                dp[v] = max(dp[v], dp[u] + time[v - 1])
                ans = max(ans, dp[v])
                indegrees[v] -= 1
                if indegrees[v] == 0:
                    queue.append(v)

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$，其中 $m$ 为数组 $relations$ 的长度。
- **空间复杂度**：$O(m + n)$。
# [2156. 查找给定哈希值的子串](https://leetcode.cn/problems/find-substring-with-given-hash-value/)

- 标签：字符串、滑动窗口、哈希函数、滚动哈希
- 难度：困难

## 题目链接

- [2156. 查找给定哈希值的子串 - 力扣](https://leetcode.cn/problems/find-substring-with-given-hash-value/)

## 题目大意

**描述**：如果给定整数 `p` 和 `m`，一个长度为 `k` 且下标从 `0` 开始的字符串 `s` 的哈希值按照如下函数计算：

- $hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^{k-1}) mod m$.

其中 `val(s[i])` 表示 `s[i]` 在字母表中的下标，从 `val('a') = 1` 到 `val('z') = 26`。

现在给定一个字符串 `s` 和整数 `power`，`modulo`，`k` 和 `hashValue` 。

**要求**：返回 `s` 中 第一个 长度为 `k` 的 子串 `sub`，满足 `hash(sub, power, modulo) == hashValue`。

**说明**：

- 子串：定义为一个字符串中连续非空字符组成的序列。
- $1 \le k \le s.length \le 2 * 10^4$。
- $1 \le power, modulo \le 10^9$。
- $0 \le hashValue < modulo$。
- `s` 只包含小写英文字母。
- 测试数据保证一定存在满足条件的子串。

**示例**：

- 示例 1：

```python
输入：s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
输出："ee"
解释："ee" 的哈希值为 hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。
"ee" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 "ee" 。
```

## 解题思路

### 思路 1：Rabin Karp 算法、滚动哈希算法

这道题目的思想和 Rabin Karp 字符串匹配算法中用到的滚动哈希思想是一样的。不过两者计算的公式是相反的。

- 本题目中的子串哈希计算公式：$hash(s, p, m) = (val(s[i]) * p^0 + val(s[i+1]) * p^1 + ... + val(s[i+k-1]) * p^{k-1}) \mod m$.

- RK 算法中的子串哈希计算公式：$hash(s, p, m) = (val(s[i]) * p^{k-1} + val(s[i+1]) * p^{k-2} + ... + val(s[i+k-1]) * p^0) \mod m$.

可以看出两者的哈希计算公式是反的。

在 RK 算法中，下一个子串的哈希值计算方式为：$Hash(s_{[i + 1, i + k]}) = \{[Hash(s_{[i, i + k - 1]}) - s_i \times d^{k - 1}] \times d + s_{i + k} \times d^{0} \} \mod m$。其中 $Hash(s_{[i, i + k - 1]}$ 为当前子串的哈希值，$Hash(s_{[i + 1, i + k]})$ 为下一个子串的哈希值。

这个公式也可以用文字表示为：**在计算完当前子串的哈希值后，向右滚动字符串，即移除当前子串中最左侧字符的哈希值（$val(s[i]) * p^{k-1}$）之后，再将整体乘以 $p$，再移入最右侧字符的哈希值 $val(s[i+k])$**。

我们可以参考 RK 算法中滚动哈希的计算方式，将其应用到本题中。

因为两者的哈希计算公式相反，所以本题中，我们可以从右侧想左侧逆向遍历字符串，当计算完当前子串的哈希值后，移除当前子串最右侧字符的哈希值（$ val(s[i+k-1]) * p^{k-1}$）之后，再整体乘以 $p$，再移入最左侧字符的哈希值 $val(s[i - 1])$。

在本题中，对应的下一个逆向子串的哈希值计算方式为：$Hash(s_{[i - 1, i + k - 2]}) = \{ [Hash(s_{[i, i + k - 1]}) - s_{i + k - 1} \times d^{k - 1}] \times d + s_{i - 1} \times d^{0} \} \mod m$。其中 $Hash(s_{[i, i + k - 1]})$ 为当前子串的哈希值，$Hash(s_{[i - 1, i + k - 2]})$ 是下一个逆向子串的哈希值。

利用取模运算的两个公式：

- $(a \times b) \mod m = ((a \mod m) \times (b \mod m)) \mod m$
- $(a + b) \mod m = (a \mod m + b \mod m) \mod m$

我们可以把上面的式子转变为：

$$\begin{aligned} Hash(s_{[i - 1, i + k - 2]}) &=  \{[Hash(s_{[i, i + k - 1]}) - s_{i + k - 1} \times d^{k - 1}] \times d + s_{i - 1} \times d^{0} \} \mod m  \cr &= \{[Hash(s_{[i, i + k - 1]}) - s_{i + k - 1} \times d^{k - 1}] \times d \mod m + s_{i - 1} \times d^{0} \mod m \} \mod m \cr &= \{[Hash(s_{[i, i + k - 1]}) - s_{i + k - 1} \times d^{k - 1}] \mod m \times d \mod m + s_{i - 1} \times d^{0} \mod m \} \mod m \end{aligned}$$

> 注意：这里之所以用了「反向迭代」而不是「正向迭代」是因为如果使用了正向迭代，那么每次移除的最左侧字符哈希值为 $val(s[i]) * p^0$，之后整体需要除以 $p$，再移入最右侧字符哈希值为（$val(s[i+k]) * p^{k-1})$）。
>
> 这样就用到了「除法」。而除法是不满足取模运算对应的公式的，所以这里不能用这种方法进行迭代。
>
> 而反向迭代，用到的是乘法。在整个过程中是满足取模运算相关的公式。乘法取余不影响最终结果。

### 思路 1：代码

```python
class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        hash_t = 0
        n = len(s)
        for i in range(n - 1, n - k - 1, -1):
            hash_t = (hash_t * power + (ord(s[i]) - ord('a') + 1)) % modulo # 计算最后一个子串的哈希值
    
        h = pow(power, k - 1) % modulo                                      # 计算最高位项，方便后续移除操作
        ans = ""
        if hash_t == hashValue:
            ans = s[n - k: n]
        for i in range(n - k - 1, -1, -1):                                   # 反向迭代，滚动计算子串的哈希值
            hash_t = (hash_t - h * (ord(s[i + k]) - ord('a') + 1)) % modulo  # 移除 s[i + k] 的哈希值
            hash_t = (hash_t * power % modulo + (ord(s[i]) - ord('a') + 1) % modulo) % modulo  # 添加 s[i] 的哈希值
            if hash_t == hashValue:                                          # 如果子串哈希值等于 hashValue，则为答案
                ans = s[i: i + k]
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。其中字符串 $s$ 的长度为 $n$。
- **空间复杂度**：$O(1)$。
# [2172. 数组的最大与和](https://leetcode.cn/problems/maximum-and-sum-of-array/)

- 标签：位运算、数组、动态规划、状态压缩
- 难度：困难

## 题目链接

- [2172. 数组的最大与和 - 力扣](https://leetcode.cn/problems/maximum-and-sum-of-array/)

## 题目大意

**描述**：给定一个长度为 $n$ 的整数数组 $nums$ 和一个整数 $numSlots$ 满足 $2 \times numSlots \ge n$。一共有 $numSlots$ 个篮子，编号为 $1 \sim numSlots$。

现在需要将所有 $n$ 个整数分到这些篮子中，且每个篮子最多有 $2$ 个整数。

**要求**：返回将 $nums$ 中所有数放入 $numSlots$ 个篮子中的最大与和。

**说明**：

- **与和**：当前方案中，每个数与它所在篮子编号的按位与运算结果之和。
  - 比如，将数字 $[1, 3]$ 放入篮子 $1$ 中，$[4, 6]$ 放入篮子 $2$ 中，这个方案的与和为 $(1 \text{ AND } 1) + (3 \text{ AND } 1) + (4 \text{ AND } 2) + (6 \text{ AND } 2) = 1 + 1 + 0 + 2 = 4$。
- $n == nums.length$。
- $1 \le numSlots \le 9$。
- $1 \le n \le 2 \times numSlots$。
- $1 \le nums[i] \le 15$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4,5,6], numSlots = 3
输出：9
解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。
最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9。
```

- 示例 2：

```python
输入：nums = [1,3,10,4,7,1], numSlots = 9
输出：24
解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。
最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。
注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。
```

## 解题思路

### 思路 1：状压 DP

每个篮子最多可分 $2$ 个整数，则我们可以将 $1$ 个篮子分成两个篮子，这样总共有 $2 \times numSlots$ 个篮子，每个篮子中最多可以装 $1$ 个整数。

同时因为 $numSlots$ 的范围为 $[1, 9]$，$2 \times numSlots$ 的范围为 $[2, 19]$，范围不是很大，所以我们可以用「状态压缩」的方式来表示每个篮子中的整数放取情况。

即使用一个 $n \times numSlots$ 位的二进制数 $state$ 来表示每个篮子中的整数放取情况。如果 $state$ 的第 $i$ 位为 $1$，表示第 $i$ 个篮子里边放了整数，如果 $state$ 的第 $i$ 位为 $0$，表示第 $i$ 个篮子为空。

这样，我们就可以通过动态规划的方式来解决这道题。

###### 1. 划分阶段

按照 $2 \times numSlots$ 个篮子中的整数放取情况进行阶段划分。

###### 2. 定义状态

定义当前每个篮子中的整数放取情况为 $state$，$state$ 对应选择的整数个数为 $count(state)$。

则可以定义状态 $dp[state]$ 表示为：将前 $count(state)$ 个整数放到篮子里，并且每个篮子中的整数放取情况为 $state$ 时，可以获得的最大与和。

###### 3. 状态转移方程

对于当前状态 $dp[state]$，肯定是从比 $state$ 少选一个元素的状态中递推而来。我们可以枚举少选一个元素的状态，找到可以获得的最大与和，赋值给 $dp[state]$。

即状态转移方程为：$dp[state] = min(dp[state], dp[state \oplus (1 \text{ <}\text{< } i)] + (i // 2 + 1) \text{ \& } nums[one\underline{\hspace{0.5em}}cnt - 1])$，其中：

1. $state$ 第 $i$ 位一定为 $1$。
2. $state \oplus (1 \text{ <}\text{< } i)$ 为比 $state$ 少选一个元素的状态。
3. $i // 2 + 1$ 为篮子对应编号
4. $nums[one\underline{\hspace{0.5em}}cnt - 1]$ 为当前正在考虑的数组元素。

###### 4. 初始条件

- 初始每个篮子中都没有放整数的情况下，可以获得的最大与和为 $0$，即 $dp[0] = 0$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：将前 $count(state)$ 个整数放到篮子里，并且每个篮子中的整数放取情况为 $state$ 时，可以获得的最大与和。所以最终结果为 $max(dp)$。

> 注意：当 $one\underline{\hspace{0.5em}}cnt > len(nums)$ 时，无法通过递推得到 $dp[state]$，需要跳过。

### 思路 1：代码

```python
class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        states = 1 << (numSlots * 2)
        dp = [0 for _ in range(states)]

        for state in range(states):
            one_cnt = bin(state).count('1')
            if one_cnt > len(nums):
                continue
            for i in range(numSlots * 2):
                if (state >> i) & 1:
                    dp[state] = max(dp[state], dp[state ^ (1 << i)] + ((i // 2 + 1) & nums[one_cnt - 1]))
        
        return max(dp)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(2^m \times m)$，其中 $m = 2 \times numSlots$。
- **空间复杂度**：$O(2^m)$。

# [2235. 两整数相加](https://leetcode.cn/problems/add-two-integers/)

- 标签：数学
- 难度：简单

## 题目链接

- [2235. 两整数相加 - 力扣](https://leetcode.cn/problems/add-two-integers/)

## 题目大意

**描述**：给定两个整数 $num1$ 和 $num2$。

**要求**：返回这两个整数的和。

**说明**：

- $-100 \le num1, num2 \le 100$。

**示例**：

- 示例 1：

```python
示例 1：
输入：num1 = 12, num2 = 5
输出：17
解释：num1 是 12，num2 是 5，它们的和是 12 + 5 = 17，因此返回 17。
```

- 示例 2：

```python
输入：num1 = -10, num2 = 4
输出：-6
解释：num1 + num2 = -6，因此返回 -6。
```

## 解题思路

### 思路 1：直接计算

1. 直接计算整数 $num1$ 与 $num2$ 的和，返回 $num1 + num2$ 即可。

### 思路 1：代码

```python
class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。
- **空间复杂度**：$O(1)$。
# [2246. 相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)

- 标签：树、深度优先搜索、图、拓扑排序、数组、字符串
- 难度：困难

## 题目链接

- [2246. 相邻字符不同的最长路径 - 力扣](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)

## 题目大意

**描述**：给定一个长度为 $n$ 的数组 $parent$ 来表示一棵树（即一个连通、无向、无环图）。该树的节点编号为 $0 \sim n - 1$，共 $n$ 个节点，其中根节点的编号为 $0$。其中 $parent[i]$ 表示节点 $i$ 的父节点，由于节点 $0$ 是根节点，所以 $parent[0] == -1$。再给定一个长度为 $n$ 的字符串，其中 $s[i]$ 表示分配给节点 $i$ 的字符。

**要求**：找出路径上任意一对相邻节点都没有分配到相同字符的最长路径，并返回该路径的长度。

**说明**：

- $n == parent.length == s.length$。
- $1 \le n \le 10^5$。
- 对所有 $i \ge 1$ ，$0 \le parent[i] \le n - 1$ 均成立。
- $parent[0] == -1$。
- $parent$ 表示一棵有效的树。
- $s$ 仅由小写英文字母组成。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png)

```python
输入：parent = [-1,0,0,1,1,2], s = "abacbe"
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：0 -> 1 -> 3 。该路径的长度是 3 ，所以返回 3。
可以证明不存在满足上述条件且比 3 更长的路径。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png)

```python
输入：parent = [-1,0,0,0], s = "aabc"
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：2 -> 0 -> 3 。该路径的长度为 3 ，所以返回 3。
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

因为题目给定的是表示父子节点的 $parent$  数组，为了方便递归遍历相邻节点，我们可以根据 $partent$ 数组，建立一个由父节点指向子节点的有向图 $graph$。

如果不考虑相邻节点是否为相同字符这一条件，那么这道题就是在求树的直径（树的最长路径长度）中的节点个数。

对于根节点为 $u$ 的树来说：

1. 如果其最长路径经过根节点 $u$，则 **最长路径长度 = 某子树中的最长路径长度 + 另一子树中的最长路径长度 + 1**。
2. 如果其最长路径不经过根节点 $u$，则 **最长路径长度 = 某个子树中的最长路径长度**。

即：**最长路径长度 = max(某子树中的最长路径长度 + 另一子树中的最长路径长度 + 1，某个子树中的最长路径长度)**。

对此，我们可以使用深度优先搜索递归遍历 $u$ 的所有相邻节点 $v$，并在递归遍历的同时，维护一个全局最大路径和变量 $ans$，以及当前节点 $u$ 的最大路径长度变量 $u\underline{\hspace{0.5em}}len$。

1. 先计算出从相邻节点 $v$ 出发的最长路径长度 $v\underline{\hspace{0.5em}}len$。
2. 更新维护全局最长路径长度为 $self.ans = max(self.ans, \quad u\underline{\hspace{0.5em}}len + v\underline{\hspace{0.5em}}len + 1)$。
3. 更新维护当前节点 $u$ 的最长路径长度为 $u\underline{\hspace{0.5em}}len = max(u\underline{\hspace{0.5em}}len, \quad v\underline{\hspace{0.5em}}len + 1)$。

因为题目限定了「相邻节点字符不同」，所以在更新全局最长路径长度和当前节点 $u$ 的最长路径长度时，我们需要判断一下节点 $u$ 与相邻节点 $v$ 的字符是否相同，只有在字符不同的条件下，才能够更新维护。

最后，因为题目要求的是树的直径（树的最长路径长度）中的节点个数，而：**路径的节点 = 路径长度 + 1**，所以最后我们返回 $self.ans + 1$ 作为答案。

### 思路 1：代码

```python
class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        size = len(parent)

        # 根据 parent 数组，建立有向图
        graph = [[] for _ in range(size)]
        for i in range(1, size):
            graph[parent[i]].append(i)

        ans = 0
        def dfs(u):
            nonlocal ans
            u_len = 0                                   # u 节点的最大路径长度
            for v in graph[u]:                          # 遍历 u 节点的相邻节点
                v_len = dfs(v)                          # 相邻节点的最大路径长度
                if s[u] != s[v]:                        # 相邻节点字符不同
                    ans = max(ans, u_len + v_len + 1)   # 维护最大路径长度
                    u_len = max(u_len, v_len + 1)       # 更新 u 节点的最大路径长度
            return u_len                                # 返回 u 节点的最大路径长度

        dfs(0)
        return ans + 1
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是树的节点数目。
- **空间复杂度**：$O(n)$。
# [2249. 统计圆内格点数目](https://leetcode.cn/problems/count-lattice-points-inside-a-circle/)

- 标签：几何、数组、哈希表、数学、枚举
- 难度：中等

## 题目链接

- [2249. 统计圆内格点数目 - 力扣](https://leetcode.cn/problems/count-lattice-points-inside-a-circle/)

## 题目大意

**描述**：给定一个二维整数数组 `circles`。其中 `circles[i] = [xi, yi, ri]` 表示网格上圆心为 `(xi, yi)` 且半径为 `ri` 的第 $i$ 个圆。

**要求**：返回出现在至少一个圆内的格点数目。

**说明**：

- **格点**：指的是整数坐标对应的点。
- 圆周上的点也被视为出现在圆内的点。
- $1 \le circles.length \le 200$。
- $circles[i].length == 3$。
- $1 \le xi, yi \le 100$。
- $1 \le ri \le min(xi, yi)$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2022/03/02/exa-11.png)

```python
输入：circles = [[2,2,1]]
输出：5
解释：
给定的圆如上图所示。
出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。
像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。
因此，出现在至少一个圆内的格点数目是 5。
```

- 示例 2：

```python
输入：circles = [[2,2,2],[3,4,1]]
输出：16
解释：
给定的圆如上图所示。
共有 16 个格点出现在至少一个圆内。
其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4)。
```

## 解题思路

### 思路 1：枚举算法

题目要求中 $1 \le xi, yi \le 100$，$1 \le ri \le min(xi, yi)$。则圆中点的范围为 $1 \le x, y \le 200$。

我们可以枚举所有坐标和所有圆，检测该坐标是否在圆中。

为了优化枚举范围，我们可以先遍历一遍所有圆，计算最小、最大的 $x$、$y$ 范围，再枚举所有坐标和所有圆，并进行检测。

### 思路 1：代码

```python
class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        min_x, min_y = 200, 200
        max_x, max_y = 0, 0
        for circle in circles:
            if circle[0] + circle[2] > max_x:
                max_x = circle[0] + circle[2]
            if circle[0] - circle[2] < min_x:
                min_x = circle[0] - circle[2]
            if circle[1] + circle[2] > max_y:
                max_y = circle[1] + circle[2]
            if circle[1] - circle[2] < min_y:
                min_y = circle[1] - circle[2]
        
        ans = 0
        for x in range(min_x, max_x + 1):
            for y in range(min_y, max_y + 1):
                for xi, yi, ri in circles:
                    if (xi - x) * (xi - x) + (yi - y) * (yi - y) <= ri * ri:
                        ans += 1
                        break
        
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(x \times y)$，其中 $x$、$y$ 分别为横纵坐标的个数。
- **空间复杂度**：$O(1)$。
# [2276. 统计区间中的整数数目](https://leetcode.cn/problems/count-integers-in-intervals/)

- 标签：设计、线段树、有序集合
- 难度：困难

## 题目链接

- [2276. 统计区间中的整数数目 - 力扣](https://leetcode.cn/problems/count-integers-in-intervals/)

## 题目大意

**描述**：给定一个区间的空集。

**要求**：设计并实现满足要求的数据结构：

- 新增：添加一个区间到这个区间集合中。
- 统计：计算出现在 至少一个 区间中的整数个数。

实现 CountIntervals 类：

- `CountIntervals()` 使用区间的空集初始化对象
- `void add(int left, int right)` 添加区间 `[left, right]` 到区间集合之中。
- `int count()` 返回出现在 至少一个 区间中的整数个数。

**说明**：

- 区间 `[left, right]` 表示满足 $left \le x \le right$ 的所有整数 `x`。
- $1 \le left \le right \le 10^9$。
- 最多调用 `add` 和 `count` 方法 **总计** $10^5$ 次。
- 调用 `count` 方法至少一次。

**示例**：

- 示例 1：

```python
输入：
["CountIntervals", "add", "add", "count", "add", "count"]
[[], [2, 3], [7, 10], [], [5, 8], []]
输出：
[null, null, null, 6, null, 8]

解释：
CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象
countIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中
countIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中
countIntervals.count();    // 返回 6
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 7、8、9、10 出现在区间 [7, 10] 中
countIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中
countIntervals.count();    // 返回 8
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 5 和 6 出现在区间 [5, 8] 中
                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中
                           // 整数 9 和 10 出现在区间 [7, 10] 中
```

## 解题思路

### 思路 1：动态开点线段树

这道题可以使用线段树来做。

因为区间的范围是 $[1, 10^9]$，普通数组构成的线段树不满足要求。需要用到动态开点线段树。具体做法如下：

- 初始化方法，构建一棵线段树。每个线段树的节点类存储当前区间中保存的元素个数。

- 在 `add` 方法中，将区间 `[left, right]` 上的每个元素值赋值为 `1`，则区间值为 `right - left + 1`。

- 在 `count` 方法中，返回区间 $[0, 10^9]$ 的区间值（即区间内元素个数）。

### 思路 1：动态开点线段树代码

```python
# 线段树的节点类
class SegTreeNode:
    def __init__(self, left=-1, right=-1, val=0, lazy_tag=None, leftNode=None, rightNode=None):
        self.left = left                            # 区间左边界
        self.right = right                          # 区间右边界
        self.mid = left + (right - left) // 2
        self.leftNode = leftNode                    # 区间左节点
        self.rightNode = rightNode                  # 区间右节点
        self.val = val                              # 节点值（区间值）
        self.lazy_tag = lazy_tag                    # 区间问题的延迟更新标记
        
        
# 线段树类
class SegmentTree:
    # 初始化线段树接口
    def __init__(self, function):
        self.tree = SegTreeNode(0, int(1e9))
        self.function = function                    # function 是一个函数，左右区间的聚合方法
    
    # 区间更新接口：将区间为 [q_left, q_right] 上的元素值修改为 val
    def update_interval(self, q_left, q_right, val):
        self.__update_interval(q_left, q_right, val, self.tree)
    
    # 区间查询接口：查询区间为 [q_left, q_right] 的区间值
    def query_interval(self, q_left, q_right):
        return self.__query_interval(q_left, q_right, self.tree)
            
    
    # 以下为内部实现方法
    
    # 区间更新实现方法
    def __update_interval(self, q_left, q_right, val, node):
        if node.left >= q_left and node.right <= q_right:  # 节点所在区间被 [q_left, q_right] 所覆盖
            node.lazy_tag = val                     # 将当前节点的延迟标记标记为 val
            interval_size = (node.right - node.left + 1)    # 当前节点所在区间大小
            node.val = val * interval_size          # 当前节点所在区间每个元素值改为 val
            return
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return
    
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
    
        if q_left <= node.mid:                      # 在左子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.leftNode)
        if q_right > node.mid:                      # 在右子树中更新区间值
            self.__update_interval(q_left, q_right, val, node.rightNode)
            
        self.__pushup(node)
    
    # 区间查询实现方法：在线段树的 [left, right] 区间范围中搜索区间为 [q_left, q_right] 的区间值
    def __query_interval(self, q_left, q_right, node):
        if node.left >= q_left and node.right <= q_right:   # 节点所在区间被 [q_left, q_right] 所覆盖
            return node.val                         # 直接返回节点值
        if node.right < q_left or node.left > q_right:  # 节点所在区间与 [q_left, q_right] 无关
            return 0
                                  
        self.__pushdown(node)                       # 向下更新节点所在区间的左右子节点的值和懒惰标记
        
        res_left = 0                                # 左子树查询结果
        res_right = 0                               # 右子树查询结果
        if q_left <= node.mid:                      # 在左子树中查询
            res_left = self.__query_interval(q_left, q_right, node.leftNode)
        if q_right > node.mid:                      # 在右子树中查询
            res_right = self.__query_interval(q_left, q_right, node.rightNode)
        return self.function(res_left, res_right)   # 返回左右子树元素值的聚合计算结果
    
    # 向上更新实现方法：更新 node 节点区间值 等于 该节点左右子节点元素值的聚合计算结果
    def __pushup(self, node):
        if node.leftNode and node.rightNode:
            node.val = self.function(node.leftNode.val, node.rightNode.val)
            
    # 向下更新实现方法：更新 node 节点所在区间的左右子节点的值和懒惰标记
    def __pushdown(self, node):
        if node.leftNode is None:
            node.leftNode = SegTreeNode(node.left, node.mid)
        if node.rightNode is None:
            node.rightNode = SegTreeNode(node.mid + 1, node.right)
            
        lazy_tag = node.lazy_tag
        if node.lazy_tag is None:
            return
            
        node.leftNode.lazy_tag = lazy_tag           # 更新左子节点懒惰标记
        left_size = (node.leftNode.right - node.leftNode.left + 1)
        node.leftNode.val = lazy_tag * left_size    # 更新左子节点值
        
        node.rightNode.lazy_tag = lazy_tag          # 更新右子节点懒惰标记
        right_size = (node.rightNode.right - node.rightNode.left + 1)
        node.rightNode.val = lazy_tag * right_size  # 更新右子节点值
        
        node.lazy_tag = None                        # 更新当前节点的懒惰标记
    
    
class CountIntervals:

    def __init__(self):
        self.STree = SegmentTree(lambda x, y: x + y)
        self.left = 10 ** 9
        self.right = 0


    def add(self, left: int, right: int) -> None:
        self.STree.update_interval(left, right, 1) 


    def count(self) -> int:
        return self.STree.query_interval(0, int(1e9))



# Your CountIntervals object will be instantiated and called as such:
# obj = CountIntervals()
# obj.add(left,right)
# param_2 = obj.count()
```

# [2376. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/)

- 标签：数学、动态规划
- 难度：困难

## 题目链接

- [2376. 统计特殊整数 - 力扣](https://leetcode.cn/problems/count-special-integers/)

## 题目大意

**描述**：给定一个正整数 $n$。

**要求**：求区间 $[1, n]$ 内的所有整数中，特殊整数的数目。

**说明**：

- **特殊整数**：如果一个正整数的每一个数位都是互不相同的，则称它是特殊整数。
- $1 \le n \le 2 \times 10^9$。

**示例**：

- 示例 1：

```python
输入：n = 20
输出：19
解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。
```

- 示例 2：

```python
输入：n = 5
输出：5
解释：1 到 5 所有整数都是特殊整数。
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, state, isLimit, isNum):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True, False)` 开始递归。 `dfs(0, 0, True, False)` 表示：
      1. 从位置 $0$ 开始构造。
      2. 初始没有使用数字（即前一位所选数字集合为 $0$）。
      3. 开始时受到数字 $n$ 对应最高位数位的约束。
      4. 开始时没有填写数字。

2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
      1. 如果 $isNum == True$，说明当前方案符合要求，则返回方案数 $1$。
      2. 如果 $isNum == False$，说明当前方案不符合要求，则返回方案数 $0$。

3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
      1. 根据 $isNum$ 和 $isLimit$ 来决定填当前位数位所能选择的最小数字（$minX$）和所能选择的最大数字（$maxX$），
      2. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
      3. 如果之前没有选择 $d$，即 $d$ 不在之前选择的数字集合 $state$ 中，则方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)`。
            1. `state | (1 << d)` 表示之前选择的数字集合 $state$ 加上 $d$。
            2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前 $pos$ 位限制。
            3. $isNum == True$ 表示 $pos$ 位选择了数字。

6. 最后的方案数为 `dfs(0, 0, True, False)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # state: 之前选过的数字集合。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        # isNum: 表示 pos 前面的数位是否填了数字。如果为真，则当前位不可跳过；如果为假，则当前位可跳过。
        def dfs(pos, state, isLimit, isNum):
            if pos == len(s):
                # isNum 为 True，则表示当前方案符合要求
                return int(isNum)
            
            ans = 0
            if not isNum:
                # 如果 isNum 为 False，则可以跳过当前数位
                ans = dfs(pos + 1, state, False, False)
            
            # 如果前一位没有填写数字，则最小可选择数字为 0，否则最少为 1（不能含有前导 0）。
            minX = 0 if isNum else 1
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                # d 不在选择的数字集合中，即之前没有选择过 d
                if (state >> d) & 1 == 0:
                    ans += dfs(pos + 1, state | (1 << d), isLimit and d == maxX, True)
            return ans
    
        return dfs(0, 0, True, False)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n \times 10 \times 2^{10})$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(\log n \times 2^{10})$。
# [2427. 公因子的数目](https://leetcode.cn/problems/number-of-common-factors/)

- 标签：数学、枚举、数论
- 难度：简单

## 题目链接

- [2427. 公因子的数目 - 力扣](https://leetcode.cn/problems/number-of-common-factors/)

## 题目大意

**描述**：给定两个正整数 $a$ 和 $b$。

**要求**：返回 $a$ 和 $b$ 的公因子数目。

**说明**：

- **公因子**：如果 $x$ 可以同时整除 $a$ 和 $b$，则认为 $x$ 是 $a$ 和 $b$ 的一个公因子。
- $1 \le a, b \le 1000$。

**示例**：

- 示例 1：

```python
输入：a = 12, b = 6
输出：4
解释：12 和 6 的公因子是 1、2、3、6。
```

- 示例 2：

```python
输入：a = 25, b = 30
输出：2
解释：25 和 30 的公因子是 1、5。
```

## 解题思路

### 思路 1：枚举算法

最直接的思路就是枚举所有 $[1, min(a, b)]$ 之间的数，并检查是否能同时整除 $a$ 和 $b$。

当然，因为 $a$ 与 $b$ 的公因子肯定不会超过 $a$ 与 $b$ 的最大公因数，则我们可以直接枚举 $[1, gcd(a, b)]$ 之间的数即可，其中 $gcd(a, b)$ 是 $a$ 与 $b$ 的最大公约数。

### 思路 1：代码

```python
class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        ans = 0
        for i in range(1, math.gcd(a, b) + 1):
            if a % i == 0 and b % i == 0:
                ans += 1
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\sqrt{min(a, b)})$。
- **空间复杂度**：$O(1)$。
# [2538. 最大价值和与最小价值和的差值](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/)

- 标签：树、深度优先搜索、数组、动态规划
- 难度：困难

## 题目链接

- [2538. 最大价值和与最小价值和的差值 - 力扣](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/)

## 题目大意

**描述**：给定一个整数 $n$ 和一个长度为 $n - 1$ 的二维整数数组 $edges$ 用于表示一个 $n$ 个节点的无向无根图，节点编号为 $0 \sim n - 1$。其中 $edges[i] = [ai, bi]$ 表示树中节点 $ai$ 和 $bi$ 之间有一条边。再给定一个整数数组 $price$，其中 $price[i]$ 表示图中节点 $i$ 的价值。

一条路径的价值和是这条路径上所有节点的价值之和。

你可以选择树中任意一个节点作为根节点 $root$。选择 $root$ 为根的开销是以 $root$ 为起点的所有路径中，价值和最大的一条路径与最小的一条路径的差值。

**要求**：返回所有节点作为根节点的选择中，最大的开销为多少。

**说明**：

- $1 \le n \le 10^5$。
- $edges.length == n - 1$。
- $0 \le ai, bi \le n - 1$。
- $edges$ 表示一棵符合题面要求的树。
- $price.length == n$。
- $1 \le price[i] \le 10^5$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2022/12/01/example14.png)

```python
输入：n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
输出：24
解释：上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。
- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。
- 第二条路径节点为 [2] ，价值为 [7] 。
最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png)

```python
输入：n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
输出：2
解释：上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。
- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。
- 第二条路径节点为 [0] ，价值为 [1] 。
最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。
```

## 解题思路

### 思路 1：树形 DP + 深度优先搜索

1. 因为 $price$ 数组中元素都为正数，所以价值和最小的一条路径一定为「单个节点」，也就是根节点 $root$ 本身。
2. 因为价值和最大的路径是从根节点 $root$ 出发的价值和最大的一条路径，所以「最大的开销」等于「从根节点 $root$ 出发的价值和最大的一条路径」与「路径中一个端点值」 的差值。
3. 价值和最大的路径的两个端点中，一个端点为根节点 $root$，另一个节点为叶子节点。

这样问题就变为了求树中一条路径，使得路径的价值和减去其中一个端点值的权值最大。

对此我们可以使用深度优先搜索递归遍历二叉树，并在递归遍历的同时，维护一个最大开销变量 $ans$。

然后定义函数 ` def dfs(self, u, father):` 计算以节点 $u$ 为根节点的子树中，带端点的最大路径和 $max\underline{\hspace{0.5em}}s1$，以及去掉端点的最大路径和 $max\underline{\hspace{0.5em}}s2$，其中 $father$ 表示节点 $u$ 的根节点，用于遍历邻接节点的过程中过滤父节点，避免重复遍历。

初始化带端点的最大路径和 $max\underline{\hspace{0.5em}}s1$ 为 $price[u]$，表示当前只有一个节点，初始化去掉端点的最大路径和 $max\underline{\hspace{0.5em}}s2$ 为 $0$，表示当前没有节点。

然后在遍历节点 $u$ 的相邻节点 $v$ 时，递归调用 $dfs(v, u)$，获取以节点 $v$ 为根节点的子树中，带端点的最大路径和 $s1$，以及去掉端点的最大路径和 $s2$。此时最大开销变量 $self.ans$ 有两种情况：

1. $u$ 的子树中带端点的最大路径和，加上 $v$ 的子树中不带端点的最大路径和，即：$max\underline{\hspace{0.5em}}s1 + s2$。
2. $u$ 的子树中去掉端点的最大路径和，加上 $v$ 的子树中带端点的最大路径和，即：$max\underline{\hspace{0.5em}}s2 + s1$。

此时我们更新最大开销变量 $self.ans$，即：$self.ans = max(self.ans, \quad max\underline{\hspace{0.5em}}s1 + s2, \quad  max\underline{\hspace{0.5em}}s2 + s1)$。

然后更新 $u$ 的子树中带端点的最大路径和 $max\underline{\hspace{0.5em}}s1$，即：$max\underline{\hspace{0.5em}}s1= max(max\underline{\hspace{0.5em}}s1, \quad s1 + price[u])$。

再更新 $u$ 的子树中去掉端点的最大路径和 $max\underline{\hspace{0.5em}}s2$，即：$max\underline{\hspace{0.5em}}s2 = max(max\underline{\hspace{0.5em}}s2, \quad s2 + price[u])$。

最后返回带端点 $u$ 的最大路径和 $max\underline{\hspace{0.5em}}s1$，以及去掉端点 $u$ 的最大路径和 $。

最终，最大开销变量 $self.ans$ 即为答案。

### 思路 1：代码

```python
class Solution:
    def __init__(self):
        self.ans = 0
        
    def dfs(self, graph, price, u, father):
        max_s1 = price[u]
        max_s2 = 0
        for v in graph[u]:
            if v == father:    # 过滤父节点，避免重复遍历
                continue
            s1, s2 = self.dfs(graph, price, v, u)
            self.ans = max(self.ans, max_s1 + s2, max_s2 + s1)
            max_s1 = max(max_s1, s1 + price[u])
            max_s2 = max(max_s2, s2 + price[u])
        return max_s1, max_s2

    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        self.dfs(graph, price, 0, -1)
        return self.ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中节点个数。
- **空间复杂度**：$O(n)$。

## 参考链接

- 【题解】[二维差分模板 双指针 树形DP 树的直径【力扣周赛 328】](https://www.bilibili.com/video/BV1QT41127kJ/)
- 【题解】[2538. 最大价值和与最小价值和的差值 题解](https://github.com/doocs/leetcode/blob/main/solution/2500-2599/2538.Difference Between Maximum and Minimum Price Sum/README.md)
# [2585. 获得分数的方法数](https://leetcode.cn/problems/number-of-ways-to-earn-points/)

- 标签：数组、动态规划
- 难度：困难

## 题目链接

- [2585. 获得分数的方法数 - 力扣](https://leetcode.cn/problems/number-of-ways-to-earn-points/)

## 题目大意

**描述**：考试中有 $n$ 种类型的题目。给定一个整数 $target$ 和一个下标从 $0$ 开始的二维整数数组 $types$，其中 $types[i] = [count_i, marks_i]$ 表示第 $i$ 种类型的题目有 $count_i$ 道，每道题目对应 $marks_i$ 分。

**要求**：返回你在考试中恰好得到 $target$ 分的方法数。由于答案可能很大，结果需要对 $10^9 + 7$ 取余。

**说明**：

- 同类型题目无法区分。比如说，如果有 $3$ 道同类型题目，那么解答第 $1$ 和第 $2$ 道题目与解答第 $1$ 和第 $3$ 道题目或者第 $2$ 和第 $3$ 道题目是相同的。
- $1 \le target \le 1000$。
- $n == types.length$。
- $1 \le n \le 50$。
- $types[i].length == 2$。
- $1 \le counti, marksi \le 50$。

**示例**：

- 示例 1：

```python
输入：target = 6, types = [[6,1],[3,2],[2,3]]
输出：7
解释：要获得 6 分，你可以选择以下七种方法之一：
- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6
- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6
- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6
- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6
- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6
- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6
- 解决 2 道第 2 种类型的题目：3 + 3 = 6
```

- 示例 2：

```python
输入：target = 5, types = [[50,1],[50,2],[50,5]]
输出：4
解释：要获得 5 分，你可以选择以下四种方法之一：
- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5
- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5
- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5
- 解决 1 道第 2 种类型的题目：5
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][w]$ 表示为：前 $i$ 种题目恰好组成 $w$ 分的方案数。

###### 3. 状态转移方程

前 $i$ 种题目恰好组成 $w$ 分的方案数，等于前 $i - 1$ 种问题恰好组成 $w - k \times marks_i$ 分的方案数总和，即状态转移方程为：$dp[i][w] = \sum_{k = 0} dp[i - 1][w - k \times marks_i]$。

###### 4. 初始条件

- 前 $0$ 种题目恰好组成 $0$ 分的方案数为 $1$。

###### 5. 最终结果

根据我们之前定义的状态， $dp[i][w]$ 表示为：前 $i$ 种题目恰好组成 $w$ 分的方案数。 所以最终结果为 $dp[size][target]$。

### 思路 1：代码

```python
class Solution:    
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        size = len(types)
        group_count = [types[i][0] for i in range(len(types))]
        weight = [[(types[i][1] * k) for k in range(types[i][0] + 1)] for i in range(len(types))]
        mod = 1000000007
            
        dp = [[0 for _ in range(target + 1)] for _ in range(size + 1)]
        dp[0][0] = 1
        
        # 枚举前 i 组物品
        for i in range(1, size + 1):
            # 枚举背包装载重量
            for w in range(target + 1):
                # 枚举第 i 组物品能取个数
                dp[i][w] = dp[i - 1][w]
                for k in range(1, group_count[i - 1] + 1):
                    if w >= weight[i - 1][k]:
                        dp[i][w] += dp[i - 1][w - weight[i - 1][k]]
                        dp[i][w] %= mod
        
        return dp[size][target]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times target \times m)$，其中 $n$ 为题目种类数，$target$ 为目标分数，$m$ 为每种题目的最大分数。
- **空间复杂度**：$O(n \times target)$。

# [2719. 统计整数数目](https://leetcode.cn/problems/count-of-integers/)

- 标签：数学、字符串、动态规划
- 难度：困难

## 题目链接

- [2719. 统计整数数目 - 力扣](https://leetcode.cn/problems/count-of-integers/)

## 题目大意

**描述**：给定两个数字字符串 $num1$ 和 $num2$，以及两个整数 $max\underline{\hspace{0.5em}}sum$ 和 $min\underline{\hspace{0.5em}}sum$。

**要求**：返回好整数的数目。答案可能很大，请返回答案对 $10^9 + 7$ 取余后的结果。

**说明**：

- **好整数**：如果一个整数 $x$ 满足一下条件，我们称它是一个好整数：
  - $num1 \le x \le num2$。
  - $num\underline{\hspace{0.5em}}sum \le digit\underline{\hspace{0.5em}}sum(x) \le max\underline{\hspace{0.5em}}sum$。

- $digit\underline{\hspace{0.5em}}sum(x)$ 表示 $x$ 各位数字之和。
- $1 \le num1 \le num2 \le 10^{22}$。
- $1 \le min\underline{\hspace{0.5em}}sum \le max\underline{\hspace{0.5em}}sum \le 400$。

**示例**：

- 示例 1：

```python
输入：num1 = "1", num2 = "12", min_num = 1, max_num = 8
输出：11
解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11。
```

- 示例 2：

```python
输入：num1 = "1", num2 = "5", min_num = 1, max_num = 5
输出：5
解释：数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5。
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $num1$ 补上前导 $0$，补到和 $num2$ 长度一致，定义递归函数 `def dfs(pos, total, isMaxLimit, isMinLimit):` 表示构造第 $pos$ 位及之后所有数位的合法方案数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True, True)` 开始递归。 `dfs(0, 0, True, True)` 表示：
	1. 从位置 $0$ 开始构造。
	2. 初始数位和为 $0$。
	3. 开始时当前数位最大值受到最高位数位的约束。
	4. 开始时当前数位最小值受到最高位数位的约束。
2. 如果 $total > max\underline{\hspace{0.5em}}sum$，说明当前方案不符合要求，则返回方案数 $0$。
3. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：
	1. 如果 $min\underline{\hspace{0.5em}}sum \le total \le max\underline{\hspace{0.5em}}sum$，说明当前方案符合要求，则返回方案数 $1$。
	2. 如果不满足，则当前方案不符合要求，则返回方案数 $0$。
4. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
5. 根据 $isMaxLimit$ 和 $isMinLimit$ 来决定填当前位数位所能选择的最小数字（$minX$）和所能选择的最大数字（$maxX$）。
6. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
7. 方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, total + d, isMaxLimit and d == maxX, isMinLimit and d == minX)`。
	1. `total + d` 表示当前数位和 $total$ 加上 $d$。
	2. `isMaxLimit and d == maxX` 表示 $pos + 1$ 位最大值受到之前 $pos$ 位限制。
	3. `isMinLimit and d == maxX` 表示 $pos + 1$ 位最小值受到之前 $pos$ 位限制。
8. 最后的方案数为 `dfs(0, 0, True, True) % MOD`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        MOD = 10 ** 9 + 7
        # 将 num1 补上前导 0，补到和 num2 长度一致
        m, n = len(num1), len(num2)
        if m < n:
            num1 = '0' * (n - m) + num1
        
        @cache
        # pos: 第 pos 个数位
        # total: 表示数位和
        # isMaxLimit: 表示是否受到上限选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        # isMaxLimit: 表示是否受到下限选择限制。如果为真，则第 pos 位填入数字最小为 s[pos]；如果为假，则最小可为 0。
        def dfs(pos, total, isMaxLimit, isMinLimit):
            if total > max_sum:
                return 0
            
            if pos == n:
                # 当 min_sum <= total <= max_sum 时，当前方案符合要求
                return int(total >= min_sum)
            
            ans = 0
            # 如果受到选择限制，则最小可选择数字为 num1[pos]，否则最大可选择数字为 0。
            minX = int(num1[pos]) if isMinLimit else 0
            # 如果受到选择限制，则最大可选择数字为 num2[pos]，否则最大可选择数字为 9。
            maxX = int(num2[pos]) if isMaxLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                ans += dfs(pos + 1, total + d, isMaxLimit and d == maxX, isMinLimit and d == minX)
            return ans % MOD
    
        return dfs(0, 0, True, True) % MOD
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 10)$，其中 $n$ 为数组 $nums2$ 的长度。
- **空间复杂度**：$O(n \times max\underline{\hspace{0.5em}}sum)$。

# 题目相关

- 标签：
- 难度：

## 题目链接

- 题目相关

## 题目大意

**描述**：

**要求**：

**说明**：

- 

**示例**：

- 示例 1：

```python
```

- 示例 2：

```python
```

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照 进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i]$ 表示为：。

###### 3. 状态转移方程



###### 4. 初始条件



###### 5. 最终结果

根据我们之前定义的状态，$dp[i]$ 表示为：。 所以最终结果为 $dp[size]$。

### 思路 1：代码

```python

```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：
# 题目相关

- 标签：
- 难度：

## 题目链接

- 题目相关

## 题目大意

**描述**：

**要求**：

**说明**：

- 

**示例**：

- 示例 1：

```python
```

- 示例 2：

```python
```

## 解题思路

### 思路 1：



### 思路 1：代码

```python

```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

### 思路 2：



### 思路 2：代码

```python

```

### 思路 2：复杂度分析

- **时间复杂度**：
- **空间复杂度**：# [剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

- 标签：数组、哈希表、排序
- 难度：简单

## 题目链接

- [剑指 Offer 03. 数组中重复的数字 - 力扣](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

## 题目大意

给定一个包含 `n + 1` 个整数的数组 `nums`，里边包含的值都在 `1 ~ n` 之间。假设 `nums` 中只存在一个重复的整数，要求找出这个重复的数。

## 解题思路

使用哈希表存储数组每个元素，遇到重复元素则直接返回该元素。

## 代码

```python
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        nums_dict = dict()
        for num in nums:
            if num in nums_dict:
                return num
            nums_dict[num] = 1
        return -1
```

# [剑指 Offer 04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

- 标签：数组、二分查找、分治、矩阵
- 难度：中等

## 题目链接

- [剑指 Offer 04. 二维数组中的查找 - 力扣](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

## 题目大意

给定一个 `m * n` 大小的有序整数矩阵 `matrix`。每行元素从左到右升序排列，每列元素从上到下升序排列。再给定一个目标值 `target`。

要求：判断矩阵中是否可以找到 `target`，若找到 `target`，返回 `True`，否则返回 `False`。

## 解题思路

矩阵是有序的，可以考虑使用二分搜索来进行查找。

迭代对角线元素，假设对角线元素的坐标为 `(row, col)`。把数组元素按对角线分为右上角部分和左下角部分。

则对于当前对角线元素右侧第 `row` 行、对角线元素下侧第 `col` 列进行二分查找。

- 如果找到目标，直接返回 `True`。
- 如果找不到目标，则缩小范围，继续查找。
- 直到所有对角线元素都遍历完，依旧没找到，则返回 `False`。

## 代码

```python
class Solution:
    def diagonalBinarySearch(self, matrix, diagonal, target):
        left = 0
        right = diagonal
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def rowBinarySearch(self, matrix, begin, cols, target):
        left = begin
        right = cols
        while left < right:
            mid = left + (right - left) // 2
            if matrix[begin][mid] < target:
                left = mid + 1
            elif matrix[begin][mid] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= cols and matrix[begin][left] == target

    def colBinarySearch(self, matrix, begin, rows, target):
        left = begin + 1
        right = rows
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][begin] < target:
                left = mid + 1
            elif matrix[mid][begin] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= rows and matrix[left][begin] == target

    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        rows = len(matrix)
        if rows == 0:
            return False
        cols = len(matrix[0])
        if cols == 0:
            return False

        min_val = min(rows, cols)
        index = self.diagonalBinarySearch(matrix, min_val - 1, target)
        if matrix[index][index] == target:
            return True
        for i in range(index + 1):
            row_search = self.rowBinarySearch(matrix, i, cols - 1, target)
            col_search = self.colBinarySearch(matrix, i, rows - 1, target)
            if row_search or col_search:
                return True
        return False
```

# [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

- 标签：字符串
- 难度：简单

## 题目链接

- [剑指 Offer 05. 替换空格 - 力扣](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

## 题目大意

给定一个字符串 `s`。

要求：将字符串 `s` 中的每个空格换成 `%20`。

## 解题思路

Python 的字符串是不可变类型，所以需要先用数组存储答案，再将其转为字符串返回。具体操作如下。

- 定义数组 `res`，遍历字符串 `s`。
  - 如果当前字符 `ch` 为空格，则将 ` %20` 加入到数组中。
  - 如果当前字符 `ch` 不为空格，则直接加入到数组中。
- 遍历完之后，通过 `join` 将其转为字符串返回。

## 代码

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        res = []
        for ch in s:
            if ch == ' ':
                res.append("%20")
            else:
                res.append(ch)
        return "".join(res)
```

# [剑指 Offer 06. 从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 标签：栈、递归、链表、双指针
- 难度：简单

## 题目链接

- [剑指 Offer 06. 从尾到头打印链表 - 力扣](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

## 题目大意

给定一个链表的头节点 `head`。

要求：从尾到头反过来返回每个节点的值（用数组返回）。

## 解题思路

- 定义数组 `res`，从头到尾遍历链表。
- 将每个节点值存入数组中。
- 直接返回倒序数组。

## 代码

```python
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return res[::-1]
```

# [剑指 Offer 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

- 标签：树、数组、哈希表、分治、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer 07. 重建二叉树 - 力扣](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

## 题目大意

给定一棵二叉树的前序遍历结果和中序遍历结果。

要求：构建该二叉树，并返回其根节点。假设树中没有重复的元素。

## 解题思路

前序遍历的顺序是：根 -> 左 -> 右。中序遍历的顺序是：左 -> 根 -> 右。根据前序遍历的顺序，可以找到根节点位置。然后在中序遍历的结果中可以找到对应的根节点位置，就可以从根节点位置将二叉树分割成左子树、右子树。同时能得到左右子树的节点个数。此时构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历进行上述步骤，直到节点为空，具体操作步骤如下：

- 从前序遍历顺序中当前根节点的位置在 `postorder[0]`。
- 通过在中序遍历中查找上一步根节点对应的位置 `inorder[k]`，从而将二叉树的左右子树分隔开，并得到左右子树节点的个数。
- 从上一步得到的左右子树个数将前序遍历结果中的左右子树分开。
- 构建当前节点，并递归建立左右子树，在左右子树对应位置继续递归遍历并执行上述三步，直到节点为空。

## 代码

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def createTree(preorder, inorder, n):
            if n == 0:
                return None
            k = 0
            while preorder[0] != inorder[k]:
                k += 1
            node = TreeNode(inorder[k])
            node.left = createTree(preorder[1: k + 1], inorder[0: k], k)
            node.right = createTree(preorder[k + 1:], inorder[k + 1:], n - k - 1)
            return node

        return createTree(preorder, inorder, len(inorder))
```

# [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

- 标签：栈、设计、队列
- 难度：简单

## 题目链接

- [剑指 Offer 09. 用两个栈实现队列 - 力扣](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

## 题目大意

要求：使用两个栈实现先入先出队列。需要实现对应的两个函数：

- `appendTail`：在队列尾部插入整数。
- `deleteHead`：在队列头部删除整数（如果队列中没有元素，`deleteHead` 返回 -1）。

## 解题思路

使用两个栈，inStack 用于输入，outStack 用于输出。

- `appendTail` 操作：将元素压入 inStack 中
- `deleteHead` 操作：
  - 先判断  `inStack` 和 `outStack` 是否都为空，如果都为空则说明队列中没有元素，直接返回 `-1`。
  - 如果 `outStack` 输出栈为空，将 `inStack` 输入栈元素依次取出，按顺序压入 `outStack` 栈。这样 `outStack` 栈的元素顺序和之前 `inStack` 元素顺序相反，`outStack` 顶层元素就是要取出的队头元素，将其移出，并返回该元素。如果 `outStack` 输出栈不为空，则直接取出顶层元素。

## 代码

```python
class CQueue:

    def __init__(self):
        self.inStack = []
        self.outStack = []


    def appendTail(self, value: int) -> None:
        self.inStack.append(value)


    def deleteHead(self) -> int:
        if len(self.outStack) == 0 and len(self.inStack) == 0:
            return -1
        if (len(self.outStack) == 0):
            while (len(self.inStack) != 0):
                self.outStack.append(self.inStack[-1])
                self.inStack.pop()
        top = self.outStack[-1]
        self.outStack.pop()
        return top
```

# [剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

- 标签：记忆化搜索、数学、动态规划
- 难度：简单

## 题目链接

- [剑指 Offer 10- I. 斐波那契数列 - 力扣](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

## 题目大意

给定一个整数 `n`。

要求：计算斐波那契数列的第 `n` 项。

注意：答案需对 `1000000007` 进行取余操作。

## 解题思路

斐波那契的递推公式为：`F(n) = F(n-1) + F(n-2)`。

直接根据递推公式求解即可。注意答案需要取余。

## 代码

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        f1 = 0
        f2 = 0
        f3 = 1
        for i in range(2, n + 1):
            f1, f2 = f2, f3
            f3 = (f1 + f2) % 1000000007
        return f3
```

# [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

- 标签：记忆化搜索、数学、动态规划
- 难度：简单

## 题目链接

- [剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

## 题目大意

一直青蛙一次可以跳上 `1` 级台阶，也可以跳上 `2` 级台阶。

要求：求该青蛙跳上 `n` 级台阶共有多少中跳法。答案需要对 `1000000007` 取余。

## 解题思路

先来看一下规律：

第 0 级台阶：1 种方法（比较特殊）

第 1 级台阶：1 种方法（从 0 阶爬 1 阶）

第 2 阶台阶：2 种方法（从 0 阶爬 2 阶，从 1 阶爬 1 阶）

第 i 阶台阶：从第 i-1 阶台阶爬 1 阶，或者从第 i-2 阶台阶爬 2 阶。

则推出递推公式为：

- 当 `n = 0` 时，`F(i) = 1`。
- 当 `n > 0` 时，`F(i) = F(i-1) + F(i-2)`。

## 代码

```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0:
            return 1

        f1, f2, f3 = 0, 1, 1
        for i in range(2, n + 1):
            f1, f2 = f2, f3
            f3 = (f1 + f2) % 1000000007
        return f3
```

# [剑指 Offer 11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer 11. 旋转数组的最小数字 - 力扣](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

## 题目大意

给定一个数组 `numbers`，`numbers` 是有升序数组经过「旋转」得到的。但是旋转次数未知。数组中可能存在重复元素。

要求：找出数组中的最小元素。

- 旋转：将数组整体右移。

## 解题思路

数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。

第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。

```
          *
        *
      *
    *
  *
*
```



```
    *
  *
*
          *
        *
      *
```

最直接的办法就是遍历一遍，找到最小值。但是还可以有更好的方法。考虑用二分查找来降低算法的时间复杂度。

创建两个指针 left、right，分别指向数组首尾。让后计算出两个指针中间值 mid。将 mid 与右边界进行比较。

1. 如果 `numbers[mid] > numbers[right]`，则最小值不可能在 `mid` 左侧，一定在 `mid` 右侧，则将 `left` 移动到 `mid + 1` 位置，继续查找右侧区间。
2. 如果 `numbers[mid] < numbers[right]`，则最小值一定在 `mid` 左侧，将 `right` 移动到 `mid` 位置上，继续查找左侧区间。
3. 当 `numbers[mid] == numbers[right]`，无法判断在 `mid` 的哪一侧，可以采用 `right = right - 1` 逐步缩小区域。

## 代码

```python
class Solution:
    def minArray(self, numbers: List[int]) -> int:
        left = 0
        right = len(numbers) - 1
        while left < right:
            mid = left + (right - left) // 2
            if numbers[mid] > numbers[right]:
                left = mid + 1
            elif numbers[mid] < numbers[right]:
                right = mid
            else:
                right = right - 1
        return numbers[left]
```

# [剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

- 标签：数组、回溯、矩阵
- 难度：中等

## 题目链接

- [剑指 Offer 12. 矩阵中的路径 - 力扣](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

## 题目大意

给定一个 `m * n` 大小的二维字符矩阵 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `True`，否则返回 `False`。

- 单词必须按照字母顺序通过上下左右相邻的单元格字母构成。且同一个单元格内的字母不允许被重复使用。

## 解题思路

回溯算法在二维矩阵 `board` 中按照上下左右四个方向递归搜索。设函数 `backtrack(i, j, index)` 表示从 `board[i][j]` 出发，能否搜索到单词字母 `word[index]`，以及 `index` 位置之后的后缀子串。如果能搜索到，则返回 `True`，否则返回 `False`。`backtrack(i, j, index)` 执行步骤如下：

- 如果 $board[i][j] = word[index]$，而且 `index` 已经到达 `word` 字符串末尾，则返回 `True`。
- 如果 $board[i][j] = word[index]$，而且 `index` 未到达 `word` 字符串末尾，则遍历当前位置的所有相邻位置。如果从某个相邻位置能搜索到后缀子串，则返回 `True`，否则返回 `False`。
- 如果 $board[i][j] \ne word[index]$，则当前字符不匹配，返回 `False`。

## 代码

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        rows = len(board)
        if rows == 0:
            return False
        cols = len(board[0])
        visited = [[False for _ in range(cols)] for _ in range(rows)]

        def backtrack(i, j, index):
            if index == len(word) - 1:
                return board[i][j] == word[index]

            if board[i][j] == word[index]:
                visited[i][j] = True
                for direct in directs:
                    new_i = i + direct[0]
                    new_j = j + direct[1]
                    if 0 <= new_i < rows and 0 <= new_j < cols and visited[new_i][new_j] == False:
                        if backtrack(new_i, new_j, index + 1):
                            return True
                visited[i][j] = False
            return False

        for i in range(rows):
            for j in range(cols):
                if backtrack(i, j, 0):
                    return True
        return False
```

# [剑指 Offer 13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

- 标签：深度优先搜索、广度优先搜索、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer 13. 机器人的运动范围 - 力扣](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

## 题目大意

**描述**：有一个 `m * n` 大小的方格，坐标从 `(0, 0)` 到 `(m - 1, n - 1)`。一个机器人从 `(0, 0)` 处的格子开始移动，每次可以向上、下、左、右移动一格（不能移动到方格外），也不能移动到行坐标和列坐标的数位之和大于 `k` 的格子。现在给定 `3` 个整数 `m`、`n`、`k`。

**要求**：计算并输出该机器人能够达到多少个格子。

**说明**：

- $1 \le n, m \le 100$。
- $0 \le k \le 20$。

**示例**：

- 示例 1：

```python
输入：m = 2, n = 3, k = 1
输出：3
```

- 示例 2：

```python
输入：m = 3, n = 1, k = 0
输出：1
```

## 解题思路

### 思路 1：广度优先搜索

先定义一个计算数位和的方法 `digitsum`，该方法输入一个整数，返回该整数各个数位的总和。

然后我们使用广度优先搜索方法，具体步骤如下：

- 将 `(0, 0)` 加入队列 `queue` 中。
- 当队列不为空时，每次将队首坐标弹出，加入访问集合 `visited` 中。
- 再将满足行列坐标的数位和不大于 `k` 的格子位置加入到队列中，继续弹出队首位置。
- 直到队列为空时停止。输出访问集合的长度。

### 思路 1：代码

```python
import collections

class Solution:
    def digitsum(self, n: int):
        ans = 0
        while n:
            ans += n % 10
            n //= 10
        return ans

    def movingCount(self, m: int, n: int, k: int) -> int:
        queue = collections.deque([(0, 0)])
        visited = set()

        while queue:
            x, y = queue.popleft()
            if (x, y) not in visited and self.digitsum(x) + self.digitsum(y) <= k:
                visited.add((x, y))
                for dx, dy in [(1, 0), (0, 1)]:
                    nx = x + dx
                    ny = y + dy
                    if 0 <= nx < m and 0 <= ny < n:
                        queue.append((nx, ny))
        return len(visited)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$。其中 $m$ 为方格的行数，$n$ 为方格的列数。
- **空间复杂度**：$O(m \times n)$。

# [剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

- 标签：数学、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer 14- I. 剪绳子 - 力扣](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

## 题目大意

给定一根长度为 `n` 的绳子，将绳子剪成整数长度的 `m` 段，每段绳子长度即为 `k[0]`、`k[1]`、...、`k[m - 1]`。

要求：计算出 `k[0] * k[1] * ... * k[m - 1]` 可能的最大乘积。

## 解题思路

可以使用动态规划求解。

定义状态 `dp[i]` 为：拆分长度为 `i` 的绳子，可以获得的最大乘积为 `dp[i]`。

将 `j` 从 `1` 遍历到 `i - 1`，通过两种方式得到 `dp[i]`：

- `(i - j) * j` ，直接将长度为 `i` 的绳子分割为 `i - j` 和 `j`，获取两者乘积。
- `dp[i - j] * j`，将长度为 `i`的绳子 中的 `i - j` 部分拆分，得到 `dp[i - j]`，和 `j` ，获取乘积。

则 `dp[i]` 取两者中的最大值。遍历 `j`，得到 `dp[i]` 的最大值。

则状态转移方程为：`dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)`。

最终输出 `dp[n]`。

## 代码

```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)
        return dp[n]
```

# [剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

- 标签：位运算
- 难度：简单

## 题目链接

- [剑指 Offer 15. 二进制中1的个数 - 力扣](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

## 题目大意

给定一个无符号整数 `n`。

要求：统计其对应二进制表达式中 `1` 的个数。

## 解题思路

### 1. 循环按位计算

对整数 n 的每一位进行按位与运算，并统计结果。

### 2. 改进位运算

利用 $n \text{ \& } (n-1)$ 。这个运算刚好可以将 n 的二进制中最低位的 $1$ 变为 $0$。 比如 $n = 6$ 时，$6 = (110)_2$，$6 - 1 = (101)_2$，$(110)_2 \text{ \& } (101)_2 = (100)_2$ 。

利用这个位运算，不断的将 $n$ 中最低位的 $1$ 变为 $0$，直到 $n$ 变为 $0$ 即可，其变换次数就是我们要求的结果。

## 代码

1. 循环按位计算

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n:
            ans += (n & 1)
            n = n >> 1
        return ans
```

2. 改进位运算

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        ans = 0
        while n:
            n &= n-1
            ans += 1
        return ans
```



# [剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

- 标签：递归、数学
- 难度：中等

## 题目链接

- [剑指 Offer 16. 数值的整数次方 - 力扣](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

## 题目大意

给定浮点数 `x` 和整数 `n`。

要求：实现 `pow(x, n)`，即计算 $x^n$，不能使用库函数，不需要考虑大数问题。

## 解题思路

常规方法是直接将 x 累乘 n 次得出结果，时间复杂度为 $O(n)$。可以利用快速幂来减少时间复杂度。

如果 n 为偶数，$x^n = x^{n/2} * x^{n/2}$。如果 n 为奇数，$x^n = x * x^{(n-1)/2} * x^{(n-1)/2}$。

$x^(n/2)$ 又可以继续向下递归划分。则我们可以利用低纬度的幂计算结果，来得到高纬度的幂计算结果。

这样递归求解，时间复杂度为 $O(logn)$，并且递归也可以转为递推来做。

需要注意如果 n 为负数，可以转换为 $\frac{1}{x} ^{(-n)}$。

## 代码

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0.0:
            return 0.0
        res = 1
        if n < 0:
            x = 1 / x
            n = -n
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

# [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

- 标签：数组、数学
- 难度：简单

## 题目链接

- [剑指 Offer 17. 打印从1到最大的n位数 - 力扣](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

## 题目大意

给定一个数字 `n`。

要求：按顺序打印从 `1` 到最大 `n` 位的十进制数。

## 解题思路

直接枚举 $1 \sim 10^{n} - 1$，生成列表并返回。

## 代码

```python
class Solution:
    def printNumbers(self, n: int) -> List[int]:
        return [i for i in range(1, 10 ** n)]
```

# [剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

- 标签：链表
- 难度：简单

## 题目链接

- [剑指 Offer 18. 删除链表的节点 - 力扣](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

## 题目大意

给定一个链表。

要求：删除链表中值为 `val` 的节点，并返回新的链表头节点。

## 解题思路

用两个指针 `prev` 和 `curr`。`prev` 指向前一节点和当前节点，`curr` 指向当前节点。从前向后遍历链表，遇到值为 `val` 的节点时，将 `prev` 指向当前节点的下一个节点，继续递归遍历。遇不到则更新 `prev` 指针，并继续遍历。

需要注意的是要删除的节点可能包含了头节点。我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则删除原头节点即可。返回结果的时候，可以直接返回新建头节点的下一位节点。

## 代码

```python
class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        newHead = ListNode(0, head)
        newHead.next = head

        prev, curr = newHead, head
        while curr:
            if curr.val == val:
                prev.next = curr.next
            else:
                prev = curr
            curr = curr.next
        return newHead.next
```

# [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

- 标签：数组、双指针、排序
- 难度：简单

## 题目链接

- [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：将奇数元素位于数组的前半部分，偶数元素位于数组的后半部分。

**说明**：

- $0 \le nums.length \le 50000$。
- $0 \le nums[i] \le 10000$。

**示例**：

- 示例 1：

```python
输入：nums = [1,2,3,4,5]
输出：[1,3,5,2,4] 
解释：为正确答案之一
```

## 解题思路

### 思路 1：快慢指针

定义快慢指针 $slow$、$fast$，开始时都指向 $0$。

- $fast$ 向前搜索奇数位置，$slow$ 指向下一个奇数应当存放的位置。
- $fast$ 不断进行右移，当遇到奇数时，将该奇数与 $slow$ 指向的元素进行交换，并将 $slow$ 进行右移。
- 重复上面操作，直到 $fast$ 指向数组末尾。

### 思路 1：代码

```python
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast] % 2 == 1:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
            fast += 1

        return nums
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为数组 $nums$ 中的元素个数。
- **空间复杂度**：$O(1)$。

# [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 标签：链表、双指针
- 难度：简单

## 题目链接

- [剑指 Offer 22. 链表中倒数第k个节点 - 力扣](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

## 题目大意

给定一个链表的头节点 `head`，以及一个整数 `k`。

要求返回链表的倒数第 `k` 个节点。

## 解题思路

常规思路是遍历一遍链表，求出链表长度，再遍历一遍到对应位置，返回该位置上的节点。

如果用一次遍历实现的话，可以使用快慢指针。让快指针先走 `k` 步，然后快慢指针、慢指针再同时走，每次一步，这样等快指针遍历到链表尾部的时候，慢指针就刚好遍历到了倒数第 `k` 个节点位置。返回该该位置上的节点即可。

## 代码

```python
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        slow = head
        fast = head
        for _ in range(k):
            if fast == None:
                return fast
            fast = fast.next
        while fast:
            slow = slow.next
            fast = fast.next
        return slow
```

# [剑指 Offer 24. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [剑指 Offer 24. 反转链表 - 力扣](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

## 题目大意

**描述**：给定一个链表的头节点 `head`。

**要求**：将该链表反转并输出反转后链表的头节点。

## 解题思路

### 思路 1. 迭代

1. 使用两个指针 `cur` 和 `pre` 进行迭代。`pre` 指向 `cur` 前一个节点位置。初始时，`pre` 指向 `None`，`cur` 指向 `head`。

2. 将 `pre` 和 `cur` 的前后指针进行交换，指针更替顺序为：
   1. 使用 `next` 指针保存当前节点 `cur` 的后一个节点，即 `next = cur.next`；
   2. 断开当前节点 `cur` 的后一节点链接，将 `cur` 的 `next` 指针指向前一节点 `pre`，即 `cur.next = pre`；
   3. `pre` 向前移动一步，移动到 `cur` 位置，即 `pre = cur`；
   4. `cur` 向前移动一步，移动到之前 `next` 指针保存的位置，即 `cur = next`。
3. 继续执行第 2 步中的 1、2、3、4。
4. 最后等到 `cur` 遍历到链表末尾，即 `cur == None`，时，`pre` 所在位置就是反转后链表的头节点，返回新的头节点 `pre`。

使用迭代法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111133639.png)

### 思路 2. 递归

具体做法如下：

- 首先定义递归函数含义为：将链表反转，并返回反转后的头节点。
- 然后从 `head.next` 的位置开始调用递归函数，即将 `head.next` 为头节点的链表进行反转，并返回该链表的头节点。
- 递归到链表的最后一个节点，将其作为最终的头节点，即为 `new_head`。
- 在每次递归函数返回的过程中，改变 `head` 和 `head.next` 的指向关系。也就是将 `head.next` 的`next` 指针先指向当前节点 `head`，即 `head.next.next = head `。
- 然后让当前节点 `head` 的 `next` 指针指向 `None`，从而实现从链表尾部开始的局部反转。
- 当递归从末尾开始顺着递归栈的退出，从而将整个链表进行反转。
- 最后返回反转后的链表头节点 `new_head`。

使用递归法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111134246.png)

## 代码

1. 迭代

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur != None:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        return pre
```

2. 递归

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None or head.next == None:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

## 参考资料

- 【题解】[反转链表 - 反转链表 - 力扣](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/)
- 【题解】[【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/)

# [剑指 Offer 25. 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [剑指 Offer 25. 合并两个排序的链表 - 力扣](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

## 题目大意

给定两个升序链表。

要求：将其合并为一个升序链表。

## 解题思路

利用归并排序的思想。

创建一个新的链表节点作为头节点（记得保存），然后判断 l1和 l2 头节点的值，将较小值的节点添加到新的链表中。

当一个节点添加到新的链表中之后，将对应的 l1 或 l2 链表向后移动一位。

然后继续判断当前 l1 节点和当前 l2 节点的值，继续将较小值的节点添加到新的链表中，然后将对应的链表向后移动一位。

这样，当 l1 或 l2 遍历到最后，最多有一个链表还有节点未遍历，则直接将该节点链接到新的链表尾部即可。

## 代码

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        newHead = ListNode(-1)

        curr = newHead
        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next

        curr.next = l1 if l1 is not None else l2

        return newHead.next
```

# [剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer 26. 树的子结构 - 力扣](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

## 题目大意

给定两棵二叉树的根节点 `A`、`B`。

要求：判断 `B` 是不是 `A` 的子结构。（空树不是任意一棵树的子结构）。

- `B` 是 `A` 的子结构：`A` 中有出现和 `B` 相同的结构和节点值。

## 解题思路

深度优先搜索。

- 先判断特例，如果 `A`、`B` 都为空树，则直接返回 `False`。
- 然后递归判断 `A`、`B` 是否相等。
    - 如果 `A`、`B` 相等，则返回 `True`。
    - 如果 `A`、`B` 不相等，则递归判断 `B` 是否是  `A` 的左子树的子结构，或者 `B` 是否是 `A` 的右子树的子结构，如果有一种满足，则返回 `True`，如果都不满足，则返回 `False`。

递归判断 `A`、`B` 是否相等的具体方法如下：

- 如果 `B` 为空树，则直接返回 `False`，因为空树不是任意一棵树的子结构。
- 如果 `A` 为空树或者 `A` 节点的值不等于 `B` 节点的值，则返回 `False`。
- 如果 `A`、`B` 都不为空，且节点值相同，则递归判断 `A` 的左子树和 `B` 的左子树是否相等，判断 `A` 的右子树和 `B` 的右子树是否相等。如果都相等，则返回 `True`，否则返回 `False`。

## 代码

```python
class Solution:
    def hasSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        if not B:
            return True
        if not A or A.val != B.val:
            return False
        return self.hasSubStructure(A.left, B.left) and self.hasSubStructure(A.right, B.right)

    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        if not A or not B:
            return False
        if self.hasSubStructure(A, B):
            return True
        return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)
```

# [剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 27. 二叉树的镜像 - 力扣](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：将其进行左右翻转。

## 解题思路

从根节点开始遍历，然后从叶子节点向上递归交换左右子树位置。

## 代码

```python
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        left = self.mirrorTree(root.left)
        right = self.mirrorTree(root.right)
        root.left = right
        root.right = left
        return root
```

# [剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 28. 对称的二叉树 - 力扣](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：检查这课二叉树是否是左右对称的。

## 解题思路

递归遍历左右子树， 然后判断当前节点的左右子节点。如果可以直接判断的情况，则跳出递归，直接返回结果。如果无法直接判断结果，则递归检测左右子树的外侧节点是否相等，同理再递归检测左右子树的内侧节点是否相等。

## 代码

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        return self.check(root.left, root.right)

    def check(self, left: TreeNode, right: TreeNode):
        if not left and not right:
            return True
        elif not left and right:
            return False
        elif left and not right:
            return False
        elif left.val != right.val:
            return False

        return self.check(left.left, right.right) and self.check(left.right, right.left)
```

# [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

- 标签：数组、矩阵、模拟
- 难度：简单

## 题目链接

- [剑指 Offer 29. 顺时针打印矩阵 - 力扣](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

## 题目大意

给定一个 `m * n` 大小的二维矩阵 `matrix`。

要求：按照顺时针旋转的顺序，返回矩阵中的所有元素。

## 解题思路

按照题意进行模拟。可以实现定义一下上、下、左、右的边界，然后按照逆时针的顺序从边界上依次访问元素。

当访问完当前边界之后，要更新一下边界位置，缩小范围，方便下一轮进行访问。

## 代码

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        size_m = len(matrix)
        if size_m == 0:
            return []
        size_n = len(matrix[0])
        if size_n == 0:
            return []

        up, down, left, right = 0, size_m - 1, 0, size_n - 1
        ans = []
        while True:
            for i in range(left, right + 1):
                ans.append(matrix[up][i])
            up += 1
            if up > down:
                break
            for i in range(up, down + 1):
                ans.append(matrix[i][right])
            right -= 1
            if right < left:
                break
            for i in range(right, left - 1, -1):
                ans.append(matrix[down][i])
            down -= 1
            if down < up:
                break
            for i in range(down, up - 1, -1):
                ans.append(matrix[i][left])
            left += 1
            if left > right:
                break
        return ans
```

# [剑指 Offer 30. 包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

- 标签：栈、设计
- 难度：简单

## 题目链接

- [剑指 Offer 30. 包含min函数的栈 - 力扣](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

## 题目大意

要求：设计一个「栈」，实现  `push` ，`pop` ，`top` ，`min` 操作，并且操作时间复杂度都是 `O(1)`。

## 解题思路

使用一个栈，栈元素中除了保存当前值之外，再保存一个当前最小值。

-  `push` 操作：如果栈不为空，则判断当前值与栈顶元素所保存的最小值，并更新当前最小值，将新元素保存到栈中。
-  `pop`操作：正常出栈
-  `top` 操作：返回栈顶元素保存的值。
-  `min` 操作：返回栈顶元素保存的最小值。

## 代码

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    class Node:
        def __init__(self, x):
            self.val = x
            self.min = x

    def push(self, x: int) -> None:
        node = self.Node(x)
        if len(self.stack) == 0:
            self.stack.append(node)
        else:
            topNode = self.stack[-1]
            if node.min > topNode.min:
                node.min = topNode.min

            self.stack.append(node)


    def pop(self) -> None:
        self.stack.pop()


    def top(self) -> int:
        return self.stack[-1].val


    def min(self) -> int:
        return self.stack[-1].min
```

# [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

- 标签：栈、数组、模拟
- 难度：中等

## 题目链接

- [剑指 Offer 31. 栈的压入、弹出序列 - 力扣](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

## 题目大意

给定连个整数序列 `pushed` 和 `popped`，其中 `pushed` 表示栈的压入顺序。

要求：判断第二个序列 `popped` 是否为栈的压出序列。

## 解题思路

借助一个栈来模拟压入、压出的操作。检测最后是否能模拟成功。

## 代码

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack = []
        index = 0
        for item in pushed:
            stack.append(item)
            while(stack and stack[-1] == popped[index]):
                stack.pop()
                index += 1

        return len(stack) == 0
```

# [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

## 解题思路

广度优先搜索。

具体步骤如下：

- 根节点入队。
- 当队列不为空时，求出当前队列长度 $s_i$。
    - 依次从队列中取出这 $s_i$ 个元素，将其加入答案数组，并将其左右子节点入队，然后继续迭代。
- 当队列为空时，结束。

## 代码

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                order.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
        return order
```

# [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

- 标签：树、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

## 解题思路

广度优先搜索，需要增加一些变化。普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 i 层上所有元素。

具体步骤如下：

- 根节点入队。
- 当队列不为空时，求出当前队列长度 $s_i$。
    - 依次从队列中取出这 $s_i$ 个元素，并将其左右子节点入队，遍历完之后将这层节点数组加入答案数组中，然后继续迭代。
- 当队列为空时，结束。

## 代码

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            level = []
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                level.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if level:
                order.append(level)
        return order
```

# [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

- 标签：树、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：返回其之字形层序遍历。

- 之字形层序遍历：从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。

## 解题思路

广度优先搜索，在二叉树的层序遍历的基础上需要增加一些变化。

普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 i 层上所有元素。

新增一个变量 odd，用于判断当前层数是奇数层，还是偶数层。从而判断元素遍历方向。

存储每层元素的 level 列表改用双端队列，如果是奇数层，则从末尾添加元素。如果是偶数层，则从头部添加元素。

具体步骤如下：

- 根节点入队。
- 当队列不为空时，求出当前队列长度 $s_i$，并判断当前层数的奇偶性。
- 依次从队列中取出这 $s_i$ 个元素。
    - 如果为奇数层，如果是奇数层，则从 level 末尾添加元素。
    - 如果是偶数层，则从 level头部添加元素。
- 然后保存将其左右子节点入队，然后继续迭代。
- 当队列为空时，结束。

## 代码

```python
import collections

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        order = []
        odd = True
        while queue:
            level = collections.deque()
            size = len(queue)
            for _ in range(size):
                curr = queue.pop(0)
                if odd:
                    level.append(curr.val)
                else:
                    level.appendleft(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if level:
                order.append(list(level))
            odd = not odd
        return order
```

# [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

- 标签：栈、树、二叉搜索树、递归、二叉树、单调栈
- 难度：中等

## 题目链接

- [剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

## 题目大意

**描述**：给定一个整数数组 $postorder$。数组的任意两个数字都互不相同。

**要求**：判断该数组是不是某二叉搜索树的后序遍历结果。如果是，则返回 `True`，否则返回 `False`。

**说明**：

- 数组长度 <= 1000。
- $postorder$ 中无重复数字。

**示例**：

- 示例 1：

![](https://pic.leetcode.cn/1694762751-fwHhWX-%E5%89%91%E6%8C%8733%E7%A4%BA%E4%BE%8B1.png)

```python
输入: postorder = [4,9,6,9,8]
输出: false 
解释：从上图可以看出这不是一颗二叉搜索树
```

- 示例 2：

![](https://pic.leetcode.cn/1694762510-vVpTic-%E5%89%91%E6%8C%8733.png)

```python
输入: postorder = [4,6,5,9,8]
输出: true 
解释：可构建的二叉搜索树如上图
```

## 解题思路

### 思路 1：递归分治

后序遍历的顺序为：左 -> 右 -> 根。而二叉搜索树的定义是：左子树所有节点值 < 根节点值，右子树所有节点值 > 根节点值。

所以，可以把数组最右侧元素作为二叉搜索树的根节点值。然后判断数组的左右两侧是否符合左侧值都小于该节点值，右侧值都大于该节点值。如果不满足，则说明不是某二叉搜索树的后序遍历结果。

找到左右分界线位置，然后递归左右数组继续查找。

终止条件为数组 开始位置 > 结束位置，此时该树的子节点数目小于等于 $1$，直接返回 `True` 即可。

### 思路 1：代码

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def verify(left, right):
            if left >= right:
                return True
            index = left
            while postorder[index] < postorder[right]:
                index += 1
            mid = index
            while postorder[index] > postorder[right]:
                index += 1

            return index == right and verify(left, mid - 1) and verify(mid, right - 1)
        if len(postorder) <= 2:
            return True
        return verify(0, len(postorder) - 1)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。
- **空间复杂度**：$O(n)$。



# [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

- 标签：树、深度优先搜索、回溯、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer 34. 二叉树中和为某一值的路径 - 力扣](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root` 和一个整数 `target`。

要求：打印出二叉树中各节点的值的和为 `target` 的所有路径。从根节点开始往下一直到叶节点所经过的节点形成一条路径。

## 解题思路

回溯求解。在回溯的同时，记录下当前路径。同时维护 `target`，每遍历到一个节点，就减去该节点值。如果遇到叶子节点，并且 `target == 0` 时，将当前路径加入答案数组中。然后递归遍历左右子树，并回退当前节点，继续遍历。

## 代码

```python
class Solution:
    def pathSum(self, root: TreeNode, target: int) -> List[List[int]]:
        res = []
        path = []
        def dfs(root: TreeNode, target: int):
            if not root:
                return
            path.append(root.val)
            target -= root.val
            if not root.left and not root.right and target == 0:
                res.append(path[:])
            dfs(root.left, target)
            dfs(root.right, target)
            path.pop()
        dfs(root, target)
        return res

```

# [剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

- 标签：哈希表、链表
- 难度：中等

## 题目链接

- [剑指 Offer 35. 复杂链表的复制 - 力扣](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

## 题目大意

给定一个链表，每个节点除了 `next` 指针之后，还包含一个随机指针 `random`，该指针可以指向链表中的任何节点或者空节点。

要求：将该链表进行深拷贝。

## 解题思路

遍历链表，利用哈希表，以旧节点：新节点为映射关系，将节点关系存储下来。

再次遍历链表，将新链表的 `next` 和 `random` 指针设置好。

## 代码

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return None
        node_dict = dict()
        curr = head
        while curr:
            new_node = Node(curr.val, None, None)
            node_dict[curr] = new_node
            curr = curr.next
        curr = head
        while curr:
            if curr.next:
                node_dict[curr].next = node_dict[curr.next]
            if curr.random:
                node_dict[curr].random = node_dict[curr.random]
            curr = curr.next
        return node_dict[head]
```

# [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

- 标签：栈、树、深度优先搜索、二叉搜索树、链表、二叉树、双向链表
- 难度：中等

## 题目链接

- [剑指 Offer 36. 二叉搜索树与双向链表 - 力扣](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：将这棵二叉树转换为一个排序的循环双向链表。要求不能创建新的节点，只能调整树中节点指针的指向。

## 解题思路

通过中序递归遍历可以将二叉树升序排列输出。这道题需要在中序遍历的同时，将节点的左右指向进行改变。使用 `head`、`tail` 存放双向链表的头尾节点，然后从根节点开始，进行中序递归遍历。

具体做法如下：

- 如果当前节点为空，直接返回。
- 如果当前节点不为空：
  - 递归遍历左子树。
  - 如果尾节点不为空，则将尾节点与当前节点进行连接。
  - 如果尾节点为空，则初始化头节点。
  - 将当前节点标记为尾节点。
  - 递归遍历右子树。
- 最后将头节点和尾节点进行连接。

## 代码

```python
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(node: 'Node'):
            if not node:
                return

            dfs(node.left)
            if self.tail:
                self.tail.right = node
                node.left = self.tail
            else:
                self.head = node
            self.tail = node
            dfs(node.right)

        if not root:
            return None

        self.head, self.tail = None, None
        dfs(root)
        self.head.left = self.tail
        self.tail.right = self.head
        return self.head
```

# [剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

- 标签：树、深度优先搜索、广度优先搜索、设计、字符串、二叉树
- 难度：困难

## 题目链接

- [剑指 Offer 37. 序列化二叉树 - 力扣](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：设计一个算法，来实现二叉树的序列化与反序列化。

## 解题思路

1. 序列化：将二叉树转为字符串数据表示

按照前序递归遍历二叉树，并将根节点跟左右子树的值链接起来（中间用 `,` 隔开）。

注意：如果遇到空节点，则标记为 'None'，这样在反序列化时才能唯一确定一棵二叉树。

2. 反序列化：将字符串数据转为二叉树结构

先将字符串按 `,` 分割成数组。然后递归处理每一个元素。

- 从数组左侧取出一个元素。
  - 如果当前元素为 'None'，则返回 None。
  - 如果当前元素不为空，则新建一个二叉树节点作为根节点，保存值为当前元素值。并递归遍历左右子树，不断重复从数组中取出元素，进行判断。
  - 最后返回当前根节点。

## 代码

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return 'None'
        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        def dfs(datalist):
            val = datalist.pop(0)
            if val == 'None':
                return None
            root = TreeNode(int(val))
            root.left = dfs(datalist)
            root.right = dfs(datalist)
            return root

        datalist = data.split(',')
        return dfs(datalist)
```

# [剑指 Offer 38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

- 标签：字符串、回溯
- 难度：中等

## 题目链接

- [剑指 Offer 38. 字符串的排列 - 力扣](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

## 题目大意

给定一个字符串 `s`。

要求：打印出该字符串中字符的所有排列。可以以任意顺序返回这个字符串数组，但里边不能有重复元素。

## 解题思路

因为原字符串可能含有重复元素，所以在回溯的时候需要进行去重。先将字符串 `s` 转为 `list` 列表，再对列表进行排序，然后使用 `visited` 数组标记该元素在当前排列中是否被访问过。若未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。

然后再递归遍历下一层元素之前，增加一句语句进行判重：`if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue`。

然后进行回溯遍历。

## 代码

```python
class Solution:
    res = []
    path = []
    def backtrack(self, ls, visited):
        if len(self.path) == len(ls):
            self.res.append(''.join(self.path))
            return
        for i in range(len(ls)):
            if i > 0 and ls[i] == ls[i - 1] and not visited[i - 1]:
                continue

            if not visited[i]:
                visited[i] = True
                self.path.append(ls[i])
                self.backtrack(ls, visited)
                self.path.pop()
                visited[i] = False

    def permutation(self, s: str) -> List[str]:
        self.res.clear()
        self.path.clear()
        ls = list(s)
        ls.sort()
        visited = [False for _ in range(len(s))]
        self.backtrack(ls, visited)
        return self.res
```

# [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

- 标签：数组、哈希表、分治、计数、排序
- 难度：简单

## 题目链接

- [剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

## 题目大意

给定一个数组 `nums`，其中有一个数字出现次数超过数组长度一半。

要求：找到出现次数超过数组长度一半的数字。

## 解题思路

可以利用哈希表。遍历一遍数组 `nums`，用哈希表统计每个元素 `num` 出现的次数，再遍历一遍哈希表，找出元素个数最多的元素即可。

## 代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        numDict = dict()
        for num in nums:
            if num in numDict:
                numDict[num] += 1
            else:
                numDict[num] = 1
        max = 0
        max_index = -1
        for num in numDict:
            if numDict[num] > max:
                max = numDict[num]
                max_index = num
        return max_index
```

# [剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

- 标签：数组、分治、快速选择、排序、堆（优先队列）
- 难度：简单

## 题目链接

- [剑指 Offer 40. 最小的k个数 - 力扣](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

## 题目大意

**描述**：给定整数数组 $arr$，再给定一个整数 $k$。

**要求**：返回数组 $arr$ 中最小的 $k$ 个数。

**说明**：

- $0 \le k \le arr.length \le 10000$。
- $0 \le arr[i] \le 10000$。

**示例**：

- 示例 1：

```python
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

- 示例 2：

```python
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

## 解题思路

直接可以想到的思路是：排序后输出数组上对应的最小的 k 个数。所以问题关键在于排序方法的复杂度。

冒泡排序、选择排序、插入排序时间复杂度 $O(n^2)$ 太高了，解答会超时。

可考虑堆排序、归并排序、快速排序。

### 思路 1：堆排序（基于大顶堆）

具体做法如下：

1. 使用数组前 $k$ 个元素，维护一个大小为 $k$ 的大顶堆。
2. 遍历数组 $[k, size - 1]$ 的元素，判断其与堆顶元素关系，如果遇到比堆顶元素小的元素，则将与堆顶元素进行交换。再将这 $k$ 个元素调整为大顶堆。
3. 最后输出大顶堆的 $k$ 个元素。

### 思路 1：代码

```python
class Solution:
    def heapify(self, nums: [int], index: int, end: int):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子节点
            max_index = index
            if nums[left] > nums[max_index]:
                max_index = left
            if right <= end and nums[right] > nums[max_index]:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            nums[index], nums[max_index] = nums[max_index], nums[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1

    # 初始化大顶堆
    def buildMaxHeap(self, nums: [int], k: int):
        # (k-2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((k - 2) // 2, -1, -1):
            self.heapify(nums, i, k - 1)
        return nums

    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        size = len(arr)
        if k <= 0 or not arr:
            return []
        if size <= k:
            return arr

        self.buildMaxHeap(arr, k)
        
        for i in range(k, size):
            if arr[i] < arr[0]:
                arr[i], arr[0] = arr[0], arr[i]
                self.heapify(arr, 0, k - 1)

        return arr[:k]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n\log_2k)$。
- **空间复杂度**：$O(1)$。

### 思路 2：快速排序

使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。

这样，只要某次划分的元素恰好是第 $k$ 个元素下标，就找到了数组中最小的 $k$ 个数所对应的区间，即 $[0, k - 1]$。 并且我们只需关注第 $k$ 个最小元素所在区间的排序情况，与第 $k$ 个最小元素无关的区间排序都可以忽略。这样进一步减少了执行步骤。

### 思路 2：代码

```python
import random

class Solution:
    # 从 arr[low: high + 1] 中随机挑选一个基准数，并进行移动排序
    def randomPartition(self, arr: [int], low: int, high: int):
        # 随机挑选一个基准数
        i = random.randint(low, high)
        # 将基准数与最低位互换
        arr[i], arr[low] = arr[low], arr[i]
        # 以最低位为基准数，然后将序列中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。最后将基准数放到正确位置上
        return self.partition(arr, low, high)
    
    # 以最低位为基准数，然后将序列中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧。最后将基准数放到正确位置上
    def partition(self, arr: [int], low: int, high: int):
        pivot = arr[low]            # 以第 1 为为基准数
        i = low + 1                 # 从基准数后 1 位开始遍历，保证位置 i 之前的元素都小于基准数
        
        for j in range(i, high + 1):
            # 发现一个小于基准数的元素
            if arr[j] < pivot:
                # 将小于基准数的元素 arr[j] 与当前 arr[i] 进行换位，保证位置 i 之前的元素都小于基准数
                arr[i], arr[j] = arr[j], arr[i]
                # i 之前的元素都小于基准数，所以 i 向右移动一位
                i += 1
        # 将基准节点放到正确位置上
        arr[i - 1], arr[low] = arr[low], arr[i - 1]
        # 返回基准数位置
        return i - 1

    def quickSort(self, arr, low, high, k):
        size = len(arr)
        if low < high:
            # 按照基准数的位置，将序列划分为左右两个子序列
            pi = self.randomPartition(arr, low, high)
            if pi == k:
                return arr[:k]
            if pi > k:
                # 对左子序列进行递归快速排序
                self.quickSort(arr, low, pi - 1, k)
            if pi < k:
                # 对右子序列进行递归快速排序
                self.quickSort(arr, pi + 1, high, k)

        return arr[:k]

    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        size = len(arr)
        if k >= size:
            return arr
        return self.quickSort(arr, 0, size - 1, k)
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$。证明过程可参考「算法导论 9.2：期望为线性的选择算法」。
- **空间复杂度**：$O(\log n)$。递归使用栈空间的空间代价期望为 $O(\log n)$。

# [剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

- 标签：设计、双指针、数据流、排序、堆（优先队列）
- 难度：困难

## 题目链接

- [剑指 Offer 41. 数据流中的中位数 - 力扣](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

## 题目大意

要求：设计一个支持一下两种操作的数组结构：

- `void addNum(int num)`：从数据流中添加一个整数到数据结构中。
- `double findMedian()`：返回目前所有元素的中位数。

## 解题思路

使用一个大顶堆 `queMax` 记录大于中位数的数，使用一个小顶堆 `queMin` 小于中位数的数。

- 当添加元素数量为偶数： `queMin` 和 `queMax` 中元素数量相同，则中位数为它们队头的平均值。
- 当添加元素数量为奇数：`queMin` 中的数比 `queMax` 多一个，此时中位数为 `queMin` 的队头。

为了满足上述条件，在进行 `addNum` 操作时，我们应当分情况处理：

- `num > max{queMin}`：此时 `num` 大于中位数，将该数添加到大顶堆 `queMax` 中。新的中位数将大于原来的中位数，所以可能需要将 `queMax` 中的最小数移动到 `queMin` 中。
- `num ≤ max{queMin}`：此时 `num` 小于中位数，将该数添加到小顶堆 `queMin` 中。新的中位数将小于等于原来的中位数，所以可能需要将 `queMin` 中最大数移动到 `queMax` 中。

## 代码

```python
import heapq

class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.queMin = list()
        self.queMax = list()


    def addNum(self, num: int) -> None:
        if not self.queMin or num < -self.queMin[0]:
            heapq.heappush(self.queMin, -num)
            if len(self.queMax) + 1 < len(self.queMin):
                heapq.heappush(self.queMax, -heapq.heappop(self.queMin))
        else:
            heapq.heappush(self.queMax, num)
            if len(self.queMax) > len(self.queMin):
                heapq.heappush(self.queMin, -heapq.heappop(self.queMax))


    def findMedian(self) -> float:
        if len(self.queMin) > len(self.queMax):
            return -self.queMin[0]
        return (-self.queMin[0] + self.queMax[0]) / 2
```

# [剑指 Offer 42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

- 标签：数组、分治、动态规划
- 难度：简单

## 题目链接

- [剑指 Offer 42. 连续子数组的最大和 - 力扣](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

## 题目大意

给定一个整数数组 `nums` 。

要求：找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和，要求时间复杂度为 `O(n)`。

## 解题思路

动态规划的方法，关键点是要找到状态转移方程。

假设 f(i) 表示第 i 个数结尾的「连续子数组的最大和」，那么 $max_{0 < i \le n-1} {f(i)} = max(f(i-1) + nums[i], nums[i])$

即将之前累加和加上当前值与当前值做比较。

- 如果将之前累加和加上当前值 > 当前值，那么加上当前值。
- 如果将之前累加和加上当前值 < 当前值，那么 $f(i) = nums[i]$。

## 代码

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_ans = nums[0]
        ans = 0
        for num in nums:
            ans = max(ans + num, num)
            max_ans = max(max_ans, ans)
        return max_ans
```

# [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

- 标签：数学、二分查找
- 难度：中等

## 题目链接

- [剑指 Offer 44. 数字序列中某一位的数字 - 力扣](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

## 题目大意

数字以 `0123456789101112131415…` 的格式序列化到一个字符序列中。在这个序列中，第 `5` 位（从下标 `0` 开始计数）是 `5`，第 `13` 位是 `1`，第 `19` 位是 `4`，等等。

要求：返回任意第 `n` 位对应的数字。

## 解题思路

根据题意中的字符串，找数学规律：

- `123456789`：是 `9` 个 `1` 位数字。
- `10111213...9899`：是 `90` 个 `2` 位数字。
- `100...999`：是 `900` 个 `3` 位数字。
- `1000...9999` 是 `9000` 个 `4` 位数字。

- 我们可以先找到对应的数字对应的位数 `digits`。
- 然后找到该位数 `digits` 的起始数字 `start`。
- 再计算出 `n` 所在的数字 `number`。`number` 等于从起始数字 `start` 开始的第 $\lfloor(n - 1) / digits\rfloor$ 个数字。即 `number = start + (n - 1) // digits`。
- 然后确定 `n` 对应的是数字 `number` 中的哪一位。即 `idx = (n - 1) % digits`。
- 最后返回结果。

## 代码

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        digits = 1
        start = 1
        base = 9
        while n > base:
            n -= base
            digits += 1
            start *= 10
            base = start * digits * 9

        number = start + (n - 1) // digits
        idx = (n - 1) % digits
        return int(str(number)[idx])
```

## 参考资料

- 【题解】[面试题44. 数字序列中某一位的数字（迭代 + 求整 / 求余，清晰图解） - 数字序列中某一位的数字 - 力扣](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/)
# [剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

- 标签：贪心、字符串、排序
- 难度：中等

## 题目链接

- [剑指 Offer 45. 把数组排成最小的数 - 力扣](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

## 题目大意

**描述**：给定一个非负整数数组 $nums$。

**要求**：将数组中的数字拼接起来排成一个数，打印能拼接出的所有数字中的最小的一个。

**说明**：

- $0 < nums.length \le 100$。
- 输出结果可能非常大，所以你需要返回一个字符串而不是整数。
- 拼接起来的数字可能会有前导 $0$，最后结果不需要去掉前导 $0$。

**示例**：

- 示例 1：

```python
输入: [10,2]
输出: "102"
```

- 示例 2：

```python
输入：[3,30,34,5,9]
输出："3033459"
```

## 解题思路

### 思路 1：自定义排序

本质上是给数组进行排序。假设 $x$、$y$ 是数组 $nums$ 中的两个元素。则排序的判断规则如下所示：

- 如果拼接字符串 $x + y > y + x$，则 $x$ 大于 $y$，$y$ 应该排在 $x$ 前面，从而使拼接起来的数字尽可能的小。
- 反之，如果拼接字符串 $x + y < y + x$，则 $x$ 小于 $y$，$x$ 应该排在 $y$ 前面，从而使拼接起来的数字尽可能的小。

按照上述规则，对原数组进行排序。这里使用了 `functools.cmp_to_key` 自定义排序函数。

### 思路 1：自定义排序代码

```python
import functools

class Solution:
    def minNumber(self, nums: List[int]) -> str:
        def cmp(a, b):
            if a + b == b + a:
                return 0
            elif a + b > b + a:
                return 1
            else:
                return -1

        nums_s = list(map(str, nums))
        nums_s.sort(key=functools.cmp_to_key(cmp))
        return ''.join(nums_s)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。排序算法的时间复杂度为 $O(n \times \log n)$。
- **空间复杂度**：$O(1)$。

## 参考资料

- 【题解】[剑指 Offer 45. 把数组排成最小的数（自定义排序，清晰图解） - 把数组排成最小的数 - 力扣](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/)
# [剑指 Offer 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer 46. 把数字翻译成字符串 - 力扣](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

## 题目大意

给定一个数字 `num`，按照如下规则将其翻译为字符串：`0` 翻译为 `a`，`1` 翻译为 `b`，…，`11` 翻译为 `l`，…，`25` 翻译为 `z`。

要求：计算出共有多少种可能的翻译方案。

## 解题思路

可用动态规划来做。

将数字 `nums` 转为字符串 `s`。设 `dp[i]` 表示字符串 `s` 前 `i` 个数字 `s[0: i]` 的翻译方案数。`dp[i]` 的来源有两种情况：

1. 第 `i - 1`、`i - 2` 构成的数字在 `[10, 25]`之间，则 `dp[i]` 来源于： `s[i - 1]` 单独翻译的方案数（即 `dp[i - 1]`） +  `s[i - 2]` 和 `s[i - 1]` 连起来进行翻译的方案数（即 `dp[i - 2]`）。
2. 第 `i - 1`、`i - 2` 构成的数字在 `[10, 25]`之外，则 `dp[i]` 来源于：`s[i]` 单独翻译的方案数。

## 代码

```python
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        size = len(s)
        dp = [0 for _ in range(size + 1)]
        dp[0] = 1
        dp[1] = 1
        for i in range(2, size + 1):
            temp = int(s[i-2:i])
            if temp >= 10 and temp <= 25:
                dp[i] = dp[i - 1] + dp[i - 2]
            else:
                dp[i] = dp[i - 1]
        return dp[size]
```

# [剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

- 标签：数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [剑指 Offer 47. 礼物的最大价值 - 力扣](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

## 题目大意

给定一个 `m * n` 大小的二维矩阵 `grid` 代表棋盘，棋盘的每一格都放有一个礼物，每个礼物有一定的价值（价值大于 `0`）。`grid[i][j]` 表示棋盘第 `i` 行第 `j` 列的礼物价值。我们可以从左上角的格子开始拿礼物，每次只能向右或者向下移动一格，直到到达棋盘的右下角。

要求：计算出最多能拿多少价值的礼物。 

## 解题思路

可以用动态规划求解，设 `dp[i][j]` 是从 `(0, 0)` 到 `(i - 1, j - 1)` 能得礼物的最大价值。

显然 `dp[i][j] = max(dp[i - 1][j] + dp[i][j - 1]) + grid[i][j]`。

因为是自上而下递推 `dp[i-1][j]` 可以用 `dp[j]` 来表示，所以也可以将二维改为一位。状态转移公式为： `dp[j] = max(dp[j], dp[j - 1]) + grid[i][j]`。

## 代码

```python
class Solution:
    def maxValue(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        size_m = len(grid)
        size_n = len(grid[0])
        dp = [0 for _ in range(size_n + 1)]
        for i in range(size_m):
            for j in range(size_n):
                dp[j + 1] = max(dp[j], dp[j + 1]) + grid[i][j]
        return dp[size_n]
```

# [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

## 题目大意

给定一个字符串 `s`。

要求：找出其中不含有重复字符的最长子串的长度。

## 解题思路

利用集合来存储不重复的字符。用两个指针分别指向最长子串的左右节点。遍历字符串，右指针不断右移，利用集合来判断有没有重复的字符，如果没有，就持续向右扩大右边界。如果出现重复字符，就缩小左侧边界。每次移动终止，都要计算一下当前不含重复字符的子串长度，并判断一下是否需要更新最大长度。

## 代码

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0

        letterSet = set()
        right = 0
        ans = 0
        for i in range(len(s)):
            if i != 0:
                letterSet.remove(s[i - 1])
            while right < len(s) and s[right] not in letterSet:
                letterSet.add(s[right])
                right += 1
            ans = max(ans, right - i)
        return ans
```

# [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

- 标签：哈希表、数学、动态规划、堆（优先队列）
- 难度：中等

## 题目链接

- [剑指 Offer 49. 丑数 - 力扣](https://leetcode.cn/problems/chou-shu-lcof/)

## 题目大意

给定一个整数 `n`。

要求：找出并返回第 `n` 个丑数。

- 丑数：只包含质因数 `2`、`3`、`5` 的正整数。

## 解题思路

动态规划求解。

定义状态 `dp[i]` 表示第 `i` 个丑数。

状态转移方程为：`dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)` ，其中 `p2`、`p3`、`p5` 分别表示当前 `i` 中  `2`、`3`、`5` 的质因子数量。

## 代码

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [1 for _ in range(n)]
        p2, p3, p5 = 0, 0, 0
        for i in range(1, n):
            dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)
            if dp[i] == dp[p2] * 2:
                p2 += 1
            if dp[i] == dp[p3] * 3:
                p3 += 1
            if dp[i] == dp[p5] * 5:
                p5 += 1
        return dp[n - 1]
```

# [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

- 标签：队列、哈希表、字符串、计数
- 难度：简单

## 题目链接

- [剑指 Offer 50. 第一个只出现一次的字符 - 力扣](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

## 题目大意

给定一个字符串 `s`。

要求：从字符串 `s` 中找到第一个只出现一次的字符。如果没有，则返回空格 ` `。

## 解题思路

遍历字符串 `s`，使用哈希表存储每个字符频数。

再次遍历字符串 `s`，返回第一个频数为 `1` 的字符。

## 代码

```python
class Solution:
    def firstUniqChar(self, s: str) -> str:
        dic = dict()
        for ch in s:
            if ch in dic:
                dic[ch] += 1
            else:
                dic[ch] = 1

        for ch in s:
            if ch in dic and dic[ch] == 1:
                return ch
        return ' '
```

# [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

- 标签：树状数组、线段树、数组、二分查找、分治、有序集合、归并排序
- 难度：困难

## 题目链接

- [剑指 Offer 51. 数组中的逆序对 - 力扣](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

## 题目大意

**描述**：给定一个数组 $nums$。

**要求**：计算出数组中的逆序对的总数。

**说明**：

- **逆序对**：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
- $0 \le nums.length \le 50000$。

**示例**：

- 示例 1：

```python
输入: [7,5,6,4]
输出: 5
```

## 解题思路

### 思路 1：归并排序

归并排序主要分为：「分解过程」和「合并过程」。其中「合并过程」实质上是两个有序数组的合并过程。

![](https://qcdn.itcharge.cn/images/20220414204405.png)

每当遇到 左子数组当前元素 > 右子树组当前元素时，意味着「左子数组从当前元素开始，一直到左子数组末尾元素」与「右子树组当前元素」构成了若干个逆序对。

比如上图中的左子数组 $[0, 3, 5, 7]$ 与右子树组 $[1, 4, 6, 8]$，遇到左子数组中元素 $3$ 大于右子树组中元素 $1$。则左子数组从 $3$ 开始，经过 $5$ 一直到 $7$，与右子数组当前元素 $1$ 都构成了逆序对。即 $[3, 1]$、$[5, 1]$、$[7, 1]$ 都构成了逆序对。

因此，我们可以在合并两个有序数组的时候计算逆序对。具体做法如下：

1. 使用全局变量 $cnt$ 来存储逆序对的个数。然后进行归并排序。
2. **分割过程**：先递归地将当前序列平均分成两半，直到子序列长度为 $1$。
   1. 找到序列中心位置 $mid$，从中心位置将序列分成左右两个子序列 $left\underline{\hspace{0.5em}}arr$、$right\underline{\hspace{0.5em}}arr$。
   2. 对左右两个子序列 $left\underline{\hspace{0.5em}}arr$、$right\underline{\hspace{0.5em}}arr$ 分别进行递归分割。
   3. 最终将数组分割为 $n$ 个长度均为 $1$ 的有序子序列。
3. **归并过程**：从长度为 $1$ 的有序子序列开始，依次进行两两归并，直到合并成一个长度为 $n$ 的有序序列。
   1. 使用数组变量 $arr$ 存放归并后的有序数组。
   2. 使用两个指针 $left\underline{\hspace{0.5em}}i$、$right\underline{\hspace{0.5em}}i$ 分别指向两个有序子序列 $left\underline{\hspace{0.5em}}arr$、$right\underline{\hspace{0.5em}}arr$ 的开始位置。
   3. 比较两个指针指向的元素：
      1. 如果 $left\underline{\hspace{0.5em}}arr[left\underline{\hspace{0.5em}}i] \le right\underline{\hspace{0.5em}}arr[right\underline{\hspace{0.5em}}i]$，则将 $left\underline{\hspace{0.5em}}arr[left\underline{\hspace{0.5em}}i]$ 存入到结果数组 $arr$ 中，并将指针移动到下一位置。
      2. 如果 $left\underline{\hspace{0.5em}}arr[left\underline{\hspace{0.5em}}i] > right\underline{\hspace{0.5em}}arr[right\underline{\hspace{0.5em}}i]$，则 **记录当前左子序列中元素与当前右子序列元素所形成的逆序对的个数，并累加到 $cnt$ 中，即 `self.cnt += len(left_arr) - left_i`**，然后将 $right\underline{\hspace{0.5em}}arr[right\underline{\hspace{0.5em}}i]$ 存入到结果数组 $arr$ 中，并将指针移动到下一位置。
   4. 重复步骤 $3$，直到某一指针到达子序列末尾。
   5. 将另一个子序列中的剩余元素存入到结果数组 $arr$ 中。
   6. 返回归并后的有序数组 $arr$。
4. 返回数组中的逆序对的总数，即 $self.cnt$。

### 思路 1：代码

```python
class Solution:
    cnt = 0
    def merge(self, left_arr, right_arr):           # 归并过程
        arr = []
        left_i, right_i = 0, 0
        while left_i < len(left_arr) and right_i < len(right_arr):
            # 将两个有序子序列中较小元素依次插入到结果数组中
            if left_arr[left_i] <= right_arr[right_i]:
                arr.append(left_arr[left_i])
                left_i += 1
            else:
                self.cnt += len(left_arr) - left_i
                arr.append(right_arr[right_i])
                right_i += 1
        
        while left_i < len(left_arr):
            # 如果左子序列有剩余元素，则将其插入到结果数组中
            arr.append(left_arr[left_i])
            left_i += 1
            
        while right_i < len(right_arr):
            # 如果右子序列有剩余元素，则将其插入到结果数组中
            arr.append(right_arr[right_i])
            right_i += 1
        
        return arr                                  # 返回排好序的结果数组

    def mergeSort(self, arr):                       # 分割过程
        if len(arr) <= 1:                           # 数组元素个数小于等于 1 时，直接返回原数组
            return arr
        
        mid = len(arr) // 2                         # 将数组从中间位置分为左右两个数组。
        left_arr = self.mergeSort(arr[0: mid])      # 递归将左子序列进行分割和排序
        right_arr =  self.mergeSort(arr[mid:])      # 递归将右子序列进行分割和排序
        return self.merge(left_arr, right_arr)      # 把当前序列组中有序子序列逐层向上，进行两两合并。

    def reversePairs(self, nums: List[int]) -> int:
        self.cnt = 0
        self.mergeSort(nums)
        return self.cnt
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

### 思路 2：树状数组

数组 $tree[i]$ 表示数字 $i$ 是否在序列中出现过，如果数字 $i$ 已经存在于序列中，$tree[i] = 1$，否则 $tree[i] = 0$。

1. 按序列从左到右将值为 $nums[i]$ 的元素当作下标为$nums[i]$，赋值为 $1$ 插入树状数组里，这时，比 $nums[i]$ 大的数个数就是 $i + 1 - query(a)$。
2. 将全部结果累加起来就是逆序数了。

### 思路 2：代码

```python
import bisect

class BinaryIndexTree:

    def __init__(self, n):
        self.size = n
        self.tree = [0 for _ in range(n + 1)]

    def lowbit(self, index):
        return index & (-index)

    def update(self, index, delta):
        while index <= self.size:
            self.tree[index] += delta
            index += self.lowbit(index)

    def query(self, index):
        res = 0
        while index > 0:
            res += self.tree[index]
            index -= self.lowbit(index)
        return res

class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        size = len(nums)
        sort_nums = sorted(nums)
        for i in range(size):
            nums[i] = bisect.bisect_left(sort_nums, nums[i]) + 1

        bit = BinaryIndexTree(size)
        ans = 0
        for i in range(size):
            bit.update(nums[i], 1)
            ans += (i + 1 - bit.query(nums[i]))
        return ans
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(n)$。

# [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 标签：哈希表、链表、双指针
- 难度：简单

## 题目链接

- [剑指 Offer 52. 两个链表的第一个公共节点 - 力扣](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

## 题目大意

给定 A、B 两个链表，判断两个链表是否相交，返回相交的起始点。如果不相交，则返回 None。

比如：链表 A 为 [4, 1, 8, 4, 5]，链表 B 为 [5, 0, 1, 8, 4, 5]。则如下图所示，两个链表相交的起始节点为 8，则输出结果为 8。

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

## 解题思路

如果两个链表相交，那么从相交位置开始，到结束，必有一段等长且相同的节点。假设链表 A 的长度为 m、链表 B 的长度为 n，他们的相交序列有 k 个，则相交情况可以如下如所示：

![](https://qcdn.itcharge.cn/images/20210401113538.png)

现在问题是如何找到 m-k 或者 n-k 的位置。

考虑将链表 A 的末尾拼接上链表 B，链表 B 的末尾拼接上链表 A。

然后使用两个指针 pA 、PB，分别从链表 A、链表 B 的头节点开始遍历，如果走到共同的节点，则返回该节点。

否则走到两个链表末尾，返回 None。

![](https://qcdn.itcharge.cn/images/20210401114100.png)

## 代码

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pA = headA
        pB = headB
        while pA != pB:
            pA = pA.next if pA else headB
            pB = pB.next if pB else headA
        return pA
```

# [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

## 题目大意

给定一个排序数组 `nums`，以及一个整数 `target`。

要求：统计 `target` 在排序数组 `nums` 中出现的次数。

## 解题思路

两次二分查找。

- 先查找 `target` 第一次出现的位置（下标）：`left`。
- 再查找 `target` 最后一次出现的位置（下标）：`right`。
- 最终答案为 `right - left + 1`。

## 代码

```python
class Solution:
    def searchLeft(self, nums, target):
        left, right = 0, len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        if nums[left] == target:
            return left
        else:
            return -1

    def searchRight(self, nums, target):
        left, right = 0, len(nums) - 1
        while left < right:
            mid = left + (right - left + 1) // 2
            if nums[mid] <= target:
                left = mid
            else:
                right = mid - 1
        return left

    def search(self, nums: List[int], target: int) -> int:
        if len(nums) == 0:
            return 0
        left = self.searchLeft(nums, target)
        right = self.searchRight(nums, target)

        if left == -1:
            return 0

        return right - left + 1
```

# [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

- 标签：位运算、数组、哈希表、数学、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

## 题目大意

给定一个 `n - 1` 个数的升序数组，数组中元素值都在 `0 ~ n - 1` 之间。 `nums` 中有且只有一个数字不在该数组中。

要求：找出这个缺失的数字。

## 解题思路

可以用二分查找解决。

对于中间值，判断元素值与索引值是否一致，如果一致，则说明缺失数字在索引的右侧。如果不一致，则可能为当前索引或者索引的左侧。

## 代码

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        left, right = 0, len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if mid == nums[mid]:
                left = mid + 1
            else:
                right = mid
        if left == nums[left]:
            return left + 1
        else:
            return left
```

# [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

## 题目大意

**描述**：给定一棵二叉搜索树的根节点 $root$，以及一个整数 $k$。

**要求**：找出二叉搜索树书第 $k$ 大的节点。

**说明**：

- 

**示例**：

- 示例 1：

![](https://pic.leetcode.cn/1695101634-kzHKZW-image.png)

```python
输入：root = [7, 3, 9, 1, 5], cnt = 2
       7
      / \
     3   9
    / \
   1   5
输出：7
```

- 示例 2：

![](https://pic.leetcode.cn/1695101636-ESZtLa-image.png)

```python
输入: root = [10, 5, 15, 2, 7, null, 20, 1, null, 6, 8], cnt = 4
       10
      / \
     5   15
    / \    \
   2   7    20
  /   / \ 
 1   6   8
输出: 8
```

## 解题思路

### 思路 1：遍历

已知中序遍历「左 -> 根 -> 右」能得到递增序列。逆中序遍历「右 -> 根 -> 左」可以得到递减序列。

则根据「右 -> 根 -> 左」递归遍历 k 次，找到第 $k$ 个节点位置，并记录答案。

### 思路 1：代码

```python
class Solution:
    res = 0
    k = 0
    def dfs(self, root):
        if not root:
            return
        self.dfs(root.right)
        if self.k == 0:
            return
        self.k -= 1
        if self.k == 0:
            self.res = root.val
            return
        self.dfs(root.left)

    def kthLargest(self, root: TreeNode, k: int) -> int:
        self.res = 0
        self.k = k
        self.dfs(root)
        return self.res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为树中节点数量。
- **空间复杂度**：$O(n)$。

# [剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 55 - I. 二叉树的深度 - 力扣](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：找出树的深度。

- 深度：从根节点到叶节点一次经过的节点形成一条路径，最长路径的长度为树的深度。

## 解题思路

递归遍历，先递归遍历左右子树，返回左右子树的高度，则当前节点的高度为左右子树最大深度 + 1。即 `max(left_height, right_height) + 1`。

## 代码

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root == None:
            return 0

        left_height = self.maxDepth(root.left)
        right_height = self.maxDepth(root.right)
        return max(left_height, right_height) + 1
```

# [剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

- 标签：树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 55 - II. 平衡二叉树 - 力扣](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：判断该树是不是平衡二叉树。如果是平衡二叉树，返回 `True`，否则，返回 `False`。

- 平衡二叉树：任意节点的左右子树深度不超过 `1`。

## 解题思路

递归遍历二叉树。先递归遍历左右子树，判断左右子树是否平衡，再判断以当前节点为根节点的左右子树是否平衡。

如果遍历的子树是平衡的，则返回它的高度，否则返回 `-1`。

只要出现不平衡的子树，则该二叉树一定不是平衡二叉树。

## 代码

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if root == None:
                return False
            leftHeight = height(root.left)
            rightHeight = height(root.right)
            if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) > 1:
                return -1
            else:
                return max(leftHeight, rightHeight) + 1

        return height(root) >= 0
```

# [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

- 标签：位运算、数组
- 难度：中等

## 题目链接

- [剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

## 题目大意

给定一个整型数组 `nums` 。`nums` 里除两个数字之外，其他数字都出现了两次。

要求：找出这两个只出现一次的数字。要求时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。

## 解题思路

- 求解这道题之前，我们先来看看如何求解「一个数组中除了某个元素只出现一次以外，其余每个元素均出现两次。」即「[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)」问题。我们可以对所有数不断进行异或操作，最终可得到单次出现的元素。

- 如果数组中有两个数字只出现一次，其余每个元素均出现两次。那么经过全部异或运算。我们可以得到只出现一次的两个数字的异或结果。
- 根据异或结果的性质，异或运算中如果某一位上为 `1`，则说明异或的两个数在该位上是不同的。根据这个性质，我们将数字分为两组：一组是和该位为 `0` 的数字，另一组是该位为 `1` 的数字。然后将这两组分别进行异或运算，就可以得到最终要求的两个数字。

## 代码

```python
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        all_xor = 0
        for num in nums:
            all_xor ^= num
        # 获取所有异或中最低位的 1
        mask = 1
        while all_xor & mask == 0:
            mask <<= 1

        a_xor, b_xor = 0, 0
        for num in nums:
            if num & mask == 0:
                a_xor ^= num
            else:
                b_xor ^= num

        return a_xor, b_xor
```

# [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

- 标签：数学、双指针、枚举
- 难度：简单

## 题目链接

- [剑指 Offer 57 - II. 和为s的连续正数序列 - 力扣](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

## 题目大意

**描述**：给定一个正整数 `target`。

**要求**：输出所有和为 `target` 的连续正整数序列（至少含有两个数）。序列中的数字由小到大排列，不同序列按照首个数字从小到大排列。

**说明**：

- $1 \le target \le 10^5$。

**示例**：

- 示例 1：

```python
输入：target = 9
输出：[[2,3,4],[4,5]]
```

- 示例 2：

```python
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

## 解题思路

### 思路 1：枚举算法

连续正整数序列中元素的最小值大于等于 `1`，而最大值不会超过 `target`。所以我们可以枚举可行的区间，并计算出区间和，将其与 `target` 进行比较，如果相等则将对应的区间元素加入答案数组中，最终返回答案数组。

因为题目要求至少含有两个数，则序列开始元素不会超过 `target` 的一半，所以序列开始元素可以从 `1` 开始，枚举到 `target // 2` 即可。

具体步骤如下：

1. 使用列表变量 `res` 作为答案数组。
2. 使用一重循环 `i`，用于枚举序列开始位置，枚举范围为 `[1, target // 2]`。
3. 使用变量 `cur_sum` 维护当前区间的区间和，`cur_sum` 初始为 `0`。
4. 使用第 `2` 重循环 `j`，用于枚举序列的结束位置，枚举范围为 `[i, target - 1]`，并累积计算当前区间的区间和，即 `cur_sum += j`。
   1. 如果当前区间的区间和大于 `target`，则跳出循环。
   2. 如果当前区间的区间和等于 `target`，则将区间上的元素保存为列表，并添加到答案数组中，然后跳出第 `2` 重循环。
5. 遍历完返回答案数组。

### 思路 1：代码

```python
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        res = []
        for i in range(1, target // 2 + 1):
            cur_sum = 0
            for j in range(i, target):
                cur_sum += j
                if cur_sum > target:
                    break
                if cur_sum == target:
                    cur_res = []
                    for k in range(i, j + 1):
                        cur_res.append(k)
                    res.append(cur_res)
                    break
        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$target \times \sqrt{target}$。
- **空间复杂度**：$O(1)$。

### 思路 2：滑动窗口

具体做法如下：

- 初始化窗口，令 `left = 1`，`right = 2`。
- 计算 `sum = (left + right) * (right - left + 1) // 2`。
- 如果 `sum == target`，时，将其加入答案数组中。
- 如果 `sum < target` 时，说明需要扩大窗口，则 `right += 1`。
- 如果 `sum > target` 时，说明需要缩小窗口，则 `left += 1`。
- 直到 `left >= right` 时停止，返回答案数组。

### 思路 2：滑动窗口代码

```python
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        left, right = 1, 2
        res = []
        while left < right:
            sum = (left + right) * (right - left + 1) // 2
            if sum == target:
                arr = []
                for i in range(0, right - left + 1):
                    arr.append(i + left)
                res.append(arr)
                left += 1
            elif sum < target:
                right += 1
            else:
                left += 1
        return res
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(target)$。
- **空间复杂度**：$O(1)$。
# [剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

- 标签：数组、双指针、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer 57. 和为s的两个数字 - 力扣](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

## 题目大意

给定一个升序数组 `nums`，以及一个目标整数 `target`。

要求：在数组中查找两个数，使它们的和刚好等于 `target`。

## 解题思路

因为数组是升序的，可以使用双指针。`left`、`right` 分别指向数组首尾位置。

- 计算 `sum = nums[left] + nums[right]`。
- 如果 `sum > target`，则 `right` 进行左移。
- 如果 `sum < target`，则 `left` 进行右移。
- 如果 `sum == target`，则返回 `[nums[left], nums[right]]`。

## 代码

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left < right:
            sum = nums[left] + nums[right]
            if sum > target:
                right -= 1
            elif sum < target:
                left += 1
            else:
                return nums[left], nums[right]
        return []
```

# [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [剑指 Offer 58 - I. 翻转单词顺序 - 力扣](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

## 题目大意

给定一个字符串 `s`。

要求：逐个翻转字符串中所有的单词。

说明：

- 数组字符串 `s` 可以再前面、后面或者单词间包含多余的空格。
- 翻转后的单词应当只有一个空格分隔。
- 翻转后的字符串不应该包含额外的空格。

## 解题思路

最简单的就是调用 API 进行切片，翻转。复杂一点的也可以根据 API 的思路写出模拟代码。

## 代码

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

# [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

- 标签：数学、双指针、字符串
- 难度：简单

## 题目链接

- [剑指 Offer 58 - II. 左旋转字符串 - 力扣](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

## 题目大意

给定一个字符串 `s` 和一个整数 `n`。

要求：将字符串 `s` 每个字符向左旋转 `n` 位。

- 左旋转：将字符串前面的若干字符转移到字符串的尾部。

## 解题思路

- 使用数组 `res` 存放答案。
- 先遍历 `[n, len(s) - 1]` 范围的字符，将其存入数组。
- 再遍历 `[0, n - 1]` 范围的字符，将其存入数组。
- 将数组转为字符串返回。

## 代码

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = []
        for i in range(n, len(s)):
            res.append(s[i])
        for i in range(n):
            res.append(s[i])
        return "".join(res)
```

# [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

- 标签：队列、滑动窗口、单调队列、堆（优先队列）
- 难度：困难

## 题目链接

- [剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

## 题目大意

给定一个整数数组 `nums` 和滑动窗口的大小 `k`。表示为大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。我们只能看到滑动窗口内的 `k` 个数字，滑动窗口每次只能向右移动一位。

要求：返回滑动窗口中的最大值。

## 解题思路

暴力求解的话，二重循环，时间复杂度为 $O(n * k)$。

我们可以使用优先队列，每次窗口移动时想优先队列中增加一个节点，并删除一个节点。将窗口中的最大值加入到答案数组中。

## 代码

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        size = len(nums)
        if size == 0:
            return []

        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)
        res = [-q[0][0]]

        for i in range(k, size):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            res.append(-q[0][0])
        return res
```

# [剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

- 标签：设计、队列、单调队列
- 难度：中等

## 题目链接

- [剑指 Offer 59 - II. 队列的最大值 - 力扣](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

## 题目大意

要求：设计一个「队列」，实现 `max_value` 函数，可通过 `max_value` 得到大年队列的最大值。并且要求 `max_value`、`push_back`、`pop_front` 的均摊时间复杂度都是 `O(1)`。

## 解题思路

利用空间换时间，使用两个队列。其中一个为原始队列 `queue`，另一个为递减队列 `deque`，`deque` 用来保存队列的最大值，具体做法如下：

- `push_back` 操作：如果 `deque` 队尾元素小于即将入队的元素 `value`，则将小于 `value` 的元素全部出队，再将 `valuew` 入队。否则直接将 `value` 直接入队，这样 `deque` 队首元素保存的就是队列的最大值。
- `pop_front` 操作：先判断 `deque`、`queue` 是否为空，如果 `deque` 或者 `queue` 为空，则说明队列为空，直接返回 `-1`。如果都不为空，从 `queue` 中取出一个元素，并跟 `deque` 队首元素进行比较，如果两者相等则需要将 `deque` 队首元素弹出。
- `max_value` 操作：如果 `deque` 不为空，则返回 `deque` 队首元素。否则返回 `-1`。

## 代码

```python
import collections
import queue


class MaxQueue:

    def __init__(self):
        self.queue = queue.Queue()
        self.deque = collections.deque()


    def max_value(self) -> int:
        if self.deque:
            return self.deque[0]
        else:
            return -1


    def push_back(self, value: int) -> None:
        while self.deque and self.deque[-1] < value:
            self.deque.pop()
        self.deque.append(value)
        self.queue.put(value)


    def pop_front(self) -> int:
        if not self.deque or not self.queue:
            return -1
        ans = self.queue.get()
        if ans == self.deque[0]:
            self.deque.popleft()
        return ans
```

# [剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

- 标签：数组、排序
- 难度：简单

## 题目链接

- [剑指 Offer 61. 扑克牌中的顺子 - 力扣](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

## 题目大意

给定一个 `5` 位数的数组 `nums` 代表扑克牌中的 `5` 张牌。其中 `2~10` 为数字本身，`A` 用 `1` 表示，`J` 用 `11` 表示，`Q` 用 `12` 表示，`K` 用 `13` 表示，大小王用 `0` 表示，且大小王可以替换任意数字。

要求：判断给定的 `5` 张牌是否是一个顺子，即是否为连续的`5` 个数。

## 解题思路

先不考虑牌中有大小王，如果 `5` 个数是连续的，则这 `5` 个数中最大值最小值的关系为：`最大值 - 最小值 = 4`。如果牌中有大小王可以替换这 `5` 个数中的任意数字，则除大小王之外剩下数的最大值最小值关系为 `最大值 - 最小值 <= 4`。而且剩余数不能有重复数字。于是可以这样进行判断。

遍历 `5` 张牌：

- 如果出现大小王，则跳过。
- 判断 `5` 张牌中是否有重复数，如果有则直接返回 `False`，如果没有则将其加入集合。
- 计算 `5` 张牌的最大值，最小值。

最后判断 `最大值 - 最小值  <= 4` 是否成立。如果成立，返回 `True`，否则返回 `False`。

## 代码

```python
class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        max_num, min_num = 0, 14
        repeat = set()
        for num in nums:
            if num == 0:
                continue
            if num in repeat:
                return False
            repeat.add(num)
            max_num = max(max_num, num)
            min_num = min(min_num, num)
        return max_num - min_num <= 4
```

# [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

- 标签：递归、数学
- 难度：简单

## 题目链接

- [剑指 Offer 62. 圆圈中最后剩下的数字 - 力扣](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

## 题目大意

**描述**：$0$、$1$、…、$n - 1$ 这 $n$ 个数字排成一个圆圈，从数字 $0$ 开始，每次从圆圈里删除第 $m$ 个数字。现在给定整数 $n$ 和 $m$。

**要求**：求出这个圆圈中剩下的最后一个数字。 

**说明**：

- $1 \le num \le 10^5$。
- $1 \le target \le 10^6$。

**示例**：

- 示例 1：

```python
输入：num = 7, target = 4
输出：1
```

- 示例 2：

```python
输入：num = 12, target = 5
输出：0
```

## 解题思路

### 思路 1：枚举 + 模拟

模拟循环删除，需要进行 $n - 1$ 轮，每轮需要对节点进行 $m$ 次访问操作。总体时间复杂度为 $O(n \times m)$。

可以通过找规律来做，以 $n = 5$、$m = 3$ 为例。

- 刚开始为 $0$、$1$、$2$、$3$、$4$。
- 第一次从 $0$ 开始数，数 $3$ 个数，于是 $2$ 出圈，变为 $3$、$4$、$0$、$1$。
- 第二次从 $3$ 开始数，数 $3$ 个数，于是 $0$ 出圈，变为 $1$、$3$、$4$。
- 第三次从 $1$ 开始数，数 $3$ 个数，于是 $4$ 出圈，变为 $1$、$3$。
- 第四次从 $1$ 开始数，数 $3$ 个数，于是 $1$ 出圈，变为 $3$。
- 所以最终为 $3$。

通过上面的流程可以发现：每隔 $m$ 个数就要删除一个数，那么被删除的这个数的下一个数就会成为新的起点。就相当于数组进行左移了 $m$ 位。反过来思考的话，从最后一步向前推，则每一步都向右移动了 $m$ 位（包括胜利者）。

如果用 $f(n, m)$ 表示： $n$ 个数构成环没删除 $m$ 个数后，最终胜利者的位置，则 $f(n, m) = f(n - 1, m) + m$。

即等于 $n - 1$ 个数构成的环没删除 $m$ 个数后最终胜利者的位置，像右移动 $m$ 次。

问题是现在并不是真的进行了右移，因为当前数组右移后超过数组容量的部分应该重新放到数组头部位置。所以公式应为：$f(n, m) = [f(n - 1, m) + m] \mod n$，$n$ 为反过来向前推的时候，每一步剩余的数字个数（比如第二步推回第一步，n $4$），则反过来递推公式为：

- $f(1, m) = 0$。
- $f(2, m) = [f(1, m) + m] \mod 2$。
- $f(3, m) = [f(2, m) + m] \mod 3$。
- 。。。。。。

- $f(n, m) = [f(n - 1, m) + m] \mod n $。

接下来就是递推求解了。

### 思路 1：代码

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        ans = 0
        for i in range(2, n + 1):
            ans = (m + ans) % i
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(1)$。

## 参考资料：

- [字节题库 - #剑62 - 简单 - 圆圈中最后剩下的数字 - 1刷](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/zi-jie-ti-ku-jian-62-jian-dan-yuan-quan-3hlji/)
# [剑指 Offer 63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer 63. 股票的最大利润 - 力扣](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

## 题目大意

给定一个数组 `nums`，`nums[i]` 表示一支给定股票第 `i` 天的价格。选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。求能获取的最大利润。

## 解题思路

最简单的思路当然是两重循环暴力枚举，寻找不同天数下的最大利润。

但更好的做法是进行一次遍历。设置两个变量 `minprice`（用来记录买入的最小值）、`maxprofit`（用来记录可获取的最大利润）。

进行一次遍历，遇到当前价格比 `minprice` 还要小的，就更新 `minprice`。如果单签价格大于或者等于 `minprice`，则判断一下以当前价格卖出的话能卖多少，如果比 `maxprofit` 还要大，就更新 `maxprofit`。

## 代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minprice = 10010
        maxprofit = 0
        for price in prices:
            if price < minprice:
                minprice = price
            elif price - minprice > maxprofit:
                maxprofit = price - minprice
        return maxprofit
```

# [剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/)

- 标签：位运算、递归、脑筋急转弯
- 难度：中等

## 题目链接

- [剑指 Offer 64. 求1+2+…+n - 力扣](https://leetcode.cn/problems/qiu-12n-lcof/)

## 题目大意

给定一个整数 `n`。

要求：计算 `1 + 2 + ... + n`，并且不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。

## 解题思路

Python 中的逻辑运算最终返回的是最后一个非空值。比如 `3 and 2 and 'a'` 最终返回的是 `'a'`。利用这个特性可以递归求解。

## 代码

```python
class Solution:
    def sumNums(self, n: int) -> int:
        return n and n + self.sumNums(n - 1)
```

# [剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

- 标签：位运算、数学
- 难度：简单

## 题目链接

- [剑指 Offer 65. 不用加减乘除做加法 - 力扣](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

## 题目大意

给定两个整数 `a`、`b`。

要求：不能使用运算符 `+`、`-`、`*`、`/`，计算两整数 `a` 、`b` 之和。

## 解题思路

需要用到位运算的一些知识。

- 异或运算 a ^ b ：可以获得 a + b 无进位的加法结果。
- 与运算 a & b：对应位置为 1，说明 a、b 该位置上原来都为 1，则需要进位。
- 座椅运算 a << 1：将 a 对应二进制数左移 1 位。

这样，通过 a^b 运算，我们可以得到相加后无进位结果，再根据 (a&b) << 1，计算进位后结果。

进行 a^b 和 (a&b) << 1操作之后判断进位是否为 0，若不为 0，则继续上一步操作，直到进位为 0。

> 注意：
>
> Python 的整数类型是无限长整数类型，负数不确定符号位是第几位。所以我们可以将输入的数字手动转为 32 位无符号整数。
>
> 通过 a &= 0xFFFFFFFF 即可将 a 转为 32 位无符号整数。最后通过对 a 的范围判断，将其结果映射为有符号整数。

## 代码

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        MAX_INT = 0x7FFFFFFF
        MASK = 0xFFFFFFFF
        a &= MASK
        b &= MASK
        while b:
            carry = ((a & b) << 1) & MASK
            a ^= b
            b = carry
        if a <= MAX_INT:
            return a
        else:
            return ~(a ^ MASK)
```

# [剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

- 标签：数组、前缀和
- 难度：中等

## 题目链接

- [剑指 Offer 66. 构建乘积数组 - 力扣](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

## 题目大意

给定一个数组 `A`。

要求：构建一个数组 `B`，其中 `B[i]` 为数组 `A` 中除了 `A[i]` 之外的其他所有元素乘积。

要求不能使用除法。

## 解题思路

构造一个答案数组 `B`，长度和数组 `A` 长度一致。先从左到右遍历一遍 `A` 数组，将 `A[i]` 左侧的元素乘积累积起来，存储到 `B` 数组中。再从右到左遍历一遍，将 `A[i]` 右侧的元素乘积累积起来，再乘以原本 `B[i]` 的值，即为 `A` 中除了 `A[i]` 之外的其他所有元素乘积。

## 代码

```python
class Solution:
    def constructArr(self, a: List[int]) -> List[int]:
        size = len(a)
        b = [1 for _ in range(size)]

        left = 1
        for i in range(size):
            b[i] *= left
            left *= a[i]

        right = 1
        for i in range(size - 1, -1, -1):
            b[i] *= right
            right *= a[i]
        return b
```

# [剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

- 标签：字符串
- 难度：中等

## 题目链接

- [剑指 Offer 67. 把字符串转换成整数 - 力扣](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

## 题目大意

给定一个字符串 `str`。

要求：使其能换成一个 32 位有符号整数。并且该方法满足以下要求：

- 丢弃开头无用的空格字符，直到找到第一个非空格字符为止。
- 当找到的第一个非空字符为正负号时，将该符号与后面尽可能多的连续数组组合起来，作为该整数的正负号。如果第一个非空字符为数字，则直接将其与之后连续的数字字符组合起来，形成整数。
- 该字符串中除了有效的整数部分之后也可能会存在多余字符，可直接将这些字符忽略，不会对函数造成影响。
- 如果第一个非空格字符不是一个有效整数字符、或者字符串为空、字符串仅包含空白字符时，函数不需要进行转换。
- 需要检测有效性，无法读取返回 0。
- 所有整数范围为 $[-2^{31}, 2^{31} - 1]$，超过这个范围，则返回 $2^{31} - 1$ 或者 $-2^{31}$。

## 解题思路

根据题意直接模拟即可。

1. 先去除前后空格。
2. 检测正负号。
3. 读入数字，并用字符串存储数字结果
4. 将数字字符串转为整数，并根据正负号转换整数结果。
5. 判断整数范围，并返回最终结果。

## 代码

```python
class Solution:
    def strToInt(self, str: str) -> int:
        num_str = ""
        positive = True
        start = 0

        s = str.lstrip()
        if not s:
            return 0

        if s[0] == '-':
            positive = False
            start = 1
        elif s[0] == '+':
            positive = True
            start = 1
        elif not s[0].isdigit():
            return 0

        for i in range(start, len(s)):
            if s[i].isdigit():
                num_str += s[i]
            else:
                break
        if not num_str:
            return 0
        num = int(num_str)
        if not positive:
            num = -num
            return max(num, -2 ** 31)
        else:
            return min(num, 2 ** 31 - 1)
```

# [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 - 力扣](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

## 题目大意

给定一棵二叉搜索树的根节点 `root` 和两个指定节点 `p`、`q`。

要求：找到该树中两个指定节点 `p`、`q` 的最近公共祖先。

- 祖先：若节点 `p` 在节点 `node` 的左子树或右子树中，或者 `p == node`，则称 `node` 是 `p` 的祖先。
- 最近公共祖先：对于树的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `lca_node`，满足 `lca_node` 是 `p`、`q` 的祖先且 `lca_node` 的深度尽可能大（一个节点也可以是自己的祖先）

## 解题思路

对于节点 `p`、节点 `q`，最近公共祖先就是从根节点分别到它们路径上的分岔点，也是路径中最后一个相同的节点，现在我们的问题就是求这个分岔点。

使用递归遍历查找最近公共祖先。

- 从根节点开始遍历；
  - 如果当前节点的值大于 `p`、`q` 的值，说明 `p` 和 `q`  应该在当前节点的左子树，因此将当前节点移动到它的左子节点，继续遍历；
  - 如果当前节点的值小于 `p`、`q` 的值，说明 `p` 和 `q`  应该在当前节点的右子树，因此将当前节点移动到它的右子节点，继续遍历；
  - 如果当前节点不满足上面两种情况，则说明 `p` 和 `q` 分别在当前节点的左右子树上，则当前节点就是分岔点，直接返回该节点即可。

## 代码

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        ancestor = root
        while True:
            if ancestor.val > p.val and ancestor.val > q.val:
                ancestor = ancestor.left
            elif ancestor.val < p.val and ancestor.val < q.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor
```

# [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

- 标签：树、深度优先搜索、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

## 题目大意

给定一个二叉树的根节点 `root`，再给定两个指定节点 `p`、`q`。

要求：找到两个指定节点 `p`、`q` 的最近公共祖先。

- 祖先：若节点 `p` 在节点 `node` 的左子树或右子树中，或者 `p == node`，则称 `node` 是 `p` 的祖先。
- 最近公共祖先：对于树的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `lca_node`，满足 `lca_node` 是 `p`、`q` 的祖先且 `lca_node` 的深度尽可能大（一个节点也可以是自己的祖先）

## 解题思路

设 `lca_node` 为节点 `p`、`q` 的最近公共祖先。则 `lca_node` 只能是下面几种情况：

- `p`、`q`  在 `lca_node` 的子树中，且分别在 `lca_node` 的两侧子树中。
- `p = lca_node`，且 `q` 在 `lca_node` 的左子树或右子树中。
- `q = lca_node`，且 `p` 在 `lca_node` 的左子树或右子树中。

下面递归求解 `lca_node`。递归需要满足以下条件：

- 如果 `p`、`q` 都不为空，则返回 `p`、`q` 的公共祖先。
- 如果 `p`、`q` 只有一个存在，则返回存在的一个。
- 如果 `p`、`q` 都不存在，则返回存在的一个。

具体思路为：

- 如果当前节点 `node` 为 `None`，则说明 `p`、`q` 不在 `node` 的子树中，不可能为公共祖先，直接返回 `None`。
- 如果当前节点 `node` 等于 `p` 或者 `q`，那么 `node` 就是 `p`、`q` 的最近公共祖先，直接返回 `node`
- 递归遍历左子树、右子树，并判断左右子树结果。
  - 如果左子树为空，则返回右子树。
  - 如果右子树为空，则返回左子树。
  - 如果左右子树都不为空，则说明 `p`、`q` 在当前根节点的两侧，当前根节点就是他们的最近公共祖先。
  - 如果左右子树都为空，则返回空。

## 代码

```python
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if root == p or root == q:
            return root

        if root:
            node_left = self.lowestCommonAncestor(root.left, p, q)
            node_right = self.lowestCommonAncestor(root.right, p, q)
            if node_left and node_right:
                return root
            elif not node_left:
                return node_right
            else:
                return node_left
        return None
```

# [剑指 Offer II 001. 整数除法](https://leetcode.cn/problems/xoh6Oh/)

- 标签：位运算、数学
- 难度：简单

## 题目链接

- [剑指 Offer II 001. 整数除法 - 力扣](https://leetcode.cn/problems/xoh6Oh/)

## 题目大意

给定两个整数，被除数 dividend 和除数 divisor。要求返回两数相除的商，并且不能使用乘法，除法和取余运算。取值范围在 $[-2^{31}, 2^{31}-1]$。如果结果溢出，则返回 $2^{31} - 1$。

## 解题思路

题目要求不能使用乘法，除法和取余运算。

可以把被除数和除数当做二进制，这样进行运算的时候，就可以通过移位运算来实现二进制的乘除。

- 先将除数不断左移，移位到位数大于或等于被除数。记录其移位次数 count。

- 然后再将除数右移 count 次，模拟二进制除法运算。
  - 如果当前被除数大于等于除数，则将 1 左移 count 位，即为当前位的商，并将其累加答案上。再用除数减去被除数，进行下一次运算。

## 代码

```python

添加备注


class Solution:
    def divide(self, a: int, b: int) -> int:
        MIN_INT, MAX_INT = -2147483648, 2147483647
        symbol = True if (a ^ b) < 0 else False
        if a < 0:
            a = -a
        if b < 0:
            b = -b

        # 除数不断左移，移位到位数大于或等于被除数
        count = 0
        while a >= b:
            count += 1
            b <<= 1

        # 向右移位，不断模拟二进制除法运算
        res = 0
        while count > 0:
            count -= 1
            b >>= 1
            if a >= b:
                res += (1 << count)
                a -= b
        if symbol:
            res = -res
        if MIN_INT <= res <= MAX_INT:
            return res
        else:
            return MAX_INT
```

# [剑指 Offer II 002. 二进制加法](https://leetcode.cn/problems/JFETK5/)

- 标签：位运算、数学、字符串、模拟
- 难度：简单

## 题目链接

- [剑指 Offer II 002. 二进制加法 - 力扣](https://leetcode.cn/problems/JFETK5/)

## 题目大意

给定两个二进制数的字符串 `a`、`b`。

要求：计算 `a` 和 `b` 的和，返回结果也用二进制表示。

## 解题思路

这道题可以直接将 `a`、`b` 转换为十进制数，相加后再转换为二进制数。

也可以利用位运算的一些知识，直接求和。

因为 `a`、`b` 为二进制的字符串，先将其转换为二进制数。

本题用到的位运算知识：

- 异或运算 `x ^ y` ：可以获得 `x + y` 无进位的加法结果。
- 与运算 `x & y`：对应位置为 `1`，说明 `x`、`y` 该位置上原来都为 `1`，则需要进位。
- 座椅运算 `x << 1`：将 a 对应二进制数左移 `1` 位。

这样，通过 `x ^ y` 运算，我们可以得到相加后无进位结果，再根据 `(x & y) << 1`，计算进位后结果。

进行 `x ^ y` 和 `(x & y) << 1`操作之后判断进位是否为 `0`，若不为 `0`，则继续上一步操作，直到进位为 `0`。

最后将其结果转为 `2` 进制返回。

## 代码

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        x = int(a, 2)
        y = int(b, 2)
        while y:
            carry = ((x & y) << 1)
            x ^= y
            y = carry
        return bin(x)[2:]
```

# [剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode.cn/problems/w3tCBm/)

- 标签：位运算、动态规划
- 难度：简单

## 题目链接

- [剑指 Offer II 003. 前 n 个数字二进制中 1 的个数 - 力扣](https://leetcode.cn/problems/w3tCBm/)

## 题目大意

给定一个整数 `n`。

要求：对于 `0 ≤ i ≤ n` 的每一个 `i`，计算其二进制表示中 `1` 的个数，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

## 解题思路

可以根据整数的二进制特点将其分为两类：

- 奇数：一定比前面相邻的偶数多一个 `1`。
- 偶数：一定和除以 `2` 之后的数一样多。
- 边界 `0`：`1` 的个数为 `0`。

于是可以根据规律，从 `0` 开始到 `n` 进行递推求解。

## 代码

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0 for _ in range(n + 1)]
        for i in range(1, n + 1):
            if i % 2 == 1:
                dp[i] = dp[i - 1] + 1
            else:
                dp[i] = dp[i // 2]
        return dp
```

# [剑指 Offer II 004. 只出现一次的数字](https://leetcode.cn/problems/WGki4K/)

- 标签：位运算、数组
- 难度：中等

## 题目链接

- [剑指 Offer II 004. 只出现一次的数字 - 力扣](https://leetcode.cn/problems/WGki4K/)

## 题目大意

给定一个整数数组 `nums`，除了某个元素仅出现一次外，其余每个元素恰好出现三次。

要求：找到并返回那个只出现了一次的元素。

## 解题思路

### 1. 哈希表

朴素解法就是利用哈希表。统计出每个元素的出现次数。再遍历哈希表，找到仅出现一次的元素。

### 2. 位运算

将出现三次的元素换成二进制形式放在一起，其二进制对应位置上，出现 `1` 的个数一定是 `3` 的倍数（包括 `0`）。此时，如果在放进来只出现一次的元素，则某些二进制位置上出现 `1` 的个数就不是 `3` 的倍数了。

将这些二进制位置上出现 `1` 的个数不是 `3` 的倍数位置值置为 `1`，是 `3` 的倍数则置为 `0`。这样对应下来的二进制就是答案所求。

注意：因为 Python 的整数没有位数限制，所以不能通过最高位确定正负。所以 Python 中负整数的补码会被当做正整数。所以在遍历到最后 `31` 位时进行 `ans -= (1 << 31)` 操作，目的是将负数的补码转换为「负号 + 原码」的形式。这样就可以正常识别二进制下的负数。参考：[Two's Complement Binary in Python? - Stack Overflow](https://stackoverflow.com/questions/12946116/twos-complement-binary-in-python/12946226)

## 代码

1. 哈希表

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums_dict = dict()
        for num in nums:
            if num in nums_dict:
                nums_dict[num] += 1
            else:
                nums_dict[num] = 1
        for key in nums_dict:
            value = nums_dict[key]
            if value == 1:
                return key
        return 0
```

2. 位运算

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            count = 0
            for j in range(len(nums)):
                count += (nums[j] >> i) & 1
            if count % 3 != 0:
                if i == 31:
                    ans -= (1 << 31)
                else:
                    ans = ans | 1 << i
        return ans
```



# [剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/)

- 标签：位运算、数组、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 005. 单词长度的最大乘积 - 力扣](https://leetcode.cn/problems/aseY1I/)

## 题目大意

给定一个字符串数组 `words`。字符串中只包含英语的小写字母。

要求：计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。如果没有不包含相同字符的一对字符串，返回 0。

## 解题思路

这道题的核心难点是判断任意两个字符串之间是否包含相同字符。最直接的做法是先遍历第一个字符串的每个字符，再遍历第二个字符串查看是否有相同字符。但是这样做的话，时间复杂度过高。考虑怎么样可以优化一下。

题目中说字符串中只包含英语的小写字母，也就是 `26` 种字符。一个 `32` 位的 `int` 整数每一个二进制位都可以表示一种字符的有无，那么我们就可以通过一个整数来表示一个字符串中所拥有的字符种类。延伸一下，我们可以用一个整数数组来表示一个字符串数组中，每个字符串所拥有的字符种类。

接下来事情就简单了，两重循环遍历整数数组，遇到两个字符串不包含相同字符的情况，就计算一下他们长度的乘积，并维护一个乘积最大值。最后输出最大值即可。

## 代码

```python
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        size = len(words)
        arr = [0 for _ in range(size)]
        for i in range(size):
            word = words[i]
            len_word = len(word)
            for j in range(len_word):
                arr[i] |= 1 << (ord(word[j]) - ord('a'))
        ans = 0
        for i in range(size):
            for j in range(i + 1, size):
                if arr[i] & arr[j] == 0:
                    k = len(words[i]) * len(words[j])
                    ans = k if ans < k else ans
        return ans
```

# [剑指 Offer II 006. 排序数组中两个数字之和](https://leetcode.cn/problems/kLl5u1/)

- 标签：数组、双指针、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer II 006. 排序数组中两个数字之和 - 力扣](https://leetcode.cn/problems/kLl5u1/)

## 题目大意

给定一个升序数组：`numbers` 和一个目标值 `target`。

要求：从数组中找出满足相加之和等于 `target` 的两个数，并返回两个数在数组中下的标值。

## 解题思路

因为数组是有序的，所以我们可以使用两个指针 low，high。low 指向数组开始较小元素位置，high 指向数组较大元素位置。判断两个位置上的元素和，如果和等于目标值，则返回两个元素位置。如果和大于目标值，则 high 左移，继续检测。如果和小于目标值，则 low 右移，继续检测。直到 low 和 high 移动到相同位置停止检测。若最终仍没找到，则返回 [0, 0]。

## 代码

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low = 0
        high = len(numbers) - 1
        while low < high:
            total = numbers[low] + numbers[high]
            if total == target:
                return [low, high]
            elif total < target:
                low += 1
            else:
                high -= 1
        return [0, 0]
```

# [剑指 Offer II 007. 数组中和为 0 的三个数](https://leetcode.cn/problems/1fGaJU/)

- 标签：数组、双指针、排序
- 难度：中等

## 题目链接

- [剑指 Offer II 007. 数组中和为 0 的三个数 - 力扣](https://leetcode.cn/problems/1fGaJU/)

## 题目大意

给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`、`b`、`c`，满足 `a + b + c = 0`。

要求：找出所有满足要求的不重复的三元组。

## 解题思路

直接三重遍历查找 a、b、c 的时间复杂度是：$O(n^3)$。我们可以通过一些操作来降低复杂度。

先将数组进行排序，以保证按顺序查找 a、b、c 时，元素值为升序，从而保证所找到的三个元素是不重复的。同时也方便下一步使用双指针减少一重遍历。时间复杂度为：$O(nlogn)$

第一重循环遍历 a，对于每个 a 元素，从 a 元素的下一个位置开始，使用双指针 left，right。left 指向 a 元素的下一个位置，right 指向末尾位置。先将 left 右移、right 左移去除重复元素，再进行下边的判断。

- 若 `nums[a] + nums[left] + nums[right] = 0`，则得到一个解，将其加入答案数组中，并继续将 left 右移，right 左移；

- 若 `nums[a] + nums[left] + nums[right] > 0`，说明 nums[right] 值太大，将 right 向左移；
- 若 `nums[a] + nums[left] + nums[right] < 0`，说明 nums[left] 值太小，将 left 右移。

## 代码

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = []

        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left = i + 1
            right = n - 1
            while left < right:
                while left < right and left > i + 1 and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and right < n - 1 and nums[right + 1] == nums[right]:
                    right -= 1
                if left < right and nums[i] + nums[left] + nums[right] == 0:
                    ans.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                else:
                    left += 1
        return ans
```

# [剑指 Offer II 008. 和大于等于 target 的最短子数组](https://leetcode.cn/problems/2VG8Kg/)

- 标签：数组、二分查找、前缀和、滑动窗口
- 难度：中等

## 题目链接

- [剑指 Offer II 008. 和大于等于 target 的最短子数组 - 力扣](https://leetcode.cn/problems/2VG8Kg/)

## 题目大意

给定一个只包含正整数的数组 `nums` 和一个正整数 `target`。

要求：找出数组中满足和大于等于 `target` 的长度最小的「连续子数组」，并返回其长度。

## 解题思路

最直接的做法是暴力枚举，时间复杂度为 $O(n^2)$。但是我们可以利用滑动窗口的方法，在时间复杂度为 $O(n)$ 的范围内解决问题。

定义两个指针 `start` 和 `end`。`start` 代表滑动窗口开始位置，`end` 代表滑动窗口结束位置。再定义一个变量 `sum` 用来存储滑动窗口中的元素和，一个变量 `ans` 来存储满足提议的最小长度。

先不断移动 `end`，直到 `sum ≥ target`，则更新最小长度值 `ans`。然后再将滑动窗口的起始位置从滑动窗口中移出去，直到 `sum ≤ target`，在移出的期间，同样要更新最小长度值 `ans`。

然后等满足 `sum ≤ target` 时，再移动 `end`，重复上一步，直到遍历到数组末尾。

## 代码

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)

        start = 0
        end = 0
        sum = 0
        ans = n + 1
        while end < n:
            sum += nums[end]
            while sum >= target:
                ans = min(ans, end - start + 1)
                sum -= nums[start]
                start += 1
            end += 1
        if ans == n + 1:
            return 0
        else:
            return ans
```

# [剑指 Offer II 009. 乘积小于 K 的子数组](https://leetcode.cn/problems/ZVAVXX/)

- 标签：数组、滑动窗口
- 难度：中等

## 题目链接

- [剑指 Offer II 009. 乘积小于 K 的子数组 - 力扣](https://leetcode.cn/problems/ZVAVXX/)

## 题目大意

给定一个正整数数组 `nums` 和一个整数 `k`。

要求：找出该数组内乘积小于 `k` 的连续子数组的个数。

## 解题思路

滑动窗口求解。

设定两个指针：`left`、`right`，分别指向滑动窗口的左右边界，保证窗口内所有数的乘积 `product` 都小于 `k`。

- 一开始，`left`、`right` 都指向 `0`。

- 向右移动 `right`，将最右侧元素加入当前子数组乘积 `product` 中。

- 如果 `product >= k` ，则不断右移 `left`，缩小滑动窗口，并更新当前乘积值 `product`  直到 `product < k`。
- 累积答案个数 += 1，继续右移 `right`，直到 `right >= len(nums)` 结束。
- 输出累积答案个数。

## 代码

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0

        size = len(nums)
        left, right = 0, 0
        count = 0
        product = 1
        while right < size:
            product *= nums[right]
            right += 1
            while product >= k:
                product /= nums[left]
                left += 1
            count += (right - left)
        return count
```

# [剑指 Offer II 010. 和为 k 的子数组](https://leetcode.cn/problems/QTMn0o/)

- 标签：数组、哈希表、前缀和
- 难度：中等

## 题目链接

- [剑指 Offer II 010. 和为 k 的子数组 - 力扣](https://leetcode.cn/problems/QTMn0o/)

## 题目大意

给定一个整数数组 `nums` 和一个整数 `k`。

要求：找到该数组中和为 `k` 的连续子数组的个数。

## 解题思路

看到题目的第一想法是通过滑动窗口求解。但是做下来发现有些数据样例无法通过。发现这道题目中的整数不能保证都为正数，则无法通过滑动窗口进行求解。

先考虑暴力做法，外层两重循环，遍历所有连续子数组，然后最内层再计算一下子数组的和。部分代码如下：

```python
for i in range(len(nums)):
    for j in range(i + 1):
        sum = countSum(i, j)
```

这样下来时间复杂度就是 $O(n^3)$ 了。下一步是想办法降低时间复杂度。

先用一重循环遍历数组，计算出数组 `nums` 中前 i 个元素的和（前缀和），保存到一维数组 `pre_sum` 中，那么对于任意 `[j..i]` 的子数组 的和为 `pre_sum[i] - pre_sum[j - 1]`。这样计算子数组和的时间复杂度降为了 $O(1)$。总体时间复杂度为 $O(n^3)$。

但是还是超时了。。

由于我们只关心和为 `k` 出现的次数，不关心具体的解，可以使用哈希表来加速运算。

`pre_sum[i]` 的定义是前 `i` 个元素和，则 `pre_sum[i]` 可以由 `pre_sum[i - 1]` 递推而来，即：`pre_sum[i] = pre_sum[i - 1] + sum[i]`。 `[j..i]` 子数组和为 `k` 可以转换为：`pre_sum[i] - pre_sum[j - 1] == k`。

综合一下，可得：`pre_sum[j - 1] == pre_sum[i] - k `。

所以，当我们考虑以 `i` 结尾和为 `k` 的连续子数组个数时，只需要统计有多少个前缀和为 `pre_sum[i] - k` （即 `pre_sum[j - 1]`）的个数即可。具体做法如下：

- 使用 `pre_sum` 变量记录前缀和（代表 `pre_sum[i]`）。
- 使用哈希表 `pre_dic` 记录 `pre_sum[i]` 出现的次数。键值对为 `pre_sum[i] : pre_sum_count`。
- 从左到右遍历数组，计算当前前缀和 `pre_sum`。
- 如果 `pre_sum - k` 在哈希表中，则答案个数累加上 `pre_dic[pre_sum - k]`。
- 如果 `pre_sum` 在哈希表中，则前缀和个数累加 1，即 `pre_dic[pre_sum] += 1`。
- 最后输出答案个数。

## 代码

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        pre_dic = {0: 1}
        pre_sum = 0
        count = 0
        for num in nums:
            pre_sum += num
            if pre_sum - k in pre_dic:
                count += pre_dic[pre_sum - k]
            if pre_sum in pre_dic:
                pre_dic[pre_sum] += 1
            else:
                pre_dic[pre_sum] = 1
        return count
```

# [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/)

- 标签：数组、哈希表、前缀和
- 难度：中等

## 题目链接

- [剑指 Offer II 011. 0 和 1 个数相同的子数组 - 力扣](https://leetcode.cn/problems/A1NYOS/)

## 题目大意

给定一个二进制数组 `nums`。

要求：找到含有相同数量 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

## 解题思路

「`0` 和 `1` 数量相同」等价于「`1` 的数量减去 `0` 的数量等于 `0`」。

我们可以使用一个变量 `pre_diff` 来记录下前 `i` 个数中，`1` 的数量比 `0` 的数量多多少个。我们把这个 `pre_diff`叫做「`1` 和 `0` 数量差」，也可以理解为变种的前缀和。

然后我们再用一个哈希表 `pre_dic` 来记录「`1` 和 `0` 数量差」第一次出现的下标。

那么，如果我们在遍历的时候，发现 `pre_diff` 相同的数量差已经在之前出现过了，则说明：这两段之间相减的 `1` 和 `0` 数量差为 `0`。

什么意思呢？

比如说：`j < i`，前 `j` 个数中第一次出现 `pre_diff == 2` ，然后前 `i` 个数中个第二次又出现了 `pre_diff == 2`。那么这两段形成的子数组 `nums[j + 1: i]` 中 `1` 比 `0` 多 `0` 个，则 `0` 和 `1` 数量相同的子数组长度为 `i - j`。

而第二次之所以又出现 `pre_diff == 2` ，是因为前半段子数组 `nums[0: j]`  贡献了相同的差值。

接下来还有一个小问题，如何计算「`1` 和 `0` 数量差」？

我们可以把数组中的 `1` 记为贡献 `+1`，`0` 记为贡献 `-1`。然后使用一个变量 `count`，只要出现 `1` 就让 `count` 加上 `1`，意思是又多出了 `1` 个 `1`。只要出现 `0`，将让 `count` 减去 `1`，意思是 `0` 和之前累积的 `1` 个 `1` 相互抵消掉了。这样遍历完数组，也就计算出了对应的「`1` 和 `0` 数量差」。

整个思路的具体做法如下：

- 创建一个哈希表，键值对关系为「`1` 和 `0` 的数量差：最早出现的下标 `i`」。
- 使用变量 `pre_diff` 来计算「`1` 和 `0` 数量差」，使用变量 `count` 来记录 `0` 和 `1` 数量相同的连续子数组的最长长度，然后遍历整个数组。
- 如果 `nums[i] == 1`，则让 `pre_diff += 1`；如果 `nums[i] == 0`，则让 `pre_diff -= 1`。
- 如果在哈希表中发现了相同的 `pre_diff`，则计算相应的子数组长度，与 `count` 进行比较并更新 `count` 值。
- 如果在哈希表中没有发现相同的 `pre_diff`，则在哈希表中记录下第一次出现 `pre_diff` 的下标 `i`。
- 最后遍历完输出 `count`。

> 注意：初始化哈希表为：`pre_dic = {0: -1}`，意思为空数组时，默认「`1` 和 `0` 数量差」为 `0`，且第一次出现的下标为 `-1`。
>
> 之所以这样做，是因为在遍历过程中可能会直接出现 `pre_diff == 0` 的情况，这种情况下说明 `nums[0: i]` 中 `0` 和 `1` 数量相同，如果像上边这样初始化后，就可以直接计算出此时子数组长度为 `i - (-1) = i + 1`。

## 代码

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        pre_dic = {0: -1}
        count = 0
        pre_sum = 0
        for i in range(len(nums)):
            if nums[i]:
                pre_sum += 1
            else:
                pre_sum -= 1
            if pre_sum in pre_dic:
                count = max(count, i - pre_dic[pre_sum])
            else:
                pre_dic[pre_sum] = i
        return count
```

# [剑指 Offer II 012. 左右两边子数组的和相等](https://leetcode.cn/problems/tvdfij/)

- 标签：数组、前缀和
- 难度：简单

## 题目链接

- [剑指 Offer II 012. 左右两边子数组的和相等 - 力扣](https://leetcode.cn/problems/tvdfij/)

## 题目大意

给定一个数组 `nums`。

要求：找到「左侧元素和」与「右侧元素和相等」的位置，若找不到，则返回 `-1`。

## 解题思路

两次遍历，第一次遍历先求出数组全部元素和。第二次遍历找到左侧元素和恰好为全部元素和一半的位置。

## 代码

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        sum = 0
        for i in range(len(nums)):
            sum += nums[i]
        curr_sum = 0
        for i in range(len(nums)):
            if curr_sum * 2 + nums[i] == sum:
                return i
            curr_sum += nums[i]
        return -1
```

# [剑指 Offer II 013. 二维子矩阵的和](https://leetcode.cn/problems/O4NDxx/)

- 标签：设计、数组、矩阵、前缀和
- 难度：中等

## 题目链接

- [剑指 Offer II 013. 二维子矩阵的和 - 力扣](https://leetcode.cn/problems/O4NDxx/)

## 题目大意

给定一个二维矩阵 `matrix`。

要求：满足以下多个请求：

- ` def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:`计算以 `(row1, col1)` 为左上角、`(row2, col2)` 为右下角的子矩阵中各个元素的和。
- `def __init__(self, matrix: List[List[int]]):` 对二维矩阵 `matrix` 进行初始化操作。

## 解题思路

在进行初始化的时候做预处理，这样在多次查询时可以减少重复计算，也可以减少时间复杂度。

在进行初始化的时候，使用一个二维数组 `pre_sum` 记录下以 `(0, 0)` 为左上角，以当前 `(row, col)` 为右下角的子数组各个元素和，即 `pre_sum[row + 1][col + 1]`。

则在查询时，以 `(row1, col1)` 为左上角、`(row2, col2)` 为右下角的子矩阵中各个元素的和就等于以 `(0, 0)` 到 `(row2, col2)` 的大子矩阵减去左边 `(0, 0)` 到 `(row2, col1 - 1)`的子矩阵，再减去上边 `(0, 0)` 到 `(row1 - 1, col2)` 的子矩阵，再加上左上角 `(0, 0)` 到 `(row1 - 1, col1 - 1)` 的子矩阵（因为之前重复减了）。即 `pre_sum[row2 + 1][col2 + 1] - self.pre_sum[row2 + 1][col1] - self.pre_sum[row1][col2 + 1] + self.pre_sum[row1][col1]`。

## 代码

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        rows = len(matrix)
        cols = len(matrix[0])
        self.pre_sum = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]
        for row in range(rows):
            for col in range(cols):
                self.pre_sum[row + 1][col + 1] = self.pre_sum[row + 1][col] + self.pre_sum[row][col + 1] - self.pre_sum[row][col] + matrix[row][col]


    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.pre_sum[row2 + 1][col2 + 1] - self.pre_sum[row2 + 1][col1] - self.pre_sum[row1][col2 + 1] + self.pre_sum[row1][col1]
```

# [剑指 Offer II 016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/)

- 标签：哈希表、字符串、滑动窗口
- 难度：中等

## 题目链接

- [剑指 Offer II 016. 不含重复字符的最长子字符串 - 力扣](https://leetcode.cn/problems/wtcaE1/)

## 题目大意

给定一个字符串 `s`。

要求：找出其中不含有重复字符的 最长子串 的长度。

## 解题思路

利用集合来存储不重复的字符。用两个指针分别指向最长子串的左右节点。遍历字符串，右指针不断右移，利用集合来判断有没有重复的字符，如果没有，就持续向右扩大右边界。如果出现重复字符，就缩小左侧边界。每次移动终止，都要计算一下当前不含重复字符的子串长度，并判断一下是否需要更新最大长度。

## 代码

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0

        letterSet = set()
        right = 0
        ans = 0
        for i in range(len(s)):
            if i != 0:
                letterSet.remove(s[i - 1])
            while right < len(s) and s[right] not in letterSet:
                letterSet.add(s[right])
                right += 1
            ans = max(ans, right - i)
        return ans
```

# [剑指 Offer II 017. 含有所有字符的最短字符串](https://leetcode.cn/problems/M1oyTv/)

- 标签：哈希表、字符串、滑动窗口
- 难度：困难

## 题目链接

- [剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣](https://leetcode.cn/problems/M1oyTv/)

## 题目大意

给定一个字符串 `s`、一个字符串 `t`。

要求：返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。如果存在多个符合条件的子字符串，返回任意一个。

## 解题思路

使用滑动窗口求解。

`left`、`right` 表示窗口的边界，一开始都位于下标 `0` 处。`need` 用于记录短字符串需要的字符数。`window` 记录当前窗口内的字符数。

将 `right` 右移，直到出现了 `t` 中全部字符，开始右移 `left`，减少滑动窗口的大小，并记录下最小覆盖子串的长度和起始位置。最后输出结果。

## 代码

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = collections.defaultdict(int)
        window = collections.defaultdict(int)
        for ch in t:
            need[ch] += 1

        left, right = 0, 0
        valid = 0
        start = 0
        size = len(s) + 1

        while right < len(s):
            insert_ch = s[right]
            right += 1

            if insert_ch in need:
                window[insert_ch] += 1
                if window[insert_ch] == need[insert_ch]:
                    valid += 1

            while valid == len(need):
                if right - left < size:
                    start = left
                    size = right - left
                remove_ch = s[left]
                left += 1
                if remove_ch in need:
                    if window[remove_ch] == need[remove_ch]:
                        valid -= 1
                    window[remove_ch] -= 1
        if size == len(s) + 1:
            return ''
        return s[start:start + size]
```

# [剑指 Offer II 018. 有效的回文](https://leetcode.cn/problems/XltzEq/)

- 标签：双指针、字符串
- 难度：简单

## 题目链接

- [剑指 Offer II 018. 有效的回文 - 力扣](https://leetcode.cn/problems/XltzEq/)

## 题目大意

给定一个字符串 `s`。

要求：判断是否为回文串。（只考虑字符串中的字母和数字字符，并且忽略字母的大小写）

## 解题思路

左右两个指针 `start` 和 `end`，左指针 `start` 指向字符串头部，右指针 `end` 指向字符串尾部。先过滤掉除字母和数字字符以外的字符，在判断 `s[start]` 和 `s[end]` 是否相等。不相等返回 `False`，相等则继续过滤和判断。

## 代码

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        n = len(s)
        start = 0
        end = n - 1
        while start < end:
            if not s[start].isalnum():
                start += 1
                continue
            if not s[end].isalnum():
                end -= 1
                continue
            if s[start].lower() == s[end].lower():
                start += 1
                end -= 1
            else:
                return False
        return True
```

# [剑指 Offer II 019. 最多删除一个字符得到回文](https://leetcode.cn/problems/RQku0D/)

- 标签：贪心、双指针、字符串
- 难度：简单

## 题目链接

- [剑指 Offer II 019. 最多删除一个字符得到回文 - 力扣](https://leetcode.cn/problems/RQku0D/)

## 题目大意

给定一个非空字符串 `s`。

要求：判断如果最多从字符串中删除一个字符能否得到一个回文字符串。

## 解题思路

双指针 + 贪心算法。

- 用两个指针 `left`、`right` 分别指向字符串的开始和结束位置。

- 判断 `s[left]` 是否等于 `s[right]`。
  - 如果等于，则 `left` 右移、`right`左移。
  - 如果不等于，则判断 `s[left: right - 1]` 或 `s[left + 1, right]` 是为回文串。
    - 如果是则返回 `True`。
    - 如果不是则返回 `False`，然后继续判断。
- 如果 `right >= left`，则说明字符串 `s` 本身就是回文串，返回 `True`。



## 代码

```python
class Solution:
    def checkPalindrome(self, s: str, left: int, right: int):
        i, j = left, right
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    def validPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] == s[right]:
                left += 1
                right -= 1
            else:
                return self.checkPalindrome(s, left + 1, right) or self.checkPalindrome(s, left, right - 1)
        return True
```

# [剑指 Offer II 020. 回文子字符串的个数](https://leetcode.cn/problems/a7VOhD/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 020. 回文子字符串的个数 - 力扣](https://leetcode.cn/problems/a7VOhD/)

## 题目大意

给定一个字符串 `s`。

要求：计算 `s` 中有多少个回文子串。

## 解题思路

动态规划求解。

先定义状态 `dp[i][j]` 表示为区间 `[i, j]` 的子串是否为回文子串，如果是，则 `dp[i][j] = True`，如果不是，则 `dp[i][j] = False`。

接下来确定状态转移共识：

如果 `s[i] == s[j]`，分为以下几种情况：

- `i == j`，单字符肯定是回文子串，`dp[i][j] == True`。
- `j - i == 1`，比如 `aa` 肯定也是回文子串，`dp[i][j] = True`。
- 如果 `j - i > 1`，则需要看 `[i + 1, j - 1]` 区间是不是回文子串，`dp[i][j] = dp[i + 1][j - 1]`。

如果 `s[i] != s[j]`，那肯定不是回文子串，`dp[i][j] = False`。

下一步确定遍历方向。

由于 `dp[i][j]` 依赖于 `dp[i + 1][j - 1]`，所以我们可以从左下角向右上角遍历。

同时，在递推过程中记录下 `dp[i][j] == True` 的个数，即为最后结果。

## 代码

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        size = len(s)
        dp = [[False for _ in range(size)] for _ in range(size)]
        res = 0
        for i in range(size - 1, -1, -1):
            for j in range(i, size):
                if s[i] == s[j]:
                    if j - i <= 1:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                else:
                    dp[i][j] = False
                if dp[i][j]:
                    res += 1
        return res
```

# [剑指 Offer II 021. 删除链表的倒数第 n 个结点](https://leetcode.cn/problems/SLwz0R/)

- 标签：链表、双指针
- 难度：中等

## 题目链接

- [剑指 Offer II 021. 删除链表的倒数第 n 个结点 - 力扣](https://leetcode.cn/problems/SLwz0R/)

## 题目大意

给你一个链表的头节点 `head` 和一个整数 `n`。

要求：删除链表的倒数第 `n` 个节点，并且返回链表的头节点。并且要求使用一次遍历实现。

## 解题思路

常规思路是遍历一遍链表，求出链表长度，再遍历一遍到对应位置，删除该位置上的节点。

如果用一次遍历实现的话，可以使用快慢指针。让快指针先走 n 步，然后快慢指针、慢指针再同时走，每次一步，这样等快指针遍历到链表尾部的时候，慢指针就刚好遍历到了倒数第 n 个节点位置。将该位置上的节点删除即可。

需要注意的是要删除的节点可能包含了头节点。我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则删除原头节点即可。返回结果的时候，可以直接返回新建头节点的下一位节点。

## 代码

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        newHead = ListNode(0, head)
        fast = head
        slow = newHead
        while n:
            fast = fast.next
            n -= 1
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return newHead.next
```

# [剑指 Offer II 022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV/)

- 标签：哈希表、链表、双指针
- 难度：中等

## 题目链接

- [剑指 Offer II 022. 链表中环的入口节点 - 力扣](https://leetcode.cn/problems/c32eOV/)

## 题目大意

给定一个链表的头节点 `head`。

要求：判断链表中是否有环，如果有环则返回入环的第一个节点，无环则返回 `None`。

## 解题思路

利用两个指针，一个慢指针每次前进一步，快指针每次前进两步（两步或多步效果是等价的）。如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。

如果有环，则再定义一个指针，和慢指针一起每次移动一步，两个指针相遇的位置即为入口节点。

这是因为：假设入环位置为 A，快慢指针在在 B 点相遇，则相遇时慢指针走了 a + b 步，快指针走了 $a + n(b+c) + b$ 步。

$2(a + b) = a + n(b + c) + b$。可以推出：$a = c + (n-1)(b + c)$。

我们可以发现：从相遇点到入环点的距离 $c$ 加上 $n-1$ 圈的环长 $b + c$ 刚好等于从链表头部到入环点的距离。

## 代码

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while True:
            if not fast or not fast.next:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break

        ans = head
        while ans != slow:
            ans, slow = ans.next, slow.next
        return ans    
```

# [剑指 Offer II 023. 两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/)

- 标签：哈希表、链表、双指针
- 难度：简单

## 题目链接

- [剑指 Offer II 023. 两个链表的第一个重合节点 - 力扣](https://leetcode.cn/problems/3u1WK4/)

## 题目大意

给定 `A`、`B` 两个链表。

要求：判断两个链表是否相交，返回相交的起始点。如果不相交，则返回 `None`。

比如：链表 A 为 [4, 1, 8, 4, 5]，链表 B 为 [5, 0, 1, 8, 4, 5]。则如下图所示，两个链表相交的起始节点为 8，则输出结果为 8。

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)



## 解题思路

如果两个链表相交，那么从相交位置开始，到结束，必有一段等长且相同的节点。假设链表 A 的长度为 m、链表 B 的长度为 n，他们的相交序列有 k 个，则相交情况可以如下如所示：

![](https://qcdn.itcharge.cn/images/20210401113538.png)

现在问题是如何找到 m-k 或者 n-k 的位置。

考虑将链表 A 的末尾拼接上链表 B，链表 B 的末尾拼接上链表 A。

然后使用两个指针 pA 、PB，分别从链表 A、链表 B 的头节点开始遍历，如果走到共同的节点，则返回该节点。

否则走到两个链表末尾，返回 None。

![](https://qcdn.itcharge.cn/images/20210401114100.png)

## 代码

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if headA == None or headB == None:
            return None
        pA = headA
        pB = headB
        while pA != pB:
            pA = pA.next if pA != None else headB
            pB = pB.next if pB != None else headA
        return pA
```

# [剑指 Offer II 024. 反转链表](https://leetcode.cn/problems/UHnkqh/)

- 标签：递归、链表
- 难度：简单

## 题目链接

- [剑指 Offer II 024. 反转链表 - 力扣](https://leetcode.cn/problems/UHnkqh/)

## 题目大意

**描述**：给定一个单链表的头节点 `head`。

**要求**：将其进行反转，并返回反转后的链表的头节点。

## 解题思路

### 思路 1. 迭代

1. 使用两个指针 `cur` 和 `pre` 进行迭代。`pre` 指向 `cur` 前一个节点位置。初始时，`pre` 指向 `None`，`cur` 指向 `head`。

2. 将 `pre` 和 `cur` 的前后指针进行交换，指针更替顺序为：
   1. 使用 `next` 指针保存当前节点 `cur` 的后一个节点，即 `next = cur.next`；
   2. 断开当前节点 `cur` 的后一节点链接，将 `cur` 的 `next` 指针指向前一节点 `pre`，即 `cur.next = pre`；
   3. `pre` 向前移动一步，移动到 `cur` 位置，即 `pre = cur`；
   4. `cur` 向前移动一步，移动到之前 `next` 指针保存的位置，即 `cur = next`。
3. 继续执行第 2 步中的 1、2、3、4。
4. 最后等到 `cur` 遍历到链表末尾，即 `cur == None`，时，`pre` 所在位置就是反转后链表的头节点，返回新的头节点 `pre`。

使用迭代法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111133639.png)

### 思路 2. 递归

具体做法如下：

- 首先定义递归函数含义为：将链表反转，并返回反转后的头节点。
- 然后从 `head.next` 的位置开始调用递归函数，即将 `head.next` 为头节点的链表进行反转，并返回该链表的头节点。
- 递归到链表的最后一个节点，将其作为最终的头节点，即为 `new_head`。
- 在每次递归函数返回的过程中，改变 `head` 和 `head.next` 的指向关系。也就是将 `head.next` 的`next` 指针先指向当前节点 `head`，即 `head.next.next = head `。
- 然后让当前节点 `head` 的 `next` 指针指向 `None`，从而实现从链表尾部开始的局部反转。
- 当递归从末尾开始顺着递归栈的退出，从而将整个链表进行反转。
- 最后返回反转后的链表头节点 `new_head`。

使用递归法反转链表的示意图如下所示：

![](https://qcdn.itcharge.cn/images/20220111134246.png)

## 代码

1. 迭代

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur != None:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        return pre
```

2. 递归

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None or head.next == None:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

## 参考资料

- 【题解】[反转链表 - 反转链表 - 力扣](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/)
- 【题解】[【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/)# [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

- 标签：栈、链表、数学
- 难度：中等

## 题目链接

- [剑指 Offer II 025. 链表中的两数相加 - 力扣](https://leetcode.cn/problems/lMSNwu/)

## 题目大意

给定两个非空链表的头节点 `l1` 和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。每个节点只储存一位数字。除了数字 `0` 之外，这两个链表代表的数字都不会以 `0` 开头。

要求：将这两个数相加会返回一个新的链表。

## 解题思路

链表中最高位位于链表开始位置，最低位位于链表结束位置。这与我们做加法的数位顺序是相反的。为了将链表逆序，从而从低位开始处理数位，我们可以借用两个栈：将链表中所有数字分别压入两个栈中，再依次取出相加。

同时，在相加的时候，还要考虑进位问题。具体步骤如下：

- 将链表 `l1` 中所有节点值压入 `stack1` 栈中，再将链表 `l2` 中所有节点值压入 `stack2` 栈中。
- 使用 `res` 存储新的结果链表，一开始指向 `None`，`carry` 记录进位。
- 如果 `stack1` 或 `stack2` 不为空，或着进位 `carry` 不为 `0`，则：
  - 从 `stack1` 中取出栈顶元素 `num1`，如果 `stack1` 为空，则 `num1 = 0`。
  - 从 `stack2` 中取出栈顶元素 `num2`，如果 `stack2` 为空，则 `num2 = 0`。
  - 计算相加结果，并计算进位。
  - 建立新节点，存储进位后余下的值，并令其指向 `res`。
  - `res` 指向新节点，继续判断。
- 如果 `stack1`、`stack2` 都为空，并且进位 `carry` 为 `0`，则输出 `res`。

## 代码

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        stack1, stack2 = [], []
        while l1:
            stack1.append(l1.val)
            l1 = l1.next
        while l2:
            stack2.append(l2.val)
            l2 = l2.next

        res = None
        carry = 0
        while stack1 or stack2 or carry != 0:
            num1 = stack1.pop() if stack1 else 0
            num2 = stack2.pop() if stack2 else 0
            cur_sum = num1 + num2 + carry
            carry = cur_sum // 10
            cur_sum %= 10
            cur_node = ListNode(cur_sum)
            cur_node.next = res
            res = cur_node
        return res
```

# [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)

- 标签：栈、递归、链表、双指针
- 难度：中等

## 题目链接

- [剑指 Offer II 026. 重排链表 - 力扣](https://leetcode.cn/problems/LGjMqU/)

## 题目大意

给定一个单链表 `L` 的头节点 `head`，单链表 `L` 表示为：$L_0$ -> $L_1$ -> $L_2$ -> ... -> $L_{n-1}$ -> $L_n$。

要求：将单链表 `L` 重新排列为：$L_0$ -> $L_n$ -> $L_1$ -> $L_{n-1}$ -> $L_2$ -> $L_{n-2}$ -> $L_3$ -> $L_{n-3}$ -> ...。

注意：需要将实际节点进行交换。

## 解题思路

链表不能像数组那样直接进行随机访问。所以我们可以先将链表转为线性表。然后直接按照提要要求的排列顺序访问对应数据元素，重新建立链表。

## 代码

```python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return

        vec = []
        node = head
        while node:
            vec.append(node)
            node = node.next

        left, right = 0, len(vec) - 1
        while left < right:
            vec[left].next = vec[right]
            left += 1
            if left == right:
                break
            vec[right].next = vec[left]
            right -= 1
        vec[left].next = None
```

# [剑指 Offer II 027. 回文链表](https://leetcode.cn/problems/aMhZSa/)

- 标签：栈、递归、链表、双指针
- 难度：简单

## 题目链接

- [剑指 Offer II 027. 回文链表 - 力扣](https://leetcode.cn/problems/aMhZSa/)

## 题目大意

给定一个链表的头节点 `head`。

要求：判断该链表是否为回文链表。

## 解题思路

利用数组，将链表元素依次存入。然后再使用两个指针，一个指向数组开始位置，一个指向数组结束位置，依次判断首尾对应元素是否相等，若都相等，则为回文链表。若不相等，则不是回文链表。

## 代码

```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        nodes = []
        p1 = head
        while p1 != None:
            nodes.append(p1.val)
            p1 = p1.next
        return nodes == nodes[::-1]
```

# [剑指 Offer II 028. 展平多级双向链表](https://leetcode.cn/problems/Qv1Da2/)

- 标签：深度优先搜索、链表、双向链表
- 难度：中等

## 题目链接

- [剑指 Offer II 028. 展平多级双向链表 - 力扣](https://leetcode.cn/problems/Qv1Da2/)

## 题目大意

给定一个带子链表指针 `child` 的双向链表。

要求：将 `child` 的子链表进行扁平化处理，使所有节点出现在单级双向链表中。

扁平化处理如下：

```
原链表：
1---2---3---4---5---6--NULL
        |
        7---8---9---10--NULL
            |
            11--12--NULL
扁平化之后：
1---2---3---7---8---11---12---9---10---4---5---6--NULL
```

## 解题思路

递归处理多层链表的扁平化。遍历链表，找到 `child` 非空的节点， 将其子链表链接到当前节点的 `next` 位置（自身扁平化处理）。然后继续向后遍历，不断找到 `child` 节点，并进行链接。直到处理到尾部位置。

## 代码

```python
class Solution:
    def dfs(self, node: 'Node'):
        # 找到链表的尾节点或 child 链表不为空的节点
        while node.next and not node.child:
            node = node.next
        tail = None
        if node.child:
            # 如果 child 链表不为空，将 child 链表扁平化
            tail = self.dfs(node.child)

            # 将扁平化的 child 链表链接在该节点之后
            temp = node.next
            node.next = node.child
            node.next.prev = node
            node.child = None
            tail.next = temp
            if temp:
                temp.prev = tail
            # 链接之后，从 child 链表的尾节点继续向后处理链表
            return self.dfs(tail)
        # child 链表为空，则该节点是尾节点，直接返回
        return node

    def flatten(self, head: 'Node') -> 'Node':
        if not head:
            return head
        self.dfs(head)
        return head
```

# [剑指 Offer II 029. 排序的循环链表](https://leetcode.cn/problems/4ueAj6/)

- 标签：链表
- 难度：中等

## 题目链接

- [剑指 Offer II 029. 排序的循环链表 - 力扣](https://leetcode.cn/problems/4ueAj6/)

## 题目大意

给定循环升序链表中的一个节点 `head` 和一个整数 `insertVal`。

要求：将整数 `insertVal` 插入循环升序链表中，并且满足链表仍为循环升序链表。最终返回原先给定的节点。

## 解题思路

- 先判断所给节点 `head` 是否为空，为空直接创建一个值为 `insertVal` 的新节点，并指向自己，返回即可。

- 如果 `head` 不为空，把 `head` 赋值给 `node` ，方便最后返回原节点 `head`。
- 然后遍历 `node`，判断插入值 `insertVal` 与 `node.val` 和 `node.next.val` 的关系，找到插入位置，具体判断如下：
  - 如果新节点值在两个节点值中间， 即 `node.val <= insertVal <= node.next.val`。则说明新节点值在最大值最小值中间，应将新节点插入到当前位置，则应将 `insertVal` 插入到这个位置。
  - 如果新节点值比当前节点值和当前节点下一节点值都大，并且当前节点值比当前节点值的下一节点值大，即 `node.next.val < node.val <= insertVal`，则说明 `insertVal` 比链表最大值都大，应插入最大值后边。
  - 如果新节点值比当前节点值和当前节点下一节点值都小，并且当前节点值比当前节点值的下一节点值大，即 `insertVal < node.next.val < node.val`，则说明 `insertVal` 比链表中最小值都小，应插入最小值前边。
- 找到插入位置后，跳出循环，在插入位置插入值为 `insertVal` 的新节点。

## 代码

```python
class Solution:
    def insert(self, head: 'Node', insertVal: int) -> 'Node':
        if not head:
            node = Node(insertVal)
            node.next = node
            return node

        node = head
        while node.next != head:
            if node.val <= insertVal <= node.next.val:
                break
            elif node.next.val < node.val <= insertVal:
                break
            elif insertVal < node.next.val < node.val:
                break
            else:
                node = node.next

        insert_node = Node(insertVal)
        insert_node.next = node.next
        node.next = insert_node
        return head
```

# [剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器](https://leetcode.cn/problems/FortPu/)

- 标签：设计、数组、哈希表、数学、随机化
- 难度：中等

## 题目链接

- [剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 - 力扣](https://leetcode.cn/problems/FortPu/)

## 题目大意

设计一个数据结构 ，支持时间复杂度为 $O(1)$ 的以下操作：

- `insert(val)`：当元素 val 不存在时，向集合中插入该项。
- `remove(val)`：元素 val 存在时，从集合中移除该项。
- `getRandom`：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。

## 解题思路

普通动态数组进行访问操作，需要线性时间查找解决。我们可以利用哈希表记录下每个元素的下标，这样在访问时可以做到常数时间内访问元素了。对应的插入、删除、后去随机元素需要做相应的变化。

- 插入操作：将元素直接插入到数组尾部，并用哈希表记录插入元素的下标位置。
- 删除操作：使用哈希表找到待删除元素所在位置，将其与数组末尾位置元素相互交换，更新哈希表中交换后元素的下标值，并将末尾元素删除。
- 获取随机元素：使用` random.choice` 获取。

## 代码

```python
import random

class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dict = dict()
        self.list = list()


    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val in self.dict:
            return False
        self.dict[val] = len(self.list)
        self.list.append(val)
        return True


    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.dict:
            idx = self.dict[val]
            last = self.list[-1]
            self.list[idx] = last
            self.dict[last] = idx
            self.list.pop()
            self.dict.pop(val)
            return True
        return False


    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return random.choice(self.list)
```

# [剑指 Offer II 031. 最近最少使用缓存](https://leetcode.cn/problems/OrIXps/)

- 标签：设计、哈希表、链表、双向链表
- 难度：中等

## 题目链接

- [剑指 Offer II 031. 最近最少使用缓存 - 力扣](https://leetcode.cn/problems/OrIXps/)

## 题目大意

要求：实现一个 `LRU（最近最少使用）缓存机制`，并且在 `O(1)` 时间复杂度内完成 `get`、`put` 操作。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存。
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1`。
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

## 解题思路

LRU（最近最少使用缓存）是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。LRU 更新和插入新页面都发生在链表首，删除页面都发生在链表尾。

## 代码

```python
class Node:
    def __init__(self, key=None, val=None, prev=None, next=None):
        self.key = key
        self.val = val
        self.prev = prev
        self.next = next

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hashmap = dict()
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head


    def get(self, key: int) -> int:
        if key not in self.hashmap:
            return -1
        node = self.hashmap[key]
        self.move_node(node)
        return node.val


    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            node = self.hashmap[key]
            node.val = value
            self.move_node(node)
            return
        if len(self.hashmap) == self.capacity:
            self.hashmap.pop(self.head.next.key)
            self.remove_node(self.head.next)

        node = Node(key=key, val=value)
        self.hashmap[key] = node
        self.add_node(node)

    def remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev


    def add_node(self, node):
        self.tail.prev.next = node
        node.prev = self.tail.prev
        node.next = self.tail
        self.tail.prev = node


    def move_node(self, node):
        self.remove_node(node)
        self.add_node(node)
```

# [剑指 Offer II 032. 有效的变位词](https://leetcode.cn/problems/dKk3P7/)

- 标签：哈希表、字符串、排序
- 难度：简单

## 题目链接

- [剑指 Offer II 032. 有效的变位词 - 力扣](https://leetcode.cn/problems/dKk3P7/)

## 题目大意

给定两个字符串 `s` 和 `t`。

要求：判断 `t` 和 `s` 是否使用了相同的字符构成（字符出现的种类和数目都相同，字符顺序不完全相同）。

## 解题思路

1. 先判断字符串 `s` 和 `t` 的长度，不一样直接返回 `False`；
2. 如果 `s` 和 `t` 相等，则直接返回 `False`，因为变位词的字符顺序不完全相同；
3. 分别遍历字符串 `s` 和 `t`。先遍历字符串 `s`，用哈希表存储字符串 `s` 中字符出现的频次；
4. 再遍历字符串 `t`，哈希表中减去对应字符的频次，出现频次小于 `0` 则输出 `False`；
5. 如果没出现频次小于 `0`，则输出 `True`。

## 代码

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t) or s == t:
            return False
        strDict = dict()
        for ch in s:
            if ch in strDict:
                strDict[ch] += 1
            else:
                strDict[ch] = 1
        for ch in t:
            if ch in strDict:
                strDict[ch] -= 1
                if strDict[ch] < 0:
                    return False
            else:
                return False
        return True
```

# [剑指 Offer II 033. 变位词组](https://leetcode.cn/problems/sfvd7V/)

- 标签：数组、哈希表、字符串、排序
- 难度：中等

## 题目链接

- [剑指 Offer II 033. 变位词组 - 力扣](https://leetcode.cn/problems/sfvd7V/)

## 题目大意

给定一个字符串数组 `strs`。

要求：将包含字母相同的字符串组合在一起，不需要考虑输出顺序。

## 解题思路

使用哈希表记录字母相同的字符串。对每一个字符串进行排序，按照 排序字符串：字母相同的字符串数组 的键值顺序进行存储。最终将哈希表的值转换为对应数组返回结果。

## 代码

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        str_dict = dict()
        res = []
        for s in strs:
            sort_s = str(sorted(s))
            if sort_s in str_dict:
                str_dict[sort_s] += [s]
            else:
                str_dict[sort_s] = [s]

        for sort_s in str_dict:
            res += [str_dict[sort_s]]
        return res
```

# [剑指 Offer II 034. 外星语言是否排序](https://leetcode.cn/problems/lwyVBB/)

- 标签：数组、哈希表、字符串
- 难度：简单

## 题目链接

- [剑指 Offer II 034. 外星语言是否排序 - 力扣](https://leetcode.cn/problems/lwyVBB/)

## 题目大意

给定一组用外星语书写的单词字符串数组 `words`，以及表示外星字母表的顺序的字符串 `order` 。

要求：判断 `words` 中的单词是否都是按照 `order` 来排序的。如果是，则返回 `True`，否则返回 `False`。

## 解题思路

如果所有单词是按照 `order` 的规则升序排列，则所有单词都符合规则。而判断所有单词是升序排列，只需要两两比较相邻的单词即可。所以我们可以先用哈希表存储所有字母的顺序，然后对所有相邻单词进行两两比较，如果最终是升序排列，则符合要求。具体步骤如下：

- 使用哈希表 `order_map` 存储字母的顺序。
- 遍历单词数组 `words`，比较相邻单词 `word1` 和 `word2` 中所有字母在 `order_map` 中的下标，看是否满足 `word1 <= word2`。
- 如果全部满足，则返回 `True`。如果有不满足的情况，则直接返回 `False`。 

## 代码

```python
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        order_map = dict()
        for i in range(len(order)):
            order_map[order[i]] = i
        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i + 1]

            flag = True

            for j in range(min(len(word1), len(word2))):
                if word1[j] != word2[j]:
                    if order_map[word1[j]] > order_map[word2[j]]:
                        return False
                    else:
                        flag = False
                        break

            if flag and len(word1) > len(word2):
                return False
        return True
```

# [剑指 Offer II 035. 最小时间差](https://leetcode.cn/problems/569nqc/)

- 标签：数组、数学、字符串、排序
- 难度：中等

## 题目链接

- [剑指 Offer II 035. 最小时间差 - 力扣](https://leetcode.cn/problems/569nqc/)

## 题目大意

给定一个 24 小时制形式（小时:分钟 "HH:MM"）的时间列表 `timePoints`。

要求：找出列表中任意两个时间的最小时间差并以分钟数表示。

## 解题思路

- 遍历时间列表 `timePoints`，将每个时间转换为以分钟计算的整数形式，比如时间 `14:20`，将其转换为 `14 * 60 + 20 = 860`，存放到新的时间列表 `times` 中。
- 为了处理最早时间、最晚时间之间的时间间隔，我们将 `times` 中最小时间添加到列表末尾一起进行排序。
- 然后将新的时间列表 `times` 按照升序排列。
- 遍历排好序的事件列表 `times` ，找出相邻两个时间的最小间隔值即可。

## 代码

```python
class Solution:
    def changeTime(self, timePoint: str):
        hours, minutes = timePoint.split(':')
        return int(hours) * 60 + int(minutes)

    def findMinDifference(self, timePoints: List[str]) -> int:
        if not timePoints or len(timePoints) > 24 * 60:
            return 0

        times = sorted(self.changeTime(time) for time in timePoints)
        times.append(times[0] + 24 * 60)
        res = times[-1]
        for i in range(1, len(times)):
            res = min(res, times[i] - times[i - 1])
        return res
```

# [剑指 Offer II 036. 后缀表达式](https://leetcode.cn/problems/8Zf90G/)

- 标签：栈、数组、数学
- 难度：中等

## 题目链接

- [剑指 Offer II 036. 后缀表达式 - 力扣](https://leetcode.cn/problems/8Zf90G/)

## 题目大意

给定一个字符串数组 `tokens`，表示「逆波兰表达式」，求解表达式的值。

## 解题思路

栈的典型应用。遍历字符串数组。遇到操作字符的时候，取出栈顶两个元素，进行运算之后，再将结果入栈。遇到数字，则直接入栈。

## 代码

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token == '+':
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                stack.append(-stack.pop() + stack.pop())
            elif token == '*':
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                stack.append(int(1 / stack.pop() * stack.pop()))
            else:
                stack.append(int(token))
        return stack.pop()
```

# [剑指 Offer II 037. 小行星碰撞](https://leetcode.cn/problems/XagZNi/)

- 标签：栈、数组
- 难度：中等

## 题目链接

- [剑指 Offer II 037. 小行星碰撞 - 力扣](https://leetcode.cn/problems/XagZNi/)

## 题目大意

给定一个整数数组 `asteroids`，表示在同一行的小行星。

数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。小行星按照下面的规则发生碰撞。

-  碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

要求：找出碰撞后剩下的所有小行星，将答案存入数组并返回。

## 解题思路

用栈模拟小行星碰撞，具体步骤如下：

- 遍历数组 `asteroids`。
- 如果栈为空或者当前元素 `asteroid` 为正数，将其压入栈。
- 如果当前栈不为空并且当前元素 `asteroid` 为负数：
  - 与栈中元素发生碰撞，判断当前元素和栈顶元素的大小和方向，如果栈顶元素为正数，并且当前元素的绝对值大于栈顶元素，则将栈顶元素弹出，并继续与栈中元素发生碰撞。
  - 碰撞完之后，如果栈为空并且栈顶元素为负数，则将当前元素 `asteroid` 压入栈，表示碰撞完剩下了 `asteroid`。
  - 如果栈顶元素恰好与当前元素值大小相等、方向相反，则弹出栈顶元素，表示碰撞完两者都爆炸了。
- 最后返回栈作为答案。

## 代码

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for asteroid in asteroids:
            if not stack or asteroid > 0:
                stack.append(asteroid)
            else:
                while stack and 0 < stack[-1] < -asteroid:
                    stack.pop()
                if not stack or stack[-1] < 0:
                    stack.append(asteroid)
                elif stack[-1] == -asteroid:
                    stack.pop()

        return stack
```

# [剑指 Offer II 038. 每日温度](https://leetcode.cn/problems/iIQa4I/)

- 标签：栈、数组、单调栈
- 难度：中等

## 题目链接

- [剑指 Offer II 038. 每日温度 - 力扣](https://leetcode.cn/problems/iIQa4I/)

## 题目大意

给定一个列表 `temperatures`，每一个位置对应每天的气温。要求输出一个列表，列表上每个位置代表如果要观测到更高的气温，至少需要等待的天数。如果之后的气温不再升高，则用 `0` 来代替。

## 解题思路

题目的意思实际上就是给定一个数组，每个位置上有整数值。对于每个位置，在该位置后侧找到第一个比当前值更高的值。求该点与该位置的距离，将所有距离保存为数组返回结果。

很简单的思路是对于每个温度值，向后依次进行搜索，找到比当前温度更高的值。

更好的方式使用「递减栈」。栈中保存元素的下标。

首先，将答案数组全部赋值为 0。然后遍历数组每个位置元素。

- 如果栈为空，则将当前元素的下标入栈。
- 如果栈不为空，且当前数字大于栈顶元素对应数字，则栈顶元素出栈，并计算下标差。
    - 此时当前元素就是栈顶元素的下一个更高值，将其下标差存入答案数组中保存起来，判断栈顶元素。
- 直到当前数字小于或等于栈顶元素，则停止出栈，将当前元素下标入栈。

## 代码

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        stack = []
        ans = [0 for _ in range(n)]
        for i in range(n):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                index = stack.pop()
                ans[index] = (i - index)
            stack.append(i)
        return ans
```

# [剑指 Offer II 039. 直方图最大矩形面积](https://leetcode.cn/problems/0ynMMM/)

- 标签：栈、数组、单调栈
- 难度：困难

## 题目链接

- [剑指 Offer II 039. 直方图最大矩形面积 - 力扣](https://leetcode.cn/problems/0ynMMM/)

## 题目大意

给定一个非负整数数组 `heights` ，`heights[i]` 用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

要求：计算出在该柱状图中，能够勾勒出来的矩形的最大面积。

## 解题思路

思路一：枚举「宽度」。一重循环枚举所有柱子，第二重循环遍历柱子右侧的柱子，所得的宽度就是两根柱子形成区间的宽度，高度就是这段区间中的最小高度。然后计算出对应面积，记录并更新最大面积。这样下来，时间复杂度为 $O(n^2)$。

思路二：枚举「高度」。一重循环枚举所有柱子，以柱子高度为当前矩形高度，然后向两侧延伸，遇到小于当前矩形高度的情况就停止。然后计算当前矩形面积，记录并更新最大面积。这样下来，时间复杂度也是 $O(n^2)$。

思路三：利用「单调栈」减少两侧延伸的复杂度。

- 枚举所有柱子。
- 如果当前柱子高度较大，大于等于栈顶柱体的高度，则直接将当前柱体入栈。
- 如果当前柱体高度较小，小于栈顶柱体的高度，则一直出栈，直到当前柱体大于等于栈顶柱体高度。
  - 出栈后，说明当前柱体是出栈柱体向右找到的第一个小于当前柱体高度的柱体，那么就可以向右将宽度扩展到当前柱体。
  - 出栈后，说明新的栈顶柱体是出栈柱体向左找到的第一个小于新的栈顶柱体高度的柱体，那么就可以向左将宽度扩展到新的栈顶柱体。
  - 以新的栈顶柱体为左边界，当前柱体为右边界，以出栈柱体为高度。计算矩形面积，然后记录并更新最大面积。

## 代码

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(0)
        ans = 0
        stack = []
        for i in range(len(heights)):
            while stack and heights[stack[-1]] >= heights[i]:
                cur = stack.pop(-1)
                left = stack[-1] + 1 if stack else 0
                right = i - 1
                ans = max(ans, (right - left + 1) * heights[cur])
            stack.append(i)

        return ans
```

# [剑指 Offer II 041. 滑动窗口的平均值](https://leetcode.cn/problems/qIsx9U/)

- 标签：设计、队列、数组、数据流
- 难度：简单

## 题目链接

- [剑指 Offer II 041. 滑动窗口的平均值 - 力扣](https://leetcode.cn/problems/qIsx9U/)

## 题目大意

**描述**：给定一个整数数据流和一个窗口大小 `size`。

**要求**：根据滑动窗口的大小，计算滑动窗口里所有数字的平均值。要求实现 `MovingAverage` 类：

- `MovingAverage(int size)`：用窗口大小 `size` 初始化对象。
- `double next(int val)`：成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。

**说明**：

- $1 \le size \le 1000$。
- $-10^5 \le val \le 10^5$。
- 最多调用 `next` 方法 $10^4$ 次。

**示例**：

- 示例 1：

```python
输入：
inputs = ["MovingAverage", "next", "next", "next", "next"]
inputs = [[3], [1], [10], [3], [5]]
输出：
[null, 1.0, 5.5, 4.66667, 6.0]

解释：
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // 返回 1.0 = 1 / 1
movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2
movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3
```

## 解题思路

### 思路 1：队列

1. 使用队列保存滑动窗口的元素，并记录对应窗口大小和元素和。
2. 当队列长度小于窗口大小的时候，直接向队列中添加元素，并记录当前窗口中的元素和。
3. 当队列长度等于窗口大小的时候，先将队列头部元素弹出，再添加元素，并记录当前窗口中的元素和。
4. 然后根据元素和和队列中元素个数计算出平均值。

### 思路 1：代码

```python
class MovingAverage:

    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.queue = []
        self.size = size
        self.sum = 0


    def next(self, val: int) -> float:
        if len(self.queue) < self.size:
            self.queue.append(val)
        else:
            if self.queue:
                self.sum -= self.queue[0]
                self.queue.pop(0)
            self.queue.append(val)
        self.sum += val
        return self.sum / len(self.queue)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(1)$。初始化方法和每次调用 `next` 方法的时间复杂度都是 $O(1)$。
- **空间复杂度**：$O(size)$。其中 $size$ 就是给定的滑动窗口的大小。# [剑指 Offer II 042. 最近请求次数](https://leetcode.cn/problems/H8086Q/)

- 标签：设计、队列、数据流
- 难度：简单

## 题目链接

- [剑指 Offer II 042. 最近请求次数 - 力扣](https://leetcode.cn/problems/H8086Q/)

## 题目大意

要求：实现一个用来计算特定时间范围内的最近请求的 `RecentCounter` 类：

- `RecentCounter()` 初始化计数器，请求数为 0 。
- `int ping(int t)` 在时间 `t` 时添加一个新请求，其中 `t` 表示以毫秒为单位的某个时间，并返回在 `[t-3000, t]` 内发生的请求数。

## 解题思路

使用一个队列，用于存储 `[t - 3000, t]` 范围内的请求。

获取请求数时，将队首所有小于 `t - 3000` 时间的请求将其从队列中移除，然后返回队列的长度即可。

## 代码

```python
class RecentCounter:

    def __init__(self):
        self.queue = []


    def ping(self, t: int) -> int:
        self.queue.append(t)
        while self.queue[0] < t - 3000:
            self.queue.pop(0)
        return len(self.queue)
```

# [剑指 Offer II 043. 往完全二叉树添加节点](https://leetcode.cn/problems/NaqhDT/)

- 标签：树、广度优先搜索、设计、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 043. 往完全二叉树添加节点 - 力扣](https://leetcode.cn/problems/NaqhDT/)

## 题目大意

要求：设计一个用完全二叉树初始化的数据结构 `CBTInserter`，并支持以下几种操作：

- `CBTInserter(TreeNode root)` 使用根节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)`  向树中插入一个新节点，节点类型为 `TreeNode`，值为 `v`。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；
- `CBTInserter.get_root()` 返回树的根节点。

## 解题思路

使用数组标记完全二叉树中节点的序号，初始化数组为 `[None]`。完全二叉树中节点的序号从 `1` 开始，对于序号为 `k` 的节点，其左子节点序号为 `2k`，右子节点的序号为 `2k + 1`，其父节点的序号为 `k // 2`。

然后在初始化和插入节点的同时，按顺序向数组中插入节点。

## 代码

```python
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.queue = [root]
        self.nodelist = [None]

        while self.queue:
            node = self.queue.pop(0)
            self.nodelist.append(node)
            if node.left:
                self.queue.append(node.left)
            if node.right:
                self.queue.append(node.right)


    def insert(self, v: int) -> int:
        self.nodelist.append(TreeNode(v))
        index = len(self.nodelist) - 1
        father = self.nodelist[index // 2]
        if index % 2 == 0:
            father.left = self.nodelist[-1]
        else:
            father.right = self.nodelist[-1]
        return father.val


    def get_root(self) -> TreeNode:
        return self.nodelist[1]
```

# [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode.cn/problems/hPov7L/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 044. 二叉树每层的最大值 - 力扣](https://leetcode.cn/problems/hPov7L/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：找出二叉树中每一层的最大值。

## 解题思路

利用队列进行层序遍历，并记录下每一层的最大值，将其存入答案数组中。

## 代码

```python
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        queue = []
        res = []
        if root:
            queue.append(root)
        while queue:
            max_level = float('-inf')
            size_level = len(queue)
            for i in range(size_level):
                node = queue.pop(0)
                max_level = max(max_level, node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(max_level)
        return res
```

# [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode.cn/problems/LwUNpT/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 045. 二叉树最底层最左边的值 - 力扣](https://leetcode.cn/problems/LwUNpT/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：找出该二叉树 「最底层」的「最左边」节点的值。

## 解题思路

这个问题拆开来看，一是如何找到「最底层」，而是在「最底层」如何找到最左边的节点。

通过层序遍历，我们可以直接确定最底层节点。而「最底层」的「最左边」节点可以改变层序遍历的左右节点访问顺序。

每层元素先访问右节点，在访问左节点，则最后一个遍历的元素就是「最底层」的「最左边」节点，即左下角的节点，返回该点对应的值即可。

## 代码

```python
import collections

class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return -1
        queue = collections.deque()
        queue.append(root)
        while queue:
            cur = queue.popleft()
            if cur.right:
                queue.append(cur.right)
            if cur.left:
                queue.append(cur.left)
        return cur.val
```

# [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode.cn/problems/WNC0Lk/)

- 标签：树、深度优先搜索、广度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 046. 二叉树的右侧视图 - 力扣](https://leetcode.cn/problems/WNC0Lk/)

## 题目大意

给定一棵二叉树的根节点 `root`。

要求：按照从顶部到底部的顺序，返回从右侧能看到的节点值。

## 解题思路

二叉树的层次遍历，不过遍历每层节点的时候，只需要将最后一个节点加入结果数组即可。

## 代码

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        queue = [root]
        order = []
        while queue:
            level = []
            size = len(queue)
            for i in range(size):
                curr = queue.pop(0)
                level.append(curr.val)
                if curr.left:
                    queue.append(curr.left)
                if curr.right:
                    queue.append(curr.right)
            if i == size - 1:
                order.append(curr.val)
        return order
```

# [剑指 Offer II 047. 二叉树剪枝](https://leetcode.cn/problems/pOCWxh/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 047. 二叉树剪枝 - 力扣](https://leetcode.cn/problems/pOCWxh/)

## 题目大意

给定一棵二叉树的根节点 `root`，树的每个节点值要么是 `0`，要么是 `1`。

要求：剪除该二叉树中所有节点值为 `0` 的子树。

- 节点 `node` 的子树为： `node` 本身，以及所有 `node` 的后代。

## 解题思路

定义辅助方法 `containsOnlyZero(root)` 递归判断以 `root` 为根的子树中是否只包含 `0`。如果子树中只包含 `0`，则返回 `True`。如果子树中含有 `1`，则返回 `False`。当 `root` 为空时，也返回 `True`。

然后递归遍历二叉树，判断当前节点 `root` 是否只包含 `0`。如果只包含 `0`，则将其置空，返回 `None`。否则递归遍历左右子树，并设置对应的左右指针。

最后返回根节点 `root`。

## 代码

```python
class Solution:
    def containsOnlyZero(self, root: TreeNode):
        if not root:
            return True
        if root.val == 1:
            return False
        return self.containsOnlyZero(root.left) and self.containsOnlyZero(root.right)

    def pruneTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        if self.containsOnlyZero(root):
            return None

        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        return root
```

# [剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode.cn/problems/h54YBf/)

- 标签：树、深度优先搜索、广度优先搜索、设计、字符串、二叉树
- 难度：困难

## 题目链接

- [剑指 Offer II 048. 序列化与反序列化二叉树 - 力扣](https://leetcode.cn/problems/h54YBf/)

## 题目大意

要求：设计一个算法，来实现二叉树的序列化与反序列化。

## 解题思路

### 1. 序列化：将二叉树转为字符串数据表示

按照前序递归遍历二叉树，并将根节点跟左右子树的值链接起来（中间用 `,` 隔开）。

注意：如果遇到空节点，则标记为 'None'，这样在反序列化时才能唯一确定一棵二叉树。

### 2. 反序列化：将字符串数据转为二叉树结构

先将字符串按 `,` 分割成数组。然后递归处理每一个元素。

- 从数组左侧取出一个元素。
    - 如果当前元素为 'None'，则返回 None。
    - 如果当前元素不为空，则新建一个二叉树节点作为根节点，保存值为当前元素值。并递归遍历左右子树，不断重复从数组中取出元素，进行判断。
    - 最后返回当前根节点。

## 代码

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return 'None'
        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))

        

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """

        def dfs(datalist):
            val = datalist.pop(0)
            if val == 'None':
                return None
            root = TreeNode(int(val))
            root.left = dfs(datalist)
            root.right = dfs(datalist)
            return root

        datalist = data.split(',')
        return dfs(datalist)
```

# [剑指 Offer II 049. 从根节点到叶节点的路径数字之和](https://leetcode.cn/problems/3Etpl5/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 049. 从根节点到叶节点的路径数字之和 - 力扣](https://leetcode.cn/problems/3Etpl5/)

## 题目大意

给定一个二叉树的根节点 `root`，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。每条从根节点到叶节点的路径都代表一个数字。例如，从根节点到叶节点的路径是 `1` -> `2` -> `3`，表示数字 `123`。

要求：计算从根节点到叶节点生成的所有数字的和。

## 解题思路

使用深度优先搜索，记录下路径上所有节点构成的数字，使用 `pretotal` 保存下当前路径上构成的数字。如果遇到叶节点直接返回当前数字，否则递归遍历左右子树，并累加对应结果。

## 代码

```python
class Solution:
    def dfs(self, root, pretotal):
        if not root:
            return 0
        total = pretotal * 10 + root.val
        if not root.left and not root.right:
            return total
        return self.dfs(root.left, total) + self.dfs(root.right, total)

    def sumNumbers(self, root: TreeNode) -> int:
        return self.dfs(root, 0)
```

# [剑指 Offer II 050. 向下的路径节点之和](https://leetcode.cn/problems/6eUYwP/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 050. 向下的路径节点之和 - 力扣](https://leetcode.cn/problems/6eUYwP/)

## 题目大意



## 解题思路



## 代码

```python
class Solution:
    prefixsum_count = dict()
    def dfs(self, root, prefixsum_count, target_sum, cur_sum):
        if not root:
            return 0
        res = 0
        cur_sum += root.val
        res += prefixsum_count.get(cur_sum - target_sum, 0)
        prefixsum_count[cur_sum] = prefixsum_count.get(cur_sum, 0) + 1

        res += self.dfs(root.left, prefixsum_count, target_sum, cur_sum)
        res += self.dfs(root.right, prefixsum_count, target_sum, cur_sum)

        prefixsum_count[cur_sum] -= 1
        return res

    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        if not root:
            return 0
        prefixsum_count = dict()
        prefixsum_count[0] = 1
        return self.dfs(root, prefixsum_count, targetSum, 0)
```

# [剑指 Offer II 051. 节点之和最大的路径](https://leetcode.cn/problems/jC7MId/)

- 标签：树、深度优先搜索、动态规划、二叉树
- 难度：困难

## 题目链接

- [剑指 Offer II 051. 节点之和最大的路径 - 力扣](https://leetcode.cn/problems/jC7MId/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：返回其最大路径和。

- 路径：从树中的任意节点出发，沿父节点——子节点连接，到达任意节点的序列。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。
- 路径和：路径中各节点值的总和。

## 解题思路

深度优先搜索遍历二叉树。递归的同时，维护一个最大路径和变量。定义函数 `dfs(self, root)` 计算二叉树中以该节点为根节点，并且经过该节点的最大贡献值。

计算的结果可能的情况有 2 种：

- 经过空节点的最大贡献值等于 `0`。

- 经过非空节点的最大贡献值等于 当前节点值 + 左右子节点的最大贡献值中较大的一个。

在递归时，我们先计算左右子节点的最大贡献值，再更新维护当前最大路径和变量。

最终 `max_sum` 即为答案。

## 代码

```python
class Solution:
    def __init__(self):
        self.max_sum = float('-inf')

    def dfs(self, root):
        if not root:
            return 0
        left_max = max(self.dfs(root.left), 0)
        right_max = max(self.dfs(root.right), 0)
        self.max_sum = max(self.max_sum, root.val + left_max + right_max)
        return root.val + max(left_max, right_max)

    def maxPathSum(self, root: TreeNode) -> int:
        self.dfs(root)
        return self.max_sum
```

# [剑指 Offer II 052. 展平二叉搜索树](https://leetcode.cn/problems/NYBBNL/)

- 标签：栈、树、深度优先搜索、二叉搜索树、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer II 052. 展平二叉搜索树 - 力扣](https://leetcode.cn/problems/NYBBNL/)

## 题目大意

给定一棵二叉搜索树的根节点 `root`。

要求：按中序遍历顺序将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

## 解题思路

可以分为两步：

1. 中序遍历二叉搜索树，将节点先存储到列表中。
2. 将列表中的节点构造成一棵递增顺序搜索树。

中序遍历直接按照 `左 -> 根 -> 右` 的顺序递归遍历，然后将遍历的节点存储到 `res` 中。

构造递增顺序搜索树，则用 `head` 保存头节点位置。遍历列表中的每个节点，将其左右指针先置空，再将其连接在上一个节点的右子节点上。

最后返回 `head.right` 即可。

## 代码

```python
class Solution:
    def inOrder(self, root, res):
        if not root:
            return
        self.inOrder(root.left, res)
        res.append(root)
        self.inOrder(root.right, res)

    def increasingBST(self, root: TreeNode) -> TreeNode:
        res = []
        self.inOrder(root, res)

        if not res:
            return
        head = TreeNode(-1)
        cur = head
        for node in res:
            node.left = node.right = None
            cur.right = node
            cur = cur.right
        return head.right
```

# [剑指 Offer II 053. 二叉搜索树中的中序后继](https://leetcode.cn/problems/P5rCT8/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 053. 二叉搜索树中的中序后继 - 力扣](https://leetcode.cn/problems/P5rCT8/)

## 题目大意

给定一棵二叉搜索树的根节点 `root` 和其中一个节点 `p`。

要求：找到该节点在树中的中序后继，即按照中序遍历的顺序节点 `p` 的下一个节点。

## 解题思路

递归遍历，具体步骤如下：

- 如果 `root.val` 小于等于 `p.val`，则直接从 `root` 的右子树递归查找比 `p.val` 大的节点，从而找到中序后继。
- 如果 `root.val` 大于 `p.val`，则 `root` 有可能是中序后继，也有可能是 `root` 的左子树。则从 `root` 的左子树递归查找更接近（更小的）。如果查找的值为 `None`，则当前 `root` 就是中序后继，否则继续递归查找，从而找到中序后继。

## 代码 

```python
class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':
        if not p or not root:
            return None

        if root.val <= p.val:
            node = self.inorderSuccessor(root.right, p)
        else:
            node = self.inorderSuccessor(root.left, p)
            if not node:
                node = root
        return node
```

# [剑指 Offer II 054. 所有大于等于节点的值之和](https://leetcode.cn/problems/w6cpku/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [剑指 Offer II 054. 所有大于等于节点的值之和 - 力扣](https://leetcode.cn/problems/w6cpku/)

## 题目大意

给定一棵二叉搜索树（BST）的根节点 `root`，且二叉搜索树的节点值各不相同。要求将其转化为「累加树」，使其每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

二叉搜索树的定义：

- 若左子树不为空，则左子树上所有节点值均小于它的根节点值；
- 若右子树不为空，则右子树上所有节点值均大于它的根节点值；
- 任意节点的左、右子树也分别为二叉搜索树。

## 解题思路

题目要求将每个节点的值修改为原来的节点值加上大于它的节点值之和。已知二叉搜索树的中序遍历可以得到一个升序数组。

题目就可以变为：修改升序数组中每个节点值为末尾元素累加和。由于末尾元素累加和的求和过程和遍历顺序相反，所以我们可以考虑换种思路。

二叉搜索树的中序遍历顺序为：左 -> 根 -> 右，从而可以得到一个升序数组，那么我们将左右反着遍历，即顺序为：右 -> 根 -> 左，就可以得到一个降序数组，这样就可以在遍历的同时求前缀和。

当然我们在计算前缀和的时候，需要用到前一个节点的值，所以需要用变量 `pre` 存储前一节点的值。

## 代码

```python
class Solution:
    pre = 0

    def createBinaryTree(self, root: TreeNode):
        if not root:
            return
        self.createBinaryTree(root.right)
        root.val += self.pre
        self.pre = root.val
        self.createBinaryTree(root.left)

    def convertBST(self, root: TreeNode) -> TreeNode:
        self.pre = 0
        self.createBinaryTree(root)
        return root
```

# [剑指 Offer II 055. 二叉搜索树迭代器](https://leetcode.cn/problems/kTOapQ/)

- 标签：栈、树、设计、二叉搜索树、二叉树、迭代器
- 难度：中等

## 题目链接

- [剑指 Offer II 055. 二叉搜索树迭代器 - 力扣](https://leetcode.cn/problems/kTOapQ/)

## 题目大意

要求：实现一个二叉搜索树的迭代器 `BSTIterator`。表示一个按中序遍历二叉搜索树（BST）的迭代器：

- `def __init__(self, root: TreeNode):`：初始化 `BSTIterator` 类的一个对象，会给出二叉搜索树的根节点。
- `def hasNext(self) -> bool:`：如果向右指针遍历存在数字，则返回 `True`，否则返回 `False`。
- `def next(self) -> int:`：将指针向右移动，返回指针处的数字。

## 解题思路

中序遍历的顺序是：左、根、右。我们使用一个栈来保存节点，以便于迭代的时候取出对应节点。

- 初始的遍历当前节点的左子树，将其路径上的节点存储到栈中。
- 调用 next 方法的时候，从栈顶取出节点，因为之前已经将路径上的左子树全部存入了栈中，所以此时该节点的左子树为空，这时候取出节点右子树，再将右子树的左子树进行递归遍历，并将其路径上的节点存储到栈中。
- 调用 hasNext 的方法的时候，直接判断栈中是否有值即可。

## 代码

```python
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack = []
        self.in_order(root)


    def in_order(self, node):
        while node:
            self.stack.append(node)
            node = node.left


    def next(self) -> int:
        node = self.stack.pop()
        if node.right:
            self.in_order(node.right)
        return node.val


    def hasNext(self) -> bool:
        return len(self.stack) != 0
```

# [剑指 Offer II 056. 二叉搜索树中两个节点之和](https://leetcode.cn/problems/opLdQZ/)

- 标签：树、深度优先搜索、广度优先搜索、二叉搜索树、哈希表、双指针、二叉树
- 难度：简单

## 题目链接

- [剑指 Offer II 056. 二叉搜索树中两个节点之和 - 力扣](https://leetcode.cn/problems/opLdQZ/)

## 题目大意

给定一个二叉搜索树的根节点 `root` 和一个整数 `k`。

要求：判断该二叉搜索树是否存在两个节点值的和等于 `k`。如果存在，则返回 `True`，不存在则返回 `False`。

## 解题思路

二叉搜索树中序遍历的结果是从小到大排序，所以我们可以先对二叉搜索树进行中序遍历，将中序遍历结果存储到列表中。再使用左右指针查找节点值和为 `k` 的两个节点。

## 代码

```python
class Solution:
    def inOrder(self, root, nums):
        if not root:
            return
        self.inOrder(root.left, nums)
        nums.append(root.val)
        self.inOrder(root.right, nums)

    def findTarget(self, root: TreeNode, k: int) -> bool:
        nums = []
        self.inOrder(root, nums)
        left, right = 0, len(nums) - 1
        while left < right:
            sum = nums[left] + nums[right]
            if sum == k:
                return True
            elif sum < k:
                left += 1
            else:
                right -= 1
        return False
```

# [剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/)

- 标签：数组、桶排序、有序集合、排序、滑动窗口
- 难度：中等

## 题目链接

- [剑指 Offer II 057. 值和下标之差都在给定的范围内 - 力扣](https://leetcode.cn/problems/7WqeDu/)

## 题目大意

给定一个整数数组 `nums`，以及两个整数 `k`、`t`。判断数组中是否存在两个不同下标的 `i` 和 `j`，其对应元素满足 `abs(nums[i] - nums[j]) <= t`，同时满足 `abs(i - j) <= k`。如果满足条件则返回 `True`，不满足条件返回 `False`。

## 解题思路

对于第 `i` 个元素 `nums[i]`，需要查找的区间为 `[i - t, i + t]`。可以利用桶排序的思想。

桶的大小设置为 `t + 1`。我们将元素按照大小依次放入不同的桶中。

遍历数组 `nums` 中的元素，对于元素 `nums[i]` ：

- 如果 `nums[i]` 放入桶之前桶里已经有元素了，那么这两个元素必然满足 `abs(nums[i] - nums[j]) <= t`，
- 如果之前桶里没有元素，那么就将 `nums[i]` 放入对应桶中。
- 然后再判断左右桶的左右两侧桶中是否有元素满足 `abs(nums[i] - nums[j]) <= t`。
- 然后将 `nums[i - k]` 之前的桶清空，因为这些桶中的元素与 `nums[i]` 已经不满足 `abs(i - j) <= k` 了。

最后上述满足条件的情况就返回 `True`，最终遍历完仍不满足条件就返回 `False`。

## 代码

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        bucket_dict = dict()
        for i in range(len(nums)):
            # 将 nums[i] 划分到大小为 t + 1 的不同桶中
            num = nums[i] // (t + 1)

            # 桶中已经有元素了
            if num in bucket_dict:
                return True

            # 把 nums[i] 放入桶中
            bucket_dict[num] = nums[i]

            # 判断左侧桶是否满足条件
            if (num - 1) in bucket_dict and abs(bucket_dict[num - 1] - nums[i]) <= t:
                return True
            # 判断右侧桶是否满足条件
            if (num + 1) in bucket_dict and abs(bucket_dict[num + 1] - nums[i]) <= t:
                return True
            # 将 i-k 之前的旧桶清除，因为之前的桶已经不满足条件了
            if i >= k:
                bucket_dict.pop(nums[i - k] // (t + 1))

        return False
```

# [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/)

- 标签：树、设计、二叉搜索树、二叉树、数据流、堆（优先队列）
- 难度：简单

## 题目链接

- [剑指 Offer II 059. 数据流的第 K 大数值 - 力扣](https://leetcode.cn/problems/jBjn9C/)

## 题目大意

设计一个 ` KthLargest` 类，用于找到数据流中第 `k` 大元素。

- `KthLargest(int k, int[] nums)`：使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)`：将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

## 解题思路

- 建立大小为 `k` 的大顶堆，堆中元素保证不超过 k 个。
- 每次 `add` 操作时，将新元素压入堆中，如果堆中元素超出了 `k` 个，则将堆中最小元素（堆顶）移除。
- 此时堆中最小元素（堆顶）就是整个数据流中的第 `k` 大元素。

## 代码

```python
import heapq

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.min_heap = []
        self.k = k
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > k:
                heapq.heappop(self.min_heap)


    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

# [剑指 Offer II 060. 出现频率最高的 k 个数字](https://leetcode.cn/problems/g5c51o/)

- 标签：数组、哈希表、分治、桶排序、计数、快速选择、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [剑指 Offer II 060. 出现频率最高的 k 个数字 - 力扣](https://leetcode.cn/problems/g5c51o/)

## 题目大意

给定一个整数数组 `nums` 和一个整数 `k`。

要求：返回出现频率前 `k` 高的元素。可以按任意顺序返回答案。

## 解题思路

- 使用哈希表记录下数组中各个元素的频数。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
- 然后将哈希表中的元素去重，转换为新数组。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
- 利用建立大顶堆，此时堆顶元素即为频数最高的元素。时间复杂度 $O(n)$，空间复杂度 $O(n)$。
- 将堆顶元素加入到答案数组中，并交换堆顶元素与末尾元素，此时末尾元素已移出堆。继续调整大顶堆。时间复杂度 $O(log{n})$。
- 调整玩大顶堆之后，此时堆顶元素为频数第二高的元素，和上一步一样，将其加入到答案数组中，继续交换堆顶元素与末尾元素，继续调整大顶堆。
- 不断重复上步，直到 k 次结束。调整 k 次的时间复杂度 $O(nlog{n})$。

总体时间复杂度 $O(nlog{n})$。

因为用的是大顶堆，堆的规模是 N 个元素，调整 k 次，所以时间复杂度是 $O(nlog{n})$。
如果用小顶堆，只需维护 k 个元素的小顶堆，不断向堆中替换元素即可，时间复杂度为 $O(nlog{k})$。

## 代码

```python
class Solution:
    # 调整为大顶堆
    def heapify(self, nums, nums_dict, index, end):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子节点
            max_index = index
            if nums_dict[nums[left]] > nums_dict[nums[max_index]]:
                max_index = left
            if right <= end and nums_dict[nums[right]] > nums_dict[nums[max_index]]:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            nums[index], nums[max_index] = nums[max_index], nums[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1

    # 初始化大顶堆
    def buildMaxHeap(self, nums, nums_dict):
        size = len(nums)
        # (size-2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((size - 2) // 2, -1, -1):
            self.heapify(nums, nums_dict, i, size - 1)
        return nums

    # 堆排序方法（本题未用到）
    def maxHeapSort(self, nums, nums_dict):
        self.buildMaxHeap(nums)
        size = len(nums)
        for i in range(size):
            nums[0], nums[size - i - 1] = nums[size - i - 1], nums[0]
            self.heapify(nums, nums_dict, 0, size - i - 2)
        return nums

    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 统计元素频数
        nums_dict = dict()
        for num in nums:
            if num in nums_dict:
                nums_dict[num] += 1
            else:
                nums_dict[num] = 1

        # 使用 set 方法去重，得到新数组
        new_nums = list(set(nums))
        size = len(new_nums)
        # 初始化大顶堆
        self.buildMaxHeap(new_nums, nums_dict)
        res = list()
        for i in range(k):
            # 堆顶元素为当前堆中频数最高的元素，将其加入答案中
            res.append(new_nums[0])
            # 交换堆顶和末尾元素，继续调整大顶堆
            new_nums[0], new_nums[size - i - 1] = new_nums[size - i - 1], new_nums[0]
            self.heapify(new_nums, nums_dict, 0, size - i - 2)
        return res
```

# [剑指 Offer II 062. 实现前缀树](https://leetcode.cn/problems/QC3q1f/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 062. 实现前缀树 - 力扣](https://leetcode.cn/problems/QC3q1f/)

## 题目大意

要求：实现前缀树数据结构的相关类 `Trie` 类。

`Trie` 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word`。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `True`（即，在检索之前已经插入）；否则，返回 `False`。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `True`；否则，返回 `False`。

## 解题思路

前缀树（字典树）是一棵多叉数，其中每个节点包含指向子节点的指针数组 `children`，以及布尔变量 `isEnd`。`children` 用于存储当前字符节点，一般长度为所含字符种类个数，也可以使用哈希表代替指针数组。`isEnd` 用于判断该节点是否为字符串的结尾。

下面依次讲解插入、查找前缀的具体步骤：

插入字符串：

- 从根节点开始插入字符串。对于待插入的字符，有两种情况：
  - 如果该字符对应的节点存在，则沿着指针移动到子节点，继续处理下一个字符。
  - 如果该字符对应的节点不存在，则创建一个新的节点，保存在 `children` 中对应位置上，然后沿着指针移动到子节点，继续处理下一个字符。
- 重复上述步骤，直到最后一个字符，然后将该节点标记为字符串的结尾。

查找前缀：

- 从跟姐点开始查找前缀，对于待查找的字符，有两种情况：
  - 如果该字符对应的节点存在，则沿着指针移动到子节点，继续查找下一个字符。
  - 如果该字符对应的节点不存在，则说明字典树中不包含该前缀，直接返回空指针。
- 重复上述步骤，直到最后一个字符搜索完毕，则说明字典树中存在该前缀。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd


    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self
        for ch in prefix:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]
        return cur is not None
```

# [剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/)

- 标签：字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 063. 替换单词 - 力扣](https://leetcode.cn/problems/UhWRSj/)

## 题目大意

给定一个由许多词根组成的字典列表 `dictionary`，以及一个句子字符串 `sentence`。

要求：将句子中有词根的单词用词根替换掉。如果单词有很多词根，则用最短的词根替换掉他。最后输出替换之后的句子。

## 解题思路

将所有的词根存入到前缀树（字典树）中。然后在树上查找每个单词的最短词根。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> str:
        """
        Returns if the word is in the trie.
        """
        cur = self
        index = 0
        for ch in word:
            if ch not in cur.children:
                return word
            cur = cur.children[ch]
            index += 1
            if cur.isEnd:
                break
        return word[:index]


class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie_tree = Trie()
        for word in dictionary:
            trie_tree.insert(word)

        words = sentence.split(" ")
        size = len(words)
        for i in range(size):
            word = words[i]
            words[i] = trie_tree.search(word)
        return ' '.join(words)
```

# [剑指 Offer II 064. 神奇的字典](https://leetcode.cn/problems/US1pGT/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 064. 神奇的字典 - 力扣](https://leetcode.cn/problems/US1pGT/)

## 题目大意

要求：设计一个使用单词表进行初始化的数据结构。单词表中的单词互不相同。如果给出一个单词，要求判定能否将该单词中的一个字母替换成另一个字母，是的所形成的新单词已经在够构建的单词表中。

实现 MagicDictionary 类：

- `MagicDictionary()` 初始化对象。
- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同。
- `bool search(String searchWord)` 给定一个字符串 `searchWord`，判定能否只将字符串中一个字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `True`；否则，返回 `False`。

## 解题思路

- 初始化使用字典树结构。

- `buildDict` 方法中将所有单词存入字典树中。

- `search` 方法中替换 `searchWord` 每一个位置上的字符，然后在字典树中查询。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class MagicDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie_tree = Trie()


    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            self.trie_tree.insert(word)


    def search(self, searchWord: str) -> bool:
        size = len(searchWord)
        for i in range(size):
            for j in range(26):
                new_ch = chr(ord('a') + j)
                if searchWord[i] != new_ch:
                    new_word = searchWord[:i] + new_ch + searchWord[i + 1:]
                    if self.trie_tree.search(new_word):
                        return True
        return False
```

# [剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/)

- 标签：字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 065. 最短的单词编码 - 力扣](https://leetcode.cn/problems/iSwD2y/)

## 题目大意

给定一个单词数组 `words`。要求对 `words` 进行编码成一个助记字符串，用来帮助记忆。`words` 中拥有相同字符后缀的单词可以合并成一个单词，比如`time` 和 `me` 可以合并成 `time`。同时每个不能再合并的单词末尾以 `#` 为结束符，将所有合并后的单词排列起来就是一个助记字符串。

要求：返回对 `words` 进行编码的最小助记字符串 `s` 的长度。

## 解题思路

构建一个字典树。然后对字符串长度进行从小到大排序。

再依次将去重后的所有单词插入到字典树中。如果出现比当前单词更长的单词，则将短单词的结尾置为 `False`，意为替换掉短单词。

然后再依次在字典树中查询所有单词，「单词长度 + 1」就是当前不能在合并的单词，累加起来就是答案。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
            cur.isEnd = False
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        trie_tree = Trie()
        words = list(set(words))
        words.sort(key=lambda i: len(i))

        ans = 0
        for word in words:
            trie_tree.insert(word[::-1])

        for word in words:
            if trie_tree.search(word[::-1]):
                ans += len(word) + 1

        return ans
```

# [剑指 Offer II 066. 单词之和](https://leetcode.cn/problems/z1R5dt/)

- 标签：设计、字典树、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 066. 单词之和 - 力扣](https://leetcode.cn/problems/z1R5dt/)

## 题目大意

要求：实现一个 MapSum 类，支持两个方法，`insert` 和 `sum`：

- `MapSum()` 初始化 MapSum 对象。
- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key`，整数表示值 `val`。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。
- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。

## 解题思路

可以构造前缀树（字典树）解题。

- 初始化时，构建一棵前缀树（字典树），并增加 `val` 变量。

- 调用插入方法时，用字典树存储 `key`，并在对应字母节点存储对应的 `val`。
- 在调用查询总和方法时，先查找该前缀 `prefix` 对应的前缀树节点，从该节点开始，递归遍历该节点的子节点，并累积子节点的 `val`，进行求和，并返回求和累加结果。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.value = 0


    def insert(self, word: str, value: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.value = value


    def search(self, word: str) -> int:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return 0
            cur = cur.children[ch]
        return self.dfs(cur)

    def dfs(self, root) -> int:
        if not root:
            return 0
        res = root.value
        for node in root.children.values():
            res += self.dfs(node)
        return res



class MapSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie_tree = Trie()


    def insert(self, key: str, val: int) -> None:
        self.trie_tree.insert(key, val)


    def sum(self, prefix: str) -> int:
        return self.trie_tree.search(prefix)
```

# [剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/)

- 标签：位运算、字典树、数组、哈希表
- 难度：中等

## 题目链接

- [剑指 Offer II 067. 最大的异或 - 力扣](https://leetcode.cn/problems/ms70jA/)

## 题目大意

给定一个整数数组 `nums`。

要求：返回 `num[i] XOR nums[j]` 的最大运算结果。其中 `0 ≤ i ≤ j < n`。

## 解题思路

最直接的想法暴力求解。两层循环计算两两之间的异或结果，记录并更新最大异或结果。

更好的做法可以减少一重循环。首先，要取得异或结果的最大值，那么从二进制的高位到低位，尽可能的让每一位异或结果都为 `1`。

将数组中所有数字的二进制形式从高位到低位依次存入字典树中。然后是利用异或运算交换律：如果 `a ^ b = max` 成立，那么 `a ^ max = b` 与 `b ^ max = a` 均成立。这样当我们知道 `a` 和 `max` 时，可以通过交换律求出 `b`。`a` 是我们遍历的每一个数，`max` 是我们想要尝试的最大值，从 `111111...` 开始，从高位到低位依次填 `1`。

对于 `a` 和 `max`，如果我们所求的 `b` 也在字典树中，则表示 `max` 是可以通过 `a` 和 `b` 得到的，那么 `max` 就是所求最大的异或。如果 `b` 不在字典树中，则减小 `max` 值继续判断，或者继续查询下一个 `a`。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, num: int, max_bit: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for i in range(max_bit, -1, -1):
            bit = num >> i & 1
            if bit not in cur.children:
                cur.children[bit] = Trie()
            cur = cur.children[bit]
        cur.isEnd = True

    def search(self, num: int, max_bit: int) -> int:
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = 0
        for i in range(max_bit, -1, -1):
            bit = num >> i & 1
            if 1 - bit not in cur.children:
                res = res * 2
                cur = cur.children[bit]
            else:
                res = res * 2 + 1
                cur = cur.children[1 - bit]
        return res

class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        trie_tree = Trie()
        max_bit = len(format(max(nums), 'b')) - 1
        ans = 0
        for num in nums:
            trie_tree.insert(num, max_bit)
            ans = max(ans, trie_tree.search(num, max_bit))
            
        return ans
```

# [剑指 Offer II 068. 查找插入位置](https://leetcode.cn/problems/N6YdxV/)

- 标签：数组、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer II 068. 查找插入位置 - 力扣](https://leetcode.cn/problems/N6YdxV/)

## 题目大意

给定一个排好序的数组 `nums`，以及一个目标值 `target`。

要求：在数组中找到目标值，并返回下标。如果找不到，则返回目标值按顺序插入数组的位置。

## 解题思路

二分查找法。利用两个指针 `left` 和 `right`，分别指向数组首尾位置。每次用 `left` 和 `right` 中间位置上的元素值与目标值做比较，如果等于目标值，则返回当前位置。如果小于目标值，则更新 `left` 位置为 `mid + 1`，继续查找。如果大于目标值，则更新 `right` 位置为 `mid - 1`，继续查找。直到查找到目标值，或者 `left > right` 值时停止查找。然后返回 `left` 所在位置，即是代插入数组的位置。

## 代码

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        n = len(nums)
        left = 0
        right = n - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return left
```

# [剑指 Offer II 072. 求平方根](https://leetcode.cn/problems/jJ0w9p/)

- 标签：数学、二分查找
- 难度：简单

## 题目链接

- [剑指 Offer II 072. 求平方根 - 力扣](https://leetcode.cn/problems/jJ0w9p/)

## 题目大意

要求：实现 `int sqrt(int x)` 函数。计算并返回 `x` 的平方根（只保留整数部分），其中 `x` 是非负整数。

## 解题思路

因为求解的是 x 开方的整数部分。所以我们可以从 0~x 的范围进行遍历，找到 k^2 <= x 的最大结果。

为了减少时间复杂度，使用二分查找的方式来搜索答案。

## 代码

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        left = 0
        right = x
        ans = -1
        while left <= right:
            mid = (left + right) // 2
            if mid * mid <= x:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1
        return ans
```

# [剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/)

- 标签：数组、二分查找
- 难度：中等

## 题目链接

- [剑指 Offer II 073. 狒狒吃香蕉 - 力扣](https://leetcode.cn/problems/nZZqjQ/)

## 题目大意

给定一个数组 `piles` 代表 `n` 堆香蕉。其中 `piles[i]` 表示第 `i` 堆香蕉的个数。再给定一个整数 `h` ，表示最多可以在 `h` 小时内吃完所有香蕉。狒狒决定以速度每小时 `k`（未知）根的速度吃香蕉。每一个小时，她将选择其中一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，狒狒将在这一小时吃掉这堆的所有香蕉，并且这一小时不会再吃其他堆的香蕉。  

要求：返回狒狒可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。

## 解题思路

先来看 `k` 的取值范围，因为 `k` 是整数，且速度肯定不能为 `0` 吧，为 `0` 的话就永远吃不完了。所以`k` 的最小值可以取 `1`。`k` 的最大值根香蕉中最大堆的香蕉个数有关，因为 `1` 个小时内只能选择一堆吃，不能再吃其他堆的香蕉，则 `k` 的最大值取香蕉堆的最大值即可。即 `k` 的最大值为 `max(piles)`。

我们的目标是求出 `h` 小时内吃掉所有香蕉的最小速度 `k`。现在有了区间「`[1, max(piles)]`」，有了目标「最小速度 `k`」。接下来使用二分查找算法来查找「最小速度 `k`」。至于计算 `h` 小时内能否以 `k` 的速度吃完香蕉，我们可以再写一个方法 `canEat` 用于判断。如果能吃完就返回 `True`，不能吃完则返回 `False`。下面说一下算法的具体步骤。

- 使用两个指针 `left`、`right`。令 `left` 指向 `1`，`right` 指向 `max(piles)`。代表待查找区间为 `[left, right]`

- 取两个节点中心位置 `mid`，判断是否能在 `h` 小时内以 `k` 的速度吃完香蕉。
  - 如果不能吃完，则将区间 `[left, mid]` 排除掉，继续在区间 `[mid + 1, right]` 中查找。
  - 如果能吃完，说明 `k` 还可以继续减小，则继续在区间 `[left, mid]` 中查找。
- 当 `left == right` 时跳出循环，返回 `left`。

## 代码

```python
class Solution:
    def canEat(self, piles, hour, speed):
        time = 0
        for pile in piles:
            time += (pile + speed - 1) // speed
        return time <= hour

    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        left, right = 1, max(piles)

        while left < right:
            mid = left + (right - left) // 2
            if not self.canEat(piles, h, mid):
                left = mid + 1
            else:
                right = mid

        return left
```

# [剑指 Offer II 074. 合并区间](https://leetcode.cn/problems/SsGoHC/)

- 标签：数组、排序
- 难度：中等

## 题目链接

- [剑指 Offer II 074. 合并区间 - 力扣](https://leetcode.cn/problems/SsGoHC/)

## 题目大意

给定一个数组 `intervals` 表示若干个区间的集合，`intervals[i] = [starti, endi]` 表示单个区间。

要求：合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需要恰好覆盖原数组中的所有区间。

## 解题思路

设定一个数组 `ans` 用于表示最终不重叠的区间数组，然后对原始区间先按照区间左端点大小从小到大进行排序。

遍历所有区间。先将第一个区间加入 `ans` 数组中。然后依次考虑后边的区间，如果第 `i` 个区间左端点在前一个区间右端点右侧，则这两个区间不会重合，直接将该区间加入 `ans` 数组中。否则的话，这两个区间重合，判断一下两个区间的右区间值，更新前一个区间的右区间值为较大值，然后继续考虑下一个区间，以此类推。

## 代码

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])

        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

# [剑指 Offer II 075. 数组相对排序](https://leetcode.cn/problems/0H97ZC/)

- 标签：数组、哈希表、计数排序、排序
- 难度：简单

## 题目链接

- [剑指 Offer II 075. 数组相对排序 - 力扣](https://leetcode.cn/problems/0H97ZC/)

## 题目大意

给定两个数组，`arr1` 和 `arr2`，其中 `arr2` 中的元素各不相同，`arr2` 中的每个元素都出现在 `arr1` 中。

要求：对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

注意：

- `1 <= arr1.length, arr2.length <= 1000`。
- `0 <= arr1[i], arr2[i] <= 1000`。

## 解题思路

因为元素值范围在 `[0, 1000]`，所以可以使用计数排序的思路来解题。

使用数组 `count` 统计 `arr1` 各个元素个数。

遍历 `arr2` 数组，将对应元素`num2` 按照个数 `count[num2]` 添加到答案数组 `ans` 中，同时在 `count` 数组中减去对应个数。

然后在处理 `count` 中剩余元素，将 `count` 中大于 `0` 的元素下标依次添加到答案数组 `ans` 中。

## 代码

```python
class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        count = [0 for _ in range(1010)]
        for num1 in arr1:
            count[num1] += 1
        res = []
        for num2 in arr2:
            while count[num2] > 0:
                res.append(num2)
                count[num2] -= 1

        for num in range(len(count)):
            while count[num] > 0:
                res.append(num)
                count[num] -= 1

        return res
```

# [剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode.cn/problems/xx4gT2/)

- 标签：数组、分治、快速选择、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [剑指 Offer II 076. 数组中的第 k 大的数字 - 力扣](https://leetcode.cn/problems/xx4gT2/)

## 题目大意

给定一个未排序的数组 `nums`，从中找到第 `k` 个最大的数字。

## 解题思路

很不错的一道题，面试常考。

直接可以想到的思路是：排序后输出数组上对应第 k 位大的数。所以问题关键在于排序方法的复杂度。

冒泡排序、选择排序、插入排序时间复杂度 $O(n^2)$ 太高了，解答会超时。

可考虑堆排序、归并排序、快速排序。

这道题的要求是找到第 k 大的元素，使用归并排序只有到最后排序完毕才能返回第 k 大的数。而堆排序每次排序之后，就会确定一个元素的准确排名，同理快速排序也是如此。

### 1. 堆排序

升序堆排序的思路如下：

1. 先建立大顶堆

2. 让堆顶最大元素与最后一个交换，然后调整第一个元素到倒数第二个元素，这一步获取最大值

3. 再交换堆顶元素与倒数第二个元素，然后调整第一个元素到倒数第三个元素，这一步获取第二大值

4. 以此类推，直到最后一个元素交换之后完毕。

这道题我们只需进行 1 次建立大顶堆， k-1 次调整即可得到第 k 大的数。

时间复杂度：$O(n^2)$

### 2. 快速排序

快速排序每次调整，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了两个数组，前一个数组元素都比该元素小，后一个元素都比该元素大。

这样，只要某次划分的元素恰好是第 k 个下标就找到了答案。并且我们只需关注 k 元素所在区间的排序情况，与 k 元素无关的区间排序都可以忽略。这样进一步减少了执行步骤。

### 3. 借用标准库（不建议）

提交代码中的最快代码是调用了 Python 的 heapq 库，或者 sort 方法。
这样的确可以通过，但是不建议这样做。借用标准库实现，只能说对这个库的 API 和相关数据结构的用途相对熟悉，而不代表着掌握了这个数据结构。可以问问自己，如果换一种语言，自己还能不能实现对应的数据结构？刷题的本质目的是为了把算法学会学透，而不仅仅是调 API。

## 代码

1. 堆排序

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 调整为大顶堆
        def heapify(nums, index, end):
            left = index * 2 + 1
            right = left + 1
            while left <= end:
                # 当前节点为非叶子节点
                max_index = index
                if nums[left] > nums[max_index]:
                    max_index = left
                if right <= end and nums[right] > nums[max_index]:
                    max_index = right
                if index == max_index:
                    # 如果不用交换，则说明已经交换结束
                    break
                nums[index], nums[max_index] = nums[max_index], nums[index]
                # 继续调整子树
                index = max_index
                left = index * 2 + 1
                right = left + 1
                
        # 初始化大顶堆
        def buildMaxHeap(nums):
            size = len(nums)
            # (size-2) // 2 是最后一个非叶节点，叶节点不用调整
            for i in range((size - 2) // 2, -1, -1):
                heapify(nums, i, size - 1)
            return nums

        buildMaxHeap(nums)
        size = len(nums)
        for i in range(k-1):
            nums[0], nums[size-i-1] = nums[size-i-1], nums[0]
            heapify(nums, 0, size-i-2)
        return nums[0]
```

2. 快速排序

```python
import random
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def randomPartition(nums, low, high):
            i = random.randint(low, high)
            nums[i], nums[high] = nums[high], nums[i]
            return partition(nums, low, high)

        def partition(nums, low, high):
            x = nums[high]
            i = low-1
            for j in range(low, high):
                if nums[j] <= nums[high]:
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
            nums[i+1], nums[high] = nums[high], nums[i+1]
            return i+1

        def quickSort(nums, low, high, k):
            n = len(nums)
            if low < high:
                pi = randomPartition(nums, low, high)
                if pi == n-k:
                    return nums[len(nums)-k]
                if pi > n-k:
                    quickSort(nums, low, pi-1, k)
                if pi < n-k:
                    quickSort(nums, pi+1, high, k)

            return nums[len(nums)-k]

        return quickSort(nums, 0, len(nums)-1, k)
```

3. 借用标准库

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums)-k]
```

```python
import heapq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        res = []
        for n in nums:
            if len(res) < k:
                heapq.heappush(res, n)
            elif n > res[0]:
                heapq.heappop(res)
                heapq.heappush(res, n)
        return heapq.heappop(res)
```



# [剑指 Offer II 077. 链表排序](https://leetcode.cn/problems/7WHec2/)

- 标签：链表、双指针、分治、排序、归并排序
- 难度：中等

## 题目链接

- [剑指 Offer II 077. 链表排序 - 力扣](https://leetcode.cn/problems/7WHec2/)

## 题目大意

给定链表的头节点 `head`。

要求：按照升序排列并返回排序后的链表。

## 解题思路

归并排序。

1. 利用快慢指针找到链表的中点，以中点为界限将链表拆分成两个子链表。
2. 然后对两个子链表分别递归排序。
3. 将排序后的子链表进行归并排序，得到完整的排序后的链表。

## 代码

```python
class Solution:
    def merge_sort(self, head: ListNode, tail: ListNode) -> ListNode:
        if not head:
            return head
        if head.next == tail:
            head.next = None
            return head
        slow = fast = head
        while fast != tail:
            slow = slow.next
            fast = fast.next
            if fast != tail:
                fast = fast.next
        mid = slow
        return self.merge(self.merge_sort(head, mid), self.merge_sort(mid, tail))

    def merge(self, a: ListNode, b: ListNode) -> ListNode:
        root = ListNode(-1)
        cur = root
        while a and b:
            if a.val < b.val:
                cur.next = a
                a = a.next
            else:
                cur.next = b
                b = b.next
            cur = cur.next
        if a:
            cur.next = a
        if b:
            cur.next = b
        return root.next

    def sortList(self, head: ListNode) -> ListNode:
        return self.merge_sort(head, None)
```

# [剑指 Offer II 078. 合并排序链表](https://leetcode.cn/problems/vvXgSW/)

- 标签：链表、分治、堆（优先队列）、归并排序
- 难度：困难

## 题目链接

- [剑指 Offer II 078. 合并排序链表 - 力扣](https://leetcode.cn/problems/vvXgSW/)

## 题目大意

给定一个链表数组 `lists`，每个链表都已经按照升序排列。

要求：将所有链表合并到一个升序链表中，返回合并后的链表。

## 解题思路

分而治之的思想。将链表数组不断二分，转为规模为二分之一的子问题，然后再进行归并排序。

## 代码

```python
class Solution:
    def merge_sort(self, lists: List[ListNode], left: int, right: int) -> ListNode:
        if left == right:
            return lists[left]
        mid = left + (right - left) // 2
        node_left = self.merge_sort(lists, left, mid)
        node_right = self.merge_sort(lists, mid + 1, right)
        return self.merge(node_left, node_right)

    def merge(self, a: ListNode, b: ListNode) -> ListNode:
        root = ListNode(-1)
        cur = root
        while a and b:
            if a.val < b.val:
                cur.next = a
                a = a.next
            else:
                cur.next = b
                b = b.next
            cur = cur.next
        if a:
            cur.next = a
        if b:
            cur.next = b
        return root.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        size = len(lists)
        return self.merge_sort(lists, 0, size - 1)
```

# [剑指 Offer II 079. 所有子集](https://leetcode.cn/problems/TVdhkn/)

- 标签：位运算、数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 079. 所有子集 - 力扣](https://leetcode.cn/problems/TVdhkn/)

## 题目大意

给定一个整数数组 `nums`，数组中的元素互不相同。

要求：返回该数组所有可能的不重复子集。

## 解题思路

回溯算法，遍历数组 `nums`。为了使得子集不重复，每次遍历从当前位置的下一个位置进行下一层遍历。

## 代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(size, subset, index):
            res.append(subset)
            for i in range(index, size):
                backtrack(size, subset + [nums[i]], i + 1)

        size = len(nums)
        res = list()
        backtrack(size, [], 0)
        return res
```

# [剑指 Offer II 080. 含有 k 个元素的组合](https://leetcode.cn/problems/uUsW3B/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 080. 含有 k 个元素的组合 - 力扣](https://leetcode.cn/problems/uUsW3B/)

## 题目大意

给定两个整数 `n` 和 `k`。

要求：返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。可以按任何顺序返回答案。

## 解题思路

组合问题通常可以用回溯算法来解决。定义两个数组 `res`、`path`。`res` 用来存放最终答案，`path` 用来存放当前符合条件的一个结果。再使用一个变量 `start_index` 来表示从哪一个数开始遍历。

定义回溯方法，`start_index = 1` 开始进行回溯。

- 如果 `path` 数组的长度等于 `k`，则将 `path` 中的元素加入到 `res` 数组中。
- 然后对 `[start_index, n]` 范围内的数进行遍历取值。
    - 将当前元素 `i` 加入 `path` 数组。
    - 递归遍历 `[start_index, n]` 上的数。
    - 将遍历的 `i` 元素进行回退。
- 最终返回 `res` 数组。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, n: int, k: int, start_index: int):
        if len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start_index, n - (k - len(self.path)) + 2):
            self.path.append(i)
            self.backtrack(n, k, i + 1)
            self.path.pop()

    def combine(self, n: int, k: int) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        self.backtrack(n, k, 1)
        return self.res
```

# [剑指 Offer II 081. 允许重复选择元素的组合](https://leetcode.cn/problems/Ygoe9J/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 081. 允许重复选择元素的组合 - 力扣](https://leetcode.cn/problems/Ygoe9J/)

## 题目大意

给定一个无重复元素的正整数数组 `candidates` 和一个正整数 `target`。

要求：找出 `candidates` 中所有可以使数字和为目标数 `target` 的唯一组合。

注意：数组 `candidates` 中的数字可以无限重复选取，且 `1 ≤ candidates[i] ≤ 200`。

## 解题思路

回溯算法，因为 `1 ≤ candidates[i] ≤ 200`，所以即便是 `candidates[i]` 值为 `1`，重复选取也会等于或大于 target，从而终止回溯。

建立两个数组 `res`、`path`。`res` 用于存放所有满足题意的组合，`path` 用于存放当前满足题意的一个组合。

定义回溯方法，`start_index = 1` 开始进行回溯。

- 如果 `sum > target`，则直接返回。
- 如果 `sum == target`，则将 `path` 中的元素加入到 `res` 数组中。
- 然后对 `[start_index, n]` 范围内的数进行遍历取值。
    - 如果 `sum + candidates[i] > target`，可以直接跳出循环。
    - 将和累积，即 `sum += candidates[i]`，然后将当前元素 `i` 加入 `path` 数组。
    - 递归遍历 `[start_index, n]` 上的数。
    - 加之前的和回退，即 `sum -= candidates[i]`，然后将遍历的 `i` 元素进行回退。
- 最终返回 `res` 数组。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, candidates: List[int], target: int, sum: int, start_index: int):
        if sum > target:
            return

        if sum == target:
            self.res.append(self.path[:])
            return

        for i in range(start_index, len(candidates)):
            if sum + candidates[i] > target:
                break
            sum += candidates[i]
            self.path.append(candidates[i])
            self.backtrack(candidates, target, sum, i)
            sum -= candidates[i]
            self.path.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        candidates.sort()
        self.backtrack(candidates, target, 0, 0)
        return self.res
```

# [剑指 Offer II 082. 含有重复元素集合的组合](https://leetcode.cn/problems/4sjJUc/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 082. 含有重复元素集合的组合 - 力扣](https://leetcode.cn/problems/4sjJUc/)

## 题目大意

给定一个数组 `candidates` 和一个目标数 `target`。

要求：找出 `candidates` 中所有可以使数字和为目标数 `target` 的组合。

数组 `candidates` 中的数字在每个组合中只能使用一次，且 `1 ≤ candidates[i] ≤ 50`。

## 解题思路

本题不能有重复组合，关键步骤在于去重。

在回溯遍历的时候，下一层递归的 `start_index` 要从当前节点的后一位开始遍历，即 `i + 1` 位开始。而且统一递归层不能使用相同的元素，即需要增加一句判断 `if i > start_index and candidates[i] == candidates[i - 1]: continue`。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, candidates: List[int], target: int, sum: int, start_index: int):
        if sum > target:
            return
        if sum == target:
            self.res.append(self.path[:])
            return

        for i in range(start_index, len(candidates)):
            if sum + candidates[i] > target:
                break
            if i > start_index and candidates[i] == candidates[i - 1]:
                continue
            sum += candidates[i]
            self.path.append(candidates[i])
            self.backtrack(candidates, target, sum, i + 1)
            sum -= candidates[i]
            self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        candidates.sort()
        self.backtrack(candidates, target, 0, 0)
        return self.res
```

# [剑指 Offer II 083. 没有重复元素集合的全排列](https://leetcode.cn/problems/VvJkup/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 083. 没有重复元素集合的全排列 - 力扣](https://leetcode.cn/problems/VvJkup/)

## 题目大意

给定一个不含重复数字的数组 `nums` 。

要求：返回其有可能的全排列，可以按任意顺序返回。

## 解题思路

回溯算法递归遍历 `nums` 元素。同时使用 `visited` 数组来标记该元素在当前排列中是否被访问过。若未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。

## 代码

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(size, arrange, index):
            if index == size:
                res.append(arrange)
                return
            for i in range(size):
                if visited[i] == True:
                    continue
                visited[i] = True
                backtrack(size, arrange + [nums[i]], index + 1)
                visited[i] = False

        size = len(nums)
        res = list()
        visited = [False for _ in range(size)]
        backtrack(size, [], 0)
        return res
```

# [剑指 Offer II 084. 含有重复元素集合的全排列](https://leetcode.cn/problems/7p8L0Z/)

- 标签：数组、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 084. 含有重复元素集合的全排列 - 力扣](https://leetcode.cn/problems/7p8L0Z/)

## 题目大意

给定一个可包含重复数字的序列 `nums` 。

要求：按任意顺序返回所有不重复的全排列。

## 解题思路

这道题跟「[剑指 Offer II 083. 没有重复元素集合的全排列](https://leetcode.cn/problems/VvJkup/)」不一样的地方在于增加了序列中的元素可重复这一条件。这就涉及到了去重。先对 `nums` 进行排序，然后使用 visited 数组标记该元素在当前排列中是否被访问过。若未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。

然后再递归遍历下一层元素之前，增加一句语句进行判重：`if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue`。

然后进行回溯遍历。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, nums: List[int], visited: List[bool]):
        if len(self.path) == len(nums):
            self.res.append(self.path[:])
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:
                continue

            if not visited[i]:
                visited[i] = True
                self.path.append(nums[i])
                self.backtrack(nums, visited)
                self.path.pop()
                visited[i] = False

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        self.res.clear()
        self.path.clear()
        nums.sort()
        visited = [False for _ in range(len(nums))]
        self.backtrack(nums, visited)
        return self.res
```

# [剑指 Offer II 085. 生成匹配的括号](https://leetcode.cn/problems/IDBivT/)

- 标签：字符串、动态规划、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 085. 生成匹配的括号 - 力扣](https://leetcode.cn/problems/IDBivT/)

## 题目大意

给定一个整数 `n`。

要求：生成所有有可能且有效的括号组合。

## 解题思路

通过回溯算法生成所有答案。为了生成的括号组合是有效的，回溯的时候，使用一个标记变量 `symbol` 来表示是否当前组合是否成对匹配。

如果在当前组合中增加一个 `(`，则 `symbol += 1`，如果增加一个 `)`，则 `symbol -= 1`。显然只有在 `symbol < n` 的时候，才能增加 `(`，在 `symbol > 0` 的时候，才能增加 `)`。

如果最终生成 `2 * n` 的括号组合，并且 `symbol == 0`，则说明当前组合是有效的，将其加入到最终答案数组中。

最终输出最终答案数组。

## 代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(parenthesis, symbol, index):
            if n * 2 == index:
                if symbol == 0:
                    parentheses.append(parenthesis)
            else:
                if symbol < n:
                    backtrack(parenthesis + '(', symbol + 1, index + 1)
                if symbol > 0:
                    backtrack(parenthesis + ')', symbol - 1, index + 1)

        parentheses = list()
        backtrack("", 0, 0)
        return parentheses
```

# [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)

- 标签：深度优先搜索、广度优先搜索、图、哈希表
- 难度：中等

## 题目链接

- [剑指 Offer II 086. 分割回文子字符串 - 力扣](https://leetcode.cn/problems/M99OJA/)

## 题目大意

给定一个字符串 `s`将 `s` 分割成一些子串，保证每个子串都是「回文串」。

要求：返回 `s` 所有可能的分割方案。

## 解题思路

回溯算法，建立两个数组 `res`、`path`。`res` 用于存放所有满足题意的组合，`path` 用于存放当前满足题意的一个组合。

在回溯的时候判断当前子串是否为回文串，如果不是则跳过，如果是则继续向下一层遍历。

定义判断是否为回文串的方法和回溯方法，从 `start_index = 0` 的位置开始回溯。

- 如果 `start_index >= len(s)`，则将 `path` 中的元素加入到 `res` 数组中。
- 然后对 `[start_index, len(s) - 1]` 范围内的子串进行遍历取值。
    - 如果字符串 `s` 在范围 `[start_index, i]` 所代表的子串是回文串，则将其加入 `path` 数组。
    - 递归遍历 `[i + 1, len(s) - 1]` 范围上的子串。
    - 然后将遍历的范围 `[start_index, i]` 所代表的子串进行回退。
- 最终返回 `res` 数组。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, s: str, start_index: int):
        if start_index >= len(s):
            self.res.append(self.path[:])
            return
        for i in range(start_index, len(s)):
            if self.ispalindrome(s, start_index, i):
                self.path.append(s[start_index: i + 1])
                self.backtrack(s, i + 1)
                self.path.pop()

    def ispalindrome(self, s: str, start: int, end: int):
        i, j = start, end
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    def partition(self, s: str) -> List[List[str]]:
        self.res.clear()
        self.path.clear()
        self.backtrack(s, 0)
        return self.res
```

# [剑指 Offer II 087. 复原 IP](https://leetcode.cn/problems/0on3uN/)

- 标签：字符串、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 087. 复原 IP - 力扣](https://leetcode.cn/problems/0on3uN/)

## 题目大意

给定一个只包含数字的字符串，用来表示一个 IP 地址。

要求：返回所有由 `s` 构成的有效 IP 地址，可以按任何顺序返回答案。

- 有效 IP 地址：正好由四个整数（每个整数由 0~255 的数构成，且不能含有前导 0），整数之间用 `.` 分割。

例如：`0.1.2.201` 和 `192.168.1.1` 是有效 IP 地址，但是 `0.011.255.245`、`192.168.1.312` 和 `192.168@1.1` 是 无效 IP 地址。

## 解题思路

回溯算法。使用 `res` 存储所有有效 IP 地址。用 `point_num` 表示当前 IP 地址的 `.` 符号个数。

定义回溯方法，从 `start_index` 位置开始遍历字符串。

- 如果字符串中添加的 `.` 符号数量为 `3`，则判断当前字符串是否为有效 IP 地址，若为有效 IP 地址则加入到 `res` 数组中。直接返回。
- 然后在 `[start_index, len(s) - 1]` 范围循环遍历，判断 `[start_index, i]` 范围所代表的子串是否合法。如果合法：
    - 则 `point_num += 1`。
    - 然后在 i 位置后边增加 `.` 符号，继续回溯遍历。
    - 最后 `point_num -= 1` 进行回退。
- 不符合则直接跳出循环。
- 最后返回 `res`。

## 代码

```python
class Solution:
    res = []

    def backstrack(self, s: str, start_index: int, point_num: int):
        if point_num == 3:
            if self.isValid(s, start_index, len(s) - 1):
                self.res.append(s)
            return
        for i in range(start_index, len(s)):
            if self.isValid(s, start_index, i):
                point_num += 1
                self.backstrack(s[:i + 1] + '.' + s[i + 1:], i + 2, point_num)
                point_num -= 1
            else:
                break

    def isValid(self, s: str, start: int, end: int):
        if start > end:
            return False
        if s[start] == '0' and start != end:
            return False
        num = 0
        for i in range(start, end + 1):
            if s[i] > '9' or s[i] < '0':
                return False
            num = num * 10 + ord(s[i]) - ord('0')
            if num > 255:
                return False
        return True

    def restoreIpAddresses(self, s: str) -> List[str]:
        self.res.clear()
        if len(s) > 12:
            return self.res
        self.backstrack(s, 0, 0)
        return self.res
```

# [剑指 Offer II 088. 爬楼梯的最少成本](https://leetcode.cn/problems/GzCJIP/)

- 标签：数组、动态规划
- 难度：简单

## 题目链接

- [剑指 Offer II 088. 爬楼梯的最少成本 - 力扣](https://leetcode.cn/problems/GzCJIP/)

## 题目大意

给定一个数组 `cost` 代表一段楼梯，`cost[i]` 代表爬上第 `i` 阶楼梯醒酒药花费的体力值（下标从 `0` 开始）。

每爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

要求：找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 `0` 或 `1` 的元素作为初始阶梯。

## 解题思路

使用动态规划方法。

状态 `dp[i]` 表示为：到达第 `i` 个台阶所花费的最少体⼒。

则状态转移方程为： `dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]`。

表示为：到达第 `i` 个台阶所花费的最少体⼒ = 到达第 `i - 1` 个台阶所花费的最小体力 与 到达第 `i - 2` 个台阶所花费的最小体力中的最小值 + 到达第 `i` 个台阶所需要花费的体力值。

## 代码

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        size = len(cost)
        dp = [0 for _ in range(size + 1)]
        for i in range(2, size + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        return dp[size]
```

# [剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 089. 房屋偷盗 - 力扣](https://leetcode.cn/problems/Gu0c2T/)

## 题目大意

给定一个数组 `nums`，`num[i]` 代表第 `i` 间房屋存放的金额。相邻的房屋装有防盗系统，假如相邻的两间房屋同时被偷，系统就会报警。假如你是一名专业的小偷。

要求：计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

## 解题思路

可以用动态规划来解决问题，关键点在于找到状态转移方程。

先考虑最简单的情况。假如只有一间房，则直接偷这间屋子就能偷到最高金额，即 `dp[0] = nums[i]`。假如只有两间房屋，那么就选择金额最大的那间屋进行偷窃，就可以偷到最高金额，即 `dp[1] = max(nums[0], nums[1])`。

如果房屋大于两间，则偷窃第 `i` 间房屋的时候，就有两种状态：

- 偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋就不能偷窃了，偷窃的最高金额为：前 `i - 2` 间房屋的最高总金额 + 第 `i` 间房屋的金额，即 `dp[i] = dp[i-2] + nums[i]`；
- 不偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋可以偷窃，偷窃的最高金额为：前 `i - 1` 间房屋的最高总金额，即 `dp[i] = dp[i-1]`。

然后这两种状态取最大值即可，即 `dp[i] = max(dp[i-2] + nums[i], dp[i-1])`。

总结下就是：

$dp[i] = \begin{cases} \begin{array} {**lr**}  nums[0] & i = 0 \cr max( nums[0], nums[1]) & i = 1 \cr max( dp[i-2] + nums[i], dp[i-1]) & i \ge 2 \end{array} \end{cases}$

## 代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [0 for _ in range(size)]
        for i in range(size):
            if i == 0:
                dp[i] = nums[i]
            elif i == 1:
                dp[i] = max(nums[i - 1], nums[i])
            else:
                dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

        return dp[size - 1]
```

# [剑指 Offer II 090. 环形房屋偷盗](https://leetcode.cn/problems/PzWKhm/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 090. 环形房屋偷盗 - 力扣](https://leetcode.cn/problems/PzWKhm/)

## 题目大意

给定一个数组 `nums`，`num[i]` 代表第 `i` 间房屋存放的金额，假设房屋可以围成一圈，首尾相连。相邻的房屋装有防盗系统，假如相邻的两间房屋同时被偷，系统就会报警。假如你是一名专业的小偷。

要求：计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

## 解题思路

「[剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/)」的升级版。可以用动态规划来解决问题，关键点在于找到状态转移方程。

先来考虑最简单的情况。

假如只有一间房屋，则直接偷这间房屋就能偷到最高金额，即 $dp[0] = nums[i]$。假如有两间房屋，那么就选择金额最大的那间房屋进行偷窃，就可以偷到最高金额，即 $dp[1] = max(nums[0], nums[1])$。

两间屋子以下，最多只能偷窃一间房屋，则不用考虑首尾相连的情况。如果三个屋子以上，偷窃了第一间房屋，则不能偷窃最后一间房屋。同样偷窃了最后一间房屋则不能偷窃第一间房屋。

假设总共房屋数量为 N，这种情况可以转换为分别求解 $[0, N - 2]$ 和 $[1, N - 1]$ 范围下首尾不相连的房屋所能偷窃的最高金额，这就变成了「[剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/)」的求解问题。

「[剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/)」求解思路如下：

如果房屋大于两间，则偷窃第 `i` 间房屋的时候，就有两种状态：

- 偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋就不能偷窃了，偷窃的最高金额为：前 `i - 2` 间房屋的最高总金额 + 第 `i` 间房屋的金额，即 $dp[i] = dp[i-2] + nums[i]$；
- 不偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋可以偷窃，偷窃的最高金额为：前 `i - 1` 间房屋的最高总金额，即 $dp[i] = dp[i-1]$。

然后这两种状态取最大值即可，即 $dp[i] = max( dp[i-2] + nums[i], dp[i-1])$。

总结下就是：

$dp[i] = \begin{cases} nums[0], &  i = 0 \cr max( nums[0], nums[1]) & i = 1 \cr max( dp[i-2] + nums[i], dp[i-1]) & i \ge 2 \end{cases}$

## 代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def helper(nums):
            size = len(nums)
            if size == 1:
                return nums[0]
            dp = [0 for _ in range(size)]
            for i in range(size):
                if i == 0:
                    dp[i] = nums[0]
                elif i == 1:
                    dp[i] = max(nums[i - 1], nums[i])
                else:
                    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
            return dp[-1]

        if len(nums) == 1:
            return nums[0]
        else:
            return max(helper(nums[1:]), helper(nums[:-1]))
```

# [剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/)

- 标签：数组、哈希表、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 093. 最长斐波那契数列 - 力扣](https://leetcode.cn/problems/Q91FMA/)

## 题目大意

给定一个严格递增的正整数数组 `arr`。

要求：从 `arr` 中找出最长的斐波那契式的子序列的长度。如果不存斐波那契式的子序列，则返回 `0`。

- 斐波那契式序列：如果序列 $X_1, X_2, ..., X_n$ 满足：

    - $n \ge 3$；
    - 对于所有 $i + 2 \le n$，都有 $X_i + X_{i+1} = X_{i+2}$。

    则称该序列为斐波那契式序列。

- 斐波那契式子序列：从序列 `arr` 中挑选若干元素组成子序列，并且子序列满足斐波那契式序列，则称该序列为斐波那契式子序列。例如：`arr = [3, 4, 5, 6, 7, 8]`。则 `[3, 5, 8]` 是 `arr` 的一个斐波那契式子序列。

## 解题思路

我们先从最简单的暴力做法思考。

**1. 暴力做法：**

我们先来考虑暴力做法怎么做。

假设 `arr[i]`、`arr[j]`、`arr[k]` 是序列 `arr` 中的 3 个元素，且满足关系：`arr[i] + arr[j] == arr[k]`，则 `arr[i]`、`arr[j]`、`arr[k]` 就构成了 A 的一个斐波那契式子序列。

通过  `arr[i]`、`arr[j]`，我们可以确定下一个斐波那契式子序列元素的值为 `arr[i] + arr[j]`。

因为给定的数组是严格递增的，所以对于一个斐波那契式子序列，如果确定了 `arr[i]`、`arr[j]`，则可以顺着 `arr` 序列，从第 `j + 1` 的元素开始，查找值为 `arr[i] + arr[j]` 的元素 。找到 `arr[i] + arr[j]` 之后，然后在顺着查找子序列的下一个元素。

简单来说，就是确定了 `arr[i]`、`arr[j]`，就能尽可能的得到一个长的斐波那契式子序列，此时我们记录下子序列长度。然后对于不同的  `arr[i]`、`arr[j]`，统计不同的斐波那契式子序列的长度。将这些长度进行比较，其中最长的长度就是答案。

下面是暴力做法的代码：

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        ans = 0
        for i in range(size):
            for j in range(i + 1, size):
                temp_ans = 0
                temp_i = i
                temp_j = j
                k = j + 1
                while k < size:
                    if arr[temp_i] + arr[temp_j] == arr[k]:
                        temp_ans += 1
                        temp_i = temp_j
                        temp_j = k
                    k += 1
                if temp_ans > ans:
                    ans = temp_ans

        if ans > 0:
            return ans + 2
        else:
            return ans
```

毫无意外的，超出时间限制了。

那么我们怎么来优化呢？

**2. 使用哈希表优化做法：**

我们注意到：对于 `arr[i]`、`arr[j]`，要查找的元素 `arr[i] + arr[j]` 是否在 `arr` 中，我们可以预先建立一个反向的哈希表。键值对关系为 `value : idx`，这样就能在 `O(1)` 的时间复杂度通过 `arr[i] + arr[j]` 的值查找到对应的 `k` 值，而不用像原先一样线性查找 `arr[k]` 了。

使用哈希表优化之后的代码如下：

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        ans = 0
        idx_map = dict()
        for idx, value in enumerate(arr):
            idx_map[value] = idx
        
        for i in range(size):
            for j in range(i + 1, size):
                temp_ans = 0
                temp_i = i
                temp_j = j
                while arr[temp_i] + arr[temp_j] in idx_map:
                    temp_ans += 1
                    k = idx_map[arr[temp_i] + arr[temp_j]]
                    temp_i = temp_j
                    temp_j = k

                if temp_ans > ans:
                    ans = temp_ans

        if ans > 0:
            return ans + 2
        else:
            return ans
```

再次提交，通过了。

但是，这道题我们还可以用动态规划来做。

**3. 动态规划做法：**

这道题用动态规划来做，难点在于如何「定义状态」和「定义状态转移方程」。

- 定义状态：`dp[i][j]` 表示以 `arr[i]`、`arr[j]` 为结尾的斐波那契式子序列的最大长度。
- 定义状态转移方程：$dp[j][k] = max_{(arr[i] + arr[j] = arr[k], i < j < k)}(dp[i][j] + 1)$
    - 意思为：以 `arr[j]`、`arr[k]` 结尾的斐波那契式子序列的最大长度 = 满足 `arr[i] + arr[j] = arr[k]` 条件下，以 `arr[i]`、`arr[j]` 结尾的斐波那契式子序列的最大长度 + 1。

但是直接这样做其实跟 **1. 暴力解法** 一样仍会超时，所以我们依旧采用哈希表优化的方式来提高效率，降低算法的时间复杂度。

具体代码如下：

## 代码

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        size = len(arr)
        # 初始化 dp
        dp = [[0 for _ in range(size)] for _ in range(size)]
        ans = 0
        idx_map = {}
        # 将 value : idx 映射为哈希表，这样可以快速通过 value 获取到 idx
        for idx, value in enumerate(arr):
            idx_map[value] = idx

        for i in range(size):
            for j in range(i + 1, size):
                if arr[i] + arr[j] in idx_map:
                    # 获取 arr[i] + arr[j] 的 idx，即斐波那契式子序列下一项元素
                    k = idx_map[arr[i] + arr[j]]

                    dp[j][k] = max(dp[j][k], dp[i][j] + 1)
                    ans = max(ans, dp[j][k])

        if ans > 0:
            return ans + 2
        else:
            return ans
```

# [剑指 Offer II 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

- 标签：字符串、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 095. 最长公共子序列 - 力扣](https://leetcode.cn/problems/qJnOS7/)

## 题目大意

给定两个字符串 `text1` 和 `text2`。

要求：返回两个字符串的最长公共子序列的长度。如果不存在公共子序列，则返回 `0`。

- 子序列：原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
- 公共子序列：两个字符串所共同拥有的子序列。

## 解题思路

用动态规划来做。

动态规划的状态 `dp[i][j]` 表示为：前 `i` 个字符组成的字符串 `str1` 与前 `j` 个字符组成的字符串 `str2` 的最长公共子序列长度为 `dp[i][j]`。

遍历字符串 `text1` 和 `text2`，则状态转移方程为：

- 如果 `text1[i - 1] == text2[j - 1]`，则找到了一个公共元素，则 `dp[i][j] = dp[i - 1][j - 1] + 1`。
- 如果 `text1[i - 1] != text2[j - 1]`，则 `dp[i][j]` 需要考虑两种情况，取其中最大的那种：
    - `text1` 前 `i - 1` 个字符组成的字符串 `str1` 与 `text2` 前 `j` 个字符组成的 `str2` 的最长公共子序列长度，即 `dp[i - 1][j]`。
    - `text1` 前 `i` 个字符组成的字符串 `str1` 与 `text2` 前 `j - 1` 个字符组成的 `str2` 的最长公共子序列长度，即 `dp[i][j - 1]`。

最后输出 `dp[sise1][size2]` 即可，`size1`、`size2` 分别为 `text1`、`text2` 的字符串长度。

## 代码

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        size1 = len(text1)
        size2 = len(text2)
        dp = [[0 for _ in range(size2 + 1)] for _ in range(size1 + 1)]
        for i in range(1, size1 + 1):
            for j in range(1, size2 + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[size1][size2]
```

# [剑指 Offer II 097. 子序列的数目](https://leetcode.cn/problems/21dk04/)

- 标签：字符串、动态规划
- 难度：困难

## 题目链接

- [剑指 Offer II 097. 子序列的数目 - 力扣](https://leetcode.cn/problems/21dk04/)

## 题目大意

给定两个字符串 `s` 和 `t`。

要求：计算在 `s` 的子序列中 `t` 出现的个数。

## 解题思路

动态规划求解。

定义状态 `dp[i][j]`表示为：以 `i - 1` 为结尾的 `s` 子序列中出现以 `j - 1` 为结尾的 `t` 的个数。

则状态转移方程为：

- 如果 `s[i - 1] == t[j - 1]`，则：`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`。即 `dp[i][j]` 来源于两部分：
    - 使用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于以 `i - 2` 为结尾的 `s` 子序列中出现以 `j - 2` 为结尾的 `t` 的个数，即 `dp[i - 1][j - 1]`。
    - 不使用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于以 `i - 2` 为结尾的 `s` 子序列中出现以 `j - 1` 为结尾的 `t` 的个数，即 `dp[i - 1][j]`。
- 如果 `s[i - 1] != t[j - 1]`，那么肯定不能用 `s[i - 1]` 匹配 `t[j - 1]`，则 `dp[i][j]` 取源于 `dp[i - 1][j]`。

下面来看看初始化：

- `dp[i][0]` 表示以 `i - 1` 为结尾的 `s` 子序列中出现空字符串的个数。把 `s` 中的元素全删除，出现空字符串的个数就是 `1`，则 `dp[i][0] = 1`。
- `dp[0][j]` 表示空字符串中出现以 `j - 1` 结尾的 `t` 的个数，空字符串无论怎么变都不会变成 `t`，则 `dp[0][j] = 0`
- `dp[0][0]` 表示空字符串中出现空字符串的个数，这个应该是 `1`，即 `dp[0][0] = 1`。

然后递推求解，最后输出 `dp[size_s][size_t]`。

## 代码

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        size_s = len(s)
        size_t = len(t)
        dp = [[0 for _ in range(size_t + 1)] for _ in range(size_s + 1)]
        for i in range(size_s):
            dp[i][0] = 1
        for i in range(1, size_s + 1):
            for j in range(1, size_t + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[size_s][size_t]
```

# [剑指 Offer II 098. 路径的数目](https://leetcode.cn/problems/2AoeFn/)

- 标签：数学、动态规划、组合数学
- 难度：中等

## 题目链接

- [剑指 Offer II 098. 路径的数目 - 力扣](https://leetcode.cn/problems/2AoeFn/)

## 题目大意

给定一个 `m * n` 的棋盘， 机器人在左上角的位置，机器人每次只能向右、或者向下移动一步。

要求：求出到达棋盘右下角共有多少条不同的路径。

## 解题思路

可以用动态规划求解，设 `dp[i][j]` 是从 `(0, 0)`到 `(i, j)` 的不同路径数。显然 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。对于第一行、第一列，因为只能超一个方向走，所以 `dp[i][0] = 1`，`dp[0][j] = 1`。

## 代码

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1 for _ in range(n)]
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[-1]
```

# [剑指 Offer II 101. 分割等和子集](https://leetcode.cn/problems/NUPfPr/)

- 标签：数学、字符串、模拟
- 难度：简单

## 题目链接

- [剑指 Offer II 101. 分割等和子集 - 力扣](https://leetcode.cn/problems/NUPfPr/)

## 题目大意

给定一个只包含正整数的非空数组 `nums`。

要求：判断是否可以将这个数组分成两个子集，使得两个子集的元素和相等。

## 解题思路

动态规划求解。

如果两个子集和相等，则两个子集元素和刚好等于整个数组元素和的一半。这就相当于 `0-1` 背包问题。

定义 `dp[i][j]` 表示从 `[0, i]` 个数中任意选取一些数，放进容量为 j 的背包中，价值总和最大为多少。则 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])`。

转换为一维 dp 就是：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`。

然后进行递归求解。最后判断 `dp[target]` 和 `target` 是否相等即可。

## 代码

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        size = 100010
        dp = [0 for _ in range(size)]
        sum_nums = sum(nums)
        if sum_nums & 1:
            return False
        target = sum_nums // 2
        for i in range(len(nums)):
            for j in range(target, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])

        if dp[target] == target:
            return True
        return False
```

# [剑指 Offer II 102. 加减的目标值](https://leetcode.cn/problems/YaVDxD/)

- 标签：数组、动态规划、回溯
- 难度：中等

## 题目链接

- [剑指 Offer II 102. 加减的目标值 - 力扣](https://leetcode.cn/problems/YaVDxD/)

## 题目大意

给定一个整数数组 `nums` 和一个整数 `target`。数组长度不超过 `20`。向数组中每个整数前加 `+` 或 `-`。然后串联起来构造成一个表达式。

要求：返回通过上述方法构造的、运算结果等于 `target` 的不同表达式数目。

## 解题思路

暴力方法就是使用深度优先搜索对每位数字遍历 `+`、`-`，并统计符合要求的表达式数目。但是实际发现超时了。所以采用动态规划的方法来做。

假设数组中所有元素和为 `sum`，数组中所有符号为 `+` 的元素为 `sum_x`，符号为 `-` 的元素和为 `sum_y`。则 `target = sum_x - sum_y`。

而 `sum_x + sum_y = sum`。根据两个式子可以求出 `2 * sum_x = target + sum `，即 `sum_x = (target + sum) / 2`。

那么这道题就变成了，如何在数组中找到一个集合，使集合中元素和为 `(target + sum) / 2`。这就变为了求容量为 `(target + sum) / 2` 的 `01` 背包问题。

动态规划的状态 `dp[i]` 表示为：填满容量为 `i` 的背包，有 `dp[i]` 种方法。

动态规划的状态转移方程为：`dp[i] = dp[i] + dp[i-num]`，意思为填满容量为 `i` 的背包的方法数 = 不使用当前 `num`，只使用之前元素填满容量为 `i` 的背包的方法数 + 填满容量 `i - num` 的包的方法数，再填入 `num` 的方法数。

## 代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sum_nums = sum(nums)
        if target > sum_nums or (target + sum_nums) % 2 == 1:
            return 0
        size = (target + sum_nums) // 2
        dp = [0 for _ in range(size + 1)]
        dp[0] = 1
        for num in nums:
            for i in range(size, num - 1, -1):
                dp[i] = dp[i] + dp[i - num]
        return dp[size]
```

# [剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/)

- 标签：广度优先搜索、数组、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 103. 最少的硬币数目 - 力扣](https://leetcode.cn/problems/gaM7Ch/)

## 题目大意

给定不同面额的硬币 `coins` 和一个总金额 `amount`。

乔秋：计算出凑成总金额所需的最少的硬币个数。如果无法凑出，则返回 `-1`。

## 解题思路

完全背包问题。

可以转换为有 `n` 枚不同的硬币，每种硬币可以无限次使用。凑成总金额为 `amount` 的背包，最少需要多少硬币。

动态规划的状态 `dp[i]` 可以表示为：凑成总金额为 `i` 的组合中，至少有 `dp[i]` 枚硬币。

动态规划的状态转移方程为：`dp[i] = min(dp[i], + dp[i-coin] + 1`，意思为凑成总金额为 `i` 最少硬币数量 = 「不使用当前 `coin`，只使用之前硬币凑成金额 `i` 的最少硬币数量」和「凑成金额 `i - num` 的最少硬币数量，再加上当前硬币」两者的较小值。

## 代码

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf') for _ in range(amount + 1)]
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)

        if dp[amount] != float('inf'):
            return dp[amount]
        else:
            return -1
```

# [剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/)

- 标签：数组、动态规划
- 难度：中等

## 题目链接

- [剑指 Offer II 104. 排列的数目 - 力扣](https://leetcode.cn/problems/D0F0SV/)

## 题目大意

给定一个由不同整数组成的数组 `nums` 和一个目标整数 `target`。

要求：从 `nums` 中找出并返回总和为 `target` 的元素组合个数。

## 解题思路

完全背包问题。题目求解的是组合数。

动态规划的状态 `dp[i]` 可以表示为：凑成总和 `i` 的组合数。

动态规划的状态转移方程为：`dp[i] = dp[i] + dp[i - nums[j]]`，意思为凑成总和为 `i` 的组合数 = 「不使用当前 `nums[j]`，只使用之前整数凑成和为 `i` 的组合数」+「使用当前 `nums[j]` 凑成金额 `i - nums[j]` 的方案数」。

最终输出 `dp[target]`。

## 代码

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1
        size = len(nums)
        for i in range(target + 1):
            for j in range(size):
                if i - nums[j] >= 0:
                    dp[i] += dp[i - nums[j]]
        return dp[target]
```

# [剑指 Offer II 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/)

- 标签：深度优先搜索、广度优先搜索、并查集、数组、矩阵
- 难度：中等

## 题目链接

- [剑指 Offer II 105. 岛屿的最大面积 - 力扣](https://leetcode.cn/problems/ZL6zAn/)

## 题目大意

给定一个只包含 `0`、`1` 元素的二维数组，`1` 代表岛屿，`0` 代表水。一座岛的面积就是上下左右相邻相邻的 `1` 所组成的连通块的数目。找到最大的岛屿面积。

## 解题思路

使用深度优先搜索方法。遍历二维数组的每一个元素，对于每个值为 `1` 的元素，记下其面积。然后将该值置为 `0`（防止二次重复计算），再递归其上下左右四个位置，并将深度优先搜索搜到的值为 `1` 的元素个数，进行累积统计。

## 代码

```python
class Solution:
    def dfs(self, grid, i, j):
        size_n = len(grid)
        size_m = len(grid[0])
        if i < 0 or i >= size_n or j < 0 or j >= size_m or grid[i][j] == 0:
            return 0
        ans = 1
        grid[i][j] = 0
        ans += self.dfs(grid, i + 1, j)
        ans += self.dfs(grid, i, j + 1)
        ans += self.dfs(grid, i - 1, j)
        ans += self.dfs(grid, i, j - 1)
        return ans

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    ans = max(ans, self.dfs(grid, i, j))
        return ans
```

# [剑指 Offer II 106. 二分图](https://leetcode.cn/problems/vEAB3K/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [剑指 Offer II 106. 二分图 - 力扣](https://leetcode.cn/problems/vEAB3K/)

## 题目大意

给定一个代表 n 个节点的无向图的二维数组 `graph`，其中 `graph[u]` 是一个节点数组，由节点 `u` 的邻接节点组成。对于 `graph[u]` 中的每个 `v`，都存在一条位于节点 `u` 和节点 `v` 之间的无向边。

该无向图具有以下属性：

- 不存在自环（`graph[u]` 不包含 `u`）。
- 不存在平行边（`graph[u]` 不包含重复值）。
- 如果 `v` 在 `graph[u]` 内，那么 `u` 也应该在 `graph[v]` 内（该图是无向图）。
- 这个图可能不是连通图，也就是说两个节点 `u` 和 `v` 之间可能不存在一条连通彼此的路径。

要求：判断该图是否是二分图，如果是二分图，则返回 `True`；否则返回 `False`。

- 二分图：如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B`，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 二分图 。

## 解题思路

对于图中的任意节点 `u` 和 `v`，如果 `u` 和 `v` 之间有一条无向边，那么 `u` 和 `v` 必然属于不同的集合。

我们可以通过在深度优先搜索中对邻接点染色标记的方式，来识别该图是否是二分图。具体做法如下：

- 找到一个没有染色的节点 `u`，将其染成红色。
- 然后遍历该节点直接相连的节点 `v`，如果该节点没有被染色，则将该节点直接相连的节点染成蓝色，表示两个节点不是同一集合。如果该节点已经被染色并且颜色跟 `u` 一样，则说明该图不是二分图，直接返回 `False`。
- 从上面染成蓝色的节点 `v` 出发，遍历该节点直接相连的节点。。。依次类推的递归下去。
- 如果所有节点都顺利染上色，则说明该图为二分图，返回 `True`。否则，如果在途中不能顺利染色，则返回 `False`。

## 代码

```python
class Solution:
    def dfs(self, graph, colors, i, color):
        colors[i] = color
        for j in graph[i]:
            if colors[j] == colors[i]:
                return False
            if colors[j] == 0 and not self.dfs(graph, colors, j, -color):
                return False
        return True

    def isBipartite(self, graph: List[List[int]]) -> bool:
        size = len(graph)
        colors = [0 for _ in range(size)]
        for i in range(size):
            if colors[i] == 0 and not self.dfs(graph, colors, i, 1):
                return False
        return True
```

# [剑指 Offer II 107. 矩阵中的距离](https://leetcode.cn/problems/2bCMpM/)

- 标签：广度优先搜索、数组、动态规划、矩阵
- 难度：中等

## 题目链接

- [剑指 Offer II 107. 矩阵中的距离 - 力扣](https://leetcode.cn/problems/2bCMpM/)

## 题目大意

给定一个由 `0` 和 `1` 组成的矩阵，两个相邻元素间的距离为 `1` 。

要求：找出每个元素到最近的 `0` 的距离，并输出为矩阵。

## 解题思路

题目要求的是每个 `1` 到 `0`的最短曼哈顿距离。换句话也可以求每个 `0` 到 `1` 的最短曼哈顿距离。这样做的好处是，可以从所有值为 `0` 的元素开始进行搜索，可以不断累积距离，直到遇到值为 `1` 的元素时，可以直接将累积距离直接赋值。

具体操作如下：将所有值为 `0` 的元素坐标加入访问集合中，对所有值为`0` 的元素上下左右进行搜索。每进行一次上下左右搜索，更新新位置的距离值，并把新的位置坐标加入队列和访问集合中，直到遇见值为 `1` 的元素停止搜索。

## 代码

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        row_count = len(mat)
        col_count = len(mat[0])
        dist_map = [[0 for _ in range(col_count)] for _ in range(row_count)]
        zeroes_pos = []
        for i in range(row_count):
            for j in range(col_count):
                if mat[i][j] == 0:
                    zeroes_pos.append((i, j))

        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        queue = collections.deque(zeroes_pos)
        visited = set(zeroes_pos)

        while queue:
            i, j = queue.popleft()
            for direction in directions:
                new_i = i + direction[0]
                new_j = j + direction[1]
                if 0 <= new_i < row_count and 0 <= new_j < col_count and (new_i, new_j) not in visited:
                    dist_map[new_i][new_j] = dist_map[i][j] + 1
                    queue.append((new_i, new_j))
                    visited.add((new_i, new_j))
        return dist_map
```

# [剑指 Offer II 108. 单词演变](https://leetcode.cn/problems/om3reC/)

- 标签：广度优先搜索、哈希表、字符串
- 难度：困难

## 题目链接

- [剑指 Offer II 108. 单词演变 - 力扣](https://leetcode.cn/problems/om3reC/)

## 题目大意

给定两个单词 `beginWord` 和 `endWord`，以及一个字典 `wordList`。找到从 `beginWord` 到 `endWord` 的最短转换序列中的单词数目。如果不存在这样的转换序列，则返回 0。

转换需要遵守的规则如下：

- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须为字典中的单词。

## 解题思路

广度优先搜索。使用队列存储将要遍历的单词和单词数目。

从 `beginWord` 开始变换，把单词的每个字母都用 `a ~ z` 变换一次，变换后的单词是否是 `endWord`，如果是则直接返回。

否则查找变换后的词是否在 `wordList` 中。如果在 `wordList` 中找到就加入队列，找不到就输出 `0`。然后按照广度优先搜索的算法急需要遍历队列中的节点，直到所有单词都出队时结束。

## 代码

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if not wordList or endWord not in wordList:
            return 0
        word_set = set(wordList)
        if beginWord in word_set:
            word_set.remove(beginWord)

        queue = collections.deque()
        queue.append((beginWord, 1))
        while queue:
            word, level = queue.popleft()
            if word == endWord:
                return level

            for i in range(len(word)):
                for j in range(26):
                    new_word = word[:i] + chr(ord('a') + j) + word[i + 1:]
                    if new_word in word_set:
                        word_set.remove(new_word)
                        queue.append((new_word, level + 1))

        return 0
```

# [剑指 Offer II 109. 开密码锁](https://leetcode.cn/problems/zlDJc7/)

- 标签：广度优先搜索、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [剑指 Offer II 109. 开密码锁 - 力扣](https://leetcode.cn/problems/zlDJc7/)

## 题目大意

有一把带有四个数字的密码锁，每个位置上有 0~9 共 10 个数字。每次只能将其中一个位置上的数字转动一下。可以向上转，也可以向下转。比如：1 -> 2、2 -> 1。

密码锁的初始数字为：`0000`。现在给定一组表示死亡数字的字符串数组 `deadends`，和一个带有四位数字的目标字符串 `target`。

如果密码锁转动到 `deadends` 中任一字符串状态，则锁就会永久锁定，无法再次旋转。

要求：求出最小的选择次数，使得锁的状态由 `0000` 转动到 `target`。

## 解题思路

使用宽度优先搜索遍历，将`0000` 状态入队。

- 将队列中的元素出队，判断是否为死亡字符串
- 如果为死亡字符串，则跳过该状态，否则继续执行。

- 如果为目标字符串，则返回当前路径长度，否则继续执行。
- 枚举当前状态所有位置所能到达的所有状态，并判断是否访问过该状态。

- 如果之前出现过该状态，则继续执行，否则将其存入队列，并标记访问。

## 代码

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        queue = collections.deque(['0000'])
        visited = set(['0000'])
        deadset = set(deadends)
        level = 0
        while queue:
            size = len(queue)
            for _ in range(size):
                cur = queue.popleft()
                if cur in deadset:
                    continue
                if cur == target:
                    return level
                for i in range(len(cur)):
                    up = self.upward_adjust(cur, i)
                    if up not in visited:
                        queue.append(up)
                        visited.add(up)
                    down = self.downward_adjust(cur, i)
                    if down not in visited:
                        queue.append(down)
                        visited.add(down)
            level += 1
        return -1

    def upward_adjust(self, s, i):
        s_list = list(s)
        if s_list[i] == '9':
            s_list[i] = '0'
        else:
            s_list[i] = chr(ord(s_list[i]) + 1)
        return "".join(s_list)

    def downward_adjust(self, s, i):
        s_list = list(s)
        if s_list[i] == '0':
            s_list[i] = '9'
        else:
            s_list[i] = chr(ord(s_list[i]) - 1)
        return "".join(s_list)
```

# [剑指 Offer II 111. 计算除法](https://leetcode.cn/problems/vlzXQL/)

- 标签：深度优先搜索、广度优先搜索、并查集、图、数组、最短路
- 难度：中等

## 题目链接

- [剑指 Offer II 111. 计算除法 - 力扣](https://leetcode.cn/problems/vlzXQL/)

## 题目大意

给定一个变量对数组 `equations` 和一个实数数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]`  和 `values[i]` 共同表示 `Ai / Bi = values[i]`。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

再给定一个表示多个问题的数组 `queries`，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，要求：根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。返回所有问题的答案。如果某个答案无法确定，则用 `-1.0` 代替，如果问题中出现了给定的已知条件中没有出现的表示变量的字符串，则也用 `-1.0` 代替这个答案。

## 解题思路

在「[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations)」的基础上增加了倍数关系。在「[等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations)」中我们处理传递关系使用了并查集，这道题也是一样，不过在使用并查集的同时还要维护倍数关系。

举例说明：

- `a / b = 2.0`：说明 `a = 2b`，`a` 和 `b` 在同一个集合。
- `b / c = 3.0`：说明 `b = 3c`，`b`  和 `c`  在同一个集合。

根据上述两式可得：`a`、`b`、`c` 都在一个集合中，且 `a = 2b = 6c`。

我们可以将同一集合中的变量倍数关系都转换为与根节点变量的倍数关系，比如上述例子中都转变为与 `a` 的倍数关系。

具体操作如下：

- 定义并查集结构，并在并查集中定义一个表示倍数关系的 `multiples` 数组。
- 遍历 `equations` 数组、`values` 数组，将每个变量按顺序编号，并使用 `union` 将其并入相同集合。
- 遍历 `queries` 数组，判断两个变量是否在并查集中，并且是否在同一集合。如果找到对应关系，则将计算后的倍数关系存入答案数组，否则则将 `-1` 存入答案数组。
- 最终输出答案数组。

并查集中维护倍数相关方法说明：

- `find` 方法： 
    - 递推寻找根节点，并将倍数累乘，然后进行路径压缩，并且更新当前节点的倍数关系。
- `union` 方法：
    - 如果两个节点属于同一集合，则直接返回。
    - 如果两个节点不属于同一个集合，合并之前当前节点的倍数关系更新，然后再进行更新。
- `is_connect` 方法：
    - 如果两个节点不属于同一集合，返回 `-1`。
    - 如果两个节点属于同一集合，则返回倍数关系。

## 代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.multiples = [1 for _ in range(n)]

    def find(self, x):
        multiple = 1.0
        origin = x
        while x != self.parent[x]:
            multiple *= self.multiples[x]
            x = self.parent[x]
        self.parent[origin] = x
        self.multiples[origin] = multiple
        return x

    def union(self, x, y, multiple):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        self.parent[root_x] = root_y
        self.multiples[root_x] = multiple * self.multiples[y] / self.multiples[x]
        return

    def is_connected(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            return -1.0

        return self.multiples[x] / self.multiples[y]

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        equations_size = len(equations)
        hash_map = dict()
        union_find = UnionFind(2 * equations_size)

        id = 0
        for i in range(equations_size):
            equation = equations[i]
            var1, var2 = equation[0], equation[1]
            if var1 not in hash_map:
                hash_map[var1] = id
                id += 1
            if var2 not in hash_map:
                hash_map[var2] = id
                id += 1
            union_find.union(hash_map[var1], hash_map[var2], values[i])

        queries_size = len(queries)
        res = []
        for i in range(queries_size):
            query = queries[i]
            var1, var2 = query[0], query[1]
            if var1 not in hash_map or var2 not in hash_map:
                res.append(-1.0)
            else:
                id1 = hash_map[var1]
                id2 = hash_map[var2]
                res.append(union_find.is_connected(id1, id2))

        return res
```

# [剑指 Offer II 112. 最长递增路径](https://leetcode.cn/problems/fpTFWP/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序、记忆化搜索、数组、动态规划、矩阵
- 难度：困难

## 题目链接

- [剑指 Offer II 112. 最长递增路径 - 力扣](https://leetcode.cn/problems/fpTFWP/)

## 题目大意

给定一个 `m * n` 大小的整数矩阵 `matrix`。要求：找出其中最长递增路径的长度。

对于每个单元格，可以往上、下、左、右四个方向移动，不能向对角线方向移动或移动到边界外。

## 解题思路

深度优先搜索。使用二维数组 `record` 存储遍历过的单元格最大路径长度，已经遍历过的单元格就不需要再次遍历了。

## 代码

```python
class Solution:
    max_len = 0
    directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        rows, cols = len(matrix), len(matrix[0])
        record = [[0 for _ in range(cols)] for _ in range(rows)]

        def dfs(i, j):
            record[i][j] = 1
            for direction in self.directions:
                new_i, new_j = i + direction[0], j + direction[1]
                if 0 <= new_i < rows and 0 <= new_j < cols and matrix[new_i][new_j] > matrix[i][j]:
                    if record[new_i][new_j] == 0:
                        dfs(new_i, new_j)
                    record[i][j] = max(record[i][j], record[new_i][new_j] + 1)
            self.max_len = max(self.max_len, record[i][j])

        for i in range(rows):
            for j in range(cols):
                if record[i][j] == 0:
                    dfs(i, j)
        return self.max_len
```

# [剑指 Offer II 113. 课程顺序](https://leetcode.cn/problems/QA2IGt/)

- 标签：深度优先搜索、广度优先搜索、图、拓扑排序
- 难度：中等

## 题目链接

- [剑指 Offer II 113. 课程顺序 - 力扣](https://leetcode.cn/problems/QA2IGt/)

## 题目大意

给定一个整数 `numCourses`，代表这学期必须选修的课程数量，课程编号为 `0` 到 `numCourses - 1`。再给定一个数组 `prerequisites` 表示先修课程关系，其中 `prerequisites[i] = [ai, bi]` 表示如果要学习课程 `ai` 则必须要学习课程 `bi`。

要求：返回学完所有课程所安排的学习顺序。如果有多个正确的顺序，只要返回其中一种即可。如果无法完成所有课程，则返回空数组。

## 解题思路

拓扑排序。这道题是「[0207. 课程表](https://leetcode.cn/problems/course-schedule/)」的升级版，只需要在上一题的基础上增加一个答案数组即可。

1. 使用列表 `edges` 存放课程关系图，并统计每门课程节点的入度，存入入度列表 `indegrees`。

2. 借助队列 `queue`，将所有入度为 `0` 的节点入队。

3. 从队列中选择一个节点，并将其加入到答案数组 `res` 中，再让课程数 -1。
4. 将该顶点以及该顶点为出发点的所有边的另一个节点入度 -1。如果入度 -1 后的节点入度不为 `0`，则将其加入队列 `queue`。
5. 重复 3~4 的步骤，直到队列中没有节点。
6. 最后判断剩余课程数是否为 `0`，如果为 `0`，则返回答案数组 `res`，否则，返回空数组。

## 代码

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        indegrees = [0 for _ in range(numCourses)]
        edges = collections.defaultdict(list)
        res = []
        for x, y in prerequisites:
            edges[y].append(x)
            indegrees[x] += 1
        queue = collections.deque([])
        for i in range(numCourses):
            if not indegrees[i]:
                queue.append(i)
        while queue:
            y = queue.popleft()
            res.append(y)
            numCourses -= 1
            for x in edges[y]:
                indegrees[x] -= 1
                if not indegrees[x]:
                    queue.append(x)
        if not numCourses:
            return res
        else:
            return []
```

# [剑指 Offer II 116. 省份数量](https://leetcode.cn/problems/bLyHh0/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [剑指 Offer II 116. 省份数量 - 力扣](https://leetcode.cn/problems/bLyHh0/)

## 题目大意

一个班上有 `n` 个同学，其中一些彼此是朋友，另一些不是。如果 `a` 与 `b` 是直接朋友，且 `b` 与 `c` 也是直接朋友，那么 `a` 与 `c` 是间接朋友。

现在定义「朋友圈」是由一组直接或间接朋友组成的集合。

现在给定一个 `n * n` 的矩阵 `isConnected` 表示班上的朋友关系。其中 `isConnected[i][j] = 1` 表示第 `i` 个同学和第 `j` 个同学是直接朋友，`isConnected[i][j] = 0` 表示第 `i` 个同学和第 `j` 个同学不是直接朋友。

要求：根据给定的同学关系，返回「朋友圈」的数量。

## 解题思路

可以利用并查集来做。具体做法如下：

遍历矩阵 `isConnected`。如果 `isConnected[i][j] = 1`，将 `i` 节点和 `j` 节点相连。然后判断每个同学节点的根节点，然后统计不重复的根节点有多少个，即为「朋友圈」的数量。

## 代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return

        self.parent[root_x] = root_y
        self.count -= 1

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        size = len(isConnected)
        union_find = UnionFind(size)
        for i in range(size):
            for j in range(i + 1, size):
                if isConnected[i][j] == 1:
                    union_find.union(i, j)

        return union_find.count
```

# [剑指 Offer II 118. 多余的边](https://leetcode.cn/problems/7LpjUW/)

- 标签：深度优先搜索、广度优先搜索、并查集、图
- 难度：中等

## 题目链接

- [剑指 Offer II 118. 多余的边 - 力扣](https://leetcode.cn/problems/7LpjUW/)

## 题目大意

一个 `n` 个节点的树（节点值为 `1~n`）添加一条边后就形成了图，添加的这条边不属于树中已经存在的边。图的信息记录存储与长度为 `n` 的二维数组 `edges`，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

现在给定代表边信息的二维数组 `edges`。

要求：找到一条可以山区的边，使得删除后的剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。

## 解题思路

树可以看做是无环的图，这道题就是要找出那条添加边之后成环的边。可以考虑用并查集来做。

从前向后遍历每一条边，如果边的两个节点不在同一个集合，就加入到一个集合（链接到同一个根节点）。如果边的节点已经出现在同一个集合里，说明边的两个节点已经连在一起了，再加入这条边一定会出现环，则这条边就是所求答案。

## 代码

```python
class UnionFind:

    def __init__(self, n):
        self.parent = [i for i in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        self.parent[root_x] = root_y

    def is_connected(self, x, y):
        return self.find(x) == self.find(y)

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        size = len(edges)
        union_find = UnionFind(size + 1)

        for edge in edges:
            if union_find.is_connected(edge[0], edge[1]):
                return edge
            union_find.union(edge[0], edge[1])

        return None
```

# [剑指 Offer II 119. 最长连续序列](https://leetcode.cn/problems/WhsWhI/)

- 标签：并查集、数组、哈希表
- 难度：中等

## 题目链接

- [剑指 Offer II 119. 最长连续序列 - 力扣](https://leetcode.cn/problems/WhsWhI/)

## 题目大意

给定一个未排序的整数数组 `nums`。

要求：找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。并且要用时间复杂度为 $O(n)$ 的算法解决此问题。

## 解题思路

暴力做法有两种思路。第 1 种思路是先排序再依次判断，这种做法时间复杂度最少是 $O(n \log n)$。第 2 种思路是枚举数组中的每个数 `num`，考虑以其为起点，不断尝试匹配 `num + 1`、`num + 2`、`...` 是否存在，最长匹配次数为 `len(nums)`。这样下来时间复杂度为 $O(n^2)$。但是可以使用集合或哈希表优化这个步骤。

- 先将数组存储到集合中进行去重，然后使用 `curr_streak` 维护当前连续序列长度，使用 `ans` 维护最长连续序列长度。
- 遍历集合中的元素，对每个元素进行判断，如果该元素不是序列的开始（即 `num - 1` 在集合中），则跳过。
- 如果 `num - 1` 不在集合中，说明 `num` 是序列的开始，判断 `num + 1` 、`nums + 2`、`...` 是否在哈希表中，并不断更新当前连续序列长度 `curr_streak`。并在遍历结束之后更新最长序列的长度。
- 最后输出最长序列长度。

将数组存储到集合中进行去重的操作的时间复杂度是 $O(n)$。查询每个数是否在集合中的时间复杂度是 $O(1)$ ，并且跳过了所有不是起点的元素。更新当前连续序列长度 `curr_streak` 的时间复杂度是 $O(n)$，所以最终的时间复杂度是 $O(n)$。符合题意要求。

## 代码

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        ans = 0
        nums_set = set(nums)
        for num in nums_set:
            if num - 1 not in nums_set:
                curr_num = num
                curr_streak = 1

                while curr_num + 1 in nums_set:
                    curr_num += 1
                    curr_streak += 1
                ans = max(ans, curr_streak)

        return ans
```

# [面试题 01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

- 标签：数组、数学、矩阵
- 难度：中等

## 题目链接

- [面试题 01.07. 旋转矩阵 - 力扣](https://leetcode.cn/problems/rotate-matrix-lcci/)

## 题目大意

给定一个 `n * n` 大小的二维矩阵用来表示图像，其中每个像素的大小为 4 字节。

要求：设计一种算法，将图像旋转 90 度。并且要不占用额外内存空间。

## 解题思路

题目要求不占用额外内存空间，就是要在原二维矩阵上直接进行旋转操作。我们可以用翻转操作代替旋转操作。具体可以分为两步：

1. 上下翻转。

2. 主对角线翻转。

举个例子：

```
 1  2  3  4
 5  6  7  8
 9 10 11 12              
13 14 15 16              
```

上下翻转后变为：

```
13 14 15 16
 9 10 11 12
 5  6  7  8
 1  2  3  4 
```

在经过主对角线翻转后变为：

```
13  9  5  1
14 10  6  2
15 11  7  3
16 12  8  4
```

## 代码

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        size = len(matrix)
        for i in range(size // 2):
            for j in range(size):
                matrix[i][j], matrix[size - i - 1][j] = matrix[size - i - 1][j], matrix[i][j]
        for i in range(size):
            for j in range(i):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

# [面试题 01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/)

- 标签：数组、哈希表、矩阵
- 难度：中等

## 题目链接

- [面试题 01.08. 零矩阵 - 力扣](https://leetcode.cn/problems/zero-matrix-lcci/)

## 题目大意

给定一个 `m * n` 大小的二维矩阵 `matrix`。

要求：编写一种算法，如果矩阵中某个元素为 `0`，增将其所在行与列清零。

## 解题思路

直观上可以使用两个数组或者集合来标记行和列出现 `0` 的情况，但更好的做法是不用开辟新的数组或集合，直接原本二维矩阵 `matrix` 的空间。使用数组原本的元素进行记录出现 0 的情况。

设定两个变量 `flag_row0`、`flag_col0` 来标记第一行、第一列是否出现了 `0`。

接下来我们使用数组第一行、第一列来标记 `0` 的情况。

对数组除第一行、第一列之外的每个元素进行遍历，如果某个元素出现 `0` 了，则使用数组的第一行、第一列对应位置来存储 `0` 的标记。

再对数组除第一行、第一列之外的每个元素进行遍历，通过对第一行、第一列的标记 0 情况，进行置为 `0` 的操作。

最后再根据 `flag_row0`、`flag_col0` 的标记情况，对第一行、第一列进行置为 `0` 的操作。

## 代码

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        rows = len(matrix)
        cols = len(matrix[0])
        flag_col0 = False
        flag_row0 = False
        for i in range(rows):
            if matrix[i][0] == 0:
                flag_col0 = True
                break

        for j in range(cols):
            if matrix[0][j] == 0:
                flag_row0 = True
                break

        for i in range(1, rows):
            for j in range(1, cols):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0

        for i in range(1, rows):
            for j in range(1, cols):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

        if flag_col0:
            for i in range(rows):
                matrix[i][0] = 0

        if flag_row0:
            for j in range(cols):
                matrix[0][j] = 0
```

# [面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

- 标签：链表、双指针
- 难度：简单

## 题目链接

- [面试题 02.02. 返回倒数第 k 个节点 - 力扣](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

## 题目大意

给定一个链表的头节点 `head`，以及一个整数 `k`。

要求：返回链表的倒数第 `k` 个节点的值。

## 解题思路

常规思路是遍历一遍链表，求出链表长度，再遍历一遍到对应位置，返回该位置上的节点。

如果用一次遍历实现的话，可以使用快慢指针。让快指针先走 `k` 步，然后快慢指针、慢指针再同时走，每次一步，这样等快指针遍历到链表尾部的时候，慢指针就刚好遍历到了倒数第 `k` 个节点位置。返回该该位置上的节点即可。

## 代码

```python
class Solution:
    def kthToLast(self, head: ListNode, k: int) -> int:
        slow = head
        fast = head
        for _ in range(k):
            if fast == None:
                return fast
            fast = fast.next
        while fast:
            slow = slow.next
            fast = fast.next
        return slow.val
```

# [面试题 02.05. 链表求和](https://leetcode.cn/problems/sum-lists-lcci/)

- 标签：递归、链表、数学
- 难度：中等

## 题目链接

- [面试题 02.05. 链表求和 - 力扣](https://leetcode.cn/problems/sum-lists-lcci/)

## 题目大意

给定两个非空的链表 `l1` 和 `l2`，表示两个非负整数，每位数字都是按照逆序的方式存储的，每个节点存储一位数字。

要求：计算两个整数的和，并逆序返回表示和的链表。

## 解题思路

模拟大数加法，按位相加，将结果添加到新链表上。需要注意进位和对 `10` 取余。

## 代码

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = curr = ListNode(0)
        carry = 0
        while l1 or l2 or carry:
            if l1:
                num1 = l1.val
                l1 = l1.next
            else:
                num1 = 0
            if l2:
                num2 = l2.val
                l2 = l2.next
            else:
                num2 = 0

            sum = num1 + num2 + carry
            carry = sum // 10

            curr.next = ListNode(sum % 10)
            curr = curr.next

        return head.next
```

# [面试题 02.06. 回文链表](https://leetcode.cn/problems/palindrome-linked-list-lcci/)

- 标签：栈、递归、链表、双指针
- 难度：简单

## 题目链接

- [面试题 02.06. 回文链表 - 力扣](https://leetcode.cn/problems/palindrome-linked-list-lcci/)

## 题目大意

给定一个链表的头节点 `head`。

要求：判断该链表是否为回文链表。

## 解题思路

利用数组，将链表元素依次存入。然后再使用两个指针，一个指向数组开始位置，一个指向数组结束位置，依次判断首尾对应元素是否相等，若都相等，则为回文链表。若不相等，则不是回文链表。

## 代码

```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        nodes = []
        p1 = head
        while p1 != None:
            nodes.append(p1.val)
            p1 = p1.next
        return nodes == nodes[::-1]
```

# [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

- 标签：哈希表、链表、双指针
- 难度：简单

## 题目链接

- [面试题 02.07. 链表相交 - 力扣](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

## 题目大意

给定两个链表的头节点 `headA`、`headB`。

要求：找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `None` 。

比如：链表 A 为 `[4, 1, 8, 4, 5]`，链表 B 为 `[5, 0, 1, 8, 4, 5]`。则如下图所示，两个链表相交的起始节点为 `8`，则输出结果为 `8`。

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)





## 解题思路

如果两个链表相交，那么从相交位置开始，到结束，必有一段等长且相同的节点。假设链表 `A` 的长度为 `m`、链表 `B` 的长度为 `n`，他们的相交序列有 `k` 个，则相交情况可以如下如所示：

![](https://qcdn.itcharge.cn/images/20210401113538.png)

现在问题是如何找到 `m - k` 或者 `n - k` 的位置。

考虑将链表 `A` 的末尾拼接上链表 `B`，链表 `B` 的末尾拼接上链表 `A`。

然后使用两个指针 `pA` 、`pB`，分别从链表 `A`、链表 `B` 的头节点开始遍历，如果走到共同的节点，则返回该节点。

否则走到两个链表末尾，返回 `None`。

![](https://qcdn.itcharge.cn/images/20210401114100.png)

## 代码

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if headA == None or headB == None:
            return None
        pA = headA
        pB = headB
        while pA != pB :
            pA = pA.next if pA != None else headB
            pB = pB.next if pB != None else headA
        return pA
```

# [面试题 02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/)

- 标签：哈希表、链表、双指针
- 难度：中等

## 题目链接

- [面试题 02.08. 环路检测 - 力扣](https://leetcode.cn/problems/linked-list-cycle-lcci/)

## 题目大意

给定一个链表的头节点 `head`。

要求：判断链表中是否有环，如果有环则返回入环的第一个节点，无环则返回 None。

## 解题思路

利用两个指针，一个慢指针每次前进一步，快指针每次前进两步（两步或多步效果是等价的）。如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。

如果有环，则再定义一个指针，和慢指针一起每次移动一步，两个指针相遇的位置即为入口节点。

这是因为：假设入环位置为 A，快慢指针在在 B 点相遇，则相遇时慢指针走了 $a + b$ 步，快指针走了 $a + n(b+c) + b$ 步。

$2(a + b) = a + n(b + c) + b$。可以推出：$a = c + (n-1)(b + c)$。

我们可以发现：从相遇点到入环点的距离 $c$ 加上 $n-1$ 圈的环长 $b + c$ 刚好等于从链表头部到入环点的距离。

## 代码

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while True:
            if not fast or not fast.next:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break

        ans = head
        while ans != slow:
            ans, slow = ans.next, slow.next
        return ans
```

# [面试题 03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/)

- 标签：栈、设计
- 难度：简单

## 题目链接

- [面试题 03.02. 栈的最小值 - 力扣](https://leetcode.cn/problems/min-stack-lcci/)

## 题目大意

设计一个「栈」，要求实现  `push` ，`pop` ，`top` ，`getMin` 操作，其中 `getMin` 要求能在常数时间内实现。

## 解题思路

使用一个栈，栈元素中除了保存当前值之外，再保存一个当前最小值。

-  `push` 操作：如果栈不为空，则判断当前值与栈顶元素所保存的最小值，并更新当前最小值，将新元素保存到栈中。
-  `pop`操作：正常出栈
-  `top` 操作：返回栈顶元素保存的值。
-  `getMin` 操作：返回栈顶元素保存的最小值。

## 代码

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    class Node:
        def __init__(self, x):
            self.val = x
            self.min = x

    def push(self, x: int) -> None:
        node = self.Node(x)
        if len(self.stack) == 0:
            self.stack.append(node)
        else:
            topNode = self.stack[-1]
            if node.min > topNode.min:
                node.min = topNode.min

            self.stack.append(node)

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1].val

    def getMin(self) -> int:
        return self.stack[-1].min
```

# [面试题 03.04. 化栈为队](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

- 标签：栈、设计、队列
- 难度：简单

## 题目链接

- [面试题 03.04. 化栈为队 - 力扣](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

## 题目大意

要求：实现一个 MyQueue 类，要求仅使用两个栈实现先入先出队列。

## 解题思路

使用两个栈，`inStack` 用于输入，`outStack` 用于输出。

- `push` 操作：将元素压入 `inStack` 中。
- `pop` 操作：如果 `outStack` 输出栈为空，将 `inStack` 输入栈元素依次取出，按顺序压入 `outStack` 栈。这样 `outStack` 栈的元素顺序和之前 `inStack` 元素顺序相反，`outStack` 顶层元素就是要取出的队头元素，将其移出，并返回该元素。如果 `outStack` 输出栈不为空，则直接取出顶层元素。
- `peek` 操作：和 `pop` 操作类似，只不过最后一步不需要取出顶层元素，直接将其返回即可。
- `empty` 操作：如果 `inStack` 和 `outStack` 都为空，则队列为空，否则队列不为空。

## 代码

```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.inStack = []
        self.outStack = []


    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.inStack.append(x)


    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if (len(self.outStack) == 0):
            while (len(self.inStack) != 0):
                self.outStack.append(self.inStack[-1])
                self.inStack.pop()
        top = self.outStack[-1]
        self.outStack.pop()
        return top


    def peek(self) -> int:
        """
        Get the front element.
        """
        if (len(self.outStack) == 0):
            while (len(self.inStack) != 0):
                self.outStack.append(self.inStack[-1])
                self.inStack.pop()
        top = self.outStack[-1]
        return top


    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return len(self.outStack) == 0 and len(self.inStack) == 0
```

# [面试题 04.02. 最小高度树](https://leetcode.cn/problems/minimum-height-tree-lcci/)

- 标签：树、二叉搜索树、数组、分治、二叉树
- 难度：简单

## 题目链接

- [面试题 04.02. 最小高度树 - 力扣](https://leetcode.cn/problems/minimum-height-tree-lcci/)

## 题目大意

给定一个升序的有序数组 `nums`。

要求：创建一棵高度最小的二叉搜索树（高度平衡的二叉搜索树）。

## 解题思路

直观上，如果把数组的中间元素当做根，那么数组左侧元素都小于根节点，右侧元素都大于根节点，且左右两侧元素个数相同，或最多相差 `1` 个。那么构建的树高度差也不会超过 `1`。所以猜想出：如果左右子树约平均，树就越平衡。这样我们就可以每次取中间元素作为当前的根节点，两侧的元素作为左右子树递归建树，左侧区间 `[L, mid - 1]` 作为左子树，右侧区间 `[mid + 1, R]` 作为右子树。

## 代码

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        size = len(nums)
        if size == 0:
            return None
        mid = size // 2
        root = TreeNode(nums[mid])
        root.left = Solution.sortedArrayToBST(self, nums[:mid])
        root.right = Solution.sortedArrayToBST(self, nums[mid + 1:])
        return root
```

# [面试题 04.05. 合法二叉搜索树](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [面试题 04.05. 合法二叉搜索树 - 力扣](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

## 题目大意

给定一个二叉树的根节点 `root`。

要求：检查该二叉树是否为二叉搜索树。

二叉搜索树特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

## 解题思路

根据题意进行递归遍历即可。前序、中序、后序遍历都可以。

以前序遍历为例，递归函数为：`preorderTraversal(root, min_v, max_v)`

前序遍历时，先判断根节点的值是否在 `(min_v, max_v)` 之间。如果不在则直接返回 `False`。在区间内，则继续递归检测左右子树是否满足，都满足才是一棵二叉搜索树。

递归遍历左子树的时候，要将上界 `max_v` 改为左子树的根节点值，因为左子树上所有节点的值均小于根节点的值。同理，遍历右子树的时候，要将下界 `min_v` 改为右子树的根节点值，因为右子树上所有节点的值均大于根节点。

## 代码

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def preorderTraversal(root, min_v, max_v):
            if root == None:
                return True
            if root.val >= max_v or root.val <= min_v:
                return False
            return preorderTraversal(root.left, min_v, root.val) and preorderTraversal(root.right, root.val, max_v)

        return preorderTraversal(root, float('-inf'), float('inf'))
```

# [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

- 标签：树、深度优先搜索、二叉搜索树、二叉树
- 难度：中等

## 题目链接

- [面试题 04.06. 后继者 - 力扣](https://leetcode.cn/problems/successor-lcci/)

## 题目大意

给定一棵二叉搜索树的根节点 `root` 和其中一个节点 `p`。

要求：找出该节点在树中的中序后继，即按照中序遍历的顺序节点 `p` 的下一个节点。如果节点 `p` 没有对应的下一个节点，则返回 `None`。

## 解题思路

递归遍历，具体步骤如下：

- 如果 `root.val` 小于等于 `p.val`，则直接从 `root` 的右子树递归查找比 `p.val` 大的节点，从而找到中序后继。
- 如果 `root.val` 大于 `p.val`，则 `root` 有可能是中序后继，也有可能是 `root` 的左子树。则从 `root` 的左子树递归查找更接近（更小的）。如果查找的值为 `None`，则当前 `root` 就是中序后继，否则继续递归查找，从而找到中序后继。

## 代码

```python
class Solution:
    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> TreeNode:
        if not p or not root:
            return None

        if root.val <= p.val:
            node = self.inorderSuccessor(root.right, p)
        else:
            node = self.inorderSuccessor(root.left, p)
            if not node:
                node = root
        return node
```

# [面试题 04.08. 首个共同祖先](https://leetcode.cn/problems/first-common-ancestor-lcci/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [面试题 04.08. 首个共同祖先 - 力扣](https://leetcode.cn/problems/first-common-ancestor-lcci/)

## 题目大意

给定一个二叉树，要求找到该树中指定节点 `p`、`q` 的最近公共祖先：

- 祖先：若节点 `p` 在节点 `node` 的左子树或右子树中，或者 `p = node`，则称 `node` 是 `p` 的祖先。

- 最近公共祖先：对于树的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `lca_node`，满足 `lca_node` 是 `p`、`q` 的祖先且 `lca_node` 的深度尽可能大（一个节点也可以是自己的祖先）。

## 解题思路

设 `lca_node` 为节点 `p`、`q` 的最近公共祖先。则 `lca_node` 只能是下面几种情况：

- `p`、`q` 在 `lca_node` 的子树中，且分别在 `lca_node` 的两侧子树中。
- `p == lca_node`，且 `q` 在 `lca_node` 的左子树或右子树中。
- `q == lca_node`，且 `p` 在 `lca_node` 的左子树或右子树中。

下面递归求解 `lca_node`。递归需要满足以下条件：

- 如果 `p`、`q` 都不为空，则返回 `p`、`q` 的公共祖先。
- 如果 `p`、`q` 只有一个存在，则返回存在的一个。
- 如果 `p`、`q` 都不存在，则返回存在的一个。

具体思路为：

- 如果当前节点 `node` 为 `None`，则说明 `p`、`q` 不在 `node` 的子树中，不可能为公共祖先，直接返回 `None`。
- 如果当前节点 `node` 等于 `p` 或者 `q`，那么 `node` 就是 `p`、`q` 的最近公共祖先，直接返回 `node`。
- 递归遍历左子树、右子树，并判断左右子树结果。
  - 如果左子树为空，则返回右子树。
  - 如果右子树为空，则返回左子树。
  - 如果左右子树都不为空，则说明 `p`、`q` 在当前根节点的两侧，当前根节点就是他们的最近公共祖先。
  - 如果左右子树都为空，则返回空。

## 代码

```python
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if root == p or root == q:
            return root

        if root:
            node_left = self.lowestCommonAncestor(root.left, p, q)
            node_right = self.lowestCommonAncestor(root.right, p, q)
            if node_left and node_right:
                return root
            elif not node_left:
                return node_right
            else:
                return node_left
        return None
```

# [面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/)

- 标签：树、深度优先搜索、二叉树
- 难度：中等

## 题目链接

- [面试题 04.12. 求和路径 - 力扣](https://leetcode.cn/problems/paths-with-sum-lcci/)

## 题目大意

给定一个二叉树的根节点 `root`，和一个整数 `targetSum`。

要求：求出该二叉树里节点值之和等于 `targetSum` 的路径的数目。

- 路径：不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

## 解题思路

直观想法是：

以每一个节点 `node` 为起始节点，向下检测延伸的路径。递归遍历每一个节点所有可能的路径，然后将这些路径数目加起来即为答案。

但是这样会存在许多重复计算。我们可以定义节点的前缀和来减少重复计算。

- 节点的前缀和：从根节点到当前节点路径上所有节点的和。

有了节点的前缀和，我们就可以通过前缀和来计算两节点之间的路劲和。即：`则两节点之间的路径和 = 两节点之间的前缀和之差`。

为了计算符合要求的路径数量，我们用哈希表存储「前缀和的节点数量」。哈希表以「当前节点的前缀和」为键，以「该前缀和的节点数量」为值。这样就能通过哈希表直接计算出符合要求的路径数量，从而累加到答案上。

整个算法的具体步骤如下：

- 通过先序遍历方式递归遍历二叉树，计算每一个节点的前缀和 `cur_sum`。
- 从哈希表中取出 `cur_sum - target_sum` 的路径数量（也就是表示存在从前缀和为 `cur_sum - target_sum` 所对应的节点到前缀和为 `cur_sum` 所对应的节点的路径个数）累加到答案 `res` 中。
- 然后以「当前节点的前缀和」为键，以「该前缀和的节点数量」为值，存入哈希表中。
- 递归遍历二叉树，并累加答案值。
- 恢复哈希表「当前前缀和的节点数量」，返回答案。

## 代码

```python

```

# [面试题 08.04. 幂集](https://leetcode.cn/problems/power-set-lcci/)

- 标签：位运算、数组、回溯
- 难度：中等

## 题目链接

- [面试题 08.04. 幂集 - 力扣](https://leetcode.cn/problems/power-set-lcci/)

## 题目大意

给定一个集合 `nums`，集合中不包含重复元素。

压枪欧秋：返回该集合的所有子集。

## 解题思路

回溯算法，遍历集合 `nums`。为了使得子集不重复，每次遍历从当前位置的下一个位置进行下一层遍历。

## 代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(size, subset, index):
            res.append(subset)
            for i in range(index, size):
                backtrack(size, subset + [nums[i]], i + 1)

        size = len(nums)
        res = list()
        backtrack(size, [], 0)
        return res
```

# [面试题 08.07. 无重复字符串的排列组合](https://leetcode.cn/problems/permutation-i-lcci/)

- 标签：字符串、回溯
- 难度：中等

## 题目链接

- [面试题 08.07. 无重复字符串的排列组合 - 力扣](https://leetcode.cn/problems/permutation-i-lcci/)

## 题目大意

给定一个字符串 `S`。

要求：打印出该字符串中字符的所有排列。可以以任意顺序返回这个字符串数组，但里边不能有重复元素。

## 解题思路

使用 `visited` 数组标记该元素在当前排列中是否被访问过。若未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。然后进行回溯遍历。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, S, visited):
        if len(self.path) == len(S):
            self.res.append(''.join(self.path))
            return
        for i in range(len(S)):
            if not visited[i]:
                visited[i] = True
                self.path.append(S[i])
                self.backtrack(S, visited)
                self.path.pop()
                visited[i] = False

    def permutation(self, S: str) -> List[str]:
        self.res.clear()
        self.path.clear()
        visited = [False for _ in range(len(S))]
        self.backtrack(S, visited)
        return self.res
```

# [面试题 08.08. 有重复字符串的排列组合](https://leetcode.cn/problems/permutation-ii-lcci/)

- 标签：字符串、回溯
- 难度：中等

## 题目链接

- [面试题 08.08. 有重复字符串的排列组合 - 力扣](https://leetcode.cn/problems/permutation-ii-lcci/)

## 题目大意

给定一个字符串 `s`，字符串中包含有重复字符。

要求：打印出该字符串中字符的所有排列。可以以任意顺序返回这个字符串数组。

## 解题思路

因为原字符串可能含有重复元素，所以在回溯的时候需要进行去重。先将字符串 `s` 转为 `list` 列表，再对列表进行排序，然后使用 `visited` 数组标记该元素在当前排列中是否被访问过。若未被访问过则将其加入排列中，并在访问后将该元素变为未访问状态。

然后再递归遍历下一层元素之前，增加一句语句进行判重：`if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]: continue`。

然后进行回溯遍历。

## 代码

```python
class Solution:
    res = []
    path = []

    def backtrack(self, ls, visited):
        if len(self.path) == len(ls):
            self.res.append(''.join(self.path))
            return
        for i in range(len(ls)):
            if i > 0 and ls[i] == ls[i - 1] and not visited[i - 1]:
                continue

            if not visited[i]:
                visited[i] = True
                self.path.append(ls[i])
                self.backtrack(ls, visited)
                self.path.pop()
                visited[i] = False

    def permutation(self, S: str) -> List[str]:
        self.res.clear()
        self.path.clear()
        ls = list(S)
        ls.sort()
        visited = [False for _ in range(len(S))]
        self.backtrack(ls, visited)
        return self.res
```

# [面试题 08.09. 括号](https://leetcode.cn/problems/bracket-lcci/)

- 标签：字符串、动态规划、回溯
- 难度：中等

## 题目链接

- [面试题 08.09. 括号 - 力扣](https://leetcode.cn/problems/bracket-lcci/)

## 题目大意

给定一个整数 `n`。

要求：生成所有有可能且有效的括号组合。

## 解题思路

通过回溯算法生成所有答案。为了生成的括号组合是有效的，回溯的时候，使用一个标记变量 `symbol` 来表示是否当前组合是否成对匹配。

如果在当前组合中增加一个 `(`，则 `symbol += 1`，如果增加一个 `)`，则 `symbol -= 1`。显然只有在 `symbol < n` 的时候，才能增加 `(`，在 `symbol > 0` 的时候，才能增加 `)`。

如果最终生成 `2 * n` 的括号组合，并且 `symbol == 0`，则说明当前组合是有效的，将其加入到最终答案数组中。

最终输出最终答案数组。

## 代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(parenthesis, symbol, index):
            if n * 2 == index:
                if symbol == 0:
                    parentheses.append(parenthesis)
            else:
                if symbol < n:
                    backtrack(parenthesis + '(', symbol + 1, index + 1)
                if symbol > 0:
                    backtrack(parenthesis + ')', symbol - 1, index + 1)

        parentheses = list()
        backtrack("", 0, 0)
        return parentheses
```

# [面试题 08.10. 颜色填充](https://leetcode.cn/problems/color-fill-lcci/)

- 标签：深度优先搜索、广度优先搜索、数组、矩阵
- 难度：简单

## 题目链接

- [面试题 08.10. 颜色填充 - 力扣](https://leetcode.cn/problems/color-fill-lcci/)

## 题目大意

给定一个二维整数矩阵 `image`，其中 `image[i][j]` 表示矩阵第 `i` 行、第 `j` 列上网格块的颜色值。再给定一个起始位置 `(sr, sc)`，以及一个目标颜色 `newColor`。

要求：对起始位置 `(sr, sc)` 所在位置周围区域填充颜色为 `newColor`。并返回填充后的图像 `image`。

- 周围区域：颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。

## 解题思路

深度优先搜索。使用二维数组 `visited` 标记访问过的节点。遍历上、下、左、右四个方向上的点。如果下一个点位置越界，或者当前位置与下一个点位置颜色不一样，则对该节点进行染色。

在遍历的过程中注意使用 `visited` 标记访问过的节点，以免重复遍历。

## 代码

```python
class Solution:
    directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def dfs(self, image, i, j, origin_color, color, visited):
        rows, cols = len(image), len(image[0])

        for direct in self.directs:
            new_i = i + direct[0]
            new_j = j + direct[1]

            # 下一个位置越界，则当前点在边界，对其进行着色
            if new_i < 0 or new_i >= rows or new_j < 0 or new_j >= cols:
                image[i][j] = color
                continue

            # 如果访问过，则跳过
            if visited[new_i][new_j]:
                continue

            # 如果下一个位置颜色与当前颜色相同，则继续搜索
            if image[new_i][new_j] == origin_color:
                visited[new_i][new_j] = True
                self.dfs(image, new_i, new_j, origin_color, color, visited)
            # 下一个位置颜色与当前颜色不同，则当前位置为连通区域边界，对其进行着色
            else:
                image[i][j] = color

    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        if not image:
            return image

        rows, cols = len(image), len(image[0])
        visited = [[False for _ in range(cols)] for _ in range(rows)]
        visited[sr][sc] = True

        self.dfs(image, sr, sc, image[sr][sc], newColor, visited)

        return image
```

# [面试题 08.12. 八皇后](https://leetcode.cn/problems/eight-queens-lcci/)

- 标签：数组、回溯
- 难度：困难

## 题目链接

- [面试题 08.12. 八皇后 - 力扣](https://leetcode.cn/problems/eight-queens-lcci/)

## 题目大意

- n 皇后问题：将 n 个皇后放置在 `n * n` 的棋盘上，并且使得皇后彼此之间不能攻击。
- 皇后彼此不能相互攻击：指的是任何两个皇后都不能处于同一条横线、纵线或者斜线上。

现在给定一个整数 `n`，返回所有不同的「n 皇后问题」的解决方案。每一种解法包含一个不同的「n 皇后问题」的棋子放置方案，该方案中的 `Q` 和 `.` 分别代表了皇后和空位。

## 解题思路

经典的回溯问题。使用 `chessboard` 来表示棋盘，`Q` 代表皇后，`.` 代表空位，初始都为 `.`。然后使用 `res` 存放最终答案。

先定义棋盘合理情况判断方法，判断同一条横线、纵线或者斜线上是否存在两个以上的皇后。

再定义回溯方法，从第一行开始进行遍历。

- 如果当前行 `row` 等于 `n`，则当前棋盘为一个可行方案，将其拼接加入到 `res` 数组中。
-  遍历 `[0, n]` 列元素，先验证棋盘是否可行，如果可行：
  - 将当前行当前列尝试换为 `Q`。
  - 然后继续递归下一行。
  - 再将当前行回退为 `.`。
- 最终返回 `res` 数组。

## 代码

```python
class Solution:
    res = []
    def backtrack(self, n: int, row: int, chessboard: List[List[str]]):
        if row == n:
            temp_res = []
            for temp in chessboard:
                temp_str = ''.join(temp)
                temp_res.append(temp_str)
            self.res.append(temp_res)
            return
        for col in range(n):
            if self.isValid(n, row, col, chessboard):
                chessboard[row][col] = 'Q'
                self.backtrack(n, row + 1, chessboard)
                chessboard[row][col] = '.'

    def isValid(self, n: int, row: int, col: int, chessboard: List[List[str]]):
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False

        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j += 1

        return True

    def solveNQueens(self, n: int) -> List[List[str]]:
        self.res.clear()
        chessboard = [['.' for _ in range(n)] for _ in range(n)]
        self.backtrack(n, 0, chessboard)
        return self.res
```

# [面试题 10.01. 合并排序的数组](https://leetcode.cn/problems/sorted-merge-lcci/)

- 标签：数组、双指针、排序
- 难度：简单

## 题目链接

- [面试题 10.01. 合并排序的数组 - 力扣](https://leetcode.cn/problems/sorted-merge-lcci/)

## 题目大意

**描述**：给定两个排序后的数组 `A` 和 `B`，以及 `A` 的元素数量 `m` 和 `B` 的元素数量 `n`。 `A` 的末端有足够的缓冲空间容纳 `B`。

**要求**：编写一个方法，将 `B` 合并入 `A` 并排序。

**说明**：

- $A.length == n + m$。

**示例**：

- 示例 1：

```python
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

## 解题思路

### 思路 1：归并排序

可以利用归并排序算法的归并步骤思路。

1. 使用两个指针分别表示`A`、`B` 正在处理的元素下标。
2. 对 `A`、`B` 进行归并操作，将结果存入新数组中。归并之后，再将所有元素赋值到数组 `A` 中。

### 思路 1：代码

```python
class Solution:
    def merge(self, A: List[int], m: int, B: List[int], n: int) -> None:
        """
        Do not return anything, modify A in-place instead.
        """
        arr = []
        index_A, index_B = 0, 0
        while index_A < m and index_B < n:
            if A[index_A] <= B[index_B]:
                arr.append(A[index_A])
                index_A += 1
            else:
                arr.append(B[index_B])
                index_B += 1
        while index_A < m:
            arr.append(A[index_A])
            index_A += 1
        while index_B < n:
            arr.append(B[index_B])
            index_B += 1
        for i in range(m + n):
            A[i] = arr[i]
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m + n)$。
- **空间复杂度**：$O(m + n)$。

# [面试题 10.02. 变位词组](https://leetcode.cn/problems/group-anagrams-lcci/)

- 标签：数组、哈希表、字符串、排序
- 难度：中等

## 题目链接

- [面试题 10.02. 变位词组 - 力扣](https://leetcode.cn/problems/group-anagrams-lcci/)

## 题目大意

给定一个字符串数组 `strs`。

要求：将所有变位词组合在一起。不需要考虑输出顺序。

- 变位词：字母相同，但排列不同的字符串。

## 解题思路

使用哈希表记录变位词。对每一个字符串进行排序，按照 `排序字符串：变位词数组` 的键值顺序进行存储。

最终将哈希表的值转换为对应数组返回结果。

## 代码

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        str_dict = dict()
        res = []
        for s in strs:
            sort_s = str(sorted(s))
            if sort_s in str_dict:
                str_dict[sort_s] += [s]
            else:
                str_dict[sort_s] = [s]

        for sort_s in str_dict:
            res += [str_dict[sort_s]]
        return res
```

# [面试题 10.09. 排序矩阵查找](https://leetcode.cn/problems/sorted-matrix-search-lcci/)

- 标签：数组、二分查找、分治、矩阵
- 难度：中等

## 题目链接

- [面试题 10.09. 排序矩阵查找 - 力扣](https://leetcode.cn/problems/sorted-matrix-search-lcci/)

## 题目大意

给定一个 `m * n` 大小的有序整数矩阵。每一行、每一列都按升序排列。再给定一个目标值 `target`。

要求：判断矩阵中是否可以找到 `target`，若找到 `target`，返回 `True`，否则返回 `False`。

## 解题思路

矩阵是有序的，可以考虑使用二分搜索来进行查找。

迭代对角线元素，假设对角线元素的坐标为 `(row, col)`。把数组元素按对角线分为右上角部分和左下角部分。

则对于当前对角线元素右侧第 `row` 行、对角线元素下侧第 `col` 列进行二分查找。

- 如果找到目标，直接返回 `True`。
- 如果找不到目标，则缩小范围，继续查找。
- 直到所有对角线元素都遍历完，依旧没找到，则返回 `False`。

## 代码

```python
class Solution:
    def diagonalBinarySearch(self, matrix, diagonal, target):
        left = 0
        right = diagonal
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def rowBinarySearch(self, matrix, begin, cols, target):
        left = begin
        right = cols
        while left < right:
            mid = left + (right - left) // 2
            if matrix[begin][mid] < target:
                left = mid + 1
            elif matrix[begin][mid] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= cols and matrix[begin][left] == target

    def colBinarySearch(self, matrix, begin, rows, target):
        left = begin + 1
        right = rows
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][begin] < target:
                left = mid + 1
            elif matrix[mid][begin] > target:
                right = mid - 1
            else:
                left = mid
                break
        return begin <= left <= rows and matrix[left][begin] == target

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows = len(matrix)
        if rows == 0:
            return False
        cols = len(matrix[0])
        if cols == 0:
            return False

        min_val = min(rows, cols)
        index = self.diagonalBinarySearch(matrix, min_val - 1, target)
        if matrix[index][index] == target:
            return True
        for i in range(index + 1):
            row_search = self.rowBinarySearch(matrix, i, cols - 1, target)
            col_search = self.colBinarySearch(matrix, i, rows - 1, target)
            if row_search or col_search:
                return True
        return False
```

# [面试题 16.02. 单词频率](https://leetcode.cn/problems/words-frequency-lcci/)

- 标签：设计、字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [面试题 16.02. 单词频率 - 力扣](https://leetcode.cn/problems/words-frequency-lcci/)

## 题目大意

要求：设计一个方法，找出任意指定单词在一本书中的出现频率。

支持如下操作：

- `WordsFrequency(book)` 构造函数，参数为字符串数组构成的一本书。
- `get(word)` 查询指定单词在书中出现的频率。

## 解题思路

使用字典树统计单词频率。

构造函数时，构建一个字典树，并将所有单词存入字典树中，同时在字典树中记录并维护单词频率。

查询时，调用字典树查询方法，查询单词频率。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.count = 0


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.count += 1


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return 0
            cur = cur.children[ch]
        if cur and cur.isEnd:
            return cur.count
        return 0

class WordsFrequency:

    def __init__(self, book: List[str]):
        self.tire_tree = Trie()
        for word in book:
            self.tire_tree.insert(word)


    def get(self, word: str) -> int:
        return self.tire_tree.search(word)
```

# [面试题 16.05. 阶乘尾数](https://leetcode.cn/problems/factorial-zeros-lcci/)

- 标签：数学
- 难度：简单

## 题目链接

- [面试题 16.05. 阶乘尾数 - 力扣](https://leetcode.cn/problems/factorial-zeros-lcci/)

## 题目大意

给定一个整数 `n`。

要求：计算 `n` 的阶乘中尾随零的数量。

注意：$0 <= n <= 10^4$。

## 解题思路

阶乘中，末尾 `0` 的来源只有 `2 * 5`。所以尾随 `0` 的个数为 `2` 的倍数个数和 `5` 的倍数个数的最小值。又因为 `2 < 5`，`2` 的倍数个数肯定小于等于 `5` 的倍数，所以直接统计 `5` 的倍数个数即可。

## 代码

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n > 0:
            count += n // 5
            n = n // 5
        return count
```

# [面试题 16.26. 计算器](https://leetcode.cn/problems/calculator-lcci/)

- 标签：栈、数学、字符串
- 难度：中等

## 题目链接

- [面试题 16.26. 计算器 - 力扣](https://leetcode.cn/problems/calculator-lcci/)

## 题目大意

给定一个包含正整数、加（`+`）、减（`-`）、乘（`*`）、除（`/`）的算出表达式（括号除外）。表达式仅包含非负整数，`+`、`-`、`*`、`/` 四种运算符和空格 ` `。整数除法仅保留整数部分。

要求：计算其结果。

## 解题思路

计算表达式中，乘除运算优先于加减运算。我们可以先进行乘除运算，再将进行乘除运算后的整数值放入原表达式中相应位置，再依次计算加减。

可以考虑使用一个栈来保存进行乘除运算后的整数值。正整数直接压入栈中，负整数，则将对应整数取负号，再压入栈中。这样最终计算结果就是栈中所有元素的和。

具体做法：

- 遍历字符串 s，使用变量 op 来标记数字之前的运算符，默认为 `+`。
- 如果遇到数字，继续向后遍历，将数字进行累积，得到完整的整数 num。判断当前 op 的符号。
  - 如果 op 为 `+`，则将 num 压入栈中。
  - 如果 op 为 `-`，则将 -num 压入栈中。
  - 如果 op 为 `*`，则将栈顶元素 top 取出，计算 top * num，并将计算结果压入栈中。
  - 如果 op 为 `/`，则将栈顶元素 top 取出，计算 int(top / num)，并将计算结果压入栈中。
- 如果遇到 `+`、`-`、`*`、`/` 操作符，则更新 op。
- 最后将栈中整数进行累加，并返回结果。

## 代码

```python
class Solution:
    def calculate(self, s: str) -> int:
        size = len(s)
        stack = []
        op = '+'
        index = 0
        while index < size:
            if s[index] == ' ':
                index += 1
                continue
            if s[index].isdigit():
                num = ord(s[index]) - ord('0')
                while index + 1 < size and s[index + 1].isdigit():
                    index += 1
                    num = 10 * num + ord(s[index]) - ord('0')
                if op == '+':
                    stack.append(num)
                elif op == '-':
                    stack.append(-num)
                elif op == '*':
                    top = stack.pop()
                    stack.append(top * num)
                elif op == '/':
                    top = stack.pop()
                    stack.append(int(top / num))
            elif s[index] in "+-*/":
                op = s[index]
            index += 1
        return sum(stack)
```

# [面试题 17.06. 2出现的次数](https://leetcode.cn/problems/number-of-2s-in-range-lcci/)

- 标签：递归、数学、动态规划
- 难度：困难

## 题目链接

- [面试题 17.06. 2出现的次数 - 力扣](https://leetcode.cn/problems/number-of-2s-in-range-lcci/)

## 题目大意

**描述**：给定一个整数 $n$。

**要求**：计算从 $0$ 到 $n$ (包含 $n$) 中数字 $2$ 出现的次数。

**说明**：

- $n \le 10^9$。

**示例**：

- 示例 1：

```python
输入: 25
输出: 9
解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)
```

## 解题思路

### 思路 1：动态规划 + 数位 DP

将 $n$ 转换为字符串 $s$，定义递归函数 `def dfs(pos, cnt, isLimit):` 表示构造第 $pos$ 位及之后所有数位中数字 $2$ 出现的个数。接下来按照如下步骤进行递归。

1. 从 `dfs(0, 0, True)` 开始递归。 `dfs(0, 0, True)` 表示：
	1. 从位置 $0$ 开始构造。
	2. 初始数字 $2$ 出现的个数为 $0$。
	3. 开始时受到数字 $n$ 对应最高位数位的约束。
2. 如果遇到  $pos == len(s)$，表示到达数位末尾，此时：返回数字 $2$ 出现的个数 $cnt$。
3. 如果 $pos \ne len(s)$，则定义方案数 $ans$，令其等于 $0$，即：`ans = 0`。
4. 如果遇到 $isNum == False$，说明之前位数没有填写数字，当前位可以跳过，这种情况下方案数等于 $pos + 1$ 位置上没有受到 $pos$ 位的约束，并且之前没有填写数字时的方案数，即：`ans = dfs(i + 1, state, False, False)`。
5. 如果 $isNum == True$，则当前位必须填写一个数字。此时：
	1. 因为不需要考虑前导 $0$ 所以当前位数位所能选择的最小数字（$minX$）为 $0$。
	2. 根据 $isLimit$ 来决定填当前位数位所能选择的最大数字（$maxX$）。
	3. 然后根据 $[minX, maxX]$ 来枚举能够填入的数字 $d$。
	4. 方案数累加上当前位选择 $d$ 之后的方案数，即：`ans += dfs(pos + 1, cnt + (d == 2), isLimit and d == maxX)`。
		1. `cnt + (d == 2)` 表示之前数字 $2$ 出现的个数加上当前位为数字 $2$ 的个数。
		2. `isLimit and d == maxX` 表示 $pos + 1$ 位受到之前位 $pos$ 位限制。
6. 最后的方案数为 `dfs(0, 0, True)`，将其返回即可。

### 思路 1：代码

```python
class Solution:
    def numberOf2sInRange(self, n: int) -> int:
        # 将 n 转换为字符串 s
        s = str(n)
        
        @cache
        # pos: 第 pos 个数位
        # cnt: 之前数字 2 出现的个数。
        # isLimit: 表示是否受到选择限制。如果为真，则第 pos 位填入数字最多为 s[pos]；如果为假，则最大可为 9。
        def dfs(pos, cnt, isLimit):
            if pos == len(s):
                return cnt
            
            ans = 0            
            # 不需要考虑前导 0，则最小可选择数字为 0
            minX = 0
            # 如果受到选择限制，则最大可选择数字为 s[pos]，否则最大可选择数字为 9。
            maxX = int(s[pos]) if isLimit else 9
            
            # 枚举可选择的数字
            for d in range(minX, maxX + 1): 
                ans += dfs(pos + 1, cnt + (d == 2), isLimit and d == maxX)
            return ans
    
        return dfs(0, 0, True)
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。
# [面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/)

- 标签：数组、分治、快速选择、排序、堆（优先队列）
- 难度：中等

## 题目链接

- [面试题 17.14. 最小K个数 - 力扣](https://leetcode.cn/problems/smallest-k-lcci/)

## 题目大意

给定整数数组 `arr`，再给定一个整数 `k`。

要求：返回数组 `arr` 中最小的 `k` 个数。

## 解题思路

直接可以想到的思路是：排序后输出数组上对应的最小的 k 个数。所以问题关键在于排序方法的复杂度。

冒泡排序、选择排序、插入排序时间复杂度 $O(n^2)$ 太高了，解答会超时。

可考虑堆排序、归并排序、快速排序。本题使用堆排序。具体做法如下：

1. 利用数组前 `k` 个元素，建立大小为 `k` 的大顶堆。
2. 遍历数组 `[k, size - 1]` 的元素，判断其与堆顶元素关系，如果比堆顶元素小，则将其赋值给堆顶元素，再对大顶堆进行调整。
3. 最后输出前调整过后的大顶堆的前 `k` 个元素。

## 代码

```python
class Solution:
    def heapify(self, nums: [int], index: int, end: int):
        left = index * 2 + 1
        right = left + 1
        while left <= end:
            # 当前节点为非叶子节点
            max_index = index
            if nums[left] > nums[max_index]:
                max_index = left
            if right <= end and nums[right] > nums[max_index]:
                max_index = right
            if index == max_index:
                # 如果不用交换，则说明已经交换结束
                break
            nums[index], nums[max_index] = nums[max_index], nums[index]
            # 继续调整子树
            index = max_index
            left = index * 2 + 1
            right = left + 1

    # 初始化大顶堆
    def buildMaxHeap(self, nums: [int], k: int):
        # (k-2) // 2 是最后一个非叶节点，叶节点不用调整
        for i in range((k - 2) // 2, -1, -1):
            self.heapify(nums, i, k - 1)
        return nums

    def smallestK(self, arr: List[int], k: int) -> List[int]:
        size = len(arr)
        if k <= 0 or not arr:
            return []
        if size <= k:
            return arr

        self.buildMaxHeap(arr, k)
        for i in range(k, size):
            if arr[i] < arr[0]:
                arr[i], arr[0] = arr[0], arr[i]
                self.heapify(arr, 0, k - 1)

        return arr[:k]
```

# [面试题 17.15. 最长单词](https://leetcode.cn/problems/longest-word-lcci/)

- 标签：字典树、数组、哈希表、字符串
- 难度：中等

## 题目链接

- [面试题 17.15. 最长单词 - 力扣](https://leetcode.cn/problems/longest-word-lcci/)

## 题目大意

给定一组单词 `words`。

要求：找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。

## 解题思路

先将所有单词按照长度从长到短排序，相同长度的字典序小的排在前面。然后将所有单词存入字典树中。

然后一重循环遍历所有单词 `word`，二重循环遍历单词中所有字符 `word[i]`。

如果当前遍历的字符为单词末尾，递归判断从 `i + 1` 位置开始，剩余部分是否可以切分为其他单词组合，如果可以切分，则返回当前单词 `word`。如果不可以切分，则返回空字符串 `""`。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                return False
            cur = cur.children[ch]

        return cur is not None and cur.isEnd

    def splitToWord(self, remain):
        if not remain or remain == "":
            return True
        cur = self
        for i in range(len(remain)):
            ch = remain[i]
            if ch not in cur.children:
                return False
            if cur.children[ch].isEnd and self.splitToWord(remain[i + 1:]):
                return True
            cur = cur.children[ch]
        return False

    def dfs(self, words):
        for word in words:
            cur = self
            size = len(word)
            for i in range(size):
                ch = word[i]
                if i < size - 1 and cur.children[ch].isEnd and self.splitToWord(word[i+1:]):
                    return word
                cur = cur.children[ch]
        return ""

class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort(key=lambda x: (-len(x), x))
        trie_tree = Trie()
        for word in words:
            trie_tree.insert(word)

        ans = trie_tree.dfs(words)
        return ans
```

# [面试题 17.17. 多次搜索](https://leetcode.cn/problems/multi-search-lcci/)

- 标签：字典树、数组、哈希表、字符串、字符串匹配、滑动窗口
- 难度：中等

## 题目链接

- [面试题 17.17. 多次搜索 - 力扣](https://leetcode.cn/problems/multi-search-lcci/)

## 题目大意

给定一个较长字符串 `big` 和一个包含较短字符串的数组 `smalls`。

要求：设计一个方法，根据 `smalls` 中的每一个较短字符串，对 `big` 进行搜索。输出 `smalls` 中的字符串在 `big` 里出现的所有位置 `positions`，其中 `positions[i]` 为 `smalls[i]` 出现的所有位置。

## 解题思路

构建字典树，将 `smalls` 中所有字符串存入字典树中，并在字典树中记录下插入字符串的顺序下标。

然后一重循环遍历 `big`，表示从第 `i` 位置开始的字符串 `big[i:]`。然后在字符串前缀中搜索对应的单词，将所有符合要求的单词插入顺序位置存入列表中，返回列表。

对于列表中每个单词插入下标顺序 `index` 和 `big[i:]` 来说， `i` 就是 `smalls` 中第 `index` 个字符串所对应在 `big` 中的开始位置，将其存入答案数组并返回即可。

## 代码

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.children = dict()
        self.isEnd = False
        self.index = -1


    def insert(self, word: str, index: int) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self
        for ch in word:
            if ch not in cur.children:
                cur.children[ch] = Trie()
            cur = cur.children[ch]
        cur.isEnd = True
        cur.index = index


    def search(self, text: str) -> list:
        """
        Returns if the word is in the trie.
        """
        cur = self
        res = []
        for i in range(len(text)):
            ch = text[i]
            if ch not in cur.children:
                return res
            cur = cur.children[ch]
            if cur.isEnd:
                res.append(cur.index)
        return res

class Solution:
    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:
        trie_tree = Trie()
        for i in range(len(smalls)):
            word = smalls[i]
            trie_tree.insert(word, i)

        res = [[] for _ in range(len(smalls))]

        for i in range(len(big)):
            for index in trie_tree.search(big[i:]):
                res[index].append(i)
        return res
```

